<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[刘毅的技术博客]]></title>
  <link href="http://lucifer1988.github.io/atom.xml" rel="self"/>
  <link href="http://lucifer1988.github.io/"/>
  <updated>2015-10-12T15:40:05+08:00</updated>
  <id>http://lucifer1988.github.io/</id>
  <author>
    <name><![CDATA[刘毅]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Classes and Structs]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/12/swift-by-tutorials-classes-and-structs/"/>
    <updated>2015-10-12T15:26:48+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/12/swift-by-tutorials-classes-and-structs</id>
    <content type="html"><![CDATA[<p>继上两章对Swift的基本类型的学习，这一章开始介绍Swift中的Class和Struct，Class对所有面向对象的语言都不陌生，而Struct可能用的比较少，因为大部分用于C中，但Swift中的Struct与C还有很多不同，这章会一一介绍，而且同时Class与Struct之间的不同与使用场景，也是这一章的重点。</p>

<h2>Getting started</h2>

<ol>
<li></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Language Basics II]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/10/swift-by-tutorials-language-basics-ii/"/>
    <updated>2015-10-10T14:41:12+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/10/swift-by-tutorials-language-basics-ii</id>
    <content type="html"><![CDATA[<p>继上一篇后，本章将继续介绍Swift的基础知识，但是相比第一章会有所提升，包括了Optional类型对象的用法、Swift中的Collection类型用法以及与OC的Collection的不同之处。</p>

<!--more-->


<h2>Optionals</h2>

<p>1.空指针是一个困扰着各类语言的常见问题，在Java中，调用了空指针会直接抛出异常，在OC中向nil指针发送消息会返回nil，也就是说空指针是安全的，但有很多时候你并不希望指针为空，一般会加判断对象是否为nil的断言判断，但在Swift中，针对这个问题，有了新的解决方案。<br/>
2.Swift在对没有初始化赋值的变量使用时，会直接报错，而且像String类型也不能初始化直接赋nil值，这也保证了空指针不会出现。但是如果我们真的需要一个空值的变量怎么办呢？可以使用optional机制，它是用来指明一个变量是可能有值的，相当于给变量一个nil的默认值，这也是空指针的问题所在，它是一个合法的指针，但没有指向一个合法的对象。</p>

<h3>Declaring optionals</h3>

<p>1.使用optional很简单，如下，不赋值的话str默认为nil，在这里你可以把String?理解为一个不同于String的类型，所以能给String?直接赋值String类型实际上是Swift在内部进行了封装，Swift将String的值封装到了一个String?类型的实例中，然后再赋值给了str。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//no assignment</span>
</span><span class='line'><span class="n">var</span> <span class="nl">str:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'><span class="c1">//an assignment</span>
</span><span class='line'><span class="n">var</span> <span class="nl">str:</span> <span class="n">String</span><span class="o">?</span> <span class="o">=</span> <span class="s">&quot;Swift by Tutorials!&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.如果你现在对str使用uppercaseString方法，会报错，这也验证了上面所说String?已是另一个类型的说法，那么如何让str使用String的方法呢？如下即可，通过if语句对str进行解封，并将其赋值给一个let型的String，这就是optional和if在Swift中的经典配合，这么做的好处就是让开发者可以在必选确认指针不为空的时候强制去进行空指针的检查。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">unwrappedStr</span> <span class="o">=</span> <span class="n">str</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="s">&quot;Unwrapped! \(unwrappedStr.uppercaseString)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="s">&quot;Was nil&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Forced unwrapping</h3>

<p>1.在你了解optional机制下，在一些optional中你确定有值的时候，你可以使用强制解封，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="nl">str:</span> <span class="n">String</span><span class="o">?</span> <span class="o">=</span> <span class="s">&quot;Swift by Tutorials!&quot;</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;Force unwrapped! \(str!.uppercaseString)&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.但是需要注意的是，如果optional类型中的是nil值，那么会出现runtime error，所以使用强制解封，<strong>一定要在你100%确定你的optional对象不是空值</strong>。</p>

<h3>Implicit unwrapping</h3>

<p>1.你也可以不用!或者let来进行optional解封，使用以下方法，可以直接对变量使用方法，这看起来和没使用optional差不多，但是它在实质上和上述两种解封方法是一致的，只是语法不通而已，如果不去初始化赋值，那么你会得到和强制解封一个nil的optional的值一样的error。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="nl">str:</span> <span class="n">String</span><span class="o">!</span> <span class="o">=</span> <span class="s">&quot;Swift by Tutorials!&quot;</span>
</span><span class='line'><span class="n">str</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">lowercaseString</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.你也可以通过if来检查隐式解封的optional值，但你会发现这和OC中的做法一样，只不过在OC中你拿nil作为一个false的判断条件，而在Swift中你将nil作为一个无值的状态来判断。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">if</span> <span class="n">str</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">str</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">lowercaseString</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.<strong>最后注意，你要将隐式解封和强制解封一样重视，因为除了声明的地方，它和普通变量是一样的，这很容易忽视。</strong></p>

<h3>Optional chaining</h3>

<p>1.最后要介绍的是Optional chaining，这是上述三个解封方式之外的另一种optional来执行方法的方式，它的设计参照了OC中常用的delegate模式，即在optional类型变量执行方法时会先判断它是否为nil，不是nil的话直接执行，而如果是nil的话，则直接返回nil，其实和OC中对nil发送消息的处理是一样的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="nl">maybeString:</span> <span class="n">String</span><span class="o">?</span> <span class="o">=</span> <span class="s">&quot;Swift by Tutorials!&quot;</span>
</span><span class='line'><span class="n">let</span> <span class="n">uppercase</span> <span class="o">=</span> <span class="n">maybeString</span><span class="o">?</span><span class="p">.</span><span class="n">uppercaseString</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.由于在对象声明和方法执行时两次使用optional，所以形成了Optional chaining。</p>

<!--more-->


<h2>Collection</h2>

<p>1.任何语言都会有集合类型，OC中有NSArray、NSDictionary、NSSet，其中包含可变和不可变类型，而在Swift中只保留了Array和Dictionary两种类型。</p>

<h3>Arrays</h3>

<p>1.Swift的Array有着其他语言中共同的特性，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//initialize array</span>
</span><span class='line'><span class="n">var</span> <span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</span><span class='line'><span class="c1">//add an element</span>
</span><span class='line'><span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.Swift中你可以通过添加一个序列来扩展一个Array，比如上一节提到的Range。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//add 7,8,9,10</span>
</span><span class='line'><span class="c1">//Swift2.0中将extend()改为了appendContentsOf()</span>
</span><span class='line'><span class="c1">//array.extend(7...10)</span>
</span><span class='line'><span class="n">array</span><span class="p">.</span><span class="n">appendContentsOf</span><span class="p">(</span><span class="mf">7.</span><span class="p">.</span><span class="mf">.10</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.在上述数组中试图添加一个String，会直接报错，这在OC中可能是很正常的需求，可以在一个数组中添加不同类型的对象，但在Swift中只能在一个数组中添加同一类型的对象，在上面的Array初始化中是使用了type interface，如果制定类型声明的话应该是<em>var array: Array<Int> = [1, 2, 3, 4, 5]</em>（会在第四章详细说明），不过更常见的写法是<em>var arrray: [Int] = [1, 2, 3, 4, 5]</em>，这是Apple的语法糖，用来简化语法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//Array Initializer</span>
</span><span class='line'><span class="n">var</span> <span class="nl">array:</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span><span class='line'><span class="n">var</span> <span class="nl">arrray:</span> <span class="p">[</span><span class="n">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.当然也可以让Array像NSArray那样工作，可以将类型声明为Array<Any>，但是仍然不推荐这么做，因为这样Swift的很多Array方法会因为类型不一而不能使用，而且也会失去Swift的提供的安全性保护。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//add multiple type instance</span>
</span><span class='line'><span class="n">var</span> <span class="nl">array:</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Any</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'><span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</span><span class='line'><span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Swift By Tutorials!&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Dictionaries</h3>

<p>1.Swift的Dictionary与OC的NSDicionary大致相同，只是语法上略有变化，但需要注意的是，Dictionary也存在只能添加固定类型的键值对的情况，与上述的Array相同。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">dictionary</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">:</span> <span class="s">&quot;Dog&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span> <span class="s">&quot;Cat&quot;</span><span class="p">]</span>
</span><span class='line'><span class="c1">//Another Initializer</span>
</span><span class='line'><span class="c1">//var dictionary: Dictionary&lt;Int:String&gt; = [1: &quot;Dog&quot;, 2: &quot;Cat&quot;]</span>
</span><span class='line'><span class="c1">//var dictionary: [Int:String] = [1: &quot;Dog&quot;, 2: &quot;Cat&quot;]</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span><span class='line'><span class="n">dictionary</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Mouse&quot;</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">dictionary</span><span class="p">)</span>
</span><span class='line'><span class="n">dictionary</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">dictionary</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.从Dictionary中通过key直接获取值时，该值是optional类型的，因为有可能是不存在该key对应的值的，所以推荐读取Dictionary时还是使用上一章中介绍的安全拆解的方法，这又是Swift强制开发者随时考虑安全问题的一个表现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">value</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="s">&quot;Value is \(value)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Reference and copies</h3>

<p>1.这一节讨论Dictionary和Array在Swift中与OC所不同的内存管理策略，如下，从结果发现，Swift中将一个Dictionary直接赋值给另外的变量或常量，都是执行copy操作的，即改变新变量，并不会影响原来的Dictionary。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">dictionaryA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="o">:</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="o">:</span> <span class="mi">16</span><span class="p">]</span>
</span><span class='line'><span class="n">var</span> <span class="n">dictionaryB</span> <span class="o">=</span> <span class="n">dictionaryA</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">dictionaryA</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">dictionaryB</span><span class="p">)</span>
</span><span class='line'><span class="n">dictionaryB</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">dictionaryA</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">dictionaryB</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.那么关于Array呢？答案是一样的，Array也是会执行copy操作，这与OC中的NSDictionary和NSArray的指针赋值是完全不同的，所以单独强调一下。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">arrayA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span><span class='line'><span class="n">var</span> <span class="n">arrayB</span> <span class="o">=</span> <span class="n">arrayA</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">arrayA</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">arrayB</span><span class="p">)</span>
</span><span class='line'><span class="n">arrayB</span><span class="p">.</span><span class="n">removeAtIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">arrayA</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">arrayB</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Constant collection</h3>

<p>1.上面都是定义的var类型的Dictionary和Array，那么如果定义为let的话，Dictionary和Array是不能进行任何修改操作的（其实就是OC中的不可变类型）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">constantArray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span><span class='line'><span class="c1">//error</span>
</span><span class='line'><span class="n">constantArray</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</span><span class='line'><span class="n">constantArray</span><span class="p">.</span><span class="n">removeAtIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Language Basics I]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/08/swift-by-tutorials-language-basics-i/"/>
    <updated>2015-10-08T14:26:37+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/08/swift-by-tutorials-language-basics-i</id>
    <content type="html"><![CDATA[<p>Swift更新到2.0了，是时候来一波Swift的集中学习了，这次用的教材是raywenderlich出版的Swift by Tutorials，我手里的版本是2014年12月份的，可能有些在Swift2.0中发生了变化，我会尽量标注出来。开始第一章，介绍一些Swift的基本语法。</p>

<!--more-->


<h2>Variables,constants and strings</h2>

<p>1.Playground是Xcode新加入的一种文件，实际上就是一个可以自动编译的swift文件，可以用来测试一些简单的代码，也能显示一些资源文件，下面是申明一个string类型，可以直接在playground运行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="nl">greeting:</span> <span class="n">String</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span>
</span><span class='line'><span class="c1">//也可以不指名类型</span>
</span><span class='line'><span class="c1">//var greeting = &quot;Hello&quot;</span>
</span><span class='line'><span class="c1">//如对greeting赋值int型，会报错</span>
</span><span class='line'><span class="c1">//greeting = 9</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.string可以不声明类型，即可运行，是源于Swift的type interface的特性，即通过赋值自动确定变量的类型，但是之后再对其赋值整形，则会报错。因为Swift是静态输入语言，编译期间会进行类型检查。<strong>type interface是推荐使用的，可以使代码简洁，增加可读性</strong>。<br/>
3.Swift的string类型是可变的，而且改变方式不像NSMutableString那么复杂，直接使用+=方式即可。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span>
</span><span class='line'><span class="n">greeting</span> <span class="o">+=</span> <span class="s">&quot;World&quot;</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.如果想声明不可变String，只需添加let关键字即可。在Swift中，控制内建类型的可变性是通过添加let或var关键字来实现的，这不同于OC，需要两种类型来实现。<strong>你应该尽量使用不可变类型，这不仅使你的程序更加健壮，也会使编译器做更多优化，实际上let使用的场景是远远多于var的</strong>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.let关键字不仅限于Swift内建类型，自定义的结构体和类也可以使用，但有些细微不同，这将在第三章中详细讲到。<br/>
6.改变string也可以利用append()方法，这是Swift String自带的一些API，但是数量不多。幸运的是，Swift String与OC的NSString是可转换的，NSString的全部方法，String也可全部使用，但是还是推荐尽量使用String自带的API，比较简洁。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//Swift String API</span>
</span><span class='line'><span class="n">greeting</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Character</span><span class="p">(</span><span class="s">&quot;!&quot;</span><span class="p">))</span>
</span><span class='line'><span class="c1">//bridge to NSString</span>
</span><span class='line'><span class="c1">//logout Hello World</span>
</span><span class='line'><span class="n">import</span> <span class="n">Foundation</span>
</span><span class='line'>
</span><span class='line'><span class="n">var</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;hello world&quot;</span><span class="p">.</span><span class="n">capitalizedString</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span>
</span><span class='line'><span class="c1">//NSString style append</span>
</span><span class='line'><span class="n">import</span> <span class="n">Foundation</span>
</span><span class='line'>
</span><span class='line'><span class="n">var</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="p">.</span><span class="n">stringByAppendingString</span><span class="p">(</span><span class="s">&quot; world&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>7.Swift String是一个值类型，当它被赋值给变量、常量、或者作为参数传入方法时，它的值是被copy的，如下例，改变alternateGreeting不会影响greeting的值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">alternateGreeting</span> <span class="o">=</span> <span class="n">greeting</span>
</span><span class='line'><span class="n">alternateGreeting</span> <span class="o">+=</span> <span class="s">&quot; and beyond!&quot;</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">alternateGreeting</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Semicolons(分号)</h2>

<ol>
<li>Swift中分号只有在同一行中添加多条代码时才强制使用，其他情况可以省略不写，<strong>这又是Swift代码简洁的一大表现</strong>。</li>
</ol>


<!--more-->


<h2>Numeric types and conversion</h2>

<p>1.这一节主要讲Swift的数值类型，下面创建了两个变量，Int类型的radius和Double类型的pi，Swift还有很多其他类型，如Int8、UInt16、Float等。除非你有特殊需求，那么Int和Double类型是你的首选，这两个类型有广泛的使用，而且编译器会自动选择Int的最佳长度，32或64，基于机器的字长，来生成最高效的代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">radius</span> <span class="o">=</span> <span class="mi">4</span>
</span><span class='line'><span class="n">let</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.14159</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.在Swift中，你可以使用<strong>_</strong>来作为千分号，如下。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">milion</span> <span class="o">=</span> <span class="mi">1</span><span class="n">_000_000</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.以下代码会报错，是因为*无法直接将Int和Double相乘，而Swift中也不会隐式转化，需要开发者显式转化，需要注意这里并不是类型转化，而是新生成了一个Double类型，在第三章中会详细讲解初始化方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//error</span>
</span><span class='line'><span class="n">var</span> <span class="n">area</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">pi</span>
</span><span class='line'><span class="c1">//soluation</span>
</span><span class='line'><span class="n">var</span> <span class="n">area</span> <span class="o">=</span> <span class="n">Double</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">*</span> <span class="n">Double</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.显式转化变量是Swift的安全策略之一，另外一个是越界检查，下列代码在其他语言中可能会生成一个负数，而在Swift中会直接将其视为一个runtime error。同时，为了避免integer的越界计算error，Apple提供了&amp;+、&amp;-、&amp;*、&amp;/、&amp;%这些越界运算符，使用后会像常规计算一样，生成负数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">overflow</span> <span class="o">=</span> <span class="n">Int</span><span class="p">.</span><span class="n">max</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'><span class="c1">//overflow operators</span>
</span><span class='line'><span class="n">var</span> <span class="n">overflow</span> <span class="o">=</span> <span class="n">Int</span><span class="p">.</span><span class="n">max</span> <span class="o">&amp;+</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Booleans</h2>

<p>1.Swift的布尔类型为Bool，值为true或false，需要说明的一点是，作为Swift的安全特性之一，控制流中需要进行布尔判断的只能使用Bool类型，而不同于在OC中，可以将任意非零值作为判断条件，例如你不能在Swift中使用一个整数当做判断条件。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">alwaysTrue</span> <span class="o">=</span> <span class="n">true</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Tuples(元组)</h2>

<p>1.元组用来将多个值组成一个类型，但是不像类和结构体，你不需要显式的定义这个类型，如下，你可以通过索引来访问每个值，也可以通过索引来改变每个值（前提是你得元组的是可变的），而越界访问，编译器会报error。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="mi">742</span><span class="p">,</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">address</span><span class="mf">.0</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">address</span><span class="mf">.1</span><span class="p">)</span>
</span><span class='line'><span class="n">address</span><span class="mf">.0</span> <span class="o">=</span> <span class="mi">744</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.你也可以声明元组的类型，如下。如果想将元组的Int值类型改为Double有三种方式，同如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="nl">address:</span> <span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">742</span><span class="p">,</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">//change Int to Double</span>
</span><span class='line'><span class="c1">//1)using a type annotation</span>
</span><span class='line'><span class="n">var</span> <span class="nl">address1:</span> <span class="p">(</span><span class="n">Double</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">742</span><span class="p">,</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">//2)by explicit creation of a Double</span>
</span><span class='line'><span class="n">var</span> <span class="n">address2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Double</span><span class="p">(</span><span class="mi">742</span><span class="p">),</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">//3)by using a double literal value</span>
</span><span class='line'><span class="n">var</span> <span class="n">address3</span> <span class="o">=</span> <span class="p">(</span><span class="mf">742.0</span><span class="p">,</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.你也可以把元组解析成单个元素，而这也是一个copy操作，改变新值不会影响原始的元组值，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="mi">742</span><span class="p">,</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="p">(</span><span class="n">house</span><span class="p">,</span> <span class="n">street</span><span class="p">)</span> <span class="o">=</span> <span class="n">address</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">house</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">street</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.此外，你可以为元组的每个值加一个key，提高可读性，同时上述的访问方法依然有效。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="nl">number:</span> <span class="mi">742</span><span class="p">,</span> <span class="nl">street:</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">number</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">street</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.元组只是一个类型，也可以进行嵌套，元组作为其他元组的一个元素，类和结构体虽然包含了元组的所有功能，但是在一些轻量的场景下，元组可以更加快速简单地去构建一个复合类型。</p>

<!--more-->


<h2>String interpolation</h2>

<p>1.打印出一个类的信息，是常见的需求，例如OC中NSObject的description方法，如果我们想打印出上一节中元组的信息，我们可能这么做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="mi">742</span><span class="p">,</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="p">(</span><span class="n">house</span><span class="p">,</span> <span class="n">street</span><span class="p">)</span> <span class="o">=</span> <span class="n">address</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;I live at &quot;</span> <span class="o">+</span> <span class="n">String</span><span class="p">(</span><span class="n">house</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;, &quot;</span> <span class="o">+</span> <span class="n">street</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.这利用了Swift的+拼接字符串的技术，不过在Swift中有更加方便的字符串拼接技术来处理这一场景，string interpolation，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="mi">742</span><span class="p">,</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="p">(</span><span class="n">house</span><span class="p">,</span> <span class="n">street</span><span class="p">)</span> <span class="o">=</span> <span class="n">address</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;I live at \(house), \(street)&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.当然这不是打印日志专用的，在你需要从一系列变量中构建String时，都可使用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">import</span> <span class="n">Foundation</span>
</span><span class='line'>
</span><span class='line'><span class="n">var</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="mi">742</span><span class="p">,</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="p">(</span><span class="n">house</span><span class="p">,</span> <span class="n">street</span><span class="p">)</span> <span class="o">=</span> <span class="n">address</span>
</span><span class='line'><span class="n">let</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&quot;I live at \(house+10), \(street.uppercaseString)&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.最后，如果想只打印出\时，请用&#92;转义。</p>

<!--more-->


<h2>Control flow</h2>

<h3>For loops</h3>

<p>1.首先要介绍的Swift中的for循环的新特性是closed range operator，即闭区间运算符，例子如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;Swift by Tutorials!&quot;</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">.</span><span class="mf">.5</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="s">&quot;\(i) - \(greeting)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.注意，其中的i并不是一个var类型的变量，而是每次循环创建一个let的常量，是不可被赋值的。<br/>
3.1&hellip;5是一个Range类型，与for循环并无关系，下例说明了这一问题：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">range</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">.</span><span class="mf">.5</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">range</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="s">&quot;\(i) - \(greeting)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//what&#39;s 1..5?</span>
</span><span class='line'><span class="n">var</span> <span class="n">range</span> <span class="o">=</span> <span class="n">Range</span><span class="p">(</span><span class="nl">start:</span> <span class="mi">1</span><span class="p">,</span> <span class="nl">end:</span> <span class="mi">6</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.x&hellip;y只是Range类型的一个简化的语法糖，你可以用x..&lt;y来创建半开半闭的区间，最后一个值为y-1。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//means 1,2,3,4,5</span>
</span><span class='line'><span class="n">var</span> <span class="n">range1</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">.</span><span class="mf">.5</span>
</span><span class='line'><span class="c1">//means 1,2,3,4</span>
</span><span class='line'><span class="n">var</span> <span class="n">range2</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">.</span><span class="o">&lt;</span><span class="mi">5</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.那么还有个问题，for循环是怎么处理这个Range的？从而实现循环？其实是这样的，for循环可以处理很多可遍历的Swift类型，例如array、dictionary，还比如string也可以，所以range只是这些可遍历类型的其中之一而已。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="s">&quot;Swift&quot;</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>6.<strong>再挖的深一点，为什么String和Range一样可以被遍历？去看一下它们的定义就可以得知，它们都遵循了Sequence protocol，通过实现协议中的方法，就可以得到generator，继而循环请求其中的值，在第四章我们将自己创建类型来实现这一协议和利用generator。</strong></p>

<h3>While loops</h3>

<p>1.Swift同时支持while循环和do-while循环(<strong>Swift2.0将do-while改为了repeat-while</strong>)。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//while loop</span>
</span><span class='line'><span class="n">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;Swift by Tutorials!&quot;</span>
</span><span class='line'><span class="n">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="s">&quot;\(i) - \(greeting)&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">i</span><span class="o">++</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//repeat-while loop</span>
</span><span class='line'><span class="n">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;Swift by Tutorials!&quot;</span>
</span><span class='line'><span class="n">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="n">repeat</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="s">&quot;\(i) - \(greeting)&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">i</span><span class="o">++</span>
</span><span class='line'><span class="p">}</span> <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span>
</span></code></pre></td></tr></table></div></figure>


<h3>If statements</h3>

<p>1.Swift支持常规的if-else用法，需要注意的就是前面提到过的，if的条件必须是Bool类型，而且<strong>还有一点就是即使只有一条执行的语句，也要用{}，这是Swift和其他语言if的一个区别，不然会报错，这也是为了避免{}误用或少写导致的bug</strong>，此外，还有一个和if有关的关于optional value的技巧会在下一章讲到。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">import</span> <span class="n">Foundation</span>
</span><span class='line'>
</span><span class='line'><span class="n">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;Swift by Tutorials!&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">.</span><span class="mf">.5</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">5</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">.</span><span class="n">uppercaseString</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Switch statements</h3>

<p>1.Swift支持常规的switch语句，与OC不同的是，Swift的switch条件可以使任意类型，而OC只是原始类型，编译器来确保每个case的条件与switch条件类型一致。<br/>
2.第二点，Swift中的switch不需要在每个case后添加break，这是因为在Swift中，每个case执行完后，会自动跳出switch，所以不需要手动添加break，同时这也是安全策略之一。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">direction</span> <span class="o">=</span> <span class="s">&quot;up&quot;</span>
</span><span class='line'><span class="k">switch</span> <span class="n">direction</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="s">&quot;down&quot;</span><span class="o">:</span>
</span><span class='line'>      <span class="n">println</span><span class="p">(</span><span class="s">&quot;Going Down!&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="s">&quot;up&quot;</span><span class="o">:</span>
</span><span class='line'>      <span class="n">println</span><span class="p">(</span><span class="s">&quot;Going Up!&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>      <span class="n">println</span><span class="p">(</span><span class="s">&quot;Going Nowhere&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.第三，Swift的switch相当智能，如果你提供的switch条件的可能值没有在case中被全部覆盖，会提示你添加default，如上例的String类型，不然会报error；而如果你的case覆盖了switch条件的所有值，如enum类型，那么不添加default也不会报错。<br/>
4.如何在switch在一个case中匹配多个值，参照下例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">direction</span> <span class="o">=</span> <span class="s">&quot;up&quot;</span>
</span><span class='line'><span class="k">switch</span> <span class="n">direction</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="s">&quot;down&quot;</span><span class="p">,</span> <span class="s">&quot;up&quot;</span><span class="o">:</span>
</span><span class='line'>      <span class="n">println</span><span class="p">(</span><span class="s">&quot;Going Somewhere!&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>      <span class="n">println</span><span class="p">(</span><span class="s">&quot;Going Nowhere&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.可以利用上一节介绍的Range来实现case的区间匹配：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">570</span>
</span><span class='line'>
</span><span class='line'><span class="k">switch</span> <span class="n">score</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="mf">1.</span><span class="p">.</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;novice&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="mf">10.</span><span class="p">.</span><span class="o">&lt;</span><span class="mi">100</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;proficient&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="mf">100.</span><span class="p">.</span><span class="o">&lt;</span><span class="mi">1000</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;rock-star&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;awesome&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>6.另外switch与元组的结合，可以创造出更加复杂的场景处理：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">somePoint</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="k">switch</span> <span class="n">somePoint</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;(0, 0) is at the origin&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(somePoint.0), 0) is on the x-axis&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;(0,\(somePoint.1)) is on the y-axis&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.</span><span class="p">.</span><span class="mf">.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">.</span><span class="mf">.2</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(somePoint.0), \(somePoint.1)) is inside the box&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(somePoint.0), \(somePoint.1)) is outside the box&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>7.利用value binding技术，可以在判断期间将tuple的元素赋值给let变量（当然也可以声明为var类型，且它的作用范围只存在该case中）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">anotherPoint</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="k">switch</span> <span class="n">anotherPoint</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">(</span><span class="n">let</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;on the x-axis with an x value of \(x)&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">let</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;on the y-axis with an y value of \(y)&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;somewhere else at (\(x), \(y))&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>8.switch可以添加where语句，为每个case添加额外的判断条件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">yetAnotherPoint</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="k">switch</span> <span class="n">yetAnotherPoint</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="n">where</span> <span class="n">x</span> <span class="o">==</span> <span class="nl">y:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(x), \(y)) is on the line x == y&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="n">where</span> <span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="nl">y:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(x), \(y)) is on the line x == -y&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">let</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(x), \(y)) is just some arbitrary point&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记7]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/09/16/effective-objective-cdu-shu-bi-ji-7/"/>
    <updated>2015-09-16T15:42:34+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/09/16/effective-objective-cdu-shu-bi-ji-7</id>
    <content type="html"><![CDATA[<p>这是本书的最后一章了，集中讲解了有关Cocoa自带的system framework，这是开发中必须要使用的基本库，没有这些封装，很多基本的功能都无法实现，没有集合，也没有基类NSObject，可谓寸步难行，一些新的Api有时会节省我们很多工作量，同时这些库中的很多设计也是我们自己的代码需要学习的。</p>

<!--more-->


<h2>Item47 Familiarize Yourself with the System Frameworks</h2>

<ol>
<li>一个framework是将代码打包成一个动态库，会有头文件来描述接口，有时候也会有一些第三方的静态库（即.a文件），这些不能作为真正意义上的框架，但是被常常当做框架来用，所有的系统框架都使用了动态库。</li>
<li>Cocoa或Cocoa Touch是框架集，其中的基本框架就是Foundation框架，Foundation Framework不但提供了基本类型和基本集合，而且还有很多复杂功能，比如字符串处理。</li>
<li>除了另一个基础库是CoreFoundation，几乎就是Foundation的镜像库，只不过内部都是C接口和结构体，OC提供了一个名为toll-free bridging的转换特性，可以使OC对象和CF对象自由转化，toll-free bridging自身比较复杂，所以不建议自己去实现这一转化功能。除了上述两个基础框架，还有以下一些常用框架：</li>
<li>CFNetwork：基于C的网络请求基本框架，基于BSD socket提供了很多易用的请求工具，Foundation通过对它的部分封装，提供了OC类型的网络接口。</li>
<li>CoreAudio：提供了基于C的音频设备访问接口，本身是很复杂的，但OC的抽象将其变得易用不少。</li>
<li>AVFoundation：提供了用于播放和录制音视频的OC对象，例如播放视频的UI类。</li>
<li>CoreData：提供了用于数据持久化的OC对象，CoreData处理数据的存取，并能在Mac OS X与iOS之间通用。</li>
<li>CoreText：提供了基于C的文字高效的类型设置和渲染的接口。</li>
<li>使用一些C类型的框架，有时是必要的，因为通过绕过runtime，速度会更快，但是需要更加关注内存管理。</li>
<li>AppKit和UIKit分别是Mac OS X 和iOS的UI框架，提供了基于Foundation和CoreFoundation的OC类型，在它的下面是CoreAnimation和CoreGraphics在支持。</li>
<li>CoreAnimation基于OC类型，提供了渲染图像和展示动画的工具，它不是一个独立的框架，还是QuartzCore框架的一部分，但是很多情况CoreAnimation还是被优先使用。</li>
<li>CoreGraphics是基于C类型的，提供了用于2D渲染的必不可少的结构体和函数，CGPoint，CGSize，CGRect都是在这儿定义的。</li>
<li>UIKit的上层还有很多更高级的框架，例如：MapKit，Social framework。</li>
</ol>


<!--more-->


<h2>Item48 Prefer Block Enumeration to for Loops</h2>

<p>1.遍历一个集合类型是常见需求，，而OC也有很多方式，从标准的C的for循环，到OC 1.0的NSEnumerator，到OC 2.0的快速遍历，block加入OC后，又出现了遍历直接传入block进行对象处理的新方法。<br/>
2.For Loops：沿用最原始的C语言的循环，定义一个int型index，然后按照index去遍历每个对象，对于NSArray来说影响还不大，但是对于NSDictionary，NSSet来说，因为都是无序的，所以必须额外生成中间数组，这是额外的内存消耗，但倒序遍历只需要改变index为递减即可，还算方便。<br/>
3.OC 1.0 NSEnumerator：NSEnumerator是一个基类，需要重写-(NSArray*)allObjects,&ndash;(id)nextObject两个方法，而Foundation框架的集合类型都支持了NSEnumerator，可以通过不断执行nextObject()来完成遍历，它的优势是所有的集合类型的遍历方式都是类似的，而且也支持不同的enumerator来实现不同顺序来遍历，缺点是还是需要额外的enumerator，而且不能得知当前的index。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//NSArray enumerator</span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">anArray</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="n">NSEnumerator</span> <span class="o">*</span><span class="n">enumerator</span> <span class="o">=</span> <span class="p">[</span><span class="n">anArray</span> <span class="n">objectEnumerator</span><span class="p">];</span>
</span><span class='line'><span class="kt">id</span> <span class="n">object</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">((</span><span class="n">object</span> <span class="o">=</span> <span class="p">[</span><span class="n">enumerator</span> <span class="n">nextObject</span><span class="p">])</span><span class="o">!=</span><span class="nb">nil</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">//Do something with &#39;object&#39;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//NSDictionary enumerator</span>
</span><span class='line'><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">aDictionary</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="kt">id</span> <span class="n">key</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">((</span><span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">enumerator</span> <span class="n">nextObject</span><span class="p">])</span><span class="o">!=</span><span class="nb">nil</span><span class="p">){</span>
</span><span class='line'>  <span class="kt">id</span> <span class="n">value</span> <span class="o">=</span> <span class="n">aDictionary</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
</span><span class='line'>  <span class="c1">//Do something with &#39;key&#39; and &#39;value&#39;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//NSArray reverse enumerator</span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">anArray</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="n">NSEnumerator</span> <span class="o">*</span><span class="n">enumerator</span> <span class="o">=</span> <span class="p">[</span><span class="n">anArray</span> <span class="n">reverseObjectEnumerator</span><span class="p">];</span>
</span><span class='line'><span class="kt">id</span> <span class="n">object</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">((</span><span class="n">object</span> <span class="o">=</span> <span class="p">[</span><span class="n">enumerator</span> <span class="n">nextObject</span><span class="p">])</span><span class="o">!=</span><span class="nb">nil</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">//Do something with &#39;object&#39;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.Fast Enumeration：OC2.0引入了快速遍历，快速遍历详单与结合了for-loop和enumerator的双重特点，同时极大的简化了语法。实现这一技术是采用了NSFastEnumeration这一协议（只有一个方法），集合类型通过遵循这一协议，从而支持了快速遍历，实现协议中的方法使得类可以同时返回多个对象：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//NSFastEnumeration</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">countByEnumeratingWithState:</span><span class="p">(</span><span class="n">NSFastEnumerationState</span><span class="o">*</span><span class="p">)</span><span class="nv">state</span> <span class="nf">objects:</span><span class="p">(</span><span class="kt">id</span><span class="o">*</span><span class="p">)</span><span class="nv">stackbuffer</span> <span class="nf">count:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">length</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//NSArray</span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">anArray</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span> <span class="k">in</span> <span class="n">anArray</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">//Do something with &#39;object&#39;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//NSDictionary</span>
</span><span class='line'><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">aDictionary</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">id</span> <span class="n">key</span> <span class="k">in</span> <span class="n">aDictionary</span><span class="p">){</span>
</span><span class='line'>  <span class="kt">id</span> <span class="n">value</span> <span class="o">=</span> <span class="n">aDictionary</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
</span><span class='line'>  <span class="c1">//Do something with &#39;key&#39; and value</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果需要反向遍历，可以通过下列方法，因为NSEnumerator也实现了NSFastEnumeration：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">anArray</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span> <span class="k">in</span> <span class="p">[</span><span class="n">anArray</span> <span class="n">reverseObjectEnumerator</span><span class="p">]){</span>
</span><span class='line'>  <span class="c1">//Do something with &#39;object&#39;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>快速遍历的优点是效率很高，而且代码简洁，但是依然有两个缺陷，NSDictionary如果同时需要key和value的话，还是需要两步；同时index也是无法直接获取。</p>

<p>5.Block-Based Enumeration：是在OC引入block后的遍历集合的最新方法，下面是NSArray的基本block遍历方法，前两个参数很明显，第三个参数是用来停止遍历的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//NSArray</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">enumerateObjectsUsingBlock:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span><span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span><span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span>
</span><span class='line'><span class="c1">//NSDictionary</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">enumerateLeysAndObjectsUsingBlock:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">id</span> <span class="n">key</span><span class="p">,</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span><span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span>
</span><span class='line'><span class="c1">//example</span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">aArray</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">aArray</span> <span class="nl">enumerateObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span><span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span><span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">//Do something with &#39;object&#39;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">shouldStop</span><span class="p">){</span>
</span><span class='line'>      <span class="o">*</span><span class="n">stop</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>block遍历虽然看起来语法比快速遍历更复杂了，但是代码还是很整洁的，而且提供了方便的停止遍历的方法，而在其他方式中需要自己添加break，另外你可以现在一次性获得所有的信息，包括：NSArray的index，NSDictionary的key和value。</p>

<p>如果NSDictionary的键值类型是确定的，那么你可以重写block中的id类型，也可以在类型出现异常时抛出警告，所以如果类型确定，还是推荐这么写的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">aDictionary</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">aDictionary</span> <span class="nl">enumerateKeysAndObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span><span class="n">NSString</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span><span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">//Do Something with &#39;key&#39; and &#39;obj&#39;</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>除了这些，还有个最大的特点是，block遍历可以通过设置option（枚举类型）来实现各种各样的遍历方式，例如通过NSEnumerationConcurrent实现对集合中的对象并发执行方法（内部应该是利用了GCD的dispatch group），通过NSEnumerationReverse实现集合的逆向遍历，而且也可以通过位与操作，同时实现这两个option。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//NSArray</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">enumerateObjectsWithOptions:</span><span class="p">(</span><span class="n">NSEnumerationOptions</span><span class="p">)</span><span class="nv">options</span> <span class="nf">usingBlock:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span><span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span><span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span>
</span><span class='line'><span class="c1">//NSDictionary</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">enumerateLeysAndObjectsWithOptions:</span><span class="p">(</span><span class="n">NSEnumerationOptions</span><span class="p">)</span><span class="nv">options</span> <span class="nf">usingBlock:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">id</span> <span class="n">key</span><span class="p">,</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span><span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>综上，block遍历虽然语法不及快速遍历简洁，但是对于NSArray获得index，对于NSDictionary获得key和value这些信息，通过option获得并发执行遍历，都是优于其他遍历方法的。</p>

<!--more-->


<h2>Item49 Using Toll-Free Bridging for Collections with Custom Memory-Management Semantics</h2>

<p>1.Toll-Free Bridging是OC用来在Foundation定义的OC对象和CoreFoundation定义的对应的C结构体之间相互转化，使用了<strong>bridge关键字，相当于ARC依然持有OC对象，如果使用了</strong>bridge_retained，那么ARC就要交出持有权，那么在我们使用完CF指针后要执行CFRelease(aCFArray)来释放内存，反之你需要将CF指针转化为OC对象，并需要转移持有权时，要加上__bridge_transfer关键字，这三个关键字非常重要。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">anNSArray</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="err">@</span><span class="mi">1</span><span class="p">,</span><span class="err">@</span><span class="mi">2</span><span class="p">,</span><span class="err">@</span><span class="mi">3</span><span class="p">,</span><span class="err">@</span><span class="mi">4</span><span class="p">,</span><span class="err">@</span><span class="mi">5</span><span class="p">];</span>
</span><span class='line'><span class="n">CFArrayRef</span> <span class="n">aCFArray</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">CFArrayRef</span><span class="p">)</span><span class="n">anNSArray</span><span class="p">;</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Size of array = %li&quot;</span><span class="p">,</span> <span class="n">CFArrayGetCount</span><span class="p">(</span><span class="n">aCFArray</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.为什么要去使用CF结构体指针？当然绝大部分情况我们是不会刻意去使用的，作者列举了一个特殊的场景：NSDictionary的key是copy类型，而value是retain类型，也就意味着，不支持copy协议的类是不能作为NSDictionary的key的，如果我们需要一个value和key都是retain类型的dictionary，那要怎么办呢？<br/>
3.作者列举了一种思路，重新构建一个CF的字典类型，因为在这一级，我们可以控制key和value的回调类型，然后再通过Toll-Free Bridging来转化为需要的NSMutableDictionary，从而达到目的。</p>

<!--more-->


<h2>Item50 Use NSCache Instead of NSDictionary for Caches</h2>

<p>1.在网络请求中做缓存是常见的需求，因为一般会将data和url或者request对象做成键值对存储，所以一些年轻的程序员就会考虑用NSDictionary来做缓存，但是作者建议用NSCache来做这类缓存。<br/>
2.NSCache的优势之一是，当系统资源吃紧时，cache会被自动释放，且会优先释放最近未被使用的缓存，如果NSDictionary想实现这一点，是需要做很多额外工作的。<br/>
3.NSCache的优势之二是，NSDictionary的key是copy类型，而value是retain类型，而NSCache的key和value都是retain类型，这就意味着，NSCache可以将不实现copy协议的对象作为key，虽然根据Item49的做法，也可以把NSDictionary做成这种类型，但是实现起来很复杂。另外，NSCache是线程安全的，你可以在多个线程同时插值，在做缓存时，在主线程读取缓存，然后缓存不存在，在后台线程下载并赋值是常见的场景。<br/>
4.你可以手动控制缓存的容量，通过设置缓存数量和大小来控制，如果缓存数量或大小超过限制，也会开始自动释放，但释放的顺序是不可控的，所以想通过改变最大容量来让缓存按照顺序释放是不现实的。<br/>
5.需要注意的是，设置缓存大小容量，是基于加入缓存的对象的大小易于计算，如果计算对象大小成本过高的话，这就会影响效率，因为每次加入都会进行计算。例如去硬盘计算文件大小或去数据库查找大小就是耗时的操作，但如果是NSData作为缓存对象，那么获取它的大小代价就很小，只是读取一个property而已。<br/>
6.下面是一个使用NSCache的实例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@implementation</span> <span class="nc">EOCClass</span><span class="p">{</span>
</span><span class='line'>  <span class="n">NSCache</span> <span class="o">*</span><span class="n">_cache</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">init</span><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">((</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">])){</span>
</span><span class='line'>      <span class="n">_cache</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSCache</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'>      <span class="n">_cache</span><span class="p">.</span><span class="n">countLimit</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span><span class='line'>      <span class="n">_cache</span><span class="p">.</span><span class="n">totalCostLimit</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">downloadDataForURL:</span><span class="p">(</span><span class="n">NSURL</span><span class="o">*</span><span class="p">)</span><span class="n">url</span><span class="p">{</span>
</span><span class='line'>  <span class="n">NSData</span> <span class="o">*</span><span class="n">cachedData</span> <span class="o">=</span> <span class="p">[</span><span class="n">_cache</span> <span class="nl">objectForKey:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">cacheData</span><span class="p">){</span>
</span><span class='line'>      <span class="c1">//Cache hit</span>
</span><span class='line'>      <span class="p">[</span><span class="n">self</span> <span class="nl">useData:</span><span class="n">cachedData</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">//Cache miss</span>
</span><span class='line'>      <span class="n">EOCNetworkFetcher</span> <span class="o">*</span><span class="n">fetcher</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EOCNetworkFetcher</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithURL:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'>      <span class="p">[</span><span class="n">fetcher</span> <span class="nl">startWithCompletionHandler:</span><span class="o">^</span><span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span>
</span><span class='line'>          <span class="p">[</span><span class="n">_cache</span> <span class="nl">setObject:</span><span class="n">data</span> <span class="nl">forKey:</span><span class="n">url</span> <span class="nl">cost:</span><span class="n">data</span><span class="p">.</span><span class="n">length</span><span class="p">];</span>
</span><span class='line'>          <span class="p">[</span><span class="n">self</span> <span class="nl">useData:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>7.除了NSData，另一种可以和NSCache搭配的是NSPurgeableData，它是NSMutableData的子类，实现了NSDiscardableContent协议，NSPurgeableData的内存会在系统资源紧张时自动释放，<em>isContentDiscard</em>是协议中的一个方法，返回内存是否已释放。<br/>
8.NSPurgeableData在使用之前要用<em>beginContentAccess</em>确保目前内存不被释放，然后使用完后调用<em>endContentAccess</em>告知系统可以被释放，这一对操作可以嵌套，类似retain/release。<br/>
9.如果NSPurgeableData添加到NSCache，释放的对象会自动移出cache，这可以被<em>evictsObjectsWithDiscardedContent</em>这一property关闭或开启。<br/>
10.下面是一个NSPurgeableData的实例，注意NSPurgeableData被创建时就相当于+1purge reference count与alloc类似，所以不必再加<em>beginContentAccess</em>，但用完要加<em>endContentAccess</em>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">downloadDataForURL:</span><span class="p">(</span><span class="n">NSURL</span><span class="o">*</span><span class="p">)</span><span class="nv">url</span><span class="p">{</span>
</span><span class='line'>  <span class="n">NSPurgeableData</span> <span class="o">*</span><span class="n">cacheData</span> <span class="o">=</span> <span class="p">[</span><span class="n">_cache</span> <span class="nl">objectForKey:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">cachedData</span><span class="p">){</span>
</span><span class='line'>      <span class="c1">//Stop the data being purged</span>
</span><span class='line'>      <span class="p">[</span><span class="n">cacheData</span> <span class="n">beginContentAccess</span><span class="p">];</span>
</span><span class='line'>      <span class="c1">//Use the cached data</span>
</span><span class='line'>      <span class="p">[</span><span class="n">self</span> <span class="nl">useData:</span><span class="n">cachedData</span><span class="p">];</span>
</span><span class='line'>      <span class="c1">//Mark that the data may be purged again</span>
</span><span class='line'>      <span class="p">[</span><span class="n">cacheData</span> <span class="n">endContentAccess</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">//Cache miss</span>
</span><span class='line'>      <span class="n">EOCNetworkFetcher</span> <span class="o">*</span><span class="n">fetcher</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EOCNetworkFetcher</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithURL:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'>      <span class="p">[</span><span class="n">fetcher</span> <span class="nl">startWithCompletionHandler:</span><span class="o">^</span><span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span>
</span><span class='line'>          <span class="n">NSPurgeableData</span> <span class="o">*</span><span class="n">purgeableData</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSPurgeableData</span> <span class="nl">dataWithData:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>          <span class="p">[</span><span class="n">_cache</span> <span class="nl">setObject:</span><span class="n">purgeableData</span> <span class="nl">forKey:</span><span class="n">url</span> <span class="nl">cost:</span><span class="n">purgeableData</span><span class="p">.</span><span class="n">length</span><span class="p">];</span>
</span><span class='line'>          <span class="c1">//Don&#39;t need to beginContentAccess as it begins with access already marked</span>
</span><span class='line'>          <span class="p">[</span><span class="n">self</span> <span class="nl">useData:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>          <span class="c1">//Mark that the data may be purged now</span>
</span><span class='line'>          <span class="p">[</span><span class="n">purgeable</span> <span class="n">endContentAccess</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Item51 Keep initialize and load Implementations Lean</h2>

<ol>
<li>一个类总会有有自己的初始化方法，由于OC中类型大部分继承于NSObject，所有有很多继承于NSObject的初始化方法，第一个就是<em>*(void)load</em>方法。</li>
<li><em>load</em>方法在每个class和category中会且只会被调用一次，这个方法发生在包含该类的library在加载后，一般是应用加载中，而且只是iOS代码的独有的，Mac OS X有更灵活的dynamic loading，可以使library在应用加载后加载，而category的load在其原class加载后加载。</li>
<li>想重写<em>load</em>方法的问题是，它运行时runtime处于不稳定的状态，所有父类的<em>load</em>方法是先于其他类的<em>load</em>调用的，所依赖库中的所有<em>load</em>方法会先调用。但在一个库中，这些类的<em>load</em>方法的调用顺序就是不可控的了。</li>
<li>作者举例：EOCClassB中实现了<em>load</em>方法，它导入了Foundation.h和EOCClassA.h头文件，而EOCClassA和它同属一个库，EOCClassB在其<em>load</em>方法中使用了NSLog输出NSString，也实例化了EOCClassA并进行了操作。那么NSLog和NSString的使用是没问题的，因为Foundation.h中的class肯定先于EOCClassB的<em>load</em>方法，但使用EOCClassA就有问题了，你不能保证EOCClassA的<em>load</em>是否已经在EOCClassB的<em>load</em>方法之前调用了，因为有可能EOCClassA在<em>load</em>之前是不可用的。</li>
<li><em>load</em>方法并不遵循于一般的继承规则，一个类没有实现<em>load</em>的话，是不会调用该方法的，即使它的父类实现了；<em>load</em>方法可同时存在于类和它的category中，且category的<em>load</em>会在本类的<em>load</em>之后调用。</li>
<li>所以综上，<em>load</em>方法并不适合我们自己做初始化工作，因为我们不能确保所有的类型都已经加载，所以实际上它的用途最好仅停留在测试层面，因为如果在<em>load</em>中加载过多任务，也会影响应用的加载时间，是很影响用户体验的。</li>
<li>第二个初始化方法是<em>+(void)initialize</em>方法，它也是会且只会被调用一次，它是被runtime调用的，而不能被直接调用，它与<em>load</em>有相似的地方，也有很多不同，概括有三点。</li>
<li>区别一是<em>initialize</em>是懒加载，只有一个类被第一次用到之前才会调用，因此会出现一个类的<em>initialize</em>永远没被调用过的情况，这也意味着不像<em>load</em>会出现所有的<em>load</em>方法在同一时间加载，而且会阻塞应用加载。</li>
<li>区别二是<em>initialize</em>在执行时，runtime是稳定状态，调用其他类的方法是安全的，而且runtime保证了<em>initialize</em>的线程安全，意味着只有执行<em>initialize</em>的线程可以和class和其实例交互，其他线程将会被阻塞，知道<em>initialize</em>完成。</li>
<li>区别三是<em>initialize</em>与其他消息一样，如果类的<em>initialize</em>没实现，但是父类实现了，那么父类的<em>initialize</em>会被调用。</li>
<li>作者举例父类实现了<em>initialize</em>，但是子类没有实现，但在log中会看到该方法被调用了两次，原因是使用一个类时，其父类的<em>initialize</em>会先调用，然后到子类时，由于没有实现该方法，所以继续沿响应链得知父类实现了该方法，所以又执行一次，为了避免这一问题，在<em>initialize</em>中加上<em>if(self == [EOCBaseClass class])</em>的判断就好了。</li>
<li>虽然<em>initialize</em>比<em>load</em>灵活一些了，但是作者依然不推荐在<em>initialize</em>中做很复杂的初始化工作，原因也有三。</li>
<li>原因一，一个类的<em>initialize</em>可能在任意线程，如果它发生在UI线程，而且<em>initialize</em>做了很多工作的话，可能导致主线程阻塞。预测哪个线程会先使用一个类是不可靠的，所以强制一个固定线程去触发类的<em>initialize</em>方法是不现实的。</li>
<li>原因二，你不能控制一个类什么时候<em>initialize</em>，它是确定会在一个类被第一次使用之前调用，但是假设它会在某个固定时间执行是不可靠的，runtime可能会有所更新，导致细微改变类的初始化方式，那么你对类已经初始化完毕的设想可能是错误的。</li>
<li>原因三，比较特殊，就是两个或多个类之间的初始化方法中出现了内部数据的相互调用，可能会出现，一个类需要另一个类初始化完毕，但是第二个类还依赖于第一个类的初始化完毕，造成了两个类之间的相互等待，和循环引用有一定程度的类似。</li>
<li>综上，<em>initialize</em>中并不适合做大量的工作，尤其是调用其他类或自己的方法，如果自己的方法必须依赖自己已经初始化完毕，那么也会出现上述问题，所以<em>initialize</em>的正确用法是去初始化那些，无法在编译期间赋值的全局静态变量和全局变量，比如static NSMutableArray *kSomeObjects，因为这些OC对象必须等到runtime激活后才能使用。</li>
<li>所以始终保持<em>initialize</em>和<em>load</em>方法简洁是一个好习惯，能避免大量的奇葩问题。</li>
</ol>


<!--more-->


<h2>Item52 Remember that NSTimer Retains Its Target</h2>

<p>1.NSTimer是一个常用的类，用来定时执行一些方法，或循环执行一些方法，它是需要和一个run loop关联的，你既可以在当前run loop预设置，也可以自己创建NSTimer对象自行设置。<br/>
2.NSTimer预设置的方法需要传入target和selector，timer会retain target，而会在timer失效时release它，一个timer可以通过直接调用invalidate（一般是循环的）或者启动后（一般是一次性的）就会失效。<br/>
3.因为timer会retain target，所以在循环执行时特别容易出现循环引用，如下，startPolling后，便会出现EOCClass和timer相互引用的结果，目前想解决这一问题，只能通过要求调用方自行调用stopPolling，但如果这时一个对外使用的类的话，这是不可控的；而寄希望于dealloc去解开这一循环，是不现实的，因为对于循环引用的两个对象，是不会出现一方先释放的。而且如果这一引用存在，会一直循环去执行这个任务，带来的问题不光是内存泄露。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'> <span class="err">#</span><span class="n">import</span> <span class="o">&lt;</span><span class="n">Foundation</span><span class="o">/</span><span class="n">Foundation</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">EOCClass</span>:<span class="nc">NSObject</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">startPolling</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">stopPolling</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">EOCClass</span><span class="p">{</span>
</span><span class='line'>  <span class="n">NSTimer</span> <span class="o">*</span><span class="n">_pollTimer</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">init</span><span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dealloc</span><span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="n">_pollTimer</span> <span class="n">invalidate</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">stopPolling</span><span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="n">_pollTimer</span> <span class="n">invalidate</span><span class="p">];</span>
</span><span class='line'>  <span class="n">_pollTimer</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">startPolling</span><span class="p">{</span>
</span><span class='line'>  <span class="n">_pollTimer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nl">scheduledTimerWithTimeInterval:</span><span class="mf">5.0</span> <span class="nl">target:</span><span class="n">self</span> <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="n">p_doPoll</span><span class="p">)</span> <span class="nl">userInfo:</span><span class="nb">nil</span> <span class="nl">repeats:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">p_doPoll</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//Poll the resource</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.那么要想解决这个问题，又不依赖外部，一个方案是做一个NSTimer的block分类，如下，block被设置为userInfo参数，timer也会对它retain，block要进行一次copy，从stack移到heap上，这在Item37说过，现在的target变成了NSTimer这个类本身，因为NSTimer作为一个类对象，是一个单例，所以不用担心释放问题，虽然也存在循环引用，但是没关系。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'> <span class="err">#</span><span class="n">import</span> <span class="o">&lt;</span><span class="n">Foundation</span><span class="o">/</span><span class="n">Foundation</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">NSTimer</span><span class="nl">(EOCBlockSupport)</span>
</span><span class='line'><span class="k">+</span><span class="p">(</span><span class="n">NSTimer</span><span class="o">*</span><span class="p">)</span><span class="nf">eoc_scheduledTimerWithTimeInterval:</span><span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">interval</span> <span class="nf">block:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">block</span> <span class="nf">repeats:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">repeats</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">NSTimer</span><span class="nl">(EOCBlockSupport)</span>
</span><span class='line'><span class="k">+</span><span class="p">(</span><span class="n">NSTimer</span><span class="o">*</span><span class="p">)</span><span class="nf">eoc_scheduledTimerWithTimeInterval:</span><span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">interval</span> <span class="nf">block:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">block</span> <span class="nf">repeats:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">repeats</span><span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="nl">scheduledTimerWithTimeInterval:</span><span class="n">interval</span> <span class="nl">target:</span><span class="n">self</span> <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">eoc_blockInvoke:</span><span class="p">)</span> <span class="nl">userInfo:</span><span class="p">[</span><span class="n">block</span> <span class="n">copy</span><span class="p">]</span> <span class="nl">repeats:</span><span class="n">repeats</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">+</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">eoc_blockInvoke:</span><span class="p">(</span><span class="n">NSTimer</span><span class="o">*</span><span class="p">)</span><span class="nv">timer</span><span class="p">{</span>
</span><span class='line'>  <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)()</span><span class="o">=</span><span class="n">timer</span><span class="p">.</span><span class="n">userInfo</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">block</span><span class="p">){</span>
</span><span class='line'>      <span class="n">block</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.回到新方法的使用，像下面这样直接调用的话，还是会导致循环引用，因为block会retain self，而timer会在userInfo处retain block，而timer本身被self引用，所以正确的做法是做一个self的weak变量，在block中再声明一个strong的临时变量，确保block retain一个weak对象，而在block内部又不会提前释放掉，这也是解决block retain cycle的常见策略。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//wrong</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">startPolling</span><span class="p">{</span>
</span><span class='line'>  <span class="n">_polTimer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nl">eoc_scheduledTimerWithTimeInterval:</span><span class="mf">5.0</span> <span class="nl">block:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="p">[</span><span class="n">self</span> <span class="n">p_doPoll</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nl">repeats:</span><span class="n">YES</span>
</span><span class='line'>  <span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//right</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">startPolling</span><span class="p">{</span>
</span><span class='line'>  <span class="n">__weak</span> <span class="n">__typeof</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="n">weakSelf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'>  <span class="n">_polTimer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nl">eoc_scheduledTimerWithTimeInterval:</span><span class="mf">5.0</span> <span class="nl">block:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">__strong</span> <span class="n">__typeof</span><span class="p">(</span><span class="n">weakSelf</span><span class="p">)</span><span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>
</span><span class='line'>      <span class="p">[</span><span class="n">strongSelf</span> <span class="n">p_doPoll</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nl">repeats:</span><span class="n">YES</span>
</span><span class='line'>  <span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记6]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/09/09/effective-objective-cdu-shu-bi-ji-6/"/>
    <updated>2015-09-09T16:29:01+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/09/09/effective-objective-cdu-shu-bi-ji-6</id>
    <content type="html"><![CDATA[<p>第六章的主要内容是Blocks和GCD，这可以说是Morden OC当中的三驾马车的其余两架，它们和ARC的出现，彻底改变了OC的开发模式。多线程是现代编程中任何语言都不可或缺的技术，在iOS中阻塞UI主线程往往是应用崩溃或用户体验差的重要原因，多线程就是解决这一问题的良方，而Blocks和GCD就是Apple给开发者带来的多线程解决方案。Blocks即OC中的闭包，它可以被当做一个对象，可以运行于其他上下文中。GCD基于dispatch queues提供了对线程的抽象，它会根据系统资源自动开辟、复用、销毁后台线程，同时GCD也对一些常见编程提供了简化方案，比如：创建单例、并发任务等等。</p>

<!--more-->


<h2>Item37 Understand Blocks</h2>

<p>1.Blocks作为了GCC的拓展，也存在于Clang的所有版本中。Blocks的runtime component在Mac OS X 10.4和iOS4被加入。由于是C级别的语言特性，所以可以被用于C,C++,OC当中。</p>

<h3>Block Basics</h3>

<p>1.Blcoks的类型写法类似函数指针，也可以直接当做函数来执行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">int</span><span class="p">(</span><span class="o">^</span><span class="n">addBlcok</span><span class="p">)(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kt">int</span> <span class="n">add</span> <span class="o">=</span> <span class="n">addBlcok</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span><span class="c1">//&lt;add=7</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.Blocks最重要的特性，它可以将它包含的所有内容进行复制，也就意味着范围内的任何变量都可以使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">int</span> <span class="n">additional</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span><span class="p">(</span><span class="o">^</span><span class="n">addBlcok</span><span class="p">)(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">additional</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kt">int</span> <span class="n">add</span> <span class="o">=</span> <span class="n">addBlcok</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span><span class="c1">//&lt;add=12</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.默认Blocks是不能改变外部变量的，但是可以通过添加__blcok关键字，来声明变量可以改变。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="err">@</span><span class="mi">0</span><span class="p">,</span><span class="err">@</span><span class="mi">1</span><span class="p">,</span><span class="err">@</span><span class="mi">2</span><span class="p">,</span><span class="err">@</span><span class="mi">3</span><span class="p">,</span><span class="err">@</span><span class="mi">4</span><span class="p">,</span><span class="err">@</span><span class="mi">5</span><span class="p">];</span>
</span><span class='line'><span class="n">__blcok</span> <span class="n">NSInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">array</span> <span class="nl">enumerateObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSNumber</span> <span class="o">*</span><span class="n">number</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">){</span>
</span><span class='line'>  <span class="k">if</span><span class="p">([</span><span class="n">number</span> <span class="nl">compare:</span><span class="err">@</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">NSOrderedAscending</span><span class="p">){</span>
</span><span class='line'>      <span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'><span class="c1">//count = 2</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.上例也说明了Block作为内联参数的使用，这也是它的重要用法，取代了之前传selector name这样的方式，增加了代码可读性。<br/>
5.Block内部引用的变量会被隐性添加retain，然后在block release时再调用一次release，所以blcok可以被理解为一个一般的OC对象，它也是有retain count的。<br/>
6.那么在一个类中的实例方法中声明使用block，然后在block中使用了类的实例变量，那么其实是对self进行了一次retain，如果这时这个block被self的变量再retain一次，那么就会形成循环引用，解决方法在Item40会详细说，其实就是声明一个self的__weak替代对象就好了。</p>

<h3>The Guts of Block</h3>

<ol>
<li>Block的实质，除了包含通常的isa（block的Class为void*），flags等，block的三个主要组成为：invoke、descriptor、Captured variables。</li>
<li>invoke是一个函数指针，类型为void(<em>)(void </em>,&hellip;)，至少包含的void *其实就是block自身，因为block的Captured variables包含了所有据有变量的copy，invoke指向的就是block的实现部分，所以也证明了block实质上就是Apple对函数指针的一次高级封装，便于开发者使用。</li>
<li>descriptor指向一个结构体，包含了：size（blcok总大小），copy和dispose（都是函数指针，copy在blcok被拷贝时执行，dispose在block retain或release据有的对象时执行）。</li>
<li>Captured variables就是block据有的所有变量的copy，注意这里的copy是指针拷贝。</li>
</ol>


<h3>Global，Stack，and Heap Blocks</h3>

<p>1.Block声明的时候是存在于stack上的，类似下面的代码是不安全的，因为if/else中声明的blcok是存在于stack上的，在if/else结束时，系统可能会收回这些内存重用，而且这个问题在编译中不会报出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">blcok</span><span class="p">)();</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="cm">/*some condition*/</span><span class="p">){</span>
</span><span class='line'>  <span class="n">blcok</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Block A&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">blcok</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Block B&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">block</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>2.解决这一问题的方法，就是对声明的block进行copy，这样的话，block被copy到了heap上，这样的block和其他一般对象就一样了，也不会出现上述问题，使用ARC的话，block会在之后自动释放，而MRC将要自己去添加release方法，这也是类在为block类型的property添加属性时，一般都是copy类型的。<br/>
3.所谓的global Block就是类似于之前说的NSString和NSNumber的常量声明，如果Block内部没有任何状态变化，也不依赖于外部的状态变化，在编译期间就可以知道其所需要的空间大小，系统就会对其做优化，生成一个global block，它是被声明在global memory上，而不是stack上，而且copy对于它也是一个空操作，也不会被释放，实际就是一个单例，类似：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)()</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;This is a global blcok!&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Item38 Create typedefs for Common Block Types</h2>

<p>1.由于Block的类型像函数指针一样，参数多的话会很长，而且类型名又在中间，很难使用和记住，所以我们可以使用C语言的typedef来做类型定义，这么做也方便将来可能的修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">typedef</span> <span class="nf">int</span><span class="p">(</span><span class="o">^</span><span class="n">EOCSomeBlock</span><span class="p">)(</span><span class="kt">BOOL</span> <span class="n">flag</span><span class="p">,</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'><span class="n">EOCSomeBlock</span> <span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">flag</span><span class="p">,</span><span class="kt">int</span> <span class="n">value</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">//Implementation</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.对block命名时还是要遵循OC的命名习惯，使用命名空间，也不要还害怕对相同类型使用多个命名，有时候这是必须的，一是命名更加清楚，二是方便将来重构。</p>

<!--more-->


<h2>Item39 Use Handler Blocks to Reduce Code Separation</h2>

<ol>
<li>异步多线程执行任务，之前一直是采用Delegate模式，但现在我们可以通过定义block作为handler来完成同样的任务，而且代码简洁，可读性强。</li>
<li>尤其出现一个类中同时使用多个同种类型的实例，采用一套回调时，那么使用Delegate则会大大增加代码的复杂度，会在很多地方出现switch的判断，而使用block则能避免这一问题。</li>
<li>作者列举了两个例子使用这一模式的场景，都是针对网络请求回调，一是，使用两个block分别处理失败和成功，二是使用一个block，使用error来判断失败和成功（这两种写法都在作者的AFNetworking里出现过）。</li>
<li>方案一的好处是，代码清晰，使用者只需对不同情况填空即可；方案二的好处是，可以更灵活的处理这一问题，如出现一些数据异常、下载中断这些情况，业务端也可以自行按失败来进行处理。</li>
<li>在设计API时，有时会出现，需要在特定线程执行代码的需求，这时我们可以在接口中加入(NSOperationQueue*)queue这样的参数，可以是缺省的。</li>
</ol>


<!--more-->


<h2>Item40 Avoid Retain Cycles Introduced by Blocks Referencing the Object Owning Them</h2>

<ol>
<li>block出现循环引用一般是因为ClassA使用了ClassB的实例，ClassB有block的实例，而ClassA在block中使用了自己的其他实例，造成了block retain了ClassA，ClassA retain了ClassB，ClassB retain了block，这样循环引用就形成了。</li>
<li>解决方案一是在block中完成所有操作时，将ClassB的实例置为nil，这样retain环就断裂了，但这么做也有问题，如果这段block代码没有被执行，那么retain环还存在。</li>
<li>还有一种更隐蔽的情况，ClassA不在把ClassB当做实例变量，只是用做局部变量，但在block中使用了ClassB的局部变量，这样会出现，block retain了ClassB，ClassB ratain了block，所以形成了二元retain环，不过解决很简单，在ClassB中完成对block的最终调用后，将它的block实例置为nil。</li>
<li>这样也凸显了不将block作为外部property的好处（使用者只能通过初始化方法赋值），如果block直接暴露给使用者，你只能要求使用者去清除block property，但这通常是不合理的设计。</li>
</ol>


<!--more-->


<h2>Item41 Prefer Dispatch Queues to Locks for Synchronization</h2>

<p>1.OC大部分线程操作都是默认多线程的，但如果有些情况需要单线程，就需要开发者自己实现，GCD之前有两种方式。<br/>
2.一是synchronization block，它将包含的代码进行加锁操作，参数是self，这可以实现类的不同实例可以分别运行这个方法，但缺点是如果过度使用，会导致性能问题，也会出现代码被不知名的锁所阻塞的问题。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">synchronizedMethod</span><span class="p">{</span>
</span><span class='line'>  <span class="k">@synchronized</span><span class="p">(</span><span class="n">self</span><span class="p">){</span>
</span><span class='line'>      <span class="c1">//Safe</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.二是NSLock，而且也有专门为递归设计的NSRecursiveLock，但是NSLock一个最大的问题是会出现死锁问题，所以二者都不是最佳方案。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">_lock</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSLock</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">synchronizedMethod</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="n">_lock</span> <span class="n">lock</span><span class="p">];</span>
</span><span class='line'>  <span class="c1">//Safe</span>
</span><span class='line'>  <span class="p">[</span><span class="n">_lock</span> <span class="n">unlock</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.那么对比使用atomic属性的property，Item6也说过，我们手动实现时，可以利用synchronization block来实现，但是问题就是当多个property这么做时，会出现propertys之间出现阻塞，而且在多次频繁访问一个property时，其他线程可能会对其修改，会造成返回值不同。<br/>
5.替代方案就是GCD的serial synchronization queue，它可以使读写property在一个队列中执行，也就避免了上述问题，代码更加简化，而且利用了GCD底层的优化，而且你不用担心对象之间的相互阻塞。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">_syncQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_creat</span><span class="p">(</span><span class="s">&quot;com.EOC.syncQueue&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nf">someString</span><span class="p">{</span>
</span><span class='line'>  <span class="n">__block</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">localSomeString</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">_syncQueue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">localSomeString</span> <span class="o">=</span> <span class="n">_someString</span><span class="p">;</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">localSomeString</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setSomeString:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">someString</span><span class="p">{</span>
</span><span class='line'>  <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">_syncQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">_someString</span> <span class="o">=</span> <span class="n">someString</span><span class="p">;</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>6.对于这一方案还有优化，优化一是可以将setter方法使用异步执行，因为setter方法不会有返回值，而且由于和getter还是在一个队列执行，还是能保持读取的同步，但是涉及到一个问题，异步需要将block copy到异步线程，那么如果block内容很简单，可能copy的时间和执行的时间差不多，也就达不到优化的效果，但是当block内容比较复杂时，这一手段还是有效地。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setSomeString:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">someString</span><span class="p">{</span>
</span><span class='line'>  <span class="n">dispatch_async</span><span class="p">(</span><span class="n">_syncQueue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">_someString</span> <span class="o">=</span> <span class="n">someString</span><span class="p">;</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>7.第二种优化想实现，可以同时并发执行多个getter，但同步执行setter，且它们还要在同一线程，这对于synchronization block或NSLock来说，都是极难实现的，但是我们利用GCD的特性dispatch_barrier_sync()可以轻松实现，getter可以并行执行，如果出现barrier的setter，那么线程会等之前的所有getter都执行完，然后单独执行setter，执行完之后照常并行执行getter操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">_syncQueue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nf">someString</span><span class="p">{</span>
</span><span class='line'>  <span class="n">__block</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">localSomeString</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">_syncQueue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">localSomeString</span> <span class="o">=</span> <span class="n">_someString</span><span class="p">;</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">localSomeString</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setSomeString:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">someString</span><span class="p">{</span>
</span><span class='line'>  <span class="n">dispatch_barrier_async</span><span class="p">(</span><span class="n">_syncQueue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">_someString</span> <span class="o">=</span> <span class="n">someString</span><span class="p">;</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Item42 Prefer GCD to performSelector and Friends</h2>

<ol>
<li>&ndash;(id)performSelector:(SEL)selector，曾作为延时执行方法和在特定线程执行方法这些场景中的主要手段，利用runtime，可以改变selector的名称，在运行时再决定执行那个方法，但使用这一方法是有风险的。</li>
<li>如果你使用if/else来决定赋值不同的selector，然后再执行，这样的话，ARC模式下会报内存泄露的警告，原因是编译器不知道那个方法会执行，所以也没办法确定有没有返回值，返回值是autoreleased还是caller自己释放，所以ARC会保守的添加autoreleased，如果这时返回值是caller自己释放的，那么就出现了内存泄露，这一警告MRC不会报出，但也更难发现，且静态分析器也检查不出，所以这是需要注意的一点。</li>
<li>&ndash;(id)performSelector:(SEL)selector以及它的族函数，它们的返回类型都是id类型，也就是说必须是一个指针，如果返回值是void、C结构体、或数值型，那么就有可能出问题，然后最多只能添加两个参数，而且也必须是id类型，超过两个参数或类型不对的也不能用，所以说局限性是非常大的。</li>
<li>&ndash;(id)performSelector:(SEL)selector的延时执行和在特定线程执行的族函数也是一样，缺陷很明显，只支持一个参数，所以使用者必选把所有参数打包，才能使用。</li>
<li>而结合使用Blocks和GCD，你可以实现上述所有的功能，且不会有约束，代码还简洁。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//Using dispatch_after</span>
</span><span class='line'><span class="n">dispatch_time_t</span> <span class="n">time</span> <span class="o">=</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,(</span><span class="n">INT64_t</span><span class="p">)(</span><span class="mf">5.0</span><span class="o">*</span><span class="n">NSEC_PER_SEC</span><span class="p">));</span>
</span><span class='line'><span class="n">dispatch_after</span><span class="p">(</span><span class="n">time</span><span class="p">,</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span><span class="o">^</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span><span class='line'>  <span class="p">[</span><span class="n">self</span> <span class="n">doSomething</span><span class="p">];</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="c1">//Using dispatch_async(or if waitUntileDone is YES,then dispatch_sync)</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="n">self</span> <span class="n">doSomething</span><span class="p">];</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Item43 Know When to Use GCD and When to Use Operation Queues</h2>

<ol>
<li>上面介绍了很多GCD的优点，GCD在的同步机制（Item41）和单例机制（Item45）是非常优秀的，但并不是说GCD就是所有OC线程问题的最优解，在它之前的NSOperationQueue有时更为合适。</li>
<li>GCD是C类型的Api，而operation queues则是OC对象；GCD中的任务是一个block，比较轻量，而operation queues中的任务是NSOperation的子类，比较重量；但这不意味着GCD一直是最优解，有时作为对象的优势也是非常明显的。</li>
<li>使用NSBlockOperation或NSOperationQueue的addOperationWithBlock:方法，可以使operation queues非常像GCD，下面是它的一些优势。</li>
</ol>


<h3>Cancelling operations</h3>

<ol>
<li>NSOperation很容易就可以实现cancel，执行它的cancel方法即可，但已经执行的operation就不能cancel了，但是对于GCD也一样，不能cancel一个已经在执行的block，这类机制就是“fire and forget”，但在GCD上实现cancel，需要自己去实现，而这需要很多工作。</li>
</ol>


<h3>Operation dependencies</h3>

<ol>
<li>operation可以实现依赖，这样开发者可以自己组织执行的优先顺序，例如下载一些文件之前需要先下载验证文件，下验证文件的operation就是其他下载operation的依赖，如果其他下载是并发的，那么它们会等下载完验证文件后再并发执行。</li>
</ol>


<h3>Key-Value Observing of operation properties</h3>

<ol>
<li>Operation的很多property是很适合KVO的，比如：<em>isCancelled，isFinished</em>去监测operation是否取消或完成，如果你的代码需要对operation做到如此细粒度的控制的话，那么更应该使用operation。</li>
</ol>


<h3>Operation priorities</h3>

<ol>
<li>operation可以设置优先级（即queuePriority，从verylow到veryhigh五个枚举值），高优先级的operation会先执行，GCD无法设置每个block的执行优先级，而只能设置整个queue的优先级，所以这也是operation的一大特性。另外，operation还有一个相关的线程优先级（即threadPriority，从0.0到1.0），可以指定operation执行时线程分配的优先级，我理解它和前者一个是时间上的优先级，一个是空间上的优先级，这两者均可通过operation的property直接设置。</li>
</ol>


<h3>Reuse of operation</h3>

<ol>
<li>除非你使用内建的NSOperation的子类，比如NSBlockOperation，你一般都需要自己继承NSOperation，所以这就意味着你可以添加实例和方法，和进行复用。</li>
<li>综上operation有这很多的优点，主要集中于你可以对单个operation进行更加细粒度的操作，而不用自己去组织相关代码，这是对比GCD的block的优势之处。</li>
<li>Apple的NSNotificationCenter有一个方法，如下，其中的NSOperationQueue可以换成dispatch queue的，但是开发者不想对GCD产生无谓的依赖，在这个实例中，两者是没什么区别的。总之，GCD和Operation queue都是视情况使用，而不是一味遵从使用高级接口或底层接口，各有好处。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">addObserverForName:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">object:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span> <span class="nf">queue:</span><span class="p">(</span><span class="n">NSOperationQueue</span><span class="o">*</span><span class="p">)</span><span class="nv">queue</span> <span class="nf">usingBlock:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSNotification</span><span class="o">*</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Item44 Use Dispatch Groups to Take Advantage of Platform Scaling</h2>

<p>1.Dispatch Groups是GCD的一个特性，为了方便开发者对任务进行分组，你可以等待一组任务完成或者通过回调来被通知一组任务完成了。当你想让一组方法并行执行，但同时希望在它们完成时得到通知，那么你该使用这一特性。例如批量压缩文件。<br/>
2.一个group是一个简单的结构体，也没有标识，下面是group的类型和将task和group关联的方法，其实只是在正常的dipatch执行方法上关联了group而已：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">dispatch_group_t</span> <span class="nf">dispatch_group_creat</span><span class="p">();</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">dispatch_group_async</span><span class="p">(</span><span class="n">dispatch_group_t</span> <span class="n">group</span><span class="p">,</span> <span class="n">dispatch_queue_t</span> <span class="n">queue</span><span class="p">,</span> <span class="n">dispatch_block_t</span> <span class="n">block</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.另一个方法是使用下面这对方法，enter和leave要配合使用，类似retain和release，必须保持平衡，如果缺少一个leave，那么这个group就永远不会结束了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span> <span class="nf">dispatch_group_enter</span><span class="p">(</span><span class="n">dispatch_group_t</span> <span class="n">group</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">dispatch_group_leave</span><span class="p">(</span><span class="n">dispatch_group_t</span> <span class="n">group</span><span class="p">);</span>
</span><span class='line'><span class="c1">//Example</span>
</span><span class='line'><span class="n">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="c1">//A</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="c1">//B</span>
</span><span class='line'><span class="n">dispatch_group_enter</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'>  <span class="n">dispatch_group_leave</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.下面的方法可以阻塞目前线程，等待group中的task全部完成，timeout可以设置为一个固定值，也可以设置为DISPATCH_TIME_FOREVER，如果group在timeout内完成，返回值为0，反之则会返回非0值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">long</span> <span class="nf">dispatch_group_wait</span><span class="p">(</span><span class="n">dispatch_group_t</span> <span class="n">group</span><span class="p">,</span> <span class="n">dispatch_time_t</span> <span class="n">timeout</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.这个方法则是wait方法的替代，该方法不会阻塞当前线程，而是允许你为group完成添加一个通知回调block，而且可以指定线程，一般在主线程中，肯定是不希望阻塞的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span> <span class="nf">dispatch_group_notify</span><span class="p">(</span><span class="n">dispatch_group_t</span> <span class="n">group</span><span class="p">,</span> <span class="n">dispatch_queue_t</span> <span class="n">queue</span><span class="p">,</span> <span class="n">dispatch_block_t</span> <span class="n">block</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>6.下面是一个对一个数组中的对象并发执行相同操作，并在全部完成后进行后续操作的实例，如果不希望阻塞主线程，那么要把wait换为notify，<a href="http://stackoverflow.com/questions/10643797/wait-until-multiple-networking-requests-have-all-executed-including-their-comp/10644282#comment13830651_10644282">StackOverflow另一实例</a>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
</span><span class='line'><span class="c1">//Plan A, block main queue</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span> <span class="k">in</span> <span class="n">collection</span><span class="p">){</span>
</span><span class='line'>  <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="p">[</span><span class="n">object</span> <span class="n">performTask</span><span class="p">];</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">dispatch_group_wait</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">DISPATCH_TIME_FOREVER</span><span class="p">);</span>
</span><span class='line'><span class="c1">//Continue processing after copleting tasks</span>
</span><span class='line'><span class="n">dispatch_release</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
</span><span class='line'><span class="c1">//Plan B, not block main queue</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span> <span class="k">in</span> <span class="n">collection</span><span class="p">){</span>
</span><span class='line'>  <span class="n">dispatch_group_enter</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
</span><span class='line'>  <span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="p">[</span><span class="n">object</span> <span class="n">performTask</span><span class="p">];</span>
</span><span class='line'>      <span class="n">dispatch_group_leave</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">notifyQueue</span> <span class="o">=</span> <span class="n">dispatch_get_main_queue</span><span class="p">();</span>
</span><span class='line'><span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">notifyQueue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//Continue processing after completing tasks</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>7.可以通过创建不同优先级的dispatch_queue，来实现task进行优先级分类，但是依然并发执行，并在全部完成后统一处理。<br/>
8.如果你在一个串行的queue中加入多个任务，那么group其实是不起作用的，因为本来这些任务就会串行执行，你只需要继续添加一个block，就可以实现所有任务完成后统一处理。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.EOC.queue&quot;</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span> <span class="k">in</span> <span class="n">collection</span><span class="p">){</span>
</span><span class='line'>  <span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="p">[</span><span class="n">object</span> <span class="n">performTask</span><span class="p">];</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//Continue processing after completing tasks</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>9.如果你不是自己创建queue，而是使用系统方法返回的queue，那么加入的task，系统会根据系统资源开辟一定数量的线程，来执行这些task，再配合group特性，你只需要关注你的业务逻辑即可，而不用去在如何安排和控制它们的线程开辟和同步上面花费精力。<br/>
10.类似上面多次执行相同的任务，还有一个专门的方法来实现它，如下，传入的iterations类似for循环的最大值，i会从0循环到最大值减一。但dispatch_apply的缺点是会阻塞当前线程，如果你希望在后台线程运行，那么还要使用group的notify方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span> <span class="nf">dispatch_apply</span><span class="p">(</span><span class="n">size_t</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">dispatch_queue_t</span> <span class="n">queue</span><span class="p">,</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="n">size_t</span><span class="p">));</span>
</span><span class='line'><span class="c1">//A serial</span>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.EOC.queue&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_apple</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//perform task</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="c1">//B concurrent</span>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_apply</span><span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="n">count</span><span class="p">,</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="p">){</span>
</span><span class='line'>  <span class="kt">id</span> <span class="n">object</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">object</span> <span class="n">peformTask</span><span class="p">];</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Item45 Use dispatch_once for Thread-Safe Single-Time Code Execution</h2>

<p>1.GCD之前的单例模式实现，使用了synchronization block是为了线程安全：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">+</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">sharedInstance</span><span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="n">EOCClass</span> <span class="o">*</span><span class="n">sharedInstance</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>  <span class="k">@synchronized</span><span class="p">(</span><span class="n">self</span><span class="p">){</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">sharedInstance</span><span class="p">){</span>
</span><span class='line'>          <span class="n">sharedInstance</span> <span class="o">=</span> <span class="p">[[</span><span class="n">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">sharedInstance</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.这是GCD之后的版本，使用了dispatch_once，新类型dispatch_once_t保证了，对于每一个该类型的token，dispatch_once只会执行它对应的block一次，而且是线程安全的，为了保证token的唯一性，token也必须声明为static或global类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span> <span class="nf">dispatch_once</span><span class="p">(</span><span class="n">dispatch_once_t</span> <span class="o">*</span><span class="n">token</span><span class="p">,</span><span class="n">dispatch_block_t</span> <span class="n">block</span><span class="p">);</span>
</span><span class='line'><span class="c1">//singleton</span>
</span><span class='line'><span class="k">+</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">sharedInstance</span><span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="n">EOCClass</span> <span class="o">*</span><span class="n">sharedInstance</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>  <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">sharedInstance</span> <span class="o">=</span> <span class="p">[[</span><span class="n">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">sharedInstance</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.相比较synchronization block的版本，dispatch_once版本效率更高，因为前者在每次运行这段代码时都会进行加锁操作，它对dispatch token进行了原子型的访问来确定代码是否执行过，作者测试使用dispatch_once较synchronization block快将近两倍。</p>

<!--more-->


<h2>Item46 Avoid dispatch_get_current_queue</h2>

<ol>
<li>使用GCD时，获得当前运行的queue是一个常见的需求，而Apple也提供了一个方法：<em>dispatch_queue_t dispatch_get_current_queue()</em>，但是作者告诉我们，这个方法像retainCount一样，并不可靠，iOS6已经将其弃用，目前只可以在debug模式下使用。</li>
<li>回想Item41的getter/setter最终方案，可能会出现这样的场景，就是调用getter的queue和getter中的synchronization queue是同一队列，这样就会产生死锁，dispatch_sync会一直等待queue可用，而这个queue实际上就是当前的queue，所以block永远不会执行。所以就会想到用dispatch_get_current_queue()来判断当前的queue是否是synchronization queue，如果是就直接执行block，不是的话用dispatch_sync()。</li>
<li>如果在简单场景下应该是没问题，如果考虑到一些特殊情况，比如queueA->queueB->queueA嵌套执行，且所有的操作都是同步操作，那么内部的queueA关联的block还是会出现死锁，因为外层的queueA block还未执行完。</li>
<li>所以这个例子中，使用dispatch_get_current_queue()并不是一个可靠地解决方法，而还是应该单独建立一个queue专门供synchronization使用，并确保该queue中会调用getter方法。</li>
<li>从更为普遍的角度讲，因为dispatch queues是存在等级划分的，也就是说在当前queueA中的block加入了在queueB中执行的block，那么queueB上执行的block同样执行与queueA上，而顶层的queue则是global concurrent queues的其中一个。</li>
<li>只有两个queue不存在这种包含关系，才可以并行执行，反之，如果两个queue存在包含的关系，那么在他们中执行同步操作，怎要特别关注死锁问题。这也就是dispatch_get_current_queue()这个方法意义不大的根本原因，因为它只能返回当前的queue，而无法得知整个queue的包含链。</li>
<li>最容易产生这个问题的场景是Api需要你传入想运行的queue，而Api内部在另一个queue上使用了串行同步操作，然后将它的结果在传入的queue中返回，使用者一般会假设dispatch_get_current_queue()会返回自己传入的queue，但结果会返回内部的同步queue。</li>
<li>Queue-specific data是解决上述问题的一个方案，它可以将任意数据和queue绑定，最重要的是，如果没发现与对应key绑定的值，系统会一直沿包含链向上，知道找到对应的queue被找到，或者到root queue。</li>
<li><em>dispatch_queue_set_specific()</em>方法是这一技术的核心，给queue关联的是一个类似键值对的结构，键值均为空指针类型，对于key来说，需要注意的是，作为key的是指针的值而不是指向内容的值，所以其实更像Item10中介绍的associated references。value也是空指针类型，所以理论上你可以将任何值作为value，但是你希望自己管理它的内存，如果在ARC下，使用OC对象就很难做到这一点，所以作者推荐使用了CFString，因为ARC不会管理CoreFoundation的对象，而且也可以很方便转化为OC对象，所以很合适。最后的参数希望传入一个函数指针，它将用作析构函数，将在value从key移除时调用，这可能是queue被释放或者value被赋新值时。dispatch_function_t的类型是只有一个指针且返回空值，示例中CFRelease作为了参数，对应传入的CFString，如果传入的是自己定义的对象，开发者也可以自己重写CFRelease函数，做一些清除工作。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span> <span class="nf">dispatch_queue_set_specific</span><span class="p">(</span><span class="n">dispatch_queue_t</span> <span class="n">queue</span><span class="p">,</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="n">dispatch_function_t</span> <span class="n">destructor</span><span class="p">);</span>
</span><span class='line'><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">*</span><span class="n">dispatch_function_t</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span>
</span><span class='line'><span class="c1">//Example</span>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queueA</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.EOC.queueA&quot;</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queueB</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.EOC.queueB&quot;</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_set_target_queue</span><span class="p">(</span><span class="n">queueB</span><span class="p">,</span><span class="n">queueA</span><span class="p">);</span>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">kQueueSpecific</span><span class="p">;</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">queueSpecificValue</span> <span class="o">=</span> <span class="n">CFSTR</span><span class="p">(</span><span class="s">&quot;queueA&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_queue_set_specific</span><span class="p">(</span><span class="n">queueA</span><span class="p">,</span><span class="o">&amp;</span><span class="n">kQueueSpecific</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">queueSpecificValue</span><span class="p">,(</span><span class="n">dispatch_function_t</span><span class="p">)</span><span class="n">CFRelease</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_sync</span><span class="p">(</span><span class="n">queueB</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="n">dispatch_block_t</span> <span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;No deadlock!&quot;</span><span class="p">);};</span>
</span><span class='line'>  <span class="n">CFStringRef</span> <span class="n">retrievedValue</span> <span class="o">=</span> <span class="n">dispatch_get_specific</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kQueueSpecific</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">retrievedValue</span><span class="p">){</span>
</span><span class='line'>      <span class="n">block</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">queueA</span><span class="p">,</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记5]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/08/28/effective-objective-cdu-shu-bi-ji-5/"/>
    <updated>2015-08-28T11:45:07+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/08/28/effective-objective-cdu-shu-bi-ji-5</id>
    <content type="html"><![CDATA[<p>第五部分开始将讨论OC的核心技术，Reference Counting，也就是使用引用计数来进行内存管理，这一部分涉及到底层内存管理机制，ARC相关技术细节和在开发中涉及到内存管理需要注意的常见问题。</p>

<!--more-->


<h2>Item29 Understand Reference Counting</h2>

<ol>
<li>Reference Counting是OC管理内存的方式，当一个对象的RC为0时，将被释放，iOS没有垃圾回收机制。</li>
</ol>


<h3>How Reference Counting Works</h3>

<ol>
<li>在NSObject Protocol中有三个方法可以改变RC，<em>retain,release,autorelease</em>。</li>
<li>retainCount这个方法可以查看对象当前的RC值，但是并不推荐使用，Item36会讨论。</li>
<li>对象之间往往是互相持有的，当该持有关系是<em>strong</em>时，被持有对象的RC加1，而持有链的最顶端是根对象，Mac OSX是NSApplication，iOS是UIApplication，都是应用创建的单例。</li>
<li>举例一个NSMutableArray添加一个NSNumber，虽然在array添加number后，释放number，number的RC还是1，调用number理论上是可以的，但是并不推荐这么做，因为如果任何其他原因使number的RC为0，这一做法会导致崩溃。</li>
<li>对象被释放后，它的内存将进入可用内存池，如果调用发生在内存被复写之前，不会发生错误，所以之类bug有时会很难复现，所以在MRC中往往在调用release后会赋值nil。</li>
</ol>


<h3>Memory Management in Property Accessors</h3>

<ol>
<li>strong命名的property的setter方法，是新值retain，然后旧值release，然后赋值，这一顺序不能错，因为如果先release再retain，且正好两个对象是同一个，可能会导致对象提前释放，RC为0，成为野指针，再调用retain则会出错。想按照这个顺序来，必须判断新旧两值是否是同一对象。</li>
</ol>


<h3>Autorelease Pools</h3>

<ol>
<li>借助autorelease pool替代release操作的autorelease，常用于需要返回新建对象的方法，具体释放时间在下一次事件循环（Item34将讨论）。</li>
<li>在直接调用该方法时不用额外的内存空间，直接调用即可。</li>
<li>但是如果返回对象需要持有时，比如赋值给一个实例变量，它需要retain一次，然后使用完后手动release，所以可以将autorelease理解为延长对象的生命周期，可以至少保证到方法调用的边界。</li>
</ol>


<h3>Retain Cycles</h3>

<ol>
<li>循环引用一般是指两个或多个对象直接互相存在强引用，而导致RC都不能为0，所有对象都不能释放。</li>
<li>在垃圾回收机制下，retain cycle会被定义为孤岛，而直接被全部释放，而在RC机制下，只能通过定义weak引用或者依靠外部帮助来使其中某个对象交出对其他对象的引用。</li>
</ol>


<!--more-->


<h2>Item30 Use ARC to Make Reference Counting Easier</h2>

<ol>
<li>Clang编译器带来了一个静态分析器，可以定位出现RC问题的位置，例如没有添加release，除此之外，该分析器可以为你自动添加retain，release这些操作，这也就是ARC技术的基础。</li>
<li>在ARC机制下，retain、release、autorelease、dealloc这些操作都是不允许的，因为这回影响编译器判断添加语句的位置。</li>
<li>事实上，ARC并没有直接调用上述这些方法，而是调用了他们的C的替代方法，例如objc_retain，这么做的好处是，因为这些操作会频繁调用，使用C方法可以提高效率。这也是为什么不允许直接重写retain，release这些方法，因为这方法并不是直接调用的。</li>
</ol>


<h3>Method-Naming Rules Applied by ARC</h3>

<ol>
<li>内存管理指定方法名在OC里一直是惯例，而ARC将其加强了，含有以下名称的方法：<em>alloc、new、copy、mutableCopy</em>，所返回的对象的所有者为方法的调用者，而其他方法返回的对象为autorelease，会保持到方法调用边界。</li>
<li>而ARC会依据方法名的开头添加响应的语句，例如上述四个关键字开头的，会直接返回，而一般方法，ARC会在返回对象前加上autorelease。</li>
<li>而在调用这些方法时，第一类方法返回的对象，ARC会在方法结束前添加release方法，而第二类方法因为有autorelease，所以不会添加操作。</li>
<li>ARC通过命名规范来规范内存管理，再加上之前的命名空间，OC是少有的如此强调命名的语言之一。</li>
<li>ARC可以做一些无法手动完成的优化，比如，它将在编译期间取消多余的retain和release操作。</li>
<li>ARC在runtime也有进行优化，举例：EOCPerson的一般初始化方法返回的值（添加了autorelease），被赋值给一个对象的strong属性实例，按照之前的原则，需要在返回的对象加retain，这里的autorelease和retain看起来是多余的，ARC确实可以为了性能，直接去掉autorelease这个方法，所有返回的对象都为RC+1，但为了兼容MRC，ARC还是需要特殊处理。</li>
<li>ARC确实对这种现象做了处理，在返回对象之前它调用了<em>objc_autoreleaseReturnValue</em>，如果被发现该对象是需要retain的，则会添加一个flag，而不是调用autorelease。同样的，调用者也会调用<em>objc_retainAutoreleasedReturnValue</em>，而不是retain，该方法也会先检测flag，如果存在，则不会retain，这样提高了效率：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//Within EOCPerson class</span>
</span><span class='line'><span class="k">+</span><span class="p">(</span><span class="n">EOCPerson</span><span class="o">*</span><span class="p">)</span><span class="nf">personWithName:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">EOCPerson</span> <span class="o">*</span><span class="n">person</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EOCPerson</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>  <span class="n">person</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'>  <span class="n">objc_autoreleaseReturnValue</span><span class="p">(</span><span class="n">person</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Code using EOCPerson class</span>
</span><span class='line'><span class="n">EOCPerson</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">EOCPerson</span> <span class="nl">personWithName:</span><span class="s">@&quot;Matt&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">_myPerson</span> <span class="o">=</span> <span class="n">objc_retainAutoreleasedReturnValue</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//objc_autoreleaseReturnValue</span>
</span><span class='line'><span class="kt">id</span> <span class="nf">objc_autoreleaseReturnValue</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="cm">/*caller will retain object*/</span><span class="p">){</span>
</span><span class='line'>      <span class="n">set_flag</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">object</span><span class="p">;</span><span class="c1">//no autorelease</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">[</span><span class="n">object</span> <span class="n">autorelease</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//objc_retainAutoreleasedReturnValue</span>
</span><span class='line'><span class="kt">id</span> <span class="nf">objc_retainAutoreleasedReturnValue</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">get_flag</span><span class="p">(</span><span class="n">object</span><span class="p">)){</span>
</span><span class='line'>      <span class="n">clear_flag</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">object</span><span class="p">;</span><span class="c1">//no retain</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">[</span><span class="n">object</span> <span class="n">retain</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Memory-Management Semantics of Variables</h3>

<ol>
<li>ARC也同时管理着本地变量和实例变量的内存，默认每个变量对于对象是strong引用。</li>
<li>在setter方法中，ARC中直接对旧值赋值即可，ARC会自动添加正确的代码。</li>
<li>声明实例变量时，也可以改变内存管理方式，<strong>strong（默认，赋值将被retain）、</strong>unsafe_retained（赋值同assign，但指针不会自动置空，可能出现野指针）、<strong>weak（赋值同assign，对象被释放时，指针会自动置为nil，所以是安全的，iOS5后可用）、</strong>autoreleasing（多用与方法的返回值）。</li>
<li>__weak用于本地变量时，常用于避免循环引用，比如在block中：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSURL</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURL</span> <span class="nl">URLWithString:</span><span class="s">@&quot;http://www.example.com/&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">EOCNetworkRetcher</span> <span class="o">*</span><span class="n">fetcher</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EOCNetworkFetcher</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithURL:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'><span class="n">EOCNetworkFetcher</span> <span class="o">*</span> <span class="n">__weak</span> <span class="n">weakFetcher</span> <span class="o">=</span> <span class="n">fetcher</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">fetcher</span> <span class="nl">startWithCompletion:</span><span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">success</span><span class="p">){</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finished fetching from %@&quot;</span><span class="p">,</span> <span class="n">weakFetcher</span><span class="p">.</span><span class="n">url</span><span class="p">);</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>ARC Handling of Instance Variables</h3>

<ol>
<li>在ARC中，你一般不需要再重写dealloc方法，ARC借用Objective-C++的特性，Objective-C++对象在释放时会调用所有持有对象的析构方法，当编译器发现对象包含C++对象时，会生成<em>.cxx_destruct</em>方法，ARC借助这个方法，在其中执行清除内存的代码。</li>
<li>但有时你仍需要重写dealloc方法，像CoreFoundation对象和堆上开辟的内存（如malloc），以及KVO、的解除，都需要手动释放，但注意<em>在ARC中，不需要在dealloc中写[super dealloc]</em>，因为ARC在<em>.cxx_destruct</em>中已经调用了这一方法。</li>
</ol>


<h3>Overriding the Memory-Management Methods</h3>

<ol>
<li>在MRC中，重写内存相关方法是允许的，比如单例常常重写release方法为一个空操作，这样单例就不会被释放。</li>
<li>但在ARC中是不允许的，一是会导致ARC对对象周期的误判，二是ARC对内存管理做了深度的优化，当需要执行retain、release、autorelease时，ARC在OC的message dispatch做了优化处理，不能重写或调用这些方法则是该优化的前提。</li>
</ol>


<!--more-->


<h2>Item31 Release References and Clean Up Observation State Only in dealloc</h2>

<p>1.dealloc方法会在对象的引用计数为0时自动调用，但什么时候调用并不能保证，即使是在MRC中，手动控制release也一样，因为很多库会在你不知道的情况下修改对象，这会导致调用dealloc的时间发生变化。所以你千万不要手动去调用dealloc，runtime会在合适的时间调用。<br/>
2.那么在ARC下，重写dealloc的话，一是用于释放CoreFoundation的对象，二是取消NSNotificationCenter中注册该对象的监听或KVO。<br/>
3.如果你的类中使用到了文件描述集，sockets、或者开辟了大块儿内存，由于dealloc的调用时间不明，你可能在你不需要使用的时候即可释放这些内存，而不用等到dealloc触发，这样需要自定义一个清除方法，该方法必须在dealloc之前调用，不然就算异常了。<br/>
4.清除资源需要另一个方法的原因是创建的对象并不是都会被调用dealloc，因为一部分对象在应用退出后台时并不会释放，它们只有在应用彻底被系统回收后才会释放，这是一种优化措施，但也会导致大量的资源被无故占用，所以在-(void)applicationWillTerminate:(UIApplication*)application中调用一些对象的clean方法是必要的。<br/>
5.有时可以在dealloc中也可以去调用clean方法，这可以避免忘记调用clean，但最好还是手动去先执行clean，所以还是要提示下或者严重的话直接直接抛出异常：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">close</span> <span class="p">{</span>
</span><span class='line'>  <span class="cm">/*clean up resources*/</span>
</span><span class='line'>  <span class="n">_close</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">_closed</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;ERROR:close was not called before dealloc!&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="p">[</span><span class="n">self</span> <span class="n">close</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>6.除了上述特例，一般是不允许在dealloc中调用类的其他实例方法，因为有可能导致方法执行前，该对象可能已经释放了。而且，dealloc方法是在导致对象最终释放的线程上执行的，所以需要在特定线程执行的方法在此调用，不能保证线程正确，即使是通过代码强制在某线程执行，也是不安全的，因为对象处于释放状态。
7.另外dealloc中也不可调用property的setter、getter方法，尤其是被重写的accessor，也有可能触发KVO的回调，导致未知的错误。</p>

<!--more-->


<h2>Item32 Beware of Memory Management with Exception-Safe Code</h2>

<ol>
<li>Exception是OC和C++中用于处理严重异常的对象，但有时你也需要通过代码处理这些异常，例如去注销一个KVO，但之前并没有注册过的情况。</li>
<li>在try/catch中创建对象，并需要自己释放时，需要将释放代码写到finally中，这样才能保证无论是否异常都能保证对象释放。</li>
<li>但在ARC中可以自动添加额外的处理代码，使用<em>-fobjc-arc-exceptions</em>这个flag来控制，但默认是关闭的，因为exception出现时application直接crash，资源也会回收，所以没必要再做处理，而且会带来性能问题，只有编译器处于Objective-C++时才会开启，因为OC++添加代码带来性能损耗没有ARC添加时那么大，另外OC++中Exception是被大量使用的。</li>
<li>如果在ARC下需要单独处理exception，那么可以开启flag，但如果你有很多exception处理，那么你该考虑NSError了，如Item21所讲。</li>
</ol>


<!--more-->


<h2>Item33 Use Weak References to Avoid Retain Cycles</h2>

<ol>
<li>循环引用带来的问题主要是，引用环中的对象将不能再被调用，但也不能释放，从而导致内存泄露。</li>
<li>Java会有垃圾回收来解决这类问题，但iOS和Mac OS X 10.8之后是没有垃圾回收的，所以只能开发者自己去避免。</li>
<li>使用unsafe_unretained可以避免这一问题，它类似assign，但assign一般用于数值型，而unsafe_unretained用于对象，但如字面意思一样，它不会因为所指向的对象被释放而置为空值，所以调用unsafe_unretained的对象，可能会因为所指对象不存在而崩溃，所以是不安全的。</li>
<li>在ARC中我们常用的是weak字段，该字段与unsafe_unretained功能一致，但是它会在所指对象释放后自动指向nil，所以是安全的。</li>
<li>关于循环引用，总的原则就是，如果你不持有一个对象，那么你就不该retain它（数组，集合不直接持有包含的对象，但是会retain它们，是个例外）。一般场景有，controller的UI控件（一般weak属性），一个对象的delegate属性（一般为weak属性）。</li>
</ol>


<!--more-->


<h2>Item34 Use Autorelease Pool Blocks to Reduce High-Memory Waterline</h2>

<p>1.<em>@autoreleasepool{}</em>这是OC中建立autorelease pool的方法，但我们一般不必去手动创建。<br/>
2.main函数中的autorelease pool并不是必须的，只是UIApplicationMain()函数中需要autorelease的对象没有对应的pool，但它们在程序终止时时肯定会被释放的。<br/>
3.autorelease pool可以嵌套，autorelease的对象总是被添加最里面的pool中。<br/>
4.利用上述特性，我们可以对一些大量循环执行一个可能产生很多autorelease对象的方法做优化，如下EOCPerson的创建可能产生大量autorelease对象，这样产生的autorelease对象会在自己建的autorelease pool结束时释放，而不是长期存在于线程自己的autorelease pool，避免了出现应用内存陡升陡降这种“瀑布现象”：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">databaseRecords</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">people</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">record</span> <span class="k">in</span> <span class="n">databaseRecords</span><span class="p">){</span>
</span><span class='line'>  <span class="err">@</span><span class="n">autoreleasepool</span><span class="p">{</span>
</span><span class='line'>      <span class="n">EOCPerson</span> <span class="o">*</span><span class="n">person</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EOCPerson</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithRecord:</span><span class="n">record</span><span class="p">];</span>
</span><span class='line'>      <span class="p">[</span><span class="n">people</span> <span class="nl">addObject:</span><span class="n">person</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.autorelease pool可以被理解为放入了一个栈中，新建的pool会在最顶端，当它释放后会被移出栈，当一个对象调用了autorelease，它将被添加到最顶端的autorelease pool。<br/>
6.使用autorelease pool来优化瀑布现象并不是必要的，这取决你的应用，如果确实导致了问题，那么去使用它，如果不必要使用，那么就不要添加多于的autorelease pool。<br/>
7.ARC之前使用autorelease pool是使用NSAutoreleasePool，因为它属于重量级对象，所以一般是隔段时间进行释放：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">databaseRecords</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">people</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">NSAutoreleasePool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSAutoreleasePool</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">record</span> <span class="k">in</span> <span class="n">databaseRecords</span><span class="p">){</span>
</span><span class='line'>  <span class="n">EOCPerson</span> <span class="o">*</span><span class="n">person</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EOCPerson</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithRecord:</span><span class="n">record</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">people</span> <span class="nl">addObject:</span><span class="n">person</span><span class="p">];</span>
</span><span class='line'>  <span class="c1">//Drain the pool only every 10 cycles</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">==</span> <span class="mi">10</span><span class="p">){</span>
</span><span class='line'>      <span class="p">[</span><span class="n">pool</span> <span class="n">drain</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Also drain at the end in case the loop is not multiple of 10</span>
</span><span class='line'><span class="p">[</span><span class="n">pool</span> <span class="n">drain</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>8.推荐使用新语法@autoreleasepool，更加轻量，而且一个重要特性，NSAutoreleasePool中创建的autoreleased对象在执行drain之后还能使用，这可能造成崩溃，且很多时候难以发现，而使用@autoreleasepool，这类代码不会被编过，也就及早避免了这一问题。</p>

<!--more-->


<h2>Item35 Use Zombies to Help Debug Memory-Management Problems</h2>

<p>1.内存问题一般很难处理，原因是被释放的那块内存不一定就很快被重写，或者正好被一个同类的对象重写，这样有时不会导致崩溃，有时却会，所以开发者有时会无从下手。<br/>
2.Cocoa的Zombies特性会帮助我们解决这一问题，当该模式启用，所有被释放的对象会转化为NSZombie对象，其占用过的内存也不会被重用，当该对象收到消息时，会抛出异常，告知开发者所收到的消息，原来的对象类型这些信息。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span> <span class="nf">PrintClassInfo</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">){</span>
</span><span class='line'>  <span class="n">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">object_getClass</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Class</span> <span class="n">superCls</span> <span class="o">=</span> <span class="n">class_getSuperclass</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;===%s:%s===&quot;</span><span class="p">,</span><span class="n">class_getName</span><span class="p">(</span><span class="n">cls</span><span class="p">),</span><span class="n">class_getName</span><span class="p">(</span><span class="n">superCls</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
</span><span class='line'>  <span class="n">EOCClass</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EOCClass</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Before release:&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">printClassInfo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>  <span class="p">[</span><span class="n">obj</span> <span class="n">release</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;After release&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">PrintClassInfo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//result</span>
</span><span class='line'><span class="c1">//Before release:</span>
</span><span class='line'><span class="c1">//===EOCClass:NSObject===</span>
</span><span class='line'><span class="c1">//After release:</span>
</span><span class='line'><span class="c1">//===_NSZombie_EOCClass:nil===</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>3.通过上述手段我们得知obj在dealloc后变为了<em>NSZombie_EOCClass，但并没有它的父类，实际上，它是通过对原类型的类名修改，然后对</em>NSZombie<em>类型执行objc_duplicateClass()，完全拷贝zombie类并使用新类名（也可使用继承，但不如copy效率），制造出obj对应的zombie类，然后用objc_setClass()修改obj的isa指针，改变其类型，这一切都是利用runtime完成的（通过method swizzles对dealloc方法替换）。<br/>
4.由于</em>NSZombie<em>没有实现任何方法，所以向它或者它的copy类型发送任何消息，会直接进入forwarding mechanism，在寻求转发时如果发现类型名以</em>NSZombie_开头，那么直接抛出异常，并打印出message、原类型这些信息。</p>

<!--more-->


<h2>Item36 Avoid Using retainCount</h2>

<ol>
<li><em>retainCount</em>是NSObject Protocol的一个方法，用于返回对象目前的引用计数值，在ARC中已经弃用，但即使在MRC中，任然应该避免使用它。</li>
<li>原因一是<em>retainCount</em>返回的是实时的count值，也就是说像autorelease这样将要发生的count减少的情况，不会在该方法反映出来，所以依据该值去执行一些改变count的方法，往往会出问题。</li>
<li>有时retainCount会返回一个极大的值，这是NSString或NSNumber直接设置常量时，系统会将其作为一个单例的常量，而不是去创建一个对应的对象，这些对象的ratainCount是不会改变的，但只是对一些特例的优化。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记4]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/08/24/effective-objective-cdu-shu-bi-ji-4/"/>
    <updated>2015-08-24T11:35:10+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/08/24/effective-objective-cdu-shu-bi-ji-4</id>
    <content type="html"><![CDATA[<p>第四部分开始讨论OC的两大重要特性，Protocols和Categories。Protocols类似Java中的interfaces，弥补了OC没有多继承的缺点，常被用于实现OC委托模式，但还有很多其他方面的用途。Categories则是提供了不继承而向类添加拓展的方法，这要归功于OC动态语言特性，但同时了解它使用时的常见问题也非常重要。</p>

<!--more-->


<h2>Item23 Use Delegate and Data Source Protocols for Interobject Communication</h2>

<ol>
<li>Delegate是用于对象之间进行数据交互的设计模式，使用它的好处是可以让不同的业务逻辑解耦，实现代码模块化。而在OC中实现这一模式，主要依靠Protocols。</li>
<li>怎么使用Delegate不介绍了，注意点是：1）命名最好和你需要委托的类相关，例如UITableView,UITableViewDelegate；2）类的delegate property是weak属性，原因是接受委托的对象一般会持有需要委托的对象，如果delegate设置为strong，需要委托的对象也会持有接受委托的对象，这样就会出现retain cycle。</li>
<li>Delegate一般都定义为option，除非一些方法是一定要被委托者实现的，同时对于option的方法，委托者需要在调用之前使用<em>respondsToSelector:</em>来内省，确保被委托者实现了该方法。</li>
<li>Delegate中定义的方法一定要清楚，而且一定要包括被委托者自身作为其中一个参数，这样如果存在同类型多个实例对象时，委托者可以在同一个方法中区分这些实例变量。</li>
<li>Protocols还可以用于DataSource模式，与Delegate模式区别是，对于一个Class来说，Delegate的信息是流出Class的，而DataSource的信息是流入Class的，设计Protocols也可以参照这一原则。</li>
<li>对于option的方法要进行<em>respondsToSelector:</em>来检测，但是对于一些需要频繁调用的方法，采用这一方式非常影响性能，作者利用了C中的由多个1bit字段组成的结构体来标识被委托对象是否响应所有方法，这基于被委托对象一般不会动态改变对方法的响应：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">EOCNetworkFetcher</span><span class="p">(){</span>
</span><span class='line'>  <span class="n">struc</span> <span class="p">{</span>
</span><span class='line'>      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">didReceiveData:</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">didFailWithError:</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">didUpdateProgressTo:</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">_delegateFlags</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">EOCNetworkFetcher</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setDelegate:</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">EOCNetworkFetcherDelegate</span><span class="o">&gt;</span><span class="n">delegate</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">_delegate</span> <span class="o">=</span> <span class="n">delegate</span><span class="p">;</span>
</span><span class='line'>  <span class="n">_delegateFlags</span><span class="p">.</span><span class="n">didReceiveData</span> <span class="o">=</span> <span class="p">[</span><span class="n">delegate</span> <span class="nl">respondsToSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">networkFetcher:</span> <span class="nl">didReceiveData:</span><span class="p">)];</span>
</span><span class='line'>  <span class="n">_delegateFlags</span><span class="p">.</span><span class="n">didFailWithError</span> <span class="o">=</span> <span class="p">[</span><span class="n">delegate</span> <span class="nl">respondsToSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">networkFetcher:</span> <span class="nl">didFailWithError:</span><span class="p">)];</span>
</span><span class='line'>  <span class="n">_delegateFlags</span><span class="p">.</span><span class="n">didUpdateProgressTo</span> <span class="o">=</span> <span class="p">[</span><span class="n">delegate</span> <span class="nl">respondsToSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">networkFetcher:</span> <span class="nl">didUpdateProgressTo:</span><span class="p">)];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//调用委托时</span>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm">if(_delegateFlags.didUpdateProgressTo) {</span>
</span><span class='line'><span class="cm"> [_delegate networkFetcher:self didUpdateProgressTo:currentProgress];</span>
</span><span class='line'><span class="cm">}</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<!--more-->


<h2>Item24 Use Categories to Break Class Implementations into Manageable Segments</h2>

<ol>
<li>分类这一特性主要为了解决一个类在开发中无限膨胀的问题，将一个类的方法按照功能进行分类处理是常规做法。</li>
<li>第二种用途是为了对代码进行分割增加可读性，例如NSURLRequest想增加专门的HTTP请求，单纯继承不是一个很好的选择，原因是NSURLRequest封装了一组针对CFURLRequest的C方法，无法通过继承获得，而直接添加这些HTTP的方法则会导致一些代码理解错误，例如开发者使用FTP协议，去发现可以调用关于HTTP的方法，所以将HTTP部分的方法做成NSHTTPURLRequest的分类是最好的选择。</li>
<li>第三个用途是方便调试，原因是分类中的方法在日志里会显示为类似：<em>&ndash;[EOCPerson(Friendship) addFriend:]</em>，可以方便定位该方法。</li>
<li>另外，在做一个库时，把一些私有方法用名为Private的分类封装，这样这些方法不用暴露在外，而内部又可以随意调用，而且外部万一用到了，也可以在日志中看到private的标志，起到了文档的作用。</li>
</ol>


<!--more-->


<h2>Item25 Always Prefix Category Names on Third-Party Classes</h2>

<ol>
<li>为一个类添加分类后，运行时runtime会遍历category每个方法，顺便加入类的方法列表，如果这时category重写了类的某个方法，这将覆盖原有的方法，如果多个category都出现这个情况，那么最后被载入的那个分类的方法会被采用，这两种情况都将导致Bug，且难以定位。</li>
<li>解决这一问题的方法只能是添加namespace，规则参考Item15，最好就是公司+项目这样的方式，而且最好将分类的名字也加namespace，这样可以避免warning。</li>
<li>要记住添加到一个类的category中的方法，只要被添加，在所有类的示例都可以调用（这里还是需要导入这个category才可以），尤其在为Cocoa中的类添加分类时时刻注意添加命名空间，去刻意重写类中的方法是一个非常坏的习惯，它带来的问题可能比好处大得多。</li>
</ol>


<!--more-->


<h2>Item26 Avoid Properties in Categories</h2>

<ol>
<li>category默认是不支持添加property的（匿名分类除外），虽然这一做法可以在技术上实现，但是依然不推荐这么做。</li>
<li>category不支持property，主要是无法自动合成setter和getter方法，解决这一问题有两个方法：1）使用Item12的做法，用@dynamic声明，重写message-forwarding的方法，在runtime添加setter和getter方法；2）使用Item10，使用associated objects，自己在getter和setter进行关联。</li>
<li>上述两个方法均可行，但作者认为这两个方法都不完美，缺点有二：1）内存管理，你很容易忘记这个property的特殊性，而只去修改property的关键字，而忘记去修改setter方法；2）如果你想让自己的property对象在内部支持mutable，可以在内部声明一个，mutable拷贝，但是这又会出现一个进入源代码的混乱路径，所以在category中定义property的代价是很高的。</li>
<li>作者建议的方法是把所有的变量都放入原类中，而category只提供额外的方法。</li>
<li>但有时category中可以添加只读变量，而且也不涉及读写原类的变量，但是虽然不报错，还是推荐使用一个方法来完成，因为真的没必要这么做。</li>
</ol>


<!--more-->


<h2>Item27 Use the Class-Continuation Category to Hide Implementation Detail</h2>

<p>1.OC是没有真正的私有方法的，但我们还是不希望把不需要暴露的方法和变量暴露在外，所以匿名分类就是一种隐藏这些细节的手段。<br/>
2.你可以将实例变量声明在匿名变量或implementation中，可以完全不用暴露你要导入的头文件等一切信息，例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">EOCPerson</span><span class="p">(){</span>
</span><span class='line'>  <span class="n">NSString</span> <span class="o">*</span><span class="n">_anInstanceVariable</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Method declarations here</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="err">@</span><span class="n">implemenation</span> <span class="n">EOCPerson</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">_anotherInstanceVariable</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Method implemenations here</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.一般OC代码中使用C++一般两种情况：一些游戏相关的后端代码需要用C++，使用的第三方库使用了C++，而你作为使用者除非特殊情况，一定要使用匿名分类来使用C++，这样其他类使用你的类时，不用再因为C++的原因，将.m文件命名为.mm，而使编译器将其编为Objective-C++。Cocoa的web browser framework和CoreAnimation使用了这一模式。<br/>
4.还有一种应用就是在外部声明readonly的property，然后在匿名分类中再将其声明为readwrite，这样可以实现外部只能通过方法设置值，而内部可以正常使用该变量，可能会出现外部在访问，内部同时在赋值同步的问题，将在Item41讨论。<br/>
5.接下来就是可以在匿名分类声明私有方法，虽然这不是必须的，而作者比较推荐先列好方法，理清思路，再开始实现，如果是比较大的项目，还是需要这么干的。<br/>
6.最后就是可以在匿名分类添加委托。</p>

<!--more-->


<h2>Item28 Use a Protocol to Provide Anonymous Objects</h2>

<ol>
<li>利用Protocol可以实现创建一些匿名对象，例如：id<EOCDelegate> delegate。</li>
<li>例子1：来自多个第三方类库的数据库管理对象对应不同数据库类型，现在需要提供一个统一的Manager，来返回这些不同的对象，依靠基类继承是不可能的，只能通过定义一组数据库通用的操作作为Protocol，然后分别继承这些类，而新类则遵从这一protocol，这样Manager只需返回id<Protocol>类型的对象即可，而使用者也只需要知道它们实现了这些方法也足够了。</li>
<li>例子2：已确定只有一个类型，但其是一个内部使用的数据类型，不需要将其所有细节暴露，只需要暴露其中一部分方法即可，那么将这些方法声明为Protocol，然后返回类型定义为id<Protocol>即可，其实就是实现了对对象的大部分封装。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记3]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/08/17/effective-objective-cdu-shu-bi-ji-3/"/>
    <updated>2015-08-17T14:15:03+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/08/17/effective-objective-cdu-shu-bi-ji-3</id>
    <content type="html"><![CDATA[<p>第二部分主要讲了一些OC底层的运作机制，这一部分开始，主要涉及实践部分，第三部分的主题是：Interface and API Design。</p>

<!--more-->


<h2>Item15 Use Prefix Names to Avoid Namespace Clashes</h2>

<ol>
<li>OC是没有内建的命名空间的，所以必须采取措施避免这一问题。</li>
<li>解决方案是自己在所有类都添加自定义的前缀，一般是项目名缩写，但推荐使用三个字母，因为两个字母被苹果使用，所以重名的概率大。</li>
<li>在.m文件中的纯C函数和全局变量也有可能出现重名，所以定义时需格外注意，也要加上前缀。</li>
<li>还有一种可能，你自己封装的类库A和应用使用了同一类库B，而应用也使用了你的类库A，这样的话，只能手动将你自己使用的类库B的所有加上类库A的前缀，虽然麻烦，但是如果是大工程的话，必须这么做。</li>
</ol>


<!--more-->


<h2>Item16 Have a Designated Initializer</h2>

<ol>
<li>一个类可能有很多初始化方法，但其中基本初始化方法只需有一个，其他初始化方法只是参数变化，这样保证数据在一个方法中赋值，便于维护。</li>
<li>为了避免用户使用原始的<em>init:</em>方法而出现错误，该类中应该重写<em>init:</em>方法，可以做一个默认的赋值，或者直接抛出异常。</li>
<li>继承一个拥有基本初始化方法的类，子类的初始化方法要调用父类的基本初始化方法，而且需要重写父类的基本初始化方法，与上一条的理由一致。</li>
<li>有时可能需要两个基本初始化方法，特例比如遵循NSCoding的类，要有一个-(id)initWithCoder:(NSCoder*)decoder的初始化方法，而该类的子类也必须重写initWithCoder:，同时调用父类initWithCoder:。</li>
</ol>


<h2>Item17 Implement the description Method</h2>

<p>1.重写对象的-(NSString*)description方法，可以获得更多的实用信息，默认的只是类名和指针地址，这也是NSObject协议的其中一项。<br/>
2.这是一种将NSDictionary特性结合起来的description写法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;&lt;%@:%p,%@&gt;&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="p">[</span><span class="n">self</span> <span class="n">class</span><span class="p">],</span>
</span><span class='line'>  <span class="n">self</span><span class="p">,</span>
</span><span class='line'>  <span class="err">@</span><span class="p">{</span><span class="s">@&quot;title&quot;</span><span class="o">:</span> <span class="n">_title</span><span class="p">,</span>
</span><span class='line'>  <span class="s">@&quot;latitude&quot;</span><span class="o">:</span> <span class="err">@</span><span class="p">(</span><span class="n">_latitude</span><span class="p">),</span>
</span><span class='line'>  <span class="s">@&quot;longitude&quot;</span><span class="o">:</span> <span class="err">@</span><span class="p">(</span><span class="n">_longitude</span><span class="p">)}</span>
</span><span class='line'>  <span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>3.LLDB中的<em>po</em>命令会执行print-object函数，它返回的是NSObject协议的另一方法-(NSString *)debugDescription，而这一方法默认返回的是description的结果，如果需要隐藏部分信息，可以分别重写这两个方法，OC默认类型很多就是这么干的，例如NSArray。</p>

<!--more-->


<h2>Item18 Prefer Immutable Objects</h2>

<ol>
<li>设计类的时候，其中的property除非必须可变，都应设计为不可变只读类型，之前Item8也讨论过类似问题，一个可变集合加入两个可变数组，然后设法改变数组，可能会出现集合中有相同数组，而不会报错的问题。</li>
<li>解决这个问题的设计是在.h文件中设置property为readonly，而在.m文件中添加匿名分类，重新定义相同的property为readwrite，这样实现了对外只读，而内部可以进行修改。</li>
<li>如果需要对外提供修改变量的方法，也不建议直接把可变变量暴露，而是对外还是暴露只读变量，内部再定义一个可变的内部变量，外部的只读变量的getter方法返回内部可变变量的copy，而同时添加增删的外部方法来操作内部变量。</li>
</ol>


<!--more-->


<h2>Item19 Use Clear and Consistent Naming</h2>

<ol>
<li>OC命名方式是尽量详细，多使用一些介词，表明方法功能，同时使用驼峰命名法。</li>
</ol>


<h3>Method Naming</h3>

<ol>
<li>如果一个方法返回了一个新对象，那么方法一般以该对象的类型开头。</li>
<li>一个参数前需要加一个名词来描述他的类型。</li>
<li>一个方法描述对一个对象进行操作时，需要包含一个动词，然后每个参数前依旧需要名词描述。</li>
<li>避免使用缩写，而使用全称，例如：<em>str</em>和<em>string</em>。</li>
<li><em>Boolean</em>类型的property的getter方法用<em>is</em>前缀，返回<em>Boolean</em>的方法应该以<em>has</em>或<em>is</em>作为前缀。</li>
<li>保留<em>get</em>关键字，在方法并无返回值，但是通过传入的参数，进行值的返回时使用get，比如：-(void)getCharacters:(unichar *)buffer range:(NSRange)aRange。</li>
</ol>


<h3>Class and Protocol Naming</h3>

<ol>
<li>主要是注意你继承的类要以其类名结尾，但前缀不要，要加上自己的前缀，协议要以Delegate结尾。</li>
</ol>


<!--more-->


<h2>Item20 Prefix Private Method Names</h2>

<ol>
<li>用特殊前缀标记类的私有方法，会在调试时更加方便，Matt的方式是在方法前加<em>p_</em>前缀，例如：<em>&ndash;(void)p_privateMethod</em>，当然你最好定义自己的方式。</li>
<li>Apple的方式是在方法前加<em>_</em>来标识私有方法，但不推荐开发者这么做，因为如果你继承了Cocoa的类，很容易覆盖原来的私有方法。</li>
</ol>


<!--more-->


<h2>Item21 Understand the Objective-C Error Model</h2>

<p>1.抛出exception后，本来将要释放的对象将得不到释放，所以会造成内存泄露，所以抛异常时一定是非常严重的错误出现的场景。<br/>
2.场景一是基类的一些必须被子类重写的方法可以抛出异常已告知开发者去重写，因为OC没有基类的特殊概念。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">mustOverrideMethod</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">NSString</span> <span class="o">*</span><span class="n">reason</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;%@ must be overridden&quot;</span><span class="p">,</span> <span class="n">NSStringRromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">)];</span>
</span><span class='line'>  <span class="k">@throw</span><span class="p">[</span><span class="n">NSException</span> <span class="nl">exceptionWithName:</span><span class="n">NSInternalInconsistencyException</span> <span class="nl">reason:</span><span class="n">reason</span> <span class="nl">userInfo:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.而处理一般的异常OC通常使用NSError，该类包含以下信息：<br/>
1）Error domain(String):表明错误发生的域，一般是自定义的全局变量，例如：<em>NSURLErrorDomain</em>。
2）Error code(Integer):表明特定域的错误码，参考HTTP的状态码。<br/>
3）Userinfo(Dictionary):额外的信息，包括本地化描述信息和导致该错误的原因。<br/>
4.NSError的一些使用场景：<br/>
1）被用于Delegate中，例如：-(void)connection:(NSURLConnection <em>)connection didFailWithError:(NSError </em>)error。<br/>
2）用于返回型参数，参照Item19，类似：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//-(BOOL)doSomething:(NSError**)error</span>
</span><span class='line'><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="kt">BOOL</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">object</span> <span class="nl">doSomething:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">//There was an error</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
5.上述方法传入的是NSError<em><em>类型，开启ARC时该类型会转化为NSError</em> __autoreleasing</em>类型，该对象会在方法执行后自动释放，这么做，是因为doSomething:不能确定调用者会不会对NSError释放，大部分方法return的对象也是一样会添加autorelease（除了new，alloc，copy，mutableCopy等）。<br/>
6.doSomething的内部实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">doSomething:</span><span class="p">(</span><span class="n">NSError</span><span class="o">**</span><span class="p">)</span><span class="nv">error</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">//Do something that may cause an error</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="cm">/*there was an error*/</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">//有必要检查error，有可能传入nil值</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="c1">//Pass error through the out-parameter</span>
</span><span class='line'>          <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSError</span> <span class="nl">errorWithDomain:</span><span class="n">domain</span> <span class="nl">code:</span><span class="n">code</span> <span class="nl">userInfo:</span><span class="n">userInfo</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<!--more-->


<h2>Item22 Understand the NSCopying Protocol</h2>

<p>1.想要让自定义对象实现copy功能，必须遵循NSCopying协议，其中只有一个方法需要重写：-(id)copyWithZone:(NSZone*)zone。<br/>
2.一个重写copyWithZone:方法的例子，<em>friends是内部变量，所以使用了copy-></em>friends：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">copyWithZone:</span><span class="p">(</span><span class="n">NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nv">zone</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">EOCPerson</span> <span class="o">*</span><span class="n">copy</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">self</span> <span class="n">class</span><span class="p">]</span> <span class="nl">allocWithZone:</span><span class="n">zone</span><span class="p">]</span> <span class="nl">initWithFirstName:</span><span class="n">_firstName</span> <span class="nl">andLastName:</span><span class="n">_lastName</span><span class="p">];</span>
</span><span class='line'>  <span class="n">copy</span><span class="o">-&gt;</span><span class="n">_friends</span> <span class="o">=</span> <span class="p">[</span><span class="n">_friends</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">copy</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.关于这儿是否需要对_friends进行copy的讨论，作者认为如果原变量是可变的，是需要深拷贝的，而如果原变量是不可变的，则直接进行指针赋值即可，这样可以省一部分内存。<br/>
4.如果你的类有mutable和immutable两个类型，那么应该分别遵循NSMutableCopying和NSCopying协议，分别返回可变和不可变的copy。<br/>
5.采取这种方式的好处是可以提供一个可变与不可变类型的转换，而且采用copy，immutableCopy，mutableCopy三个方法的缺陷是我们很难判断将要复制的对象是不是可变的。<br/>
6.接下来讨论的是深拷贝和浅拷贝的问题，OC默认的Copy协议支持的都是浅拷贝，也就是指针拷贝，但是一些类的初始化方法提供了深拷贝，例如NSSet的：-(id)initWithSet:(NSArray*)array copyItems:(BOOL)copyItems。所以如果你需要进行深拷贝，必须自己定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">deepCopy</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">EOCPerson</span> <span class="o">*</span><span class="n">copy</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">self</span> <span class="n">class</span><span class="p">]</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFirstName:</span><span class="n">_firstName</span> <span class="nl">andLastName:</span><span class="n">_lastName</span><span class="p">];</span>
</span><span class='line'>  <span class="n">copy</span><span class="o">-&gt;</span><span class="n">_friends</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableSet</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSet:</span><span class="n">_friends</span> <span class="nl">copyItems:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">copy</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记2]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/07/22/effective-objective-cdu-shu-bi-ji-2/"/>
    <updated>2015-07-22T17:09:55+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/07/22/effective-objective-cdu-shu-bi-ji-2</id>
    <content type="html"><![CDATA[<p>继续上一篇，这篇的主题是Objects，Messaging，and the Runtime。</p>

<!--more-->


<h2>Item6 Understand Properties</h2>

<ol>
<li>在C++和Java中常使用@public和@private来声明实例变量，但在OC中由于对象是在编译期间定义的，所以按照这种定义方法，在新增变量后会导致访问偏移量出错，除非重新编译，但是这样就失去了动态语言的优势。</li>
<li>OC的解决方案是将实例变量作为可存储内存偏移量的类对象，这同时可以将实例变量定义到实现文件中，从而实现隐藏。Apple鼓励使用存取方法而不是直接访问实例变量，也是为了解决这一问题，@property就是为了方便提供getter和setter方法。</li>
<li>OC中的点方法类似C中访问结构体的成员，但其实是编译器转化为了对应的getter方法。</li>
</ol>


<h3>Property Attributes</h3>

<ol>
<li>主要说下有关内存管理的property属性，主要有assign，strong，weak，unsafe_unretained，copy。</li>
<li>assign：主要用于标量的property属性，简单的赋值操作，引用计数不变。</li>
<li>strong：声明的是持有关系，新值会被retain，旧值release，引用计数加1。</li>
<li>weak：声明的是非持有关系，与assign类似，如果指向的对象被释放，该值也会被释放。</li>
<li>unsafe_unretained：可以理解为针对对象的assign属性，但是所指向的对象被释放后，该值不会被释放，所以容易造成野指针，一般很少用到它。</li>
<li>copy：与strong类似，只不过所赋值的引用计数不变，旧值会被赋给一个所赋值copy的引用计数为1的对象，一般用于不可变对象，可能被赋可变对象的值时，这样可确保旧值改变时，不可变对象不发生变化。</li>
<li>get=&lt;>：可以自定义getter方法的名字，一般用于布尔型property，一般getter方法以is开头。</li>
<li>额外1：如果对一不可变对象复制，copy是指针复制（浅拷贝）和mutableCopy就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。</li>
<li>额外2：不要在init（包括自定义的初始化方法）和dealloc中使用setter和getter方法。</li>
<li>atomic用以确保线程安全，但是iOS平台的property基本都是nonatomic的，主要是因为性能问题，而且atomic也并非完全是线程安全的（例如一个线程频繁访问一个对象时，另一线程同时在写入，前一线程也会拿到不同的值），而在Mac OS X就不存在这个性能瓶颈了。</li>
</ol>


<!--more-->


<h2>Item7 Access Instance Variables Primarliy Directly When Accessing Them Internally</h2>

<ol>
<li>本章讨论的是如何在内部使用实例变量，有两种方式，一是使用生成的存取方法，二是直接使用实例变量。</li>
<li>优缺点如下：

<ol>
<li>直接访问对象，速度会快，绕开了OC的method dispatch，编译器会直接访问存储对象的内存。</li>
<li>直接访问对象会绕开与内存相关的setter方法，例如你设置的copy型的setter，只会按照retain来执行。</li>
<li>直接访问对象不会触发KVO。</li>
<li>使用存取方法会使调试变得简单，你可以在getter/setter添加断点。</li>
</ol>
</li>
<li>比较推荐的做法是，在存对象的时候使用setter方法，而在读取对象时直接读取，这样既享受了快速读取，也可以利用property控制保存对象。</li>
<li>但是这么做还是有一些需要注意的地方：

<ol>
<li>在初始化方法中，一定要使用直接赋值的方法，主要是因为怕子类复写了对象的setter方法，而导致异常，如果一个对象声明在了父类的内部，而子类不能直接访问它，你也不能直接访问读取该变量，这种情况只能通过setter赋值
2.如果实例变量使用了延时加载，那么读取一定要使用getter方法，不然这个对象永远都不会有值。</li>
</ol>
</li>
</ol>


<!--more-->


<h2>Item8 Understand Object Equality</h2>

<ol>
<li>比较两个对象，不使用==，那样只会比较指针的值，而一般使用<em>isEqual:</em>，如果对象有自己的专有比较方法，例如<em>isEqualToString:</em>，优先使用这些方法，速度会快些。</li>
<li><em>&ndash;(NSUIntegetr)hash;</em>是一个与比较对象息息相关的方法，hash相同的对象不一定相同，而相同的对象hash值一定相同。</li>
<li>所以自定义对象重写<em>isEqual:</em>方法，也一定要重写hash方法，共有三种方案：

<ol>
<li>返回一个常数，这个方案优点是使用单个对象时快，但是如果把大量对象放入同一集合，由于hash值相同，集合会挨个检查这些对象是否真的相同，从而导致向一个集合添加大量对象时就会很慢；</li>
<li>使用一个拼接的唯一字符串，然后进行hash，这个方案避免了上面的问题，但是出现了单个对象需要生成一个字符串，从而影响了速度的问题；</li>
<li>先取一系列变量的hash值，再将其异或，这个方案算是为了避免上述问题的折衷方案。</li>
</ol>
</li>
</ol>


<h3>Class-Specific Equality Methods</h3>

<ol>
<li>自定义类可以通过重写<em>isEqual:</em>方法，在方法里判断如果是同一类型，就调用上面的比较方法，如不是就调用父类的<em>isEqual:</em>方法，这样可以实现子类也可以与父类进行比较。</li>
</ol>


<h3>Deep versus Shallow Equality</h3>

<ol>
<li>有时你并不需要判断对象的所有信息是否相同，比如来自数据库的信息，可能只通过判断id就可以进行判断，所谓的浅比较就是这样。</li>
</ol>


<h3>Equality of Mutable Classes in Containers</h3>

<ol>
<li>这一部分主要讲的是，向集合添加可变对象，然后改变该对象，是有可能让集合出现重复对象的，这点值得关注。</li>
</ol>


<!--more-->


<h2>Item9 Use the Class Cluster Pattern to Hide Implementation Detail</h2>

<ol>
<li>类簇是OC中很重要的一个设计模式，例如UIButton的创建，类簇解决的问题是需要统一创建同一基本类型的不同对象，而同时避免暴露子类和父类内部复杂的switch语句。</li>
</ol>


<h3>Creating a Class Cluster</h3>

<ol>
<li>创建类簇的思路：一个基类，一些空方法，一个创建对象的工厂方法，继承的子类对空方法重写。这样的类簇有个缺点就是用户可能以为自己使用的类就是那个基类，而不知道其实是它的子类。</li>
</ol>


<h3>Class Clusters in Cocoa</h3>

<ol>
<li>由于很多Cocoa类都是使用了类簇模式，所以类似<em>[maybeAnArray class] == [NSArray class]</em>这样的校验类型的方法是不会返回正确值的，而要使用<em>[maybeAnArray isKindOfClass:[NSArray class]]</em>。</li>
<li>添加一个类簇的子类而不去改写其基类的工厂方法，对于NSArray是可以的，但是有三点要求：1、必须是该类簇基类的子类；2、该子类必须定义自己的存储空间，也就是说内部要有一个NSArray的对象来实现数据的存储；3、子类必须重写类簇文档中规定重写的方法。</li>
</ol>


<!--more-->


<h2>Item10 Use Associated Objects to Attach Custom Data to Existing Classes</h2>

<ol>
<li>有时为了为一个类绑定一些信息，而又不方便添加多余的property或者继承这个类，可以考虑使用<em>association</em>，类似字典型的键值读取，也可以设置内存管理策略，但是需要注意绑定的key必须是唯一的指针，而不只是值相同，所以一般使用全局的静态变量作为key。</li>
</ol>


<h3>An Example of Using Associated Objects</h3>

<ol>
<li>通过使用<em>Associated Objects</em>实现了UIAlertView的回调Block化，使得代码的可读性更好，也更方便。</li>
<li><em>Associated Objects</em>提供了一个将对象之间互相绑定的方法，但是并不推荐大范围使用该方法，因为会导致调试变的更难。</li>
</ol>


<!--more-->


<h2>Item11 Understand the Role of objec_msgSend</h2>

<ol>
<li>OC利用动态绑定成为了真正的动态语言，OC中传递消息最终被转化为函数<em>void objc_msgSend(id self, SEL cmd, &hellip;)</em>，例如：<em>id returnValue = [someObkect messageName:parameter];</em>转化后，<em>id returnValue = objc_msgSend(someObject, @sleector(messageName:), parameter);</em>。</li>
<li><em>objc_msgSend</em>执行的顺序是先在接受者实现的方法中找符合的方法来执行，如没有，向继承链上方逐级寻找符合的实现方法。</li>
<li><em>objc_msgSend</em>会为每个类缓存一张查找表，来加速这一过程，但即使如此，还是比在C中直接调用静态调用函数慢，但这常常不是应用的瓶颈，这样来换取程序的灵活性还是值得的。</li>
<li><em>objc_msgSend</em>是针对确定消息的处理，下面还有一些处理个别案例的方法。</li>
<li><em>objc_msgSend_stret</em>用于处理用户返回适用于CPU寄存器的结构体的消息（不太懂）。</li>
<li><em>objc_msgSend_fpret</em>用于处理返回浮点值的消息，一些结构需要在函数调用时对浮点数寄存器特殊处理，所以这是该方法存在的意义（不太懂）。</li>
<li><em>objc_msgSendSuper</em>直接把消息转发给父类执行，类的所有方法都是一个个类似<em>&lt;return_type> Class_selector(id self, SEL _CMD, &hellip;)</em>这样的原型，这些方法指针存在该类的一个查找表中等待调用，该原型与<em>objc_msgSend</em>是相同的，也就实现了<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html">尾部递归调用</a>的可能，这样会实现调用栈的空间复杂度保持O(1)，不会产生溢出。</li>
</ol>


<!--more-->


<h2>Item12 Understand Message Forwarding</h2>

<ol>
<li>转发路径是为了处理接受者无法处理消息的情况，分为两条路径：1、<em>dynamic method resolution</em>期望接收者自己在runtime添加处理方法；2、<em>full forwarding mechanism</em>到了这一步，runtime得知接收者是不可能对消息做出响应了，所以要求接收者自己处理该消息，又分为两步：(1)询问是否有其他对象可以接收消息，如果有则转发给该对象；(2)如果也没有替代的接收者，那么将使用<em>NSInvocation</em>来对消息进行封装，然后交给原接收者去处理。<a href="http://bugly.qq.com/blog/?p=64">这儿也做了详细解释</a>。</li>
</ol>


<h3>Dynamic Method Resolution</h3>

<ol>
<li><em>+(BOOL)resolveInstanceMethod:(SEL)selector</em>用于表明类有无实例方法可处理该消息，可以说是给予该类的第二次机会。</li>
<li>这类方法是存在的，例如CoreData的@dynamic的property的accessing方法，而<em>+(BOOL)resolveInstanceMethod:(SEL)selector</em>对其的处理是判断是否是@dynamic property，如果是，向该类添加预备好的getter，setter方法，已确保类可以响应该消息。</li>
</ol>


<h3>Replacement Receiver</h3>

<ol>
<li><em>&ndash;(id)forwardTargetForSelector:(SEL)selector</em>用于返回可以替代原接收者的对象（如果其存在的话），这其实提供了一些多继承的特性，即原类内部可以有其他对象来实现这一方法。但是无法对消息进行修改，只是转发，如需修改消息，则需要采取最后一步。</li>
</ol>


<h3>Full Forwarding Mechanism</h3>

<ol>
<li>&ndash;(void)forwardInvocation:(NSInvocation*)invocation用于转发接收到的NSInvocation消息，可以进行简单转发，但这和上述的方法没有区别，而更为常见的用途是修改消息，如增加参数或者改变方法等。</li>
<li>重写该方法时需要调用父类的相同方法来处理改invocation，这样会最终调用NSObject的<em>doesNotRecognizeSelector</em>，最终抛出异常，但如果你不希望程序崩溃，就不要去调用父类的方法。</li>
</ol>


<h3>The Full Picture</h3>

<ol>
<li>具体图表见<a href="http://bugly.qq.com/blog/?p=64">这儿</a>。</li>
<li>解决的代价是越来越高的，所以最好在第一阶段解决这一问题。</li>
</ol>


<h3>Full Example of Dynamic Method Resolution</h3>

<ol>
<li>举例说明，将一个model中的所有对象都存在一个dictionary中，而这些对象申明为@dynamic，在<em>+(BOOL)resolveInstanceMethod:(SEL)selector</em>中根据selector的信息对相应的对象动态添加setter，getter方法，大幅减少代码量，但缺点是想特殊处理某个对象，就变得比较麻烦了。</li>
</ol>


<!--more-->


<h2>Item13 Consider Method Swizzling to Debug Opaque Methods</h2>

<ol>
<li><em>Method Swizzling</em>主要用于不知道类的源码，且不用继承、重写，即可为原方法添加hook的手段（其实是在runtime中先交换，再执行一次原方法而已-_-）。</li>
<li>通过添加一个类的分类，在分类添加一个方法，在这个方法中进行递归调用，然后与目标方法进行交换，这时再执行原方法时，会依次执行这两个方法。<a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411">另外一篇文章也有说明</a>。</li>
</ol>


<!--more-->


<h2>Item14 Understand What a Class Object Is</h2>

<ol>
<li>Class本身也是一个结构体指针，叫objc_class，Class也有一个Class类型的isa指针，说明Class本身也是一个OC对象，他的类型叫做metaclass，Class有Class类型的super_class指针，用来指向他的父类Class。</li>
</ol>


<h3>Inspecting the Class Hierarchy</h3>

<ol>
<li><em>isMemberOfClass:</em>用于判断是否属于该类，<em>isKindOfClass:</em>用于判断是否属于该类或者该类的子类。原理还是利用上述的Class的isa和super_class指针。</li>
<li>内省（自我类型检查）是OC中的重要技术，应用也很广泛，除了上述方法，也可利用<em>[object class] == [EOCSomeClass class]</em>来判断，之所以这么写是合理的，是因为每个class的Class类型是一个单例对象，所以可以直接比较指针。</li>
<li>但是还是推荐使用默认的类型检测方法，因为这样可以利用消息转发技术，如果一个对象的所有方法都是代理对象执行的，那么调用class方法只会返回代理对象的类型，而调用<em>isKindOfClass:</em>方法，代理会把消息转给被代理的对象，会得到正确的类型。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记1]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/07/20/effective-objective-cdu-shu-bi-ji-1/"/>
    <updated>2015-07-20T14:47:04+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/07/20/effective-objective-cdu-shu-bi-ji-1</id>
    <content type="html"><![CDATA[<p>关于书不多做介绍了，很有名的一本书，是Mattt Thompson大神写的，他是AFNetworking的主要作者，同时维护了<a href="http://nshipster.com">NSHipster</a>，这本书之前看了一次，但是没那么细致，打算再看一次，同时做做笔记。</p>

<!--more-->


<h2>Item1 Familiarize Yourself with Objective-C&rsquo;s Roots</h2>

<ol>
<li>OC采用消息传递而非函数调用的基本结构，二者最大区别是消息传递中运行时才决定执行的代码，而函数调用中编译器会决定执行的代码。所以运行期承担了OC运作的大部分工作，所以每当运行期更新时你的应用都会从中受益，而不需等到重新编译（最后这段，不是太明白）。</li>
<li>学好C会让你更好理解OC，诸如内存模型和引用计数这些概念。所有OC对象的内存都是<a href="http://mobile.51cto.com/iphone-394484.htm">开辟在堆上的，不在栈上</a>，栈是编译器控制的，堆是程序员控制的，而这些对象的指针是存放在栈上的，所以当指针不存在，而程序员又没有释放堆上的对象，就导致了内存泄露。</li>
<li>OC是通过引用计数来模拟内存的开辟与释放。</li>
<li>有些变量是直接开辟在栈上的，如CGRect，他是一个结构体，不同于对象，他们的使用不会影响性能。</li>
</ol>


<!--more-->


<h2>Item2 Minimize Importing Headers in Headers</h2>

<ol>
<li>尽量避免在类的头文件直接#import其他class的头文件，能使用@class尽量使用，有俩个好处：1、避免引用头文件的连锁效应，增加编译时间；2、避免了互相#import头文件而出现的循环导入的特殊情况。</li>
<li>一些需要导入头文件到.h文件的请款：1、class所继承的父类；2、使用protocol类型。</li>
<li>遵从的protocol可以放在匿名分类中#import。</li>
</ol>


<!--more-->


<h2>Item3 Prefer Literal Syntax over the Equivalent Methods</h2>

<ol>
<li>尽量多去使用文字型语法，这样可减少代码量，增加可读性。</li>
<li>关于NSArray的文字型创建语法，如果其中一个对象为nil，则会立即抛出异常，而使用传统的<em>arrayWithObjects:</em>则会在加入nil对象时停下，并不会报错，这使得我们更难发现这一问题。</li>
<li>唯一一个不足是文字型语法只接受Foundation框架的对象，而不接受自定义对象。</li>
</ol>


<!--more-->


<h2>Item4 Prefer Typed Constants to Preprocessor #define</h2>

<ol>
<li>尽量多使用静态常量，而不是预编译常量。原因只要是预编译常量是代码整体进行替换，容易被重赋值，常量的范围不好控制。类似<em>static const NSTimeInterval kAnimationDuration = 0.3</em></li>
<li>而如果要使用全局常量（比如注册和接受通知的名称），采用以下方式</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//in the header file</span>
</span><span class='line'><span class="k">extern</span> <span class="n">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">EOCStringConstant</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//in the implementation file</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">EOCStringConstant</span> <span class="o">=</span> <span class="s">@&quot;VALUE&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//基本类型常量</span>
</span><span class='line'><span class="c1">//EOCAnimatedView.h</span>
</span><span class='line'><span class="k">extern</span> <span class="k">const</span> <span class="n">NSTimeInterval</span> <span class="n">EOCAnimatedViewAnimationDuration</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//EOCAnimatedView.m</span>
</span><span class='line'><span class="k">const</span> <span class="n">NSTimeInterval</span> <span class="n">EOCAnimatedViewAnimationDuration</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Item5 Use Enumerations for States, Options, and Status Codes</h2>

<p>1.使用枚举类型主要是用于定义状态和选项，可读性好是它最大的优点，c++11后OC开始支持自定义枚举类型所用的数据类型。<br/>
2.用枚举做选项时，可用位移的方式实现多个选项合并使用，这种方式广泛用于UIKit。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">typedef</span> <span class="nf">NS_OPTIONS</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">,</span> <span class="n">EOCPermittedDirection</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">EOCPermittedDirectionUp</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span>
</span><span class='line'>  <span class="n">EOCPermittedDirectionDown</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>
</span><span class='line'>  <span class="n">EOCPermittedDirectionLeft</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span>
</span><span class='line'>  <span class="n">EOCPermittedDirectionRight</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">EOCPermittedDirection</span> <span class="n">permittedDirection</span> <span class="o">=</span> <span class="n">EOCPermittedDirectionUp</span> <span class="o">|</span> <span class="n">EOCPermittedDirectionDown</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">permittedDirection</span> <span class="o">&amp;</span> <span class="n">EOCPermittedDirectionUp</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">//EOCPermittedDirectionUp is set</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.OC定义了专门定义枚举的宏，NS_ENUM和NS_OPTIONS，他们对兼容新旧编译器做了自动判断，推荐使用，如想使用可合并的枚举，必须使用NS_OPTIONS来定义。<br/>
4. 最后一点，对枚举型值执行switch语句时，不要添加default处理。</p>

<!--more-->


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[raywenderlich.com代码风格规范]]></title>
    <link href="http://lucifer1988.github.io/blog/2014/04/09/raywenderlich-dot-comdai-ma-feng-ge-gui-fan/"/>
    <updated>2014-04-09T14:36:55+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2014/04/09/raywenderlich-dot-comdai-ma-feng-ge-gui-fan</id>
    <content type="html"><![CDATA[<p><img src="http://lucifer1988.github.io/images/rayWenderlich_icon.png"></p>

<p><a href="http://www.raywenderlich.com">raywenderlich.com</a>对于搞iOS开发的人来说不会陌生（如果你经常关注一些技术博客的话），它原本只是Ray Wenderlich的个人博客，但通过不断聚集优秀的开发者参与到其站点的技术博客撰写，包括了应用开发和游戏开发的各个方面，同时将这些技术博客整理成书，作为开发教程出售（貌似最近还出视频教程了，又想法圈钱了···），这样raywenderlich.com渐渐发展成了一个iOS开发社区，其优质的文章和对文章本地化的重视，使得其影响力逐渐向全球扩展。本文是对其最近公布的自家的Objective-C代码风格规范的一些整理，原文地址在<a href="https://github.com/raywenderlich/objective-c-style-guide">这里</a>。</p>

<!--more-->


<h2>目录</h2>

<ul>
<li><a href="#%E8%AF%AD%E8%A8%80">语言</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84">代码结构</a></li>
<li><a href="#%E7%A9%BA%E6%A0%BC">空格</a></li>
<li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li>
<li><a href="#%E5%91%BD%E5%90%8D">命名</a></li>
<li><a href="#%E4%B8%8B%E5%88%92%E7%BA%BF">下划线</a></li>
<li><a href="#%E6%96%B9%E6%B3%95">方法</a></li>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E5%B1%9E%E6%80%A7">属性</a></li>
<li><a href="#%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F">点表达式</a></li>
<li><a href="#%E6%96%87%E5%AD%97%E9%87%8F">文字量</a></li>
<li><a href="#%E5%B8%B8%E9%87%8F">常量</a></li>
<li><a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B">枚举类型</a></li>
<li><a href="#%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5">分支语句</a></li>
<li><a href="#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7">私有属性</a></li>
<li><a href="#%E5%B8%83%E5%B0%94%E5%9E%8B">布尔型</a></li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">条件语句</a></li>
<li><a href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6">三元运算符</a></li>
<li><a href="#Init%E6%96%B9%E6%B3%95">Init方法</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E7%B1%BB%E6%96%B9%E6%B3%95">构造类方法</a></li>
<li><a href="#CGRect%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">CGRect相关函数</a></li>
<li><a href="#%E6%84%89%E5%BF%AB%E8%B7%AF%E5%BE%84">愉快路径</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</a></li>
<li><a href="#%E5%8D%95%E4%BE%8B">单例</a></li>
<li><a href="#%E6%8D%A2%E8%A1%8C">换行</a></li>
<li><a href="#%E7%AC%91%E8%84%B8">笑脸（你没看错，这也有规范）</a></li>
<li><a href="#Xcode%E5%B7%A5%E7%A8%8B">Xcode工程</a></li>
</ul>


<h2><a name="语言"></a>语言</h2>

<p>推荐使用美英，主要体现在命名时使用美英单词。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UIColor</span> <span class="o">*</span><span class="n">myColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">whiteColor</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UIColor</span> <span class="o">*</span><span class="n">myColour</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">whiteColor</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="代码结构"></a>代码结构</h2>

<p>统一使用<code>#pragma mark -</code>组织代码结构。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#pragma mark - Lifecycle</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">init</span> <span class="p">{}</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{}</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{}</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{}</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">didReceiveMemoryWarning</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - Custom Accessors</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setCustomProperty:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">value</span> <span class="p">{}</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">customProperty</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - IBActions</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">IBAction</span><span class="p">)</span><span class="nf">submitData:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - Public</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">publicMethod</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - Private</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">privateMethod</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - Protocol conformance</span>
</span><span class='line'><span class="cp">#pragma mark - UITextFieldDelegate</span>
</span><span class='line'><span class="cp">#pragma mark - UITableViewDataSource</span>
</span><span class='line'><span class="cp">#pragma mark - UITableViewDelegate</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - NSCopying</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">copyWithZone:</span><span class="p">(</span><span class="n">NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nv">zone</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - NSObject</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="空格"></a>空格</h2>

<ul>
<li>使用2个空格缩进（理由是可以在保持打印空白的基础上，尽量减少换行的可能性），不要使用tab缩进，可以在Xcode的preference下进行修改（默认是4个空格）；</li>
<li>方法中的<code>{}</code>和在<code>if</code>/<code>else</code>/<code>switch</code>/<code>while</code>等语法中出现的<code>{}</code>在本行开始，而结束于新一行。</li>
</ul>


<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="n">isHappy</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">//Do something</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">//Do something else</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="n">isHappy</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//Do something</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">//Do something else</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>方法之间应该有且只有一空行来保持代码结构清晰，方法中的空白行用来划分功能，但是经常你可能需要将它们重构为新的方法；</li>
<li>推荐使用自动提示的语法结构，不过<code>@sythesize</code>和<code>@dyamic</code>可以声明在新行；</li>
<li><code>冒号对齐</code>这样的方法调用结构要避免，假如方法中出现3个以上的冒号，这样的调用结构会使代码可读性很差。千万别在含有block的方法中去对齐冒号，这样Xcode的缩进会使其非法。</li>
</ul>


<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// blocks are easily readable</span>
</span><span class='line'><span class="p">[</span><span class="n">UIView</span> <span class="nl">animateWithDuration:</span><span class="mf">1.0</span> <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">// something</span>
</span><span class='line'><span class="p">}</span> <span class="nl">completion:</span><span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// something</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// colon-aligning makes the block indentation hard to read</span>
</span><span class='line'><span class="p">[</span><span class="n">UIView</span> <span class="nl">animateWithDuration:</span><span class="mf">1.0</span>
</span><span class='line'>                 <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>                     <span class="c1">// something</span>
</span><span class='line'>                 <span class="p">}</span>
</span><span class='line'>                 <span class="nl">completion:</span><span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                     <span class="c1">// something</span>
</span><span class='line'>                 <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="注释"></a>注释</h2>

<p>注释主要用来解释这段代码为什么存在于此，注意所有注释需要及时更新或删除。</p>

<p>大段的注释要避免，有必要可以加到单独的文档，注释需要一些简短的说明。PS：不包括那些为生成文档而做的注释（一些工具可以通过代码中的注释生成文档）。</p>

<h2><a name="命名"></a>命名</h2>

<p>Apple的命名习惯是尽可能详细，尤其是和内存管理相关的。</p>

<p>长的，描述性的方法和变量名命名是被推荐的。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UIButton</span> <span class="o">*</span><span class="n">settingsButton</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UIButton</span> <span class="o">*</span><span class="n">setBut</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>类名和常量名必须要有三个字母的命名前缀（主要为了避免和Apple大多数两个前缀的命名冲突，比如UIButton，CAAnimation，CGRect等），不过Core Data的实体命名可以省略这些前缀。比如raywenderlich.com的命名前缀为RTW。</p>

<p>常量需要驼峰型命名，所有单词首字母大写，且使用相关类名作为前缀。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="n">NSTimeInterval</span> <span class="k">const</span> <span class="n">RWTTutorialViewControllerNavigationFadeAnimationDuration</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="n">NSTimeInterval</span> <span class="k">const</span> <span class="n">fadetime</span> <span class="o">=</span> <span class="mf">1.7</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>property使用驼峰形命名，保证开头单词小写，且使用Apple的自动合成规则，除了特殊情况，不要手动声明<code>@synthesize</code>。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">descriptiveVariableName</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">varnm</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="下划线"></a>下划线</h2>

<p>当使用property时，实例变量的读写要使用<code>self.</code>，这样的话所有的property可以清楚地区分出来。</p>

<p>一个例外：在初始化方法中，需要的实例变量要直接使用<code>_variableName</code>型，为了避免调用getter/setter方法可能出现的循环引用。</p>

<p>临时变量不能使用下划线。</p>

<h2><a name="方法"></a>方法</h2>

<p>在方法声明时，方法类型（-/+）后要有一个空格。方法段之间也要有一个空格。在每个变量前要加一个描述性的词语用来描述这个变量。</p>

<p>不要在用于描述的词语中加入“and”，具体例子见下：</p>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setExampleText:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">text</span> <span class="nf">image:</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nv">image</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sendAction:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">to:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">anObject</span> <span class="nf">forAllCells:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">flag</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">viewWithTag:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nv">tag</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithWidth:</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">width</span> <span class="nf">height:</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">height</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setT:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">text</span> <span class="nf">i:</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nv">image</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sendAction:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="o">:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">anObject</span> <span class="o">:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">flag</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">taggedView:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nv">tag</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithWidth:</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">width</span> <span class="nf">andHeight:</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">height</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWith:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">width</span> <span class="nf">and:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">height</span><span class="p">;</span>  <span class="c1">// Never do this.</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="变量"></a>变量</h2>

<p>变量命名尽量使用描述性的词语。单个字母的命名除了在<code>for()</code>循环中，其他地方都是不允许的。</p>

<p>星号声明了指向变量的指针，例如：<code>NSString *text</code>，不是<code>NSString* text</code>或<code>NSString * text</code>，除了在声明常量的时候（例如：<code>NSString *const text</code>）。</p>

<p>如果可能的话，使用<a href="#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7">私有属性</a>，而不是实例变量，尽管使用实例变量也是对的，不过这样的协定可以保持代码的一致性。</p>

<p>只有在初始化方法（如<code>init</code>，<code>initWithCoder:</code>等），<code>dealloc</code>和setter/getter方法中使用下划线加变量名的读写方法，更多关于这一情况的说明见<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW6">Apple相关文档</a></p>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">RWTTutorial</span> : <span class="nc">NSObject</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">tutorialName</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">RWTTutorial</span> : <span class="nc">NSObject</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">NSString</span> <span class="o">*</span><span class="n">tutorialName</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="属性"></a>属性</h2>

<p>属性需要清楚地列出，属性的property类型顺序应该是先内存相关，再原子性相关，这与从IB中自动关联的属性的顺序是一致的。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">weak</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="kt">IBOutlet</span> <span class="n">UIView</span> <span class="o">*</span><span class="n">containerView</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">tutorialName</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">weak</span><span class="p">)</span> <span class="kt">IBOutlet</span> <span class="n">UIView</span> <span class="o">*</span><span class="n">containerView</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">tutorialName</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>带有不可变性质的属性（比如：NSString）推荐使用<code>copy</code>而不是<code>strong</code>，理由是其他人可能传入一个其对应的可变实例（比如：NSMutableString），而你可能不会注意到。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">copy</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">tutorialName</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">tutorialName</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="点表达式"></a>点表达式</h2>

<p>读写property时应一直使用点表达式，这使代码变得简洁，而<code>[]</code>表达式用于其他所有的实例中。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSInteger</span> <span class="n">arrayCount</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">array</span> <span class="n">count</span><span class="p">];</span>
</span><span class='line'><span class="n">view</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">orangeColor</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">].</span><span class="n">delegate</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSInteger</span> <span class="n">arrayCount</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">view</span> <span class="nl">setBackgroundColor:</span><span class="p">[</span><span class="n">UIColor</span> <span class="n">orangeColor</span><span class="p">]];</span>
</span><span class='line'><span class="n">UIApplication</span><span class="p">.</span><span class="n">sharedApplication</span><span class="p">.</span><span class="n">delegate</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="文字量"></a>文字量</h2>

<p><code>NSString</code>，<code>NSDictionary</code>，<code>NSArry</code>，<code>NSNumber</code>如果可能的话，尽量使用它们的不可变实例。<code>NSArray</code>和<code>NSDictionary</code>不能存在<code>nil</code>值，否则会引起崩溃。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">names</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="s">@&quot;Brian&quot;</span><span class="p">,</span> <span class="s">@&quot;Matt&quot;</span><span class="p">,</span> <span class="s">@&quot;Chris&quot;</span><span class="p">,</span> <span class="s">@&quot;Alex&quot;</span><span class="p">,</span> <span class="s">@&quot;Steve&quot;</span><span class="p">,</span> <span class="s">@&quot;Paul&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">productManagers</span> <span class="o">=</span> <span class="err">@</span><span class="p">{</span><span class="s">@&quot;iPhone&quot;</span><span class="o">:</span> <span class="s">@&quot;Kate&quot;</span><span class="p">,</span> <span class="s">@&quot;iPad&quot;</span><span class="o">:</span> <span class="s">@&quot;Kamal&quot;</span><span class="p">,</span> <span class="s">@&quot;Mobile Web&quot;</span><span class="o">:</span> <span class="s">@&quot;Bill&quot;</span><span class="p">};</span>
</span><span class='line'><span class="n">NSNumber</span> <span class="o">*</span><span class="n">shouldUseLiterals</span> <span class="o">=</span> <span class="err">@</span><span class="n">YES</span><span class="p">;</span>
</span><span class='line'><span class="n">NSNumber</span> <span class="o">*</span><span class="n">buildingStreetNumber</span> <span class="o">=</span> <span class="err">@</span><span class="mi">10018</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSArray</span> <span class="nl">arrayWithObjects:</span><span class="s">@&quot;Brian&quot;</span><span class="p">,</span> <span class="s">@&quot;Matt&quot;</span><span class="p">,</span> <span class="s">@&quot;Chris&quot;</span><span class="p">,</span> <span class="s">@&quot;Alex&quot;</span><span class="p">,</span> <span class="s">@&quot;Steve&quot;</span><span class="p">,</span> <span class="s">@&quot;Paul&quot;</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">productManagers</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDictionary</span> <span class="nl">dictionaryWithObjectsAndKeys:</span> <span class="s">@&quot;Kate&quot;</span><span class="p">,</span> <span class="s">@&quot;iPhone&quot;</span><span class="p">,</span> <span class="s">@&quot;Kamal&quot;</span><span class="p">,</span> <span class="s">@&quot;iPad&quot;</span><span class="p">,</span> <span class="s">@&quot;Bill&quot;</span><span class="p">,</span> <span class="s">@&quot;Mobile Web&quot;</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="n">NSNumber</span> <span class="o">*</span><span class="n">shouldUseLiterals</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithBool:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'><span class="n">NSNumber</span> <span class="o">*</span><span class="n">buildingStreetNumber</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithInteger:</span><span class="mi">10018</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="常量"></a>常量</h2>

<p>常量推荐内联的字符串或数字，推荐定义为<code>static</code>变量，除非要作为宏，不然不要使用<code>#define</code>。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">RWTAboutViewControllerCompanyName</span> <span class="o">=</span> <span class="s">@&quot;RayWenderlich.com&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="n">CGFloat</span> <span class="k">const</span> <span class="n">RWTImageThumbnailHeight</span> <span class="o">=</span> <span class="mf">50.0</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#define CompanyName @&quot;RayWenderlich.com&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define thumbnailHeight 2</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="枚举类型"></a>枚举类型</h2>

<p>当使用枚举型时，推荐使用新的固定基础类型定义，理由是有更强的类型检查和代码完成功能。SDK现在包含了一个宏来确保和推广使用固定基础类型：<code>NS_ENUM()</code>。</p>

<p><strong>例如：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">NS_ENUM</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">,</span> <span class="n">RWTLeftMenuTopItemType</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">RWTLeftMenuTopItemMain</span><span class="p">,</span>
</span><span class='line'>  <span class="n">RWTLeftMenuTopItemShows</span><span class="p">,</span>
</span><span class='line'>  <span class="n">RWTLeftMenuTopItemSchedule</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>也可以做明确的赋值</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">NS_ENUM</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">,</span> <span class="n">RWTGlobalConstants</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">RWTPinSizeMin</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>  <span class="n">RWTPinSizeMax</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
</span><span class='line'>  <span class="n">RWTPinCountMin</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
</span><span class='line'>  <span class="n">RWTPinCountMax</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>旧式的k型常量定义只被用于书写CoreFoundation的C代码中。</p>

<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">enum</span> <span class="n">GlobalConstants</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">kMaxPinSize</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
</span><span class='line'>  <span class="n">kMaxPinCount</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="分支语句"></a>分支语句</h2>

<p>花括号对于分支语句并不是必须的，除非编译器强制使用。
当一个分支包含多于一条语句，花括号需要添加。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">switch</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'>  <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="c1">// Multi-line example using braces</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>有时会出现一段代码被多个分支使用，这时就相当于“穿过”。一个“穿过”就是移除这一分支的‘break’语句，使代码继续执行下一分支。“穿过”这种情况需要在代码中进行注释。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">switch</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// ** fall-through! **</span>
</span><span class='line'>  <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// code executed for values 1 and 2</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当在<code>switch</code>语句中使用枚举类型，<code>default</code>是不需要的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">RWTLeftMenuTopItemType</span> <span class="n">menuType</span> <span class="o">=</span> <span class="n">RWTLeftMenuTopItemMain</span><span class="p">;</span>
</span><span class='line'><span class="k">switch</span> <span class="p">(</span><span class="n">menuType</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nl">RWTLeftMenuTopItemMain:</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'>  <span class="k">case</span> <span class="nl">RWTLeftMenuTopItemShows:</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'>  <span class="k">case</span> <span class="nl">RWTLeftMenuTopItemSchedule:</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="私有属性"></a>私有属性</h2>

<p>私有属性应该定义到<code>.m</code>文件中的类扩展（匿名分类）中，命名的分类（如<code>RWTPrivate</code>，<code>private</code>）是不允许使用的，除非是在做另一个类的拓展。匿名分类可以暴露和共享于与<code>+Private.h</code>文件的命名惯例测试中。</p>

<p><strong>例如：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">RWTDetailViewController</span> <span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">GADBannerView</span> <span class="o">*</span><span class="n">googleAdView</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">ADBannerView</span> <span class="o">*</span><span class="n">iAdView</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">UIWebView</span> <span class="o">*</span><span class="n">adXWebView</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="布尔型"></a>布尔型</h2>

<p>Objective-C使用<code>YES</code>和<code>NO</code>。因此<code>true</code>和<code>false</code>只用于CoreFoundation，C和C++中。由于<code>nil</code>意味着<code>NO</code>，拿<code>nil</code>来做比较条件是不允许的，永远不要直接拿<code>YES</code>来比较，因为<code>YES</code>被定义为1，而一个布尔型可以支持到8比特。</p>

<p>这是为了文件间更多的一致性和更好的可读性。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">someObject</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">anotherObject</span> <span class="n">boolValue</span><span class="p">])</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">someObject</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'><span class="k">if</span> <span class="p">([</span><span class="n">anotherObject</span> <span class="n">boolValue</span><span class="p">]</span> <span class="o">==</span> <span class="n">NO</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">isAwesome</span> <span class="o">==</span> <span class="n">YES</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// Never do this.</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">isAwesome</span> <span class="o">==</span> <span class="n">true</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// Never do this.</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果布尔型被命名为一个形容词，属性名可以省略<code>is</code>，但是getter方法要保持这一命名。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">assign</span><span class="p">,</span> <span class="n">getter</span><span class="o">=</span><span class="n">isEditable</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">editable</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这一部分来自<a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-BAJGIIJE">Cocoa Naming Guidelines</a>。</p>

<h2><a name="条件语句"></a>条件语句</h2>

<p>条件语句主体任何时候都要使用花括号，即使是只有一条语句也需要。这是为了避免错误。这些错误包括添加下一条语句，以为这条语句位于if主体中。另一个更危险的缺点是，if主体内的语句被注释掉，这时下一条语句无意中成为了if语句中的一部分。除此之外，这样的风格与其他条件语句格式保持了一致，便于查找。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>或</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="三元运算符"></a>三元运算符</h2>

<p>三元运算符<code>?:</code>，只有在可以提高可读性和简洁性时才可使。单一的判断条件一般可以使用，当执行多个判断条件时推荐使用<code>if</code>语句提高可读性，或者将条件重构为实例变量。总的来说，使用三元运算符的最好时机是决定如何给一个变量赋值的时候。</p>

<p>非布尔类型变量需要比较时，要添加<code>()</code>提高可读性。如果是布尔类型，则不需要。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSInteger</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">BOOL</span> <span class="n">isHorizontal</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'><span class="n">result</span> <span class="o">=</span> <span class="n">isHorizontal</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">y</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">x</span> <span class="o">=</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="n">d</span> <span class="o">?</span> <span class="n">c</span> <span class="o">:</span> <span class="n">d</span> <span class="o">:</span> <span class="n">y</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="Init方法"></a>Init方法</h2>

<p>Init方法遵守Apple生成的代码模板，<code>instancetype</code>应取代<code>id</code>作为返回值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于<code>instancetype</code>参照<a href="#class-constructor-methods">Class Constructor Methods</a>。</p>

<h2><a name="构造类方法"></a>构造类方法</h2>

<p>当类构造方法使用时，同样需要注意返回值使用<code>instancetype</code>，而不是<code>id</code>，这样可确保编译器得知正确的结果类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">Airplane</span>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">airplaneWithType:</span><span class="p">(</span><span class="n">RWTAirplaneType</span><span class="p">)</span><span class="nv">type</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>更多关于<code>instancetype</code>在<a href="http://nshipster.com/instancetype/">NSHipster.com</a>。</p>

<h2><a name="CGRect相关函数"></a>CGRect相关函数</h2>

<p>当读取一个<code>CGRect</code>的<code>x</code>、<code>y</code>、<code>width</code>、<code>height</code>时，要使用<code>CGGeometry</code>相关的函数，而不是直接读取结构体。参照Apple的相关文档：</p>

<blockquote><p>All functions described in this reference that take CGRect data structures as inputs implicitly standardize those rectangles before calculating their results. For this reason, your applications should avoid directly reading and writing the data stored in the CGRect data structure. Instead, use the functions described here to manipulate rectangles and to retrieve their characteristics.</p></blockquote>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CGRect</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">CGFloat</span> <span class="n">x</span> <span class="o">=</span> <span class="n">CGRectGetMinX</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</span><span class='line'><span class="n">CGFloat</span> <span class="n">y</span> <span class="o">=</span> <span class="n">CGRectGetMinY</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</span><span class='line'><span class="n">CGFloat</span> <span class="n">width</span> <span class="o">=</span> <span class="n">CGRectGetWidth</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</span><span class='line'><span class="n">CGFloat</span> <span class="n">height</span> <span class="o">=</span> <span class="n">CGRectGetHeight</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</span><span class='line'><span class="n">CGRect</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CGRect</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">CGFloat</span> <span class="n">x</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'><span class="n">CGFloat</span> <span class="n">y</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'><span class="n">CGFloat</span> <span class="n">width</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'><span class="n">CGFloat</span> <span class="n">height</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
</span><span class='line'><span class="n">CGRect</span> <span class="n">frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">CGRect</span><span class="p">){</span> <span class="p">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">CGPointZero</span><span class="p">,</span> <span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">size</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="愉快路径"></a>愉快路径</h2>

<p>进行条件编程时，左边缘的代码应该是愉快路径。也就是说，不要嵌套<code>if</code>语句。多个<code>return</code>是允许的。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">someMethod</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">someOther</span> <span class="n">boolValue</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//Do something important</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">someMethod</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">([</span><span class="n">someOther</span> <span class="n">boolValue</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">//Do something important</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="异常处理"></a>异常处理</h2>

<p>当方法通过引用的方式返回一个错误参数，使用返回值进行判断，而不是那个错误参数。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">self</span> <span class="nl">trySomethingWithError:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// Handle Error</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span> <span class="nl">trySomethingWithError:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// Handle Error</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>一些Apple的API在成功的情况下向错误参数写入一些垃圾值，所以通过错误参数来判断会带来不良的影响。</p>

<h2><a name="单例"></a>单例</h2>

<p>单例对象生成共享实例时要注意线程安全。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">sharedInstance</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">id</span> <span class="n">sharedInstance</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">sharedInstance</span> <span class="o">=</span> <span class="p">[[</span><span class="n">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="n">sharedInstance</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这将避免一些<a href="http://cocoasamurai.blogspot.com/2011/04/singletons-your-doing-them-wrong.html">多线程下的应用崩溃</a>。</p>

<h2><a name="换行"></a>换行</h2>

<p>换行是一个重要的部分，本代码风格规则着重打印和在线的可读性。</p>

<p>例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">productsRequest</span> <span class="o">=</span> <span class="p">[[</span><span class="n">SKProductsRequest</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithProductIdentifiers:</span><span class="n">productIdentifiers</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>长代码的话，可以进行换行，在第二行开头遵照“空白”一节的规定，需要空两个空格。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">productsRequest</span> <span class="o">=</span> <span class="p">[[</span><span class="n">SKProductsRequest</span> <span class="n">alloc</span><span class="p">]</span>
</span><span class='line'>  <span class="nl">initWithProductIdentifiers:</span><span class="n">productIdentifiers</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="笑脸"></a>笑脸</h2>

<p>笑脸是raywenderlich.com站点代码风格的显著特征。使用正确的笑脸表现编程时巨大的喜悦和激动是很重要的。使用方括号笑脸，是因为它是使用ASCII能获得的最大的笑脸···。使用以圆括号结尾的笑脸会出现一个半心形，所以不被推荐···。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">:</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">:</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2><a name="Xcode工程"></a>Xcode工程</h2>

<p>物理文件结构和Xcode工程文件结构要保持一致。Xcode项目中的新建分组都要对应文件系统中的文件夹。代码不但要按类型，也要按特征来分组，保证结构更清晰。</p>

<p>可能的话，尽量打开&#8221;Treat Warnings as Errors&#8221;选项，如果你想忽略一个类型的警告，请查看<a href="http://clang.llvm.org/docs/UsersManual.html#controlling-diagnostics-via-pragmas">这里</a>。</p>

<h2>其他Objective-C的代码风格规范</h2>

<ul>
<li><a href="https://github.com/RobotsAndPencils/objective-c-style-guide">Robots &amp; Pencils</a></li>
<li><a href="https://github.com/NYTimes/objective-c-style-guide">New York Times</a></li>
<li><a href="http://google-styleguide.googlecode.com/svn/trunk/objcguide.xml">Google</a></li>
<li><a href="https://github.com/github/objective-c-conventions">GitHub</a></li>
<li><a href="https://trac.adium.im/wiki/CodingStyle">Adium</a></li>
<li><a href="https://gist.github.com/soffes/812796">Sam Soffes</a></li>
<li><a href="http://cocoadevcentral.com/articles/000082.php">CocoaDevCentral</a></li>
<li><a href="http://lukeredpath.co.uk/blog/my-objective-c-style-guide.html">Luke Redpath</a></li>
<li><a href="http://www.cimgf.com/zds-code-style-guide/">Marcus Zarra</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[调试利器-PonyDebugger]]></title>
    <link href="http://lucifer1988.github.io/blog/2014/03/03/diao-shi-li-qi-ponydebugger/"/>
    <updated>2014-03-03T15:12:01+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2014/03/03/diao-shi-li-qi-ponydebugger</id>
    <content type="html"><![CDATA[<p><img src="http://lucifer1988.github.io/images/ponyDebugger_icon.png"></p>

<p>PonyDebugger是git上一个利用Chrome开发者工具来进行iOS客户端远程调试的工具包，与其他远类型程调试工具相比，它有着非常IMBA且又非常实用的功能：网络活动监控、查看CoreData对象、视图层级查看等，下面让我们看看如何驾驭这只神奇的小马驹吧！</p>

<!--more-->


<h2>功能</h2>

<p>PonyDebugger提供了四个特色的功能，包括：监控网络、CoreData对象查看、视图分层查看和远程日志打印。</p>

<h3>监控网络</h3>

<p>所有通过NSURLConnection进行的网络访问，都会被监测到，也就是说那些基于NSURLConnection的第三方网络组件，如AFNetworking，都可以被监测到，而且看以方便的查看到：访问类型、接口名、错误类型，返回类型、网络延时等信息，非常强大！</p>

<p><img src="http://lucifer1988.github.io/images/ponyDebugger_Network.png"></p>

<h3>CoreData对象查看</h3>

<p>这个功能就不必多说了，你可能见过很多方便的sqlite工具，比如FireFox的SQLite Manager插件，但是这样直接查看CoreData对象的不多见吧？</p>

<p><img src="http://lucifer1988.github.io/images/ponyDebugger_CoreData.png"></p>

<h3>视图分层查看</h3>

<p>这个功能对于前端开发者来说是最重要不过了，PonyDebugger将你应用的视图关系以xml的形式分层展示出来，选择相应xml，会在客户端进行对应视图的高亮响应，xml的属性信息可以在客户端进行配置，而且竟然支持直接修改xml属性值，而客户端UI会实时做出改变！</p>

<p><img src="http://lucifer1988.github.io/images/ponyDebugger_ViewHierarchy.png"></p>

<h3>远程日志打印</h3>

<p>这个可能你觉得没什么亮点，上次介绍的NSLogger可是专门做这件事的，不过PonyDebugger的这一功能也不会让你失望，它的语句类型不多，主要分为<code>PDLog()</code>和<code>PDLogObjects()</code>，<code>PDLog()</code>负责打印字符串信息，<code>PDLogObjects()</code>负责打印对象和数组。不过正如下图所示，<code>PDLogObjects()</code>打印出的对象也是分层展示的，比如查看一个数组中自定义modal对象的一个属性的值这样的事情就非常轻松，而且不用你再回Xcode中加断点，这是不很爽啊！</p>

<p><img src="http://lucifer1988.github.io/images/ponyDebugger_Console.png"></p>

<h2>配置</h2>

<p>配置工作包括配置服务器端和客户端。</p>

<h3>配置服务器端</h3>

<ul>
<li>安装Xcode&rsquo;s Command Line Tools，在之前的版本中可直接在Xcode中安装，如果你的环境更新到10.9和Xcode5之后，不妨参考<a href="http://ourcoders.com/thread/show/1208/">这里</a>进行安装，这是之前10.9更新CocoaPods时发现的一个问题。</li>
<li>在终端执行以下命令，进行安装</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -sk https://cloud.github.com/downloads/square/PonyDebugger/bootstrap-ponyd.py | \
</span><span class='line'>  python - --ponyd-symlink=/usr/local/bin/ponyd ~/Library/PonyDebugger</span></code></pre></td></tr></table></div></figure>


<p>注：如果在安装过程中报出如下错误：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>···
</span><span class='line'>  Running setup.py (path:/Users/user/Library/PonyDebugger/build/tornado/setup.py) egg_info for package tornado
</span><span class='line'>
</span><span class='line'>    warning: no previously-included files matching '_auto2to3*' found anywhere in distribution
</span><span class='line'>Downloading/unpacking pybonjour (from ponydebugger)
</span><span class='line'>  Could not find any downloads that satisfy the requirement pybonjour (from ponydebugger)
</span><span class='line'>  Some externally hosted files were ignored (use --allow-external pybonjour to allow).
</span><span class='line'>Cleaning up...</span></code></pre></td></tr></table></div></figure>


<p>可以参考<a href="https://github.com/square/PonyDebugger/issues/100">这里</a>的解决方法，在我安装的过程中也遇到了这个问题，按照提示是<code>pip</code>安装时没有配置<code>--allow-external pybonjour --allow-unverified pybonjour</code>。</p>

<ul>
<li>成功安装后，在终端输入<code>ponyd serve --listen-interface=127.0.0.1</code>，打开监听。</li>
<li>最后打开浏览器，输入地址<code>http://localhost:9000</code>，如果访问到如下结果，说明安装成功。</li>
</ul>


<p><img src="http://lucifer1988.github.io/images/ponyDebugger_install.png"></p>

<h3>配置客户端</h3>

<p>由于现在PonyDebugger支持CocoaPods安装了，可以直接在你的podfile中加入：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod 'PonyDebugger'</span></code></pre></td></tr></table></div></figure>


<p>然后，安装一下就可以了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod install</span></code></pre></td></tr></table></div></figure>


<p>不了解CocoaPods的童鞋可以参考下唐巧大哥的<a href="http://blog.devtang.com/blog/2012/12/02/use-cocoapod-to-manage-ios-lib-dependency/">这篇介绍</a>，希望手动加入PonyDebugger的童鞋可以参考<a href="https://github.com/square/PonyDebugger">官方文档</a>中Manual Installation一项。</p>

<h2>使用</h2>

<p>相比起搭建环境，PonyDebugger的使用非常简单。你需要在你应用的<code>AppDelegate.m</code>的<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {}</code>方法中加入以下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PDDebugger *debugger = [PDDebugger defaultInstance];
</span><span class='line'>//设置网络监控
</span><span class='line'>[debugger enableNetworkTrafficDebugging];
</span><span class='line'>[debugger forwardAllNetworkTraffic];
</span><span class='line'>//通过TCP连接至服务端
</span><span class='line'>[debugger connectToURL:[NSURL URLWithString:@"ws://localhost:9000/device"]];
</span><span class='line'>// 也可通过bonjour自动连接
</span><span class='line'>//[debugger autoConnect];
</span><span class='line'>// 或连接至指定bonjour服务
</span><span class='line'>//[debugger autoConnectToBonjourServiceNamed:@"MY PONY"];
</span><span class='line'>//设置CoreData监控
</span><span class='line'>[debugger enableCoreDataDebugging];
</span><span class='line'>[debugger addManagedObjectContext:self.managedObjectContext withName:@"TIME Test MOC"];
</span><span class='line'>//设置视图分层监控
</span><span class='line'>[debugger enableViewHierarchyDebugging];
</span><span class='line'>[debugger setDisplayedViewAttributeKeyPaths:@[@"frame", @"hidden", @"alpha", @"opaque", @"accessibilityLabel", @"text"]];
</span><span class='line'>//设置远程日志打印
</span><span class='line'>[debugger enableRemoteLogging];</span></code></pre></td></tr></table></div></figure>


<h2>小结</h2>

<p>本文可以作为<code>PonyDebugger</code>一个入门级的文档。相比上一次介绍的<code>NSLogger</code>来说，<code>PonyDebugger</code>的展示方式和查看方式更加直观和方便，作为通用的调试工具非常不错，而<code>NSLogger</code>拥有强大的日志记录功能，但想要发挥<code>NSLogger</code>的作用，对程序员的经验和能力就有了一定的要求，所以两种工具各有千秋，大家各取所需就好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[强力的日志分析工具-NSLogger]]></title>
    <link href="http://lucifer1988.github.io/blog/2014/02/25/qiang-li-de-ri-zhi-fen-xi-gong-ju-nslogger/"/>
    <updated>2014-02-25T17:00:29+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2014/02/25/qiang-li-de-ri-zhi-fen-xi-gong-ju-nslogger</id>
    <content type="html"><![CDATA[<blockquote><p>NSLogger出现了，在Florent Pillet的打造下，一个开源强力的输出工具给了log这一古老的工作崭新的生命。标签输出，优先级查找，直接输出图像，多线程标记，时序控制，甚至是通过网络log到别人的终端或者是从别人的终端程序中记录log。在这里，只有想不到没有做不到，堪称是史上最为强大的logger。<br/>
<p align="right">&mdash;OneV&rsquo;s Den</p></p></blockquote>

<p>NSLogger是一款强力的日志记录和分析工具，其强大的功能，可以完全替代Xcode自带的Debugger，本文将介绍一些其主要特点和用法。git地址：<a href="https://github.com/fpillet/NSLogger">https://github.com/fpillet/NSLogger</a></p>

<!--more-->


<h2>安装</h2>

<p>NSLogger由两部分组成，一是需要加入工程中的组件代码，二是查看和管理日志的Mac客户端。组件代码可通过CocoaPods安装，也可通过手动添加（手动添加需要引入CFNetwok.framework和SystemConfiguration.framework）。Mac客户端NSLoggerViewer的源码包含在了组件当中，可以自己生成，也可以<a href="http://doruby.com/assets/NSLoggerViewer.zip">点击这里</a>下载生成好的客户端，NSLoggerViewer实际运行图：</p>

<p><img src="http://lucifer1988.github.io/images/NSLoggerViewer.png"></p>

<!--more-->


<h2>特点</h2>

<ul>
<li>标签输出</li>
<li>自定义优先级</li>
<li>直接输出图片</li>
<li>多线程标记</li>
<li>时序控制</li>
<li>远程记录</li>
</ul>


<!--more-->


<h2>配置</h2>

<p>首先要将LoggerClient.h头文件import进来，通过LoggerSetOptions()配置Logger的一些属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum {
</span><span class='line'>  kLoggerOption_LogToConsole               = 0x01,
</span><span class='line'>  kLoggerOption_BufferLogsUntilConnection  = 0x02,
</span><span class='line'>  kLoggerOption_BrowseBonjour              = 0x04,
</span><span class='line'>  kLoggerOption_BrowseOnlyLocalDomain      = 0x08,
</span><span class='line'>  kLoggerOption_UseSSL                     = 0x10,
</span><span class='line'>  kLoggerOption_CaptureSystemConsole       = 0x20
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>void LoggerSetOptions(Logger *logger, uint32_t flags);</span></code></pre></td></tr></table></div></figure>


<p>一般使用默认Logger，第一个参数传入NULL就行，至于第二个参数主要是一些功能开关选项，将需要开启的功能相或后作为第二个参数即可，详细参数说明<a href="https://github.com/fpillet/NSLogger/wiki/NSLogger-API">点击</a>，实例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> LoggerSetOptions(NULL,                  
</span><span class='line'>                   kLoggerOption_BufferLogsUntilConnection |
</span><span class='line'>                   kLoggerOption_UseSSL |
</span><span class='line'>                   kLoggerOption_CaptureSystemConsole|
</span><span class='line'>                   kLoggerOption_BrowseBonjour|
</span><span class='line'>                   kLoggerOption_BrowseOnlyLocalDomain : 0));</span></code></pre></td></tr></table></div></figure>


<p>NSLogger支持TCP和Bonjour两种方式连接终端设备，Bonjour连接一般不需要配置，如果要是使用TCP连接，要通过LoggerSetViewerHost()配置IP地址和端口（同时需配置NSLoggerViewer，在Preferences的Network中，勾选 “Listen for loggers on TCP port”打开监听）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void LoggerSetViewerHost(Logger *aLogger, CFStringRef host, UInt32 port);</span></code></pre></td></tr></table></div></figure>


<p>同样，使用默认Logger，第一参数传NULL，实例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LoggerSetViewerHost(NULL, (__bridge CFStringRef)@"192.168.11.38", (UInt32)50000);</span></code></pre></td></tr></table></div></figure>


<p>以上代码放到<code>- (void)applicationDidFinishLaunching:(UIApplication *)application</code>统一配置。</p>

<!--more-->


<h2>使用</h2>

<p>使用NSLogger基本方法和NSLog并无本质差别，只是开发者可以添加一些标签和级别参数，以供NSLoggerViewer端的日志过滤。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void LogMessage(NSString *tag, int level, NSString *format, ...);</span></code></pre></td></tr></table></div></figure>


<p>同时也支持添加文件名、方法名、行号、变量名等参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void LogMessageF(const char *file, int line, const char *function, NSString *tag, int level, NSString *format, ...);
</span><span class='line'>void LogMessage_va(NSString *tag, int level, NSString *format, va_list args);</span></code></pre></td></tr></table></div></figure>


<p>NSLogger支持直接打印二进制数据：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void LogData(NSString *tag, int level, NSData *data);
</span><span class='line'>void LogDataF(const char *file, int line, const char *function, NSString *tag, int level, NSData *data);</span></code></pre></td></tr></table></div></figure>


<p>NSLogger最大的优点，支持直接打印图片，而且可以指定打印图片的大小：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void LogImageData(NSString *tag, int level, int width, int height, NSData *data);
</span><span class='line'>void LogImageDataF(const char *file, int line, const char *function, NSString *tag, int level, int width, int height, NSData *data);</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Tips</h2>

<ul>
<li>直接使用默认打印函数过于繁琐，可结合需求自己定义宏来定义打印方法：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#ifdef DEBUG
</span><span class='line'>#define LOG_NETWORK(level, ...) LogMessageF(FILE,LINE,FUNCTION,"network",level,__VA_ARGS__) 
</span><span class='line'>#define LOG_GENERAL(level, ...) LogMessageF(__FILE__,__LINE__,__FUNCTION__,“general”,level,VA_ARGS)
</span><span class='line'>#define LOG_GRAPHICS(level, ...) LogMessageF(FILE,LINE,FUNCTION,@"graphics",level,VA_ARGS)
</span><span class='line'>#define LOG_TRACE(...) LogMessageF( __FILE__,__LINE__,__FUNCTION__, NULL, 0, __VA_ARGS__)
</span><span class='line'>#else
</span><span class='line'>#define LOG_NETWORK(...) do{}while(0)
</span><span class='line'>#define LOG_GENERAL(...) do{}while(0)
</span><span class='line'>#define LOG_GRAPHICS(...) do{}while(0)
</span><span class='line'>#define LOG_TRACE(...) do{}while(0)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>如果程序启动后，没有数据发送到NSLoggerViewer，可以先clean一下。</li>
<li>通过NSLoggerViewer当中Tools功能下<code>Add Mark</code>(<strong>Cmd-M</strong>)可以在日志列表底部快速添加一个时间戳标记，而使用<code>Add Mark With Title</code>(<strong>shift-Cmd-M</strong>)可以添加自定义标题的标记，通过这些标记将日志按照需要进行分块。<br/>
<img src="http://lucifer1988.github.io/images/NSLoggerViewer_Marker.png"></li>
</ul>


<h2>总结</h2>

<p>本文介绍了NSLogger的一些基本用法和技巧，以后还会介绍一些其他的调试工具，不过个人感觉工具再好，不能真正结合自己的项目用起来，也没有太大意义，所以还是在平时能多去试试这些工具，这样才能利用到它们为我们真正做一些事情。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown入门级教程]]></title>
    <link href="http://lucifer1988.github.io/blog/2014/02/14/markdownru-men-ji-jiao-cheng/"/>
    <updated>2014-02-14T18:53:31+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2014/02/14/markdownru-men-ji-jiao-cheng</id>
    <content type="html"><![CDATA[<blockquote><p>Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）和亚伦·斯沃茨（Aaron Swartz）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。这种语言吸收了很多在电子邮件&#8221;中已有的纯文本标记的特性。</p></blockquote>

<p>Markdown语法简洁明了、学习成本低、而且与HTML完美兼容，所以成为了Bloger们的最爱，当下主流的博客平台Octopress、WordPress等都推荐使用Markdown。本文将介绍一些基本的Markdown语法规则，仅作入门之用。</p>

<!--more-->


<h2>语法</h2>

<p>语法介绍的格式将采取上面代码，下面实际效果的格式，方便查看。</p>

<h3>1、换行和分割线</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>单个回车
</span><span class='line'>不能换行
</span><span class='line'>
</span><span class='line'>行尾添加两个空格，这里-&gt;
</span><span class='line'>可以强制换行
</span><span class='line'>
</span><span class='line'>连续回车
</span><span class='line'>
</span><span class='line'>可以分段
</span><span class='line'>
</span><span class='line'>要生成水平分割线，可以在单独一行里输入3个或以上的短横线、星号或者下划线实现。短横线和星号之间可以输入任意空格。以下每一行都产生一条水平分割线。
</span><span class='line'>* * *
</span><span class='line'>*****
</span><span class='line'>---------------------------------------</span></code></pre></td></tr></table></div></figure>


<p>单个回车
不能换行</p>

<p>行尾添加两个空格，这里-><br/>
可以换行</p>

<p>连续回车</p>

<p>可以分段</p>

<p>要生成水平分割线，可以在单独一行里输入3个或以上的短横线、星号或者下划线实现。短横线和星号之间可以输入任意空格。以下每一行都产生一条水平分割线。</p>

<hr />

<hr />

<hr />

<h3>2、标题</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#一级标题
</span><span class='line'>##二级标题
</span><span class='line'>###···
</span><span class='line'>######最小六级标题</span></code></pre></td></tr></table></div></figure>


<h1>一级标题</h1>

<h2>二级标题</h2>

<h3>···</h3>

<h6>最小六级标题</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>另一种一级标题写法
</span><span class='line'>=
</span><span class='line'>另一种二级标题写法
</span><span class='line'>-</span></code></pre></td></tr></table></div></figure>


<h1>另一种一级标题写法</h1>

<h2>另一种二级标题写法</h2>

<h3>3、强调和引用</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*注意* 或 _注意_ （斜体强调）  
</span><span class='line'>**注意** 或 __注意__ （粗体强调）  
</span><span class='line'>***注意*** 或 ___注意___ （斜粗体强调）  </span></code></pre></td></tr></table></div></figure>


<p><em>注意</em> 或 <em>注意</em> （斜体强调）<br/>
<strong>注意</strong> 或 <strong>注意</strong> （粗体强调）<br/>
<strong><em>注意</em></strong> 或 <strong><em>注意</em></strong> （斜粗体强调）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;引用只需要在被引用的内容段落开头加上右尖括号('&gt;')即可。
</span><span class='line'>你可以选择只在开头加一个。
</span><span class='line'>也可以在每行前面都加一个，效果是一样的。</span></code></pre></td></tr></table></div></figure>


<blockquote><p>引用只需要在被引用的内容段落开头加上右尖括号(&lsquo;>&rsquo;)即可。
你可以选择只在开头加一个。
也可以在每行前面都加一个，效果是一样的。</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; 嵌套引用：这是一个引用。这是第一行。  
</span><span class='line'>这是第二行。
</span><span class='line'>&gt;&gt; 这是一个嵌套的引用。这是第一行。  
</span><span class='line'>这是第二行。
</span><span class='line'>&gt; 
</span><span class='line'>&gt; 外层引用的第三行。前面需要一个视觉上的空行表示内层嵌套的结束，空行前面的('&gt;')可有可无。</span></code></pre></td></tr></table></div></figure>


<blockquote><p>嵌套引用：这是一个引用。这是第一行。<br/>
这是第二行。</p>

<blockquote><p>这是一个嵌套的引用。这是第一行。<br/>
这是第二行。</p></blockquote>

<p>外层引用的第三行。前面需要一个视觉上的空行表示内层嵌套的结束，空行前面的(&lsquo;>&rsquo;)可有可无。</p></blockquote>

<h3>4、列表</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>* 无序列表的一项（*也可用+或-代替，\*后要有一个空格）
</span><span class='line'>  * 嵌套列表子项，要以一个制表符或者4个空格缩进
</span><span class='line'>      * 最多支持三级嵌套缩进
</span><span class='line'>* 无序列表的另一项</span></code></pre></td></tr></table></div></figure>


<ul>
<li>无序列表的一项（*也可用+或-代替，*后要有一个空格）

<ul>
<li>嵌套列表子项，要以一个制表符或者4个空格缩进

<ul>
<li>最多支持三级嵌套缩进</li>
</ul>
</li>
</ul>
</li>
<li>无序列表的另一项</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1. 有序列表项目1（同样标识符与内容间有空格）
</span><span class='line'>2. 有序列表项目2
</span><span class='line'>3. 有序列表项目3</span></code></pre></td></tr></table></div></figure>


<ol>
<li>有序列表项目1（同样标识符与内容间有空格）</li>
<li>有序列表项目2</li>
<li>有序列表项目3</li>
</ol>


<h3>5、代码片段</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//行的开头空4个空格，表示程序代码（或者用两段```包起来，可显示行号）
</span><span class='line'>int main(int argc, const char * argv[])
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>    @autoreleasepool {
</span><span class='line'>
</span><span class='line'>        NSLog(@"Hello, World!");
</span><span class='line'>    }
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>6、链接和图片</h3>

<pre><code>直接标注链接：&lt;http://www.baidu.com&gt;  
链接文字：[百度](http://www.baidu.com)  
索引方式链接文字：[百度][1]  
图像和链接非常类似，区别在开头加一个惊叹号：![百度情人节Logo](http://www.baidu.com/img/pc270x119_16f8c8283f357d242afa2d432c051d44.gif)  
也可以使用索引方式：![百度情人节Logo][2]  
另：引用本地图片：&lt;img src="http://lucifer1988.github.io/images/baidu_lover'sDay.gif"&gt;

[1]:http://www.baidu.com
[2]:http://www.baidu.com/img/pc270x119_16f8c8283f357d242afa2d432c051d44.gif
</code></pre>

<p>直接标注链接：<a href="http://www.baidu.com">http://www.baidu.com</a><br/>
链接文字：<a href="http://www.baidu.com">百度</a><br/>
索引方式链接文字：<a href="http://www.baidu.com">百度</a> <br/>
图像和链接非常类似，区别在开头加一个惊叹号：<img src="http://www.baidu.com/img/pc270x119_16f8c8283f357d242afa2d432c051d44.gif" alt="百度情人节Logo" /> <br/>
也可以使用索引方式：<img src="http://www.baidu.com/img/pc270x119_16f8c8283f357d242afa2d432c051d44.gif" alt="百度情人节Logo" /><br/>
另：引用本地图片：<img src="http://lucifer1988.github.io/images/baidu_lover'sDay.gif"></p>

<!--more-->


<h2>编辑器</h2>

<p>Mac环境下推荐使用<a href="http://mouapp.com">Mou</a>，一个Mac平台上轻量级的Markdown编辑器，非常好用！</p>

<!--more-->


<h2>进一步学习</h2>

<p>如果你想深入学习下Markdown语法，可参考以下内容：<br/>
<a href="http://wowubuntu.com/markdown/index.html">http://wowubuntu.com/markdown/index.html</a><br/>
<a href="http://www.ituring.com.cn/article/504">http://www.ituring.com.cn/article/504</a></p>

<p><em>PS:当天是情人节加元宵节，祝我女朋友晓莉永远美丽漂亮，天天开心快乐，愿我们能幸福相伴一生！</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于Octopress搭建自己的博客网站]]></title>
    <link href="http://lucifer1988.github.io/blog/2014/02/13/hello-world-octopressfa-bu-wen-zhang-bu-zou/"/>
    <updated>2014-02-13T01:19:13+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2014/02/13/hello-world-octopressfa-bu-wen-zhang-bu-zou</id>
    <content type="html"><![CDATA[<p>本文将介绍当前主流的一个基于git的博客管理工具：<a href="http://octopress.org/">Octopress</a>，它是利用<a href="https://github.com/jekyll/jekyll">Jekyll</a>博客引擎开发的一个博客系统，生成的页面可以利用github page来展现，大致原理是利用git来管理你的博客文章，然后发布到github上成为独立博客站点。本博客就是基于Octopress搭建的。</p>

<!--more-->


<h2>安装</h2>

<p>安装Octopress的详细步骤在其官方文档有详细说明，地址是<a href="http://octopress.org/docs/setup/">http://octopress.org/docs/setup/</a>，这里只列一下大致步骤：</p>

<h3>安装Ruby</h3>

<p>Mac环境下一般是自带Ruby的，不过你需要注意下Ruby的版本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ruby --version</span></code></pre></td></tr></table></div></figure>


<p>如果低于1.9.3，那么就需要更新：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rvm install 1.9.3
</span><span class='line'>rvm use 1.9.3
</span><span class='line'>rvm rubygems latest</span></code></pre></td></tr></table></div></figure>


<h3>安装Octopress</h3>

<p>确保Ruby环境OK后，继续安装Octopress，先从git上clone其代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git://github.com/imathis/octopress.git octopress
</span><span class='line'>cd octopress    # If you use RVM, You'll be asked if you trust the .rvmrc file (say yes).
</span><span class='line'>ruby --version  # Should report Ruby 1.9.3</span></code></pre></td></tr></table></div></figure>


<p>继续安装依赖项：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem install bundler
</span><span class='line'>rbenv rehash    # If you use rbenv, rehash to be able to run the bundle command
</span><span class='line'>bundle install</span></code></pre></td></tr></table></div></figure>


<p>最后一步：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake install</span></code></pre></td></tr></table></div></figure>


<h3>一些配置工作</h3>

<p>安装好后要进行一些配置工作：</p>

<ul>
<li>修改_config.yml中有关博客名，作者名之类的信息，填写git上对应的仓库url（见下一小节）。</li>
<li>删去_config.yml中twitter相关的信息，否则由于GFW的原因，将会造成页面load很慢。</li>
<li>修改定制文件/source/_includes/custom/head.html 把google的自定义字体去掉，原因同上。</li>
</ul>


<p>注：在修改_config.yml时注意，所有的键值格式都是类似<code>title: 刘毅的技术博客</code>，即<code>:</code>后是有个空格的，如果在修改时不慎删去，可能在<code>rake generate</code>出现类似这样的问题：<a href="http://stackoverflow.com/questions/10086806/i-can-not-do-any-modify-after-octopress-installed/13898285#13898285">http://stackoverflow.com/questions/10086806/i-can-not-do-any-modify-after-octopress-installed/13898285#13898285</a>，在这里提醒下各位。</p>

<p>更进一步的配置参见：<a href="http://octopress.org/docs/configuring/">http://octopress.org/docs/configuring/</a></p>

<!--more-->


<h2>部署</h2>

<p>我们利用<a href="http://pages.github.com">Github Pages</a>来托管博客。</p>

<p>首先，你需要在github上创建一个新的仓库，命名方式是username.github.io，这就是上一步需要填写的url，也是将来博客地址的域名。</p>

<p>创建好仓库之后，需要在octopress文件夹下运行rake命令来部署git仓库，期间需要输入你的仓库地址：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake setup_github_pages</span></code></pre></td></tr></table></div></figure>


<p>然后生成博客内容，并部署到仓库，这也是每次编辑好新博客后需要做的事：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate
</span><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<p>现在已经就可以在<code>http://username.github.io</code>访问到新的博客内容了，不过octopress的source部分更新需要手动提交：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add .
</span><span class='line'>git commit -m 'your commit words'
</span><span class='line'>git push origin source </span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>写博客</h2>

<p>上面都完成之后，写博客要做的事就很easy了，首先依然需要rake命令new一个新博客文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_post["你的文章名"]</span></code></pre></td></tr></table></div></figure>


<p>命名支持中英文，会在source/_posts/下生成一个markdown文件，抬头是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>layout: post
</span><span class='line'>title: "基于Octopress搭建自己的博客网站"
</span><span class='line'>date: 2014-02-12 17:19:13
</span><span class='line'>comments: true
</span><span class='line'>published: false
</span><span class='line'>categories: BlogBasics</span></code></pre></td></tr></table></div></figure>


<p>这里的published: false字段是我自己添加的，它置为false的作用是即使你部署这篇博客到git上，也不会被访问到，这可以满足你在彻底完成并润色好文章之后再发布的需要。另外，这里文章的编辑使用markdown语法，我会在之后写一篇博客介绍下的。</p>

<p>现在假设你精心撰写的文章已经OK了，那么就将它发布吧：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate
</span><span class='line'>git add .
</span><span class='line'>git commit -m "Some comment here." 
</span><span class='line'>git push origin source
</span><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<p>现在你应该已经能访问到你的新博客了，如果需要在部署之前先本地预览下博客，可以在终端输入：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake preview</span></code></pre></td></tr></table></div></figure>


<p>然后在本地浏览器访问：<code>http://localhost:4000/</code>预览你的博客。</p>

<!--more-->


<h2>高级配置</h2>

<p>因为Octopress自带的Disqus Comments评论系统比较慢，所以你可以选择国内的评论和分享系统，本博客分享系统用的是<a href="http://www.jiathis.com">加网</a>，评论系统用的是<a href="http://www.uyan.cc">友言</a>，具体步骤是：</p>

<ul>
<li>增加文件：source/_includes/post/weibo.html</li>
<li>访问 <a href="http://www.jiathis.com/">http://www.jiathis.com/</a>，获取分享的代码</li>
<li>访问 <a href="http://uyan.cc/">http://uyan.cc/</a>，获得评论的代码</li>
<li>将上面2步获得的代码都加入weibo.html中即可</li>
</ul>


<!--more-->


<h2>参考</h2>

<p>我的博客搭建和这篇文章的完成主要参考了Octopress官方文档和<a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/">唐巧</a>、<a href="http://beyondvincent.com/blog/2013/08/03/108-creating-a-github-blog-using-octopress/">破船</a>的相关教程，他们都是我很尊敬的iOS开发者，可以多多关注他们，一定会受益匪浅！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2013总结&2014规划]]></title>
    <link href="http://lucifer1988.github.io/blog/2014/01/02/2013-summary-and-2014-plan/"/>
    <updated>2014-01-02T11:40:00+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2014/01/02/2013-summary-and-2014-plan</id>
    <content type="html"><![CDATA[<blockquote><p>2013可以说是自己人生的一个转折点，经历了很多，也成长了很多。过去的终究会过去，人生还得继续向前，希望从这一刻起开始记录自己的工作和生活，并能一直坚持下去！</p></blockquote>

<h2>过去的2013</h2>

<p>2013的我正式步出校园，走向了社会，但这第一步走的就异常坎坷。</p>

<h3>时间轴</h3>

<ul>
<li>1月份进入盘古实习，认识了新的同事并开始接触企业级的App的开发流程</li>
<li>3月份会学校写论文，5月答辩，之后和女朋友去了上海、杭州毕业旅行</li>
<li>6月份回到公司，得知公司欲与即刻合并，开始纠结去留</li>
<li>7月份和女朋友订婚，双方父母都来京了，虽然闹了些不愉快，自己还是决定和她一直走下去</li>
<li>8月份终于入职，自己决定留下，但是户口没有解决</li>
<li>9月份女朋友从百度跳到了人寿研发，解决了户口，两个人还是安心了些</li>
<li>10月份起开始经历公司各种变化，折腾到最后自己还是选择了老本行，选择了移动搜索事业部</li>
<li>十一回了趟家，感觉见父母的时间明显少了好多</li>
<li>11月开始和女朋友看房，见识到了帝都的房价</li>
<li>期间做了一些组件和工具类app的开发，但是由于公司变故，没有参与大型的企业级App，很遗憾</li>
<li>12月底说好的新公司仍没成立</li>
</ul>


<h3>关于工作</h3>

<ul>
<li>开始经常使用git，遇到问题会去stackOverflow看看</li>
<li>开始学习CocoaTouch SDK的机制运行的原理</li>
<li>写代码的时候开始注意实现和效率两方面</li>
<li>对设计模式开始关注</li>
<li>开始记录自己积累的一些开发经验，但没有自己的总结</li>
<li>接触了一些Web开发的皮毛</li>
<li>完成了两个iOS的小型项目</li>
<li>从实验室赶工式的开发思维开始向企业级的开发思维转变</li>
</ul>


<h3>关于生活</h3>

<ul>
<li>和晓莉同学结束1年的爱情短跑，两人订婚</li>
<li>买了土豪金，买了小米2S（给女友），买了高配台式机，挣得第一桶金做了这些</li>
<li>中午时间和同事打乒乓球，重拾儿时爱好</li>
<li>每天会玩几盘Dota2，但是技术还是那样</li>
<li>会常常去关注下房价，开始为买房发愁</li>
</ul>


<h2>要来的2014</h2>

<p>如果2013的关键字是“变化”，“适应”的话，我希望2014的关键字是“成熟”，“责任”</p>

<h3>个人能力目标</h3>

<ul>
<li>每周至少写一篇技术Blog，长短不限，但是必须是自己收到的干货</li>
<li>每月至少在gitHub提交一份代码，可以是小工程，也可以是组件，但必须是自己原创</li>
<li>看两本iOS中高级开发的书籍</li>
<li>上半年业余时间完成Web开发的基础学习，目标是完成一个小型网站的搭建</li>
<li>下半年业余时间完成Android开发的基础学习，目标是给女友手机装一个自己开发的App</li>
<li>能参与至少一个企业级App的开发过程</li>
<li>遇到难解决的问题主动找冬哥、景雲、张玺讨论，力求改变自己在技术上不太Open的性格</li>
</ul>


<h3>个人生活目标</h3>

<ul>
<li>完成自己终生大事，和晓莉同学结婚</li>
<li>坚持定期锻炼身体</li>
<li>继续看房，争取上半年买房</li>
<li>给女朋友买新版iPad，要她不再怨恨我的土豪金</li>
<li>出去旅行一次</li>
<li>每天最多玩两盘Dota</li>
</ul>


<p>最后，希望今年的目标能全部实现吧！2013，谢谢父母的支持，女朋友的陪伴，朋友们的帮助，也谢谢同事们对我这个职场新人的包容和悉心指导，真心希望2014能和大家共同实现各自的目标，谢谢大家！</p>
]]></content>
  </entry>
  
</feed>
