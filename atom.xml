<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[刘毅的技术博客]]></title>
  <link href="http://lucifer1988.github.io/atom.xml" rel="self"/>
  <link href="http://lucifer1988.github.io/"/>
  <updated>2015-11-26T16:56:08+08:00</updated>
  <id>http://lucifer1988.github.io/</id>
  <author>
    <name><![CDATA[刘毅]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Swift and Cocoa]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/25/swift-by-tutorials-swift-and-cocoa/"/>
    <updated>2015-11-25T11:20:10+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/25/swift-by-tutorials-swift-and-cocoa</id>
    <content type="html"><![CDATA[<p>Swift是一门新推出的语言，但是核心框架还是Cocoa，这与OC是一致的，Cocoa的Foundation和UIKit框架对于开发应用仍是最重要的。这一章将创建一个应用，主要介绍Swift一Cocoa直接的交互，同时了解Cocoa的设计模式如何在Swift中体现出来。</p>

<!--more-->


<h2>Getting started</h2>

<p>作者提供了一个starter project，添加了一个viewcontroller和之前介绍的JSON.swift（帮助解析JSON的工具类），另外还有facebook的SDK，所以接下来会介绍如何在Swift中混用OC代码。</p>

<h2>Bridging Swift and Objectivec-C</h2>

<p>通过<strong>bridging</strong>技术，可以让我们在Swift和OC间相互调用。</p>

<h3>Swift bridging header</h3>

<p>新建一个OC的.h文件，如：CafeHunter-ObjCBridging.h，然后在<strong>Build Settings</strong>中找到<strong>Objective-C Bridging Header</strong>，填写该头文件的路径，如：CafeHunter/CafeHunter-ObjCBridging.h，然后可以在该头文件中添加所需的OC头文件，如下，这样就可以在Swift中使用OC的类和方法了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="cp">#import &lt;FacebookSDK/FacebookSDK.h&gt;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">FBSettings</span><span class="p">.</span><span class="n">setDefaultAppID</span><span class="p">(</span><span class="s">&quot;INSERT_YOUR_FB_APP_ID&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Objective-C compatibility header</h3>

<p>那么如何在OC中使用Swift代码呢？还记得刚才在<strong>Build Settings</strong>中找到的<strong>Objective-C Bridging Header</strong>上面的<strong>Install Objective-C Compatibility Header</strong>吗？该项就是控制Swift向OC转换的开关，默认是打开的。</p>

<p>在report navigation的Build，中可以找到<strong> Copy CafeHunter-Swift.h</strong>的信息，可以双击打开该文件，你会发现你用Swift中创建的继承于OC的类和方法都在这里有对应的OC代码，而且实际上还有用@objec标记的代码，也有对应的转化。需要注意的两点是：</p>

<ol>
<li>Swift中的私有方法是没有转化的，因为理论上外部不可能使用私有方法，但私有方法仍会注册在runtime中。</li>
<li>转化的代码每个类之前会有一行类似<strong>SWIFT_CLASS(&ldquo;_TtC10CafeHunter11AppDelegate&rdquo;)</strong>的代码，实际上是Swift的压缩命名，为每个类添加了命名空间，也是该类在runtime中实际的名字，即使不同库中有相同名类，编译器也会通过该类名，准确找到对应的类。</li>
</ol>


<h2>Adding the UI</h2>

<p>添加一个FaceBook的登录View和MKMapView到Storybiard，然后关联到代码，如下。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="err">@</span><span class="kt">IBOutlet</span> <span class="n">weak</span> <span class="n">var</span> <span class="nl">mapView:</span> <span class="n">MKMapView</span><span class="o">!</span>
</span><span class='line'><span class="err">@</span><span class="kt">IBOutlet</span> <span class="n">weak</span> <span class="n">var</span> <span class="nl">loginView:</span> <span class="n">FBLoginView</span><span class="o">!</span>
</span></code></pre></td></tr></table></div></figure>


<p>有几点说明：</p>

<ol>
<li>outlet的类型是optional的，而且是隐式拆解的，这是因为如果不这么设置，编译器会发现这些变量没有在初始化中赋值，从而报错，所以这是为了避免编译器报错的手段，但我们知道它会在IB中初始化，所以采用了隐式拆解。使用outlet时不用再去拆解，但同时需要注意在view加载之前调用它们会导致崩溃，这点需要谨记。</li>
<li>outlet被加了weak关键字，这和OC中是一致的，是因为viewController的view对outlet是有强引用的，所以不必再添加额外的强引用。</li>
</ol>


<h3>Showing the user&rsquo;s location</h3>

<p>在Swift中长把协议的实现放在单独的extension中，这样可以将代码分组，但依然可以访问原类的变量和方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">extension</span> <span class="nl">ViewController:</span> <span class="n">MKMapViewDelegate</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">func</span> <span class="n">mapView</span><span class="p">(</span><span class="nl">mapView:</span> <span class="n">MKMapView</span><span class="p">,</span> <span class="n">didFailToLocateUserWithError</span> <span class="nl">error:</span> <span class="n">NSError</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">alert</span> <span class="o">=</span> <span class="n">UIAlertController</span><span class="p">(</span><span class="nl">title:</span> <span class="s">&quot;Error&quot;</span><span class="p">,</span> <span class="nl">message:</span> <span class="s">&quot;Failed to obtain location!&quot;</span><span class="p">,</span> <span class="nl">preferredStyle:</span> <span class="p">.</span><span class="n">Alert</span><span class="p">)</span>
</span><span class='line'>    <span class="n">alert</span><span class="p">.</span><span class="n">addAction</span><span class="p">(</span><span class="n">UIAlertAction</span><span class="p">(</span><span class="nl">title:</span> <span class="s">&quot;OK&quot;</span><span class="p">,</span> <span class="nl">style:</span> <span class="p">.</span><span class="n">Default</span><span class="p">,</span> <span class="nl">handler:</span> <span class="nb">nil</span><span class="p">))</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">presentViewController</span><span class="p">(</span><span class="n">alert</span><span class="p">,</span> <span class="nl">animated:</span> <span class="n">true</span><span class="p">,</span> <span class="nl">completion:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">func</span> <span class="n">mapView</span><span class="p">(</span><span class="nl">mapView:</span> <span class="n">MKMapView</span><span class="p">,</span> <span class="n">didUpdateUserLocation</span> <span class="nl">userLocation:</span> <span class="n">MKUserLocation</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">newLocation</span> <span class="o">=</span> <span class="n">userLocation</span><span class="p">.</span><span class="n">location</span><span class="o">!</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">lastLoction</span><span class="o">?</span><span class="p">.</span><span class="n">distanceFromLocation</span><span class="p">(</span><span class="n">newLocation</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">distance</span> <span class="o">==</span> <span class="nb">nil</span> <span class="o">||</span> <span class="n">distance</span> <span class="o">&gt;</span> <span class="n">searchDistance</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">self</span><span class="p">.</span><span class="n">lastLoction</span> <span class="o">=</span> <span class="n">newLocation</span>
</span><span class='line'>      <span class="n">self</span><span class="p">.</span><span class="n">centerMapOnLocation</span><span class="p">(</span><span class="n">newLocation</span><span class="p">)</span>
</span><span class='line'>      <span class="n">self</span><span class="p">.</span><span class="n">fetchCafesAroundLocation</span><span class="p">(</span><span class="n">newLocation</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>本节其他部分都是一些业务逻辑方面的内容，数不赘述。</p>

<h2>Fetching data</h2>

<p>前面的开发进行到了最后一步，就是将用户位置附近的咖啡馆找出来，并在地图上展示，这依赖于一个FaceBook的接口访问，同时本地需要定义咖啡馆的模型。</p>

<h3>Building the data model</h3>

<p>先定义Cafe的model，首先你会想到Cafe在这里是一个纯数据类型，你可能会使用struct，因为Swift中struct也是model的选择之一。</p>

<p>但同时，你希望Cafe可以直接被显示到地图上，那么它就必须遵循MKAnnotation协议，这时，编译器便会报错，因为MKAnnotation是OC的协议，Cafe遵循该协议，必须可以被转化为OC代码，但struct在OC中只是一个C的数据类型，无法转化，所以这里必须声明Cafe为class，且必须继承自NSObject，因为MKAnnotation也遵循NSObject协议。最后，别忘了在init()结尾，添加<strong>super.init()</strong>，这样才能调到NSObject的初始化方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">import</span> <span class="n">Foundation</span>
</span><span class='line'><span class="n">import</span> <span class="n">MapKit</span>
</span><span class='line'>
</span><span class='line'><span class="n">class</span> <span class="nl">Cafe:</span> <span class="n">NSObject</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">let</span> <span class="nl">fbid:</span> <span class="n">String</span>
</span><span class='line'>  <span class="n">let</span> <span class="nl">name:</span> <span class="n">String</span>
</span><span class='line'>  <span class="n">let</span> <span class="nl">location:</span> <span class="n">CLLocationCoordinate2D</span>
</span><span class='line'>  <span class="n">let</span> <span class="nl">street:</span> <span class="n">String</span>
</span><span class='line'>  <span class="n">let</span> <span class="nl">city:</span> <span class="n">String</span>
</span><span class='line'>  <span class="n">let</span> <span class="nl">zip:</span> <span class="n">String</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">init</span><span class="p">(</span><span class="nl">fbid:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">name:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">location:</span> <span class="n">CLLocationCoordinate2D</span><span class="p">,</span> <span class="nl">street:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">city:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">zip:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">fbid</span> <span class="o">=</span> <span class="n">fbid</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">location</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">street</span> <span class="o">=</span> <span class="n">street</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">city</span> <span class="o">=</span> <span class="n">city</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">zip</span> <span class="o">=</span> <span class="n">zip</span>
</span><span class='line'>    <span class="n">super</span><span class="p">.</span><span class="n">init</span><span class="p">()</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">extension</span> <span class="nl">Cafe:</span> <span class="n">MKAnnotation</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">var</span> <span class="nl">title:</span> <span class="n">String</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">name</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">var</span> <span class="nl">coordinate:</span> <span class="n">CLLocationCoordinate2D</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">location</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Fetching from Facebook</h3>

<p>下面将从Facebook的接口获取数据。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">urlString</span> <span class="o">=</span> <span class="s">&quot;https://graph.facebook.com/v2.0/search/&quot;</span>
</span><span class='line'><span class="n">urlString</span> <span class="o">+=</span> <span class="s">&quot;?access_token=&quot;</span>
</span><span class='line'><span class="n">urlString</span> <span class="o">+=</span> <span class="s">&quot;\(FBSession.activeSession().accessTokenData.accessToken)&quot;</span>
</span><span class='line'><span class="n">urlString</span> <span class="o">+=</span> <span class="s">&quot;&amp;type=place&quot;</span>
</span><span class='line'><span class="n">urlString</span> <span class="o">+=</span> <span class="s">&quot;&amp;q=cafe&quot;</span>
</span><span class='line'><span class="n">urlString</span> <span class="o">+=</span> <span class="s">&quot;&amp;center=\(location.coordinate.latitude),&quot;</span>
</span><span class='line'><span class="n">urlString</span> <span class="o">+=</span> <span class="s">&quot;\(location.coordinate.longitude)&quot;</span>
</span><span class='line'><span class="n">urlString</span> <span class="o">+=</span> <span class="s">&quot;&amp;distance=\(Int(searchDistance))&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">let</span> <span class="n">url</span> <span class="o">=</span> <span class="n">NSURL</span><span class="p">(</span><span class="nl">string:</span> <span class="n">urlString</span><span class="p">)</span><span class="o">!</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;Request URL: \(url)&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">let</span> <span class="n">request</span> <span class="o">=</span> <span class="n">NSURLRequest</span><span class="p">(</span><span class="nl">URL:</span> <span class="n">url</span><span class="p">)</span>
</span><span class='line'><span class="n">NSURLConnection</span><span class="p">.</span><span class="n">sendAsynchronousRequest</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="nl">queue:</span> <span class="n">NSOperationQueue</span><span class="p">.</span><span class="n">mainQueue</span><span class="p">())</span> <span class="p">{</span> <span class="p">(</span><span class="nl">response:</span> <span class="n">NSURLResponse</span><span class="o">?</span><span class="p">,</span> <span class="nl">data:</span> <span class="n">NSData</span><span class="o">?</span><span class="p">,</span> <span class="nl">error:</span> <span class="n">NSError</span><span class="o">?</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Void</span> <span class="k">in</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">error</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">let</span> <span class="n">alert</span> <span class="o">=</span> <span class="n">UIAlertController</span><span class="p">(</span><span class="nl">title:</span> <span class="s">&quot;Oops!&quot;</span><span class="p">,</span> <span class="nl">message:</span> <span class="s">&quot;An error occured&quot;</span><span class="p">,</span> <span class="nl">preferredStyle:</span> <span class="p">.</span><span class="n">Alert</span><span class="p">)</span>
</span><span class='line'>      <span class="n">alert</span><span class="p">.</span><span class="n">addAction</span><span class="p">(</span><span class="n">UIAlertAction</span><span class="p">(</span> <span class="nl">title:</span> <span class="s">&quot;OK&quot;</span><span class="p">,</span> <span class="nl">style:</span> <span class="p">.</span><span class="n">Default</span><span class="p">,</span> <span class="nl">handler:</span> <span class="nb">nil</span><span class="p">))</span>
</span><span class='line'>      <span class="n">self</span><span class="p">.</span><span class="n">presentViewController</span><span class="p">(</span><span class="n">alert</span><span class="p">,</span> <span class="nl">animated:</span> <span class="n">true</span><span class="p">,</span> <span class="nl">completion:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>      <span class="k">return</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">let</span> <span class="nl">jsonObject:</span> <span class="n">AnyObject</span><span class="o">!</span> <span class="o">=</span> <span class="n">try</span><span class="o">?</span> <span class="n">NSJSONSerialization</span><span class="p">.</span><span class="n">JSONObjectWithData</span><span class="p">(</span><span class="n">data</span><span class="o">!</span><span class="p">,</span> <span class="nl">options:</span> <span class="n">NSJSONReadingOptions</span><span class="p">(</span><span class="nl">rawValue:</span> <span class="mi">0</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="n">let</span> <span class="n">jsonObject</span> <span class="o">=</span> <span class="n">jsonObject</span> <span class="n">as</span><span class="o">?</span> <span class="p">[</span><span class="nl">String:</span><span class="n">AnyObject</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">JSONValue</span><span class="p">.</span><span class="n">fromObject</span><span class="p">(</span><span class="n">jsonObject</span><span class="p">)</span><span class="o">?</span><span class="p">[</span><span class="s">&quot;data&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="n">array</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">var</span> <span class="nl">cafes:</span> <span class="p">[</span><span class="n">Cafe</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>            <span class="k">for</span> <span class="n">cafeJSON</span> <span class="k">in</span> <span class="n">data</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">let</span> <span class="n">cafeJSON</span> <span class="o">=</span> <span class="n">cafeJSON</span><span class="p">.</span><span class="n">object</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="n">let</span> <span class="n">cafe</span> <span class="o">=</span> <span class="n">Cafe</span><span class="p">.</span><span class="n">fromJSON</span><span class="p">(</span><span class="n">cafeJSON</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">cafes</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">cafe</span><span class="p">)</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">mapView</span><span class="p">.</span><span class="n">removeAnnotations</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">cafes</span><span class="p">)</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">cafes</span> <span class="o">=</span> <span class="n">cafes</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">mapView</span><span class="p">.</span><span class="n">addAnnotations</span><span class="p">(</span><span class="n">cafes</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>首先拼接要访问的URL，采用了String拼接，而不是stringWithFormat:，这样代码比较清晰</li>
<li>然后将string转化为NSURL，虽然NSURL的参数需要NSString，但是使用String也没问题，这是因为Swift对它们进行了无缝的桥接。</li>
<li>使用了NSURLConnection的异步请求，使用closure处理回调。</li>
<li>JSON的反序列化，目前Swift2.0采用了try/catch这样的写法，而弃用了之前OC的传入NSError**参数的做法，代码更简洁。</li>
<li>NSJSONSerialization的JSONObjectWithData()方法实际返回的是NSDictionary，但是我们使用时是转化成[NSObject:AnyObject]，这也是Swift的隐式转换，还有NSArray和[AnyObject]。</li>
<li>具体的JSON对象的解析，使用了JSON.swift库，关于这个库的原理在之前讲过，主要是利用enum的新特性，为每一种JSON元素类型提供了type。</li>
</ol>


<h3>Parsing the JSON data</h3>

<p>让我们在Cafe类中添加一个直接从JSON初始化的方法，在取JSON每一个元素时，一定要注意使用optional类型，这样可以保证不会因为某个值不存在而崩溃。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">class</span> <span class="n">func</span> <span class="n">fromJSON</span><span class="p">(</span><span class="nl">json:</span> <span class="p">[</span><span class="nl">String:</span><span class="n">JSONValue</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Cafe</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>   <span class="n">let</span> <span class="n">fbid</span> <span class="o">=</span> <span class="n">json</span><span class="p">[</span><span class="s">&quot;id&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="n">string</span>
</span><span class='line'>   <span class="n">let</span> <span class="n">name</span> <span class="o">=</span> <span class="n">json</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="n">string</span>
</span><span class='line'>   <span class="n">let</span> <span class="n">latitude</span> <span class="o">=</span> <span class="n">json</span><span class="p">[</span><span class="s">&quot;location&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">[</span><span class="s">&quot;latitude&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="kt">double</span>
</span><span class='line'>   <span class="n">let</span> <span class="n">longitude</span> <span class="o">=</span> <span class="n">json</span><span class="p">[</span><span class="s">&quot;location&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">[</span><span class="s">&quot;longitude&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="kt">double</span>
</span><span class='line'>
</span><span class='line'>   <span class="k">if</span> <span class="n">fbid</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="o">&amp;&amp;</span> <span class="n">name</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="o">&amp;&amp;</span> <span class="n">latitude</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="o">&amp;&amp;</span> <span class="n">longitude</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>       <span class="n">var</span> <span class="nl">street:</span> <span class="n">String</span>
</span><span class='line'>       <span class="k">if</span> <span class="n">let</span> <span class="n">maybeStreet</span> <span class="o">=</span> <span class="n">json</span><span class="p">[</span><span class="s">&quot;location&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">[</span><span class="s">&quot;street&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="n">string</span> <span class="p">{</span>
</span><span class='line'>           <span class="n">street</span> <span class="o">=</span> <span class="n">maybeStreet</span>
</span><span class='line'>       <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>           <span class="n">street</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
</span><span class='line'>       <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>       <span class="n">var</span> <span class="nl">city:</span> <span class="n">String</span>
</span><span class='line'>       <span class="k">if</span> <span class="n">let</span> <span class="n">maybeCity</span> <span class="o">=</span> <span class="n">json</span><span class="p">[</span><span class="s">&quot;location&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">[</span><span class="s">&quot;city&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="n">string</span> <span class="p">{</span>
</span><span class='line'>           <span class="n">city</span> <span class="o">=</span> <span class="n">maybeCity</span>
</span><span class='line'>       <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>           <span class="n">city</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
</span><span class='line'>       <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>       <span class="n">var</span> <span class="nl">zip:</span> <span class="n">String</span>
</span><span class='line'>       <span class="k">if</span> <span class="n">let</span> <span class="n">maybeZip</span> <span class="o">=</span> <span class="n">json</span><span class="p">[</span><span class="s">&quot;location&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">[</span><span class="s">&quot;zip&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="n">string</span> <span class="p">{</span>
</span><span class='line'>           <span class="n">zip</span> <span class="o">=</span> <span class="n">maybeZip</span>
</span><span class='line'>       <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>           <span class="n">zip</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
</span><span class='line'>       <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>       <span class="n">let</span> <span class="n">location</span> <span class="o">=</span> <span class="n">CLLocationCoordinate2D</span><span class="p">(</span><span class="nl">latitude:</span> <span class="n">latitude</span><span class="o">!</span><span class="p">,</span> <span class="nl">longitude:</span> <span class="n">longitude</span><span class="o">!</span><span class="p">)</span>
</span><span class='line'>       <span class="k">return</span> <span class="n">Cafe</span><span class="p">(</span><span class="nl">fbid:</span> <span class="n">fbid</span><span class="o">!</span><span class="p">,</span> <span class="nl">name:</span> <span class="n">name</span><span class="o">!</span><span class="p">,</span> <span class="nl">location:</span> <span class="n">location</span><span class="p">,</span> <span class="nl">street:</span> <span class="n">street</span><span class="p">,</span> <span class="nl">city:</span> <span class="n">city</span><span class="p">,</span> <span class="nl">zip:</span> <span class="n">zip</span><span class="p">)</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从OC的角度考虑，我们可能会问，为什么不写一个secondary初始化方法？这是由于Swift决定的，某个类初始化方法是不能返回nil值的，如果可以，那么所有的Swift类型都是optional类型了，那么区分optional就没有意义，所以我们一定要注意，像构建这类可能返回nil的初始化方法，最好采用该类型的工厂方法来实现。</p>

<h2>Selectors</h2>

<p>这一小节想给app加一个刷新按钮，引出OC中的target/selector模式在Swift中如何使用的问题。</p>

<p>OC中的方法调用是动态分发的，即方法的调用者（target）和方法名（SEL）都是可以在runtime动态分发的，而且你可以在runtime中修改这些值，而编译器不会在意该方法有没有实现。而在Swift中，所有的方法调用在编译期间就会决定，不再采用动态分发。那么如何解决Swift中调用原OC中需要target/SEL的方法，就需要得到解决。</p>

<p>Swift给出的方案是使用一个结构体Selector，Selector遵循了StringLiteralConvertible协议，其内部使用时可以直接从String转换，而使用者只需传入一个String即可。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">navigationItem</span><span class="p">.</span><span class="n">leftBarButtonItem</span> <span class="o">=</span> <span class="n">UIBarButtonItem</span><span class="p">(</span><span class="nl">barButtonSystemItem:</span> <span class="p">.</span><span class="n">Refresh</span><span class="p">,</span> <span class="nl">target:</span> <span class="n">self</span><span class="p">,</span> <span class="nl">action:</span> <span class="s">&quot;refresh:&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">public</span> <span class="n">convenience</span> <span class="n">init</span><span class="p">(</span><span class="n">barButtonSystemItem</span> <span class="nl">systemItem:</span> <span class="n">UIBarButtonSystemItem</span><span class="p">,</span> <span class="nl">target:</span> <span class="n">AnyObject</span><span class="o">?</span><span class="p">,</span> <span class="nl">action:</span> <span class="n">Selector</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>你可以尝试不去实现refresh:方法，而编译器也不会报错，而在执行时才会报错，这就是因为它的真正实现还是使用了OC的动态分发，只是做了Swift的桥接。</p>

<h2>Protocols and delegates</h2>

<p>接下来会为每个cafe创建一个detail view，并定义一个protocol，使用委托模式，并确保可以桥接到OC。</p>

<h3>Creating the detail view</h3>

<p>创建对应的viewController，并在storyboard上定义好xib。</p>

<p>这里声明了一个Cafe变量作为数据源，如下，与以往不同的是，添加了didSet()方法，该方法会在cafe被赋值之后会调用，类似OC中的KVO，你可以为实现变量的didSet和willSet，分别在赋值前和复制后调用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="nl">cafe:</span> <span class="n">Cafe</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">didSet</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">setupWithCafe</span><span class="p">()</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在Cafe类添加一个pictureURL变量，是一个computed property，提供了返回值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="nl">pictureURL:</span> <span class="n">NSURL</span> <span class="p">{</span>
</span><span class='line'><span class="k">return</span> <span class="n">NSURL</span><span class="p">(</span><span class="nl">string:</span> <span class="s">&quot;http://graph.facebook.com/place/picture?id=\(self.fbid)&amp;type=large&quot;</span><span class="p">)</span><span class="o">!</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来是setupWithCafe()方法，由于该方法放在了cafe的didSet中调用了，而且存在很多outlet存在，需要判断这些outlet是否加载完成，所以先进行了self.isViewLoaded()判断。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">private</span> <span class="n">func</span> <span class="nf">setupWithCafe</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">!</span><span class="n">self</span><span class="p">.</span><span class="n">isViewLoaded</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="n">let</span> <span class="n">cafe</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">cafe</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">cafe</span><span class="p">.</span><span class="n">name</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">nameLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cafe</span><span class="p">.</span><span class="n">name</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">streetLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cafe</span><span class="p">.</span><span class="n">street</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">cityLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cafe</span><span class="p">.</span><span class="n">city</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">zipLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cafe</span><span class="p">.</span><span class="n">zip</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">let</span> <span class="n">request</span> <span class="o">=</span> <span class="n">NSURLRequest</span><span class="p">(</span><span class="nl">URL:</span> <span class="n">cafe</span><span class="p">.</span><span class="n">pictureURL</span><span class="p">)</span>
</span><span class='line'>    <span class="n">NSURLConnection</span><span class="p">.</span><span class="n">sendAsynchronousRequest</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="nl">queue:</span> <span class="n">NSOperationQueue</span><span class="p">.</span><span class="n">mainQueue</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>      <span class="p">(</span><span class="nl">response:</span> <span class="n">NSURLResponse</span><span class="o">?</span><span class="p">,</span> <span class="nl">data:</span> <span class="n">NSData</span><span class="o">?</span><span class="p">,</span> <span class="nl">error:</span> <span class="n">NSError</span><span class="o">?</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Void</span> <span class="k">in</span>
</span><span class='line'>      <span class="n">let</span> <span class="n">image</span> <span class="o">=</span> <span class="n">UIImage</span><span class="p">(</span><span class="nl">data:</span> <span class="n">data</span><span class="o">!</span><span class="p">)</span>
</span><span class='line'>      <span class="n">self</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Wiring up the detail view</h3>

<p>在ViewController中，通过实现mapView(mapView: MKMapView!, viewForAnnotation annotation: MKAnnotation!) &ndash;> MKAnnotationView!和mapView(mapView: MKMapView!, annotationView view: MKAnnotationView!, calloutAccessoryControlTapped control: UIControl!)两个MKMapViewDelegate的方法，完成了通过点击大头针，弹出详情按钮，再进入详情页的功能。</p>

<p>这里还想将ViewController作为CafeViewController的委托，在CafeViewController点击返回时调用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="err">@</span><span class="n">objc</span> <span class="n">protocol</span> <span class="n">CafeViewControllerDelegate</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">optional</span> <span class="n">func</span> <span class="n">cafeViewControllerDidFinish</span><span class="p">(</span><span class="nl">viewController:</span> <span class="n">CafeViewController</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里在声明protocol前加了<strong>@objc</strong>关键字是因为该protocol有optional方法，因为这样可以使Swift添加多个runtime检测，来检测protocol的一致性和是否实现了optional类型的方法。同时这也限制了，protocol的实现者必须是class类型，因为runtime对@obj的检测需要对象为class。而你也可以通过在protocol后加限制来实现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="err">@</span><span class="n">objc</span> <span class="n">protocol</span> <span class="nl">CafeViewControllerDelegate:</span> <span class="n">class</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">optional</span> <span class="n">func</span> <span class="n">cafeViewControllerDidFinish</span><span class="p">(</span><span class="nl">viewController:</span> <span class="n">CafeViewController</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在CafeViewController添加delegate变量，与OC一样，使用weak属性，需要注意的是声明为optional类型，因为不是一定有委托对象的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">weak</span> <span class="n">var</span> <span class="nl">delegate:</span> <span class="n">CafeViewControllerDelegate</span><span class="o">?</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后是delegate的调用，这里使用了optional chain，delegate的存在与cafeViewControllerDidFinish()方法的实现与否都是不确定的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="err">@</span><span class="kt">IBAction</span> <span class="n">private</span> <span class="n">func</span> <span class="n">back</span><span class="p">(</span><span class="nl">sender:</span> <span class="n">AnyObject</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">self</span><span class="p">.</span><span class="n">delegate</span><span class="o">?</span><span class="p">.</span><span class="n">cafeViewControllerDidFinish</span><span class="o">?</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，是在ViewController中的delegate实现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">extension</span> <span class="nl">ViewController:</span> <span class="n">CafeViewControllerDelegate</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">cafeViewControllerDidFinish</span><span class="p">(</span><span class="nl">viewController:</span> <span class="n">CafeViewController</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">dismissViewControllerAnimated</span><span class="p">(</span><span class="n">true</span><span class="p">,</span> <span class="nl">completion:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Functional Programming]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/23/swift-by-tutorials-functional-programming/"/>
    <updated>2015-11-23T14:09:04+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/23/swift-by-tutorials-functional-programming</id>
    <content type="html"><![CDATA[<p>前几篇分别介绍了泛型、类、枚举、范围运算符这些Swift的语言新特性，当然有一部分是对已有技术的改进，但这已经表明Swift是比OC更具表现力和更简洁的语言。而Swift不仅仅是提供了更好的语法，在Swift中，函数式编程会成为编程中可行的并且非常重要的编程工具。函数式编程，简而言之，就是一种通过数学式的函数概括计算的编程范式，不可变且具表现力，同时使用最少的变量和状态值。函数式编程对于测试是非常友好的。随着多核设备的普及，并行和并发处理显得非常重要，而函数式编程就是可以很好处理并行和并发处理的，这也是它日趋重要的原因之一。</p>

<!--more-->


<h2>Simple array filtering</h2>

<p>这个简单的例子要求我们在1到10之间找到所有的偶数的数字，看起来是一个简单的工作，但是是介绍函数式编程的一大步。</p>

<h3>Filtering the old way</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">evens</span> <span class="o">=</span> <span class="p">[</span><span class="n">Int</span><span class="p">]()</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">.</span><span class="mf">.10</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">evens</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">evens</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个很简单的小程序，而且运行也没问题，但是最核心的逻辑，检测一个数是否偶数，被隐藏在了for循环中。另外，添加数字到数组的逻辑在判断条件中，如果你想要打印每个偶数，那么除了复制粘贴，没法儿复用这部分代码。</p>

<h3>Functional filtering</h3>

<p>让我们来看看函数式的解决方案，其中filter是核心，通过传递isEven给filter，直接返回了我们需要的新数组。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">isEven</span><span class="p">(</span><span class="nl">number:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">number</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">evens</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="mf">1.</span><span class="p">.</span><span class="mf">.10</span><span class="p">).</span><span class="n">filter</span><span class="p">(</span><span class="n">isEven</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">evens</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过上一章我们知道函数只是有名字的闭包，按照之前的介绍，利用type inference我们可以对该方案进一步简化。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">evens</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="mf">1.</span><span class="p">.</span><span class="mf">.10</span><span class="p">).</span><span class="n">filter</span> <span class="p">{</span> <span class="n">number</span> <span class="k">in</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">}</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="n">evens</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者最简化的使用参数简化符号。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">evens</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="mf">1.</span><span class="p">.</span><span class="mf">.10</span><span class="p">).</span><span class="n">filter</span><span class="p">{</span> <span class="n">$0</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">}</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">evens</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于简化符号的使用，作者表示，对于比较简单的逻辑（如上例）推荐使用简化符号，而对于复杂的逻辑，则不推荐使用，因为即使减少了代码量，但牺牲了可读性，还是不太划算。</p>

<p>上面的函数式编程较上一节的方案，更为简洁，而同时它也反映了，函数式编程三个共同的特点。</p>

<ol>
<li>Higher-order functons：你需要将这些函数当做参数传入其他函数，该例中isEven即是Higher-order functons。</li>
<li>First-class function：这也是我们多次强调的一点，函数作为第一类对象，可以作为参数或者返回结果，这也是函数式编程的基础，Swift全面支持这一点。</li>
<li>Closures：闭包，可以使代码更简洁，相当于匿名函数。</li>
</ol>


<p>你可能觉得OC的block也具有类似的特点，但Swift较之更胜一筹，主要是因为它拥有很多内建的函数式语法，比如该例中的filter就是。</p>

<h3>The magic behind filter</h3>

<p>通过自定义一个myFilter方法，让我们来看一下filter的背后实现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">myFilter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nl">source:</span> <span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="nl">predicate:</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">T</span><span class="p">]()</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">source</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">result</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从上面发现，实际上的实现和我们在第一节的逻辑是相同的，只不过通过泛型和函数作为参数完成了filter这一过程的抽象，这也是函数式编程的本质。</p>

<p>原文还提出一个将myFilter()作为Array的一个方法，而不是函数，其实只需要添加一个Array的扩展，将泛型改为Array自身的元素就行，下面给出自己的解答。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">extension</span> <span class="n">Array</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">myFilter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nl">predicate:</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">var</span> <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">T</span><span class="p">]()</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">self</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">i</span> <span class="n">as</span><span class="o">!</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="n">as</span><span class="o">!</span> <span class="n">T</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">result</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">evens</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="mf">1.</span><span class="p">.</span><span class="mf">.10</span><span class="p">).</span><span class="n">myFilter</span><span class="p">{</span><span class="n">$0</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Reducing</h2>

<p>这一节将介绍Swift中内建的，比较复杂的reduce函数，进一步了解函数式编程。</p>

<h3>Manual reduction</h3>

<p>reduce的效果是输入一个数组，但最终得到一个结果，例子是要求我们找出1到10的所有偶数，并计算出他们的和，先看下常规控制流的实现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">evens</span> <span class="o">=</span> <span class="p">[</span><span class="n">Int</span><span class="p">]()</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">.</span><span class="mf">.10</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">evens</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="n">evenSum</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">evens</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">evenSum</span> <span class="o">+=</span> <span class="n">i</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">evenSum</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Functional reduce</h3>

<p>下面是reduce的函数式实现，这里采用的是全简写符号。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">evenSum</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="mf">1.</span><span class="p">.</span><span class="mf">.10</span><span class="p">).</span><span class="n">filter</span><span class="p">{</span><span class="n">$0</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}.</span><span class="n">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">){</span><span class="n">$0</span><span class="o">+</span><span class="n">$1</span><span class="p">}</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">evenSum</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>reduce的函数原型如下，有两个参数，initial和combine，initial为U类型，最终的返回值也是U类型，而combine的参数是U和T类型，返回值也是U类型，每次执行完后，返回值都会成为combine新的参数，所以实现了上述的累加效果。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">reduce</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nl">initial:</span> <span class="n">U</span><span class="p">,</span> <span class="nl">combine:</span> <span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">U</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">U</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里还有一个寻找数组中最大值的例子。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">maxNumber</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="mf">1.</span><span class="p">.</span><span class="mf">.10</span><span class="p">).</span><span class="n">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">){</span><span class="n">total</span><span class="p">,</span> <span class="n">number</span> <span class="k">in</span> <span class="n">max</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">number</span><span class="p">)}</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">maxNumber</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们发现，输入值T和最终返回值U可以是不同的类型，所以可以有更多的应用，比如下面的字符串输出。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="mf">1.</span><span class="p">.</span><span class="mf">.10</span><span class="p">).</span><span class="n">reduce</span><span class="p">(</span><span class="s">&quot;numbers:&quot;</span><span class="p">){</span><span class="n">$0</span><span class="o">+</span><span class="s">&quot;\($1)&quot;</span><span class="p">}</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里又有一个附加问题，要求输入一个[&ldquo;3&rdquo;, &ldquo;1&rdquo;, &ldquo;4&rdquo;, &ldquo;1&rdquo;]数组，而输出Int值3141，我的思路是先拼接字符串，然后转为Int。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">digits</span> <span class="o">=</span> <span class="n">Int</span><span class="p">([</span><span class="s">&quot;3&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;4&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">].</span><span class="n">reduce</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">){</span><span class="n">$0</span><span class="o">+</span><span class="n">$1</span><span class="p">})</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">digits</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>The magic behind reduce</h3>

<p>下面我们自己为Array添加一个自定义的reduce方法，实现方法与我们在之前的实现是一致的，还是做了一步抽象。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">extension</span> <span class="n">Array</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">myReduce</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nl">seed:</span><span class="n">U</span><span class="p">,</span> <span class="nl">combiner:</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">U</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">U</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">var</span> <span class="n">result</span> <span class="o">=</span> <span class="n">seed</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">self</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">result</span> <span class="o">=</span> <span class="n">combiner</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">i</span> <span class="n">as</span><span class="o">!</span> <span class="n">T</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">result</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Building an index</h2>

<p>接下来，我们将实践一次函数式编程，题目是将下面的String数组，按照首字母进行分组。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">words</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Cat&quot;</span><span class="p">,</span> <span class="s">&quot;Chicken&quot;</span><span class="p">,</span> <span class="s">&quot;fish&quot;</span><span class="p">,</span> <span class="s">&quot;Dog&quot;</span><span class="p">,</span> <span class="s">&quot;Mouse&quot;</span><span class="p">,</span> <span class="s">&quot;Guinea Pig&quot;</span><span class="p">,</span> <span class="s">&quot;monkey&quot;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先现有一个大致的思路，建立一个元组，包含首字母和其对应的String数组，最后通过一个函数返回一个该元组的数组，然后就完成了任务。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">typealias</span> <span class="n">Entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">Character</span><span class="p">,</span> <span class="p">[</span><span class="n">String</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'><span class="n">func</span> <span class="n">buildIndex</span><span class="p">(</span><span class="nl">words:</span> <span class="p">[</span><span class="n">String</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">Entry</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">Entry</span><span class="p">]()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Building an index imperatively</h3>

<p>下面是常规控制流实现，使用了两个for循环，一个用于记录所有的首字母key，第二个用于将原数组添加到对应的元组中。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">buildIndex</span><span class="p">(</span><span class="nl">words:</span> <span class="p">[</span><span class="n">String</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">Entry</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">var</span> <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">Entry</span><span class="p">]()</span>
</span><span class='line'>  <span class="n">var</span> <span class="n">letters</span> <span class="o">=</span> <span class="p">[</span><span class="n">Character</span><span class="p">]()</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">word</span> <span class="k">in</span> <span class="n">words</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">firstLetter</span> <span class="o">=</span> <span class="n">Character</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">substringToIndex</span><span class="p">(</span>
</span><span class='line'>      <span class="n">advance</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="mi">1</span><span class="p">)).</span><span class="n">uppercaseString</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">!</span><span class="n">contains</span><span class="p">(</span><span class="n">letters</span><span class="p">,</span> <span class="n">firstLetter</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">letters</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">firstLetter</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">letters</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">wordsForLetter</span> <span class="o">=</span> <span class="p">[</span><span class="n">String</span><span class="p">]()</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">word</span> <span class="k">in</span> <span class="n">words</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">let</span> <span class="n">firstLetter</span> <span class="o">=</span> <span class="n">Character</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">substringToIndex</span><span class="p">(</span>
</span><span class='line'>        <span class="n">advance</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="mi">1</span><span class="p">)).</span><span class="n">uppercaseString</span><span class="p">)</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">firstLetter</span> <span class="o">==</span> <span class="n">letter</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">wordsForLetter</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">letter</span><span class="p">,</span> <span class="n">wordsForLetter</span><span class="p">))</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">result</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Building an index the functional way</h3>

<p>下面是该问题的函数式解决方案，首先我们利用Array的map函数，得到words对应的首字母数组。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">buildIndex</span><span class="p">(</span><span class="nl">words:</span> <span class="p">[</span><span class="n">String</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">Entry</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">letters</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">word</span> <span class="o">-&gt;</span> <span class="n">Character</span> <span class="k">in</span>
</span><span class='line'>    <span class="n">Character</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">substringToIndex</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">startIndex</span><span class="p">.</span><span class="n">advancedBy</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="n">uppercaseString</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">Entry</span><span class="p">]()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>map与前面的filter，reduce一样都是Array的内建函数，它的作用是输出一个与原数组对应的相关数组。而且数组元素可以与原数组不同，这里通过map得到了words对应的首字母数组，但是不足的是重复字母并没有过滤。我们可以像之前一样自定义一个过滤相同字母的函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">distinct</span><span class="o">&lt;</span><span class="nl">T:</span> <span class="n">Equatable</span><span class="o">&gt;</span> <span class="p">(</span><span class="nl">source:</span> <span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">unique</span> <span class="o">=</span> <span class="p">[</span><span class="n">T</span><span class="p">]()</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">source</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">!</span><span class="n">unique</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">unique</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">unique</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>利用这一函数，过滤重复字母。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">buildIndex</span><span class="p">(</span><span class="nl">words:</span> <span class="p">[</span><span class="n">String</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">Entry</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">letters</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">word</span> <span class="o">-&gt;</span> <span class="n">Character</span> <span class="k">in</span>
</span><span class='line'>    <span class="n">Character</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">substringToIndex</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">startIndex</span><span class="p">.</span><span class="n">advancedBy</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="n">uppercaseString</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">distinctLetters</span> <span class="o">=</span> <span class="n">distinct</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="n">distinctLetters</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">Entry</span><span class="p">]()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，我们利用map和filter的嵌套使用，完成最终的结果数组。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">buildIndex</span><span class="p">(</span><span class="nl">words:</span> <span class="p">[</span><span class="n">String</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">Entry</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">letters</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">word</span> <span class="o">-&gt;</span> <span class="n">Character</span> <span class="k">in</span>
</span><span class='line'>    <span class="n">Character</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">substringToIndex</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">startIndex</span><span class="p">.</span><span class="n">advancedBy</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="n">uppercaseString</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">distinctLetters</span> <span class="o">=</span> <span class="n">distinct</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">distinctLetters</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">letter</span> <span class="o">-&gt;</span> <span class="n">Entry</span> <span class="k">in</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="n">words</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span> <span class="n">word</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="k">in</span>
</span><span class='line'>        <span class="n">Character</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">substringToIndex</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">startIndex</span><span class="p">.</span><span class="n">advancedBy</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="n">uppercaseString</span><span class="p">)</span> <span class="o">==</span> <span class="n">letter</span>
</span><span class='line'>            <span class="p">})</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在完成基础上我们可以进一步重构，我们在buildIndex()函数中声明了一个新的函数firstLetter()，该函数的作用范围只在外围函数中，这得益于Swift中function作为第一类对象，所以可以被视作本地变量，也有作用范围。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">buildIndex</span><span class="p">(</span><span class="nl">words:</span> <span class="p">[</span><span class="n">String</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">Entry</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">firstLetter</span><span class="p">(</span><span class="nl">str:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Character</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Character</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">substringToIndex</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">.</span><span class="n">advancedBy</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="n">uppercaseString</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">let</span> <span class="n">letters</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">word</span> <span class="o">-&gt;</span> <span class="n">Character</span> <span class="k">in</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">firstLetter</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">distinctLetters</span> <span class="o">=</span> <span class="n">distinct</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="n">distinctLetters</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">distinctLetters</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">letter</span> <span class="o">-&gt;</span> <span class="n">Entry</span> <span class="k">in</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="n">words</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span> <span class="n">word</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="k">in</span>
</span><span class='line'>            <span class="n">firstLetter</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">==</span> <span class="n">letter</span>
</span><span class='line'>            <span class="p">})</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然而，这还不是最简形式，追求最简形式，可以将所有函数连续调用，这是没问题的，以下是最终结果。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">buildIndex</span><span class="p">(</span><span class="nl">words:</span> <span class="p">[</span><span class="n">String</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">Entry</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">firstLetter</span><span class="p">(</span><span class="nl">str:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Character</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Character</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">substringToIndex</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">.</span><span class="n">advancedBy</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="n">uppercaseString</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">distinct</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">firstLetter</span><span class="p">))</span>
</span><span class='line'>        <span class="p">.</span><span class="n">map</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">letter</span> <span class="o">-&gt;</span> <span class="n">Entry</span> <span class="k">in</span>
</span><span class='line'>          <span class="k">return</span> <span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="n">words</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">word</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="k">in</span>
</span><span class='line'>            <span class="n">firstLetter</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">==</span> <span class="n">letter</span>
</span><span class='line'>          <span class="p">})</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过比较，你会发现，在常规做法中，你会声明很多临时变量，而在函数式编程中，你会使用对应的常量替代，这就意味着是不可变的，而不可变的类型更容易测试和协助并发，函数式编程与不可变类型是一体的，而且会导致你的代码更简洁，错误更少。</p>

<p>这节的挑战任务是需要输出的结果按字母排序，我们可以添加之前介绍过的最简的sort()方法，在distinct()之后进行调用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">buildIndex</span><span class="p">(</span><span class="nl">words:</span> <span class="p">[</span><span class="n">String</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">Entry</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">firstLetter</span><span class="p">(</span><span class="nl">str:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Character</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Character</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">substringToIndex</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">.</span><span class="n">advancedBy</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="n">uppercaseString</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">distinct</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">firstLetter</span><span class="p">)).</span><span class="n">sort</span><span class="p">(</span><span class="o">&lt;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">map</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">letter</span> <span class="o">-&gt;</span> <span class="n">Entry</span> <span class="k">in</span>
</span><span class='line'>          <span class="k">return</span> <span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="n">words</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">word</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="k">in</span>
</span><span class='line'>            <span class="n">firstLetter</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">==</span> <span class="n">letter</span>
</span><span class='line'>          <span class="p">})</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Partial application and currying</h2>

<p>前面几节围绕Array的三个方法，map，reduce，filter来介绍函数式编程。这一节将进一步介绍函数式编程的Partial application和currying。这里有一篇<a href="http://segmentfault.com/a/1190000000765247">博客</a>也进行了简单的介绍。</p>

<h3>Partial application</h3>

<p>为了说明Partial application，先提出一个问题，切割字符串为数组，我们的常用解决方案就是就是直接调用NSString的componentsSeparatedByString()方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">import</span> <span class="n">Foundation</span>
</span><span class='line'><span class="n">let</span> <span class="n">data</span> <span class="o">=</span> <span class="s">&quot;5,7;3,4;55,6&quot;</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">componentsSeparatedByString</span><span class="p">(</span><span class="s">&quot;;&quot;</span><span class="p">))</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">componentsSeparatedByString</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>这么调用也没问题，但是如果有场景需要我们多次用分号，或者逗号切割字符串，这样处理会出现许多重复代码，那么partical application就是这类问题的解决方案。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">creatSplitter</span><span class="p">(</span><span class="nl">separator:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">String</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">String</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">split</span><span class="p">(</span><span class="nl">source:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">String</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">source</span><span class="p">.</span><span class="n">componentsSeparatedByString</span><span class="p">(</span><span class="n">separator</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">split</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">let</span> <span class="n">commaSplitter</span> <span class="o">=</span> <span class="n">creatSplitter</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">commaSplitter</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="n">let</span> <span class="n">semiColonSplitter</span> <span class="o">=</span> <span class="n">creatSplitter</span><span class="p">(</span><span class="s">&quot;;&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">semiColonSplitter</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们创建了一个产生分割字符串方法的工厂方法，输入分隔符号，返回一个该符号的分割方法，也就是我们先实现了函数的一部分，将函数从二元降为了一元，最主要的是，我们可以反复使用这一得到的方法，可能在该例中优点体现不太明显，但是如果逻辑更复杂，参数更多后，partical application带来的效率提高就非常可观了。</p>

<h3>A mild curry</h3>

<p>使用curry也可以实现上例中的结果，如下，但是调用和工厂方法的写法都会改变。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">createSplitter</span><span class="p">(</span><span class="nl">separator:</span> <span class="n">String</span><span class="p">)(</span><span class="nl">source:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">String</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">source</span><span class="p">.</span><span class="n">componentsSeparatedByString</span><span class="p">(</span><span class="n">separator</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">let</span> <span class="n">commaSplitter</span> <span class="o">=</span> <span class="n">createSplitter</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">commaSplitter</span><span class="p">(</span><span class="nl">source:</span> <span class="n">data</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="n">let</span> <span class="n">semiColonSplitter</span> <span class="o">=</span> <span class="n">createSplitter</span><span class="p">(</span><span class="s">&quot;;&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">semiColonSplitter</span><span class="p">(</span><span class="nl">source:</span> <span class="n">data</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>curry实现了相同的目的，但是它创建的方法包含了两组“分开的”参数，而当你输入第一个参数时，会返回一个函数，你可以继续输入第二个参数（第二个参数需要使用外部参数名，与一般函数一致）。</p>

<h3>A hotter curry</h3>

<p>让我们进一步了解curry，将下面的三元函数进行curry化。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">addNumbers</span><span class="p">(</span><span class="nl">one:</span><span class="n">Int</span><span class="p">,</span> <span class="nl">two:</span><span class="n">Int</span><span class="p">,</span> <span class="nl">three:</span><span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">one</span> <span class="o">+</span> <span class="n">two</span> <span class="o">+</span> <span class="n">three</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">addNumbers</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nl">two:</span> <span class="mi">5</span><span class="p">,</span> <span class="nl">three:</span> <span class="mi">4</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">curryAddNumbers</span><span class="p">(</span><span class="nl">one:</span><span class="n">Int</span><span class="p">)(</span><span class="nl">two:</span><span class="n">Int</span><span class="p">)(</span><span class="nl">three:</span><span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">one</span><span class="o">+</span><span class="n">two</span><span class="o">+</span><span class="n">three</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>接着让我们分部对curry函数进行调用，每一步都会返回一个函数，最后一步返回最终结果。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">stepOne</span> <span class="o">=</span> <span class="n">curryAddNumbers</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">stepTwo</span> <span class="o">=</span> <span class="n">stepOne</span><span class="p">(</span><span class="nl">two:</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">stepTwo</span><span class="p">(</span><span class="nl">three:</span> <span class="mi">4</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>也可以像一般函数一样，一次性直接调用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">curryAddNumbers</span><span class="p">(</span><span class="mi">2</span><span class="p">)(</span><span class="nl">two:</span> <span class="mi">5</span><span class="p">)(</span><span class="nl">three:</span> <span class="mi">4</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然，也可以在每一步添加多个参数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">curryAddNumbers2</span><span class="p">(</span><span class="nl">one:</span><span class="n">Int</span><span class="p">,</span> <span class="nl">two:</span> <span class="n">Int</span><span class="p">)(</span><span class="nl">three:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">one</span><span class="o">+</span><span class="n">two</span><span class="o">+</span><span class="n">three</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">curryAddNumbers2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nl">two:</span> <span class="mi">5</span><span class="p">)(</span><span class="nl">three:</span> <span class="mi">4</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Practical curring</h3>

<p>上面两例主要为了说明curry的使用，这里看下它在实际开发中的用法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">text</span> <span class="o">=</span> <span class="s">&quot;Swift&quot;</span>
</span><span class='line'><span class="n">let</span> <span class="n">paddedText</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">stringByPaddingToLength</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nl">withString:</span> <span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="nl">startingAtIndex:</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">paddedText</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个调用了NSString的填充字符串的方法（额外注意一点startingAtIndex:是指明要填充的字符串从哪位开始填充，所以不能超过withString:参数的长度）。我们在他基础之上要封装一个四元的curry函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">curriedPadding</span><span class="p">(</span><span class="nl">startingAtIndex:</span> <span class="n">Int</span><span class="p">,</span> <span class="nl">withString:</span> <span class="n">String</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nl">source:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">length:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">source</span><span class="p">.</span><span class="n">stringByPaddingToLength</span><span class="p">(</span><span class="n">length</span><span class="p">,</span>
</span><span class='line'>      <span class="nl">withString:</span> <span class="n">withString</span><span class="p">,</span> <span class="nl">startingAtIndex:</span> <span class="n">startingAtIndex</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在它基础上创建一个只用点填充字符串的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">dotPadding</span> <span class="o">=</span> <span class="n">curriedPadding</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nl">withString:</span> <span class="s">&quot;.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">dotPadded</span> <span class="o">=</span> <span class="n">dotPadding</span><span class="p">(</span><span class="nl">source:</span> <span class="s">&quot;Curry!&quot;</span><span class="p">,</span> <span class="nl">length:</span> <span class="mi">10</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Enums and Switch Statements]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/20/swift-by-tutorials-enums-and-switch-statements/"/>
    <updated>2015-11-20T10:11:34+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/20/swift-by-tutorials-enums-and-switch-statements</id>
    <content type="html"><![CDATA[<p>enum枚举类型是很多编程语言的基本特性，一般是用来存储一组表示不同type的值，比如UILabel使用的NSTextAlignment，会有.Center，.Left多个type。而在Swift中，enum除了原始的用法，它的用法更像class或struct，enum可以拥有自己的方法，甚至是构造方法，然后通过配合Switch，可以实现更灵活的代码流控制，所以才会专门拿出来讲解，足见enum+switch在Swift的重要性。</p>

<!--more-->


<h2>Basic enumerations</h2>

<p>先看一个Swift中定义的简单enum，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">enum</span> <span class="n">Shape</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Rectangle</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Square</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Triangle</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Circle</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而使用时，可以按照下面两种方式赋值，如果事先定义了类型，那么可以不用在后面写类型，这还是Swift type inference的表现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">aShape</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">.</span><span class="n">Triangle</span>
</span><span class='line'><span class="n">var</span> <span class="nl">bShape:</span> <span class="n">Shape</span> <span class="o">=</span> <span class="p">.</span><span class="n">Triangle</span>
</span></code></pre></td></tr></table></div></figure>


<p>而在之后的再次赋值中，都不用再指定类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">aShape</span> <span class="o">=</span> <span class="p">.</span><span class="n">Square</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Raw values</h3>

<p>在OC中，我们一般使用NS_ENUM()来定义枚举，并可以指定值的类型，也可以单独指定某个type的值。而在Swift中，也可以做到，而且更简单。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">enum</span> <span class="nl">Shape:</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Rectangle</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Square</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Triangle</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Circle</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用上述代码就指定了enum的原始值类型为Int，同时该enum获得了一个property，<strong>rawValue</strong>，用于读取当前枚举值的raw value，和一个新的初始化方法，<strong>init(rawValue:)</strong>，用raw value来初始化enum。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">triangle</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">.</span><span class="n">Triangle</span>
</span><span class='line'><span class="n">triangle</span><span class="p">.</span><span class="n">rawValue</span>
</span><span class='line'><span class="n">var</span> <span class="n">square</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">(</span><span class="nl">rawValue:</span> <span class="mi">1</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>有一点需要注意，就是通过<strong>init(rawValue:)</strong>生成的enum值，是Optional类型的，因为可能会出现输入的raw value没有对应的enum，如下，会返回nil。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">notAShape</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">(</span><span class="nl">rawValue:</span> <span class="mi">100</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>enum可以直接给某个type赋值，然后其他未赋值的type会自动加1。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">enum</span> <span class="nl">Shape:</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Rectangle</span> <span class="o">=</span> <span class="mi">10</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Square</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Triangle</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Circle</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>此外，enum可以使用其他类型的raw value，比如Double，Float，String，但是需要为所有type指定对应的raw value，因为除了Int，其他类型的enum是不会对没赋值的enum自动加1的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">enum</span> <span class="nl">Shape:</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Rectangle</span> <span class="o">=</span> <span class="s">&quot;Rectangle&quot;</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Square</span> <span class="o">=</span> <span class="s">&quot;Square&quot;</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Triangle</span> <span class="o">=</span> <span class="s">&quot;Triangle&quot;</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Circle</span> <span class="o">=</span> <span class="s">&quot;Circle&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Switch statements</h2>

<p>switch与enum的配合在很多语言都是常见的用法，Swift中一样可以，而且有很多实用的改进。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">enum</span> <span class="n">Shape</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Rectangle</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Square</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Triangle</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Circle</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">var</span> <span class="n">aShape</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">.</span><span class="n">Rectangle</span>
</span><span class='line'>
</span><span class='line'><span class="k">switch</span><span class="p">(</span><span class="n">aShape</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="k">case</span> <span class="p">.</span><span class="nl">Rectangle:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;a rectangle&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="p">.</span><span class="nl">Square:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;a square&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">default</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;other shape&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>之前在控制流的章节我们介绍过Swift中的switch，它是需要所有case全部覆盖的，如果你实现了全部case的覆盖，则不用添加default，反之，一定要添加defaut处理。而且，你不需要在每个case后添加break，系统会自动为你添加。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">switch</span><span class="p">(</span><span class="n">aShape</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="k">case</span> <span class="p">.</span><span class="n">Rectangle</span><span class="p">,</span> <span class="p">.</span><span class="nl">Square:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;a quadrilateral&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="p">.</span><span class="nl">Circle:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;a circle&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">default</span><span class="o">:</span>
</span><span class='line'>    <span class="k">break</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个case处理多个值也很简单，只需要逗号隔开多个值即可，并不需要其他语言中，用不加break的多行处理。</p>

<h2>Associated values</h2>

<p>Associated values是Swift与其他语言的enum类型最大的不同之处，你可以向每个type添加一个类似元组类型的附加值，来作为二级判断条件，下面是有附带值的enum声明，可以为参数添加参数名。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">enum</span> <span class="n">Shape</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Rectangle</span><span class="p">(</span><span class="nl">width:</span> <span class="n">Float</span><span class="p">,</span> <span class="nl">height:</span> <span class="n">Float</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Square</span><span class="p">(</span><span class="nl">side:</span> <span class="n">Float</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Triangle</span><span class="p">(</span><span class="nl">base:</span> <span class="n">Float</span><span class="p">,</span> <span class="nl">height:</span> <span class="n">Float</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Circle</span><span class="p">(</span><span class="nl">radius:</span> <span class="n">Float</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用时，可以像类或结构体初始化一样赋值，但记住不能像两者一样用<strong>.</strong>来访问。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">rectangle</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">.</span><span class="n">Rectangle</span><span class="p">(</span><span class="nl">width:</span> <span class="mi">5</span><span class="p">,</span> <span class="nl">height:</span> <span class="mi">10</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>你可以使用这些associated values的场景只能是在switch语句中，同时你还可以使用where关键字，为case添加二级条件。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">switch</span> <span class="p">(</span><span class="n">rectangle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="k">case</span> <span class="p">.</span><span class="n">Rectangle</span><span class="p">(</span><span class="n">let</span> <span class="n">width</span><span class="p">,</span> <span class="n">let</span> <span class="n">height</span><span class="p">)</span> <span class="n">where</span> <span class="n">width</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Narrow rectangle:\(width)*\(height)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="p">.</span><span class="n">Rectangle</span><span class="p">(</span><span class="n">let</span> <span class="n">width</span><span class="p">,</span> <span class="n">let</span> <span class="n">height</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Wide rectangle:\(width)*\(height)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">default</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;other shape&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是，判断条件越来越复杂，便会出现符合多个case的情况，但像前面所说，系统会自动在case后添加break，所以也只会执行最先符合的case，这需要注意。</p>

<h2>Eunms as types</h2>

<p>Swift中的enum还有另外一个重要特性，就是可以添加方法，配合associated value，可以封转一些方便的方法，比如为上面的Shape添加一个计算面积的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">area</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Float</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">switch</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="n">Rectangle</span><span class="p">(</span><span class="n">let</span> <span class="n">width</span><span class="p">,</span> <span class="n">let</span> <span class="n">height</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="n">Square</span><span class="p">(</span><span class="n">let</span> <span class="n">side</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">side</span> <span class="o">*</span> <span class="n">side</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="n">Triangle</span><span class="p">(</span><span class="n">let</span> <span class="n">base</span><span class="p">,</span> <span class="n">let</span> <span class="n">height</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">base</span> <span class="o">*</span> <span class="n">height</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="n">Circle</span><span class="p">(</span><span class="n">let</span> <span class="n">radius</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Float</span><span class="p">(</span><span class="n">M_PI</span><span class="p">)</span> <span class="o">*</span> <span class="n">powf</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后申明一个Shape的变量，就可以直接调用该方法计算面积了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">circle</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">.</span><span class="n">Circle</span><span class="p">(</span><span class="nl">radius:</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'><span class="n">circle</span><span class="p">.</span><span class="n">area</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>除此之外，可以添加新的构建方法，这是Shape实例的构造方法，所以切记一定要给self赋值，否则self没有值是无法返回对象的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">init</span><span class="p">(</span><span class="n">_</span> <span class="nl">rect:</span> <span class="n">CGRect</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">width</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="n">CGRectGetWidth</span><span class="p">(</span><span class="n">rect</span><span class="p">))</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">height</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="n">CGRectGetHeight</span><span class="p">(</span><span class="n">rect</span><span class="p">))</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">width</span> <span class="o">==</span> <span class="n">height</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">self</span> <span class="o">=</span> <span class="n">Square</span><span class="p">(</span><span class="nl">side:</span> <span class="n">width</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">self</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">(</span><span class="nl">width:</span> <span class="n">width</span><span class="p">,</span> <span class="nl">height:</span> <span class="n">height</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">(</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以如下这个构建方法是不合法的，因为会存在无法给self赋值的情况。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">init</span><span class="p">(</span><span class="n">_</span> <span class="nl">string:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">switch</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="s">&quot;rectangle&quot;</span><span class="o">:</span>
</span><span class='line'>        <span class="n">self</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">(</span><span class="nl">width:</span> <span class="mi">5</span><span class="p">,</span> <span class="nl">height:</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="s">&quot;square&quot;</span><span class="o">:</span>
</span><span class='line'>        <span class="n">self</span> <span class="o">=</span> <span class="n">Square</span><span class="p">(</span><span class="nl">side:</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="s">&quot;triangle&quot;</span><span class="o">:</span>
</span><span class='line'>        <span class="n">self</span> <span class="o">=</span> <span class="n">Triangle</span><span class="p">(</span><span class="nl">base:</span> <span class="mi">5</span><span class="p">,</span> <span class="nl">height:</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="s">&quot;circle&quot;</span><span class="o">:</span>
</span><span class='line'>        <span class="n">self</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="nl">radius:</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'>    <span class="k">default</span><span class="o">:</span>
</span><span class='line'>        <span class="k">break</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是想通过这种思路来初始化Shape，也可以实现，就是构建一个static的工厂方法，这样就不存在一定要有值的限制了，可以返回Optional类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">static</span> <span class="n">func</span> <span class="nf">fromString</span><span class="p">(</span><span class="nl">string:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Shape</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'><span class="k">switch</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="s">&quot;rectangle&quot;</span><span class="o">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Rectangle</span><span class="p">(</span><span class="nl">width:</span> <span class="mi">5</span><span class="p">,</span> <span class="nl">height:</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="s">&quot;square&quot;</span><span class="o">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Square</span><span class="p">(</span><span class="nl">side:</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="s">&quot;triangle&quot;</span><span class="o">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Triangle</span><span class="p">(</span><span class="nl">base:</span> <span class="mi">5</span><span class="p">,</span> <span class="nl">height:</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="s">&quot;circle&quot;</span><span class="o">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Circle</span><span class="p">(</span><span class="nl">radius:</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'>    <span class="k">default</span><span class="o">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对应的，使用时也要用if来拆包。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">anotherShape</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">.</span><span class="n">fromString</span><span class="p">(</span><span class="s">&quot;rectangle&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">anotherShape</span><span class="p">.</span><span class="n">area</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Optionals are enums</h3>

<p>Swift的Optional类型是enum类型，下面是部分实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">enum</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">NilLiteralConvertible</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">None</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">Some</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
</span><span class='line'>  <span class="n">init</span><span class="p">()</span>
</span><span class='line'>  <span class="n">init</span><span class="p">(</span><span class="n">_</span> <span class="nl">some:</span> <span class="n">T</span><span class="p">)</span>
</span><span class='line'>  <span class="k">static</span> <span class="n">func</span> <span class="n">convertFromNilLiteral</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="o">?</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里使用了泛型，并将该类型作为Some的associated value，可以使Optional持有任何类型的值。</p>

<p>同时enum可以实现协议，NilLiteralConvertible协议使你可以用nil来替代optional，编译器自动会将赋值nil时去调用<strong>convertFromNilLiteral</strong>，最终转化为.None。正是因为实现了这个协议，才可以对optional类型赋nil值，不然会报错。</p>

<h2>JSON parsing using enums</h2>

<p>本节用解析JSON这一常见用例，来实践enum在Swift中的使用。</p>

<h3>Parsing JSON the hard way</h3>

<p>这是常规的解析方法，看起来确实比较繁琐（但相比OC是还是简单多了）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">json</span> <span class="o">=</span> <span class="s">&quot;{</span><span class="se">\&quot;</span><span class="s">success</span><span class="se">\&quot;</span><span class="s">:true,</span><span class="se">\&quot;</span><span class="s">data</span><span class="se">\&quot;</span><span class="s">:{</span><span class="se">\&quot;</span><span class="s">numbers</span><span class="se">\&quot;</span><span class="s">:[1,2,3,4,5],</span><span class="se">\&quot;</span><span class="s">animal</span><span class="se">\&quot;</span><span class="s">:</span><span class="se">\&quot;</span><span class="s">dog</span><span class="se">\&quot;</span><span class="s">}}&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">jsonData</span> <span class="o">=</span> <span class="p">(</span><span class="n">json</span> <span class="n">as</span> <span class="n">NSString</span><span class="p">).</span><span class="n">dataUsingEncoding</span><span class="p">(</span><span class="n">NSUTF8StringEncoding</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">let</span> <span class="nl">parsed:</span> <span class="n">AnyObject</span><span class="o">?</span> <span class="o">=</span> <span class="n">NSJSONSerialization</span><span class="p">.</span><span class="n">JSONObjectWithData</span><span class="p">(</span><span class="n">jsonData</span><span class="p">,</span> <span class="nl">options:</span> <span class="n">NSJSONReadingOptions</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nl">error:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Actual JSON parsing section</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">let</span> <span class="n">parsed</span> <span class="o">=</span> <span class="n">parsed</span> <span class="n">as</span><span class="o">?</span> <span class="p">[</span><span class="nl">String:</span><span class="n">AnyObject</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">let</span> <span class="n">success</span> <span class="o">=</span> <span class="n">parsed</span><span class="p">[</span><span class="s">&quot;success&quot;</span><span class="p">]</span> <span class="n">as</span><span class="o">?</span> <span class="n">NSNumber</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">success</span><span class="p">.</span><span class="n">boolValue</span> <span class="o">==</span> <span class="n">true</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">parsed</span><span class="p">[</span><span class="s">&quot;data&quot;</span><span class="p">]</span> <span class="n">as</span><span class="o">?</span> <span class="n">NSDictionary</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">if</span> <span class="n">let</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">&quot;numbers&quot;</span><span class="p">]</span> <span class="n">as</span><span class="o">?</span> <span class="n">NSArray</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>          <span class="k">if</span> <span class="n">let</span> <span class="n">animal</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">&quot;animal&quot;</span><span class="p">]</span> <span class="n">as</span><span class="o">?</span> <span class="n">NSString</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">print</span><span class="p">(</span><span class="n">animal</span><span class="p">)</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Introducing JSON.swift</h3>

<p>这个文件之前在第四章解析JSON时用过，下面来分析下它的结构，首先是一个enum定义，因为JSON文件就是一些基本元素和dictionary或array的组合，所以使用enum和associated value来定义JSON的基本对象，这是这一解决方案的核心思想。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">enum</span> <span class="n">JSONValue</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">JSONObject</span><span class="p">([</span><span class="nl">String:</span><span class="n">JSONValue</span><span class="p">])</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">JSONArray</span><span class="p">([</span><span class="n">JSONValue</span><span class="p">])</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">JSONString</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">JSONNumber</span><span class="p">(</span><span class="n">NSNumber</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">JSONBool</span><span class="p">(</span><span class="n">Bool</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">JSONNull</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来为了获取.JSONObject和.JSONArray，我们利用Swift中方便添加角标访问的方式，使用subscript技术。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">subscript</span><span class="p">(</span><span class="nl">i:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JSONValue</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">get</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">switch</span> <span class="n">self</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="n">JSONArray</span><span class="p">(</span><span class="n">let</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span><span class='line'>    <span class="k">default</span><span class="o">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">subscript</span><span class="p">(</span><span class="nl">key:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JSONValue</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">get</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">switch</span> <span class="n">self</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="n">JSONObject</span><span class="p">(</span><span class="n">let</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">value</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</span><span class='line'>    <span class="k">default</span><span class="o">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么访问一般元素时呢？我们采用了computed properties来访问。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="nl">object:</span> <span class="p">[</span><span class="nl">String:</span><span class="n">JSONValue</span><span class="p">]</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">switch</span> <span class="n">self</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">.</span><span class="n">JSONObject</span><span class="p">(</span><span class="n">let</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">value</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">var</span> <span class="nl">array:</span> <span class="p">[</span><span class="n">JSONValue</span><span class="p">]</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">switch</span> <span class="n">self</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">.</span><span class="n">JSONArray</span><span class="p">(</span><span class="n">let</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">value</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">var</span> <span class="nl">string:</span> <span class="n">String</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">switch</span> <span class="n">self</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">.</span><span class="n">JSONString</span><span class="p">(</span><span class="n">let</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">value</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">var</span> <span class="nl">integer:</span> <span class="n">Int</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">switch</span> <span class="n">self</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">.</span><span class="n">JSONNumber</span><span class="p">(</span><span class="n">let</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">integerValue</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">var</span> <span class="kt">double</span><span class="o">:</span> <span class="n">Double</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">switch</span> <span class="n">self</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">.</span><span class="n">JSONNumber</span><span class="p">(</span><span class="n">let</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">doubleValue</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">var</span> <span class="nl">bool:</span> <span class="n">Bool</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">switch</span> <span class="n">self</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">.</span><span class="n">JSONBool</span><span class="p">(</span><span class="n">let</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">value</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">.</span><span class="n">JSONNumber</span><span class="p">(</span><span class="n">let</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">boolValue</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后将对象转化为JSONValue也需要一个方法，而且是递归调用的，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">static</span> <span class="n">func</span> <span class="nf">fromObject</span><span class="p">(</span><span class="nl">object:</span> <span class="n">AnyObject</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JSONValue</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">switch</span> <span class="n">object</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">let</span> <span class="n">value</span> <span class="n">as</span> <span class="nl">NSString:</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">JSONValue</span><span class="p">.</span><span class="n">JSONString</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">let</span> <span class="n">value</span> <span class="n">as</span> <span class="nl">NSNumber:</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">JSONValue</span><span class="p">.</span><span class="n">JSONNumber</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">let</span> <span class="n">value</span> <span class="n">as</span> <span class="nl">NSNull:</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">JSONValue</span><span class="p">.</span><span class="n">JSONNull</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">let</span> <span class="n">value</span> <span class="n">as</span> <span class="nl">NSDictionary:</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">jsonObject:</span> <span class="p">[</span><span class="nl">String:</span><span class="n">JSONValue</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">:</span><span class="p">]</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="nl">k:</span> <span class="n">AnyObject</span><span class="p">,</span> <span class="nl">v:</span> <span class="n">AnyObject</span><span class="p">)</span> <span class="k">in</span> <span class="n">value</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">let</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="n">as</span><span class="o">?</span> <span class="n">NSString</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">JSONValue</span><span class="p">.</span><span class="n">fromObject</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">jsonObject</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">JSONValue</span><span class="p">.</span><span class="n">JSONObject</span><span class="p">(</span><span class="n">jsonObject</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">let</span> <span class="n">value</span> <span class="n">as</span> <span class="nl">NSArray:</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">jsonArray:</span> <span class="p">[</span><span class="n">JSONValue</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">value</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">JSONValue</span><span class="p">.</span><span class="n">fromObject</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">jsonArray</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">JSONValue</span><span class="p">.</span><span class="n">JSONArray</span><span class="p">(</span><span class="n">jsonArray</span><span class="p">)</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Putting it into practice</h3>

<p>现在让我们使用JSON.swift来完成JSON的解析，进过比较，现在只需要两层嵌套就完成了原来五层的嵌套解析，而且由于使用了Optional类型，也增加了安全性。所以在Swift中一定要注重利用enum这些新特性，它非常适用于可以预定义为一组不同的子类型的类型，就像JSON。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">json</span> <span class="o">=</span> <span class="s">&quot;{</span><span class="se">\&quot;</span><span class="s">success</span><span class="se">\&quot;</span><span class="s">:true,</span><span class="se">\&quot;</span><span class="s">data</span><span class="se">\&quot;</span><span class="s">:{</span><span class="se">\&quot;</span><span class="s">numbers</span><span class="se">\&quot;</span><span class="s">:[1,2,3,4,5],</span><span class="se">\&quot;</span><span class="s">animal</span><span class="se">\&quot;</span><span class="s">:</span><span class="se">\&quot;</span><span class="s">dog</span><span class="se">\&quot;</span><span class="s">}}&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">jsonData</span> <span class="o">=</span> <span class="p">(</span><span class="n">json</span> <span class="n">as</span> <span class="n">NSString</span><span class="p">).</span><span class="n">dataUsingEncoding</span><span class="p">(</span><span class="n">NSUTF8StringEncoding</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">let</span> <span class="nl">parsed:</span> <span class="n">AnyObject</span> <span class="o">=</span> <span class="n">NSJSONSerialization</span><span class="p">.</span><span class="n">JSONObjectWithData</span><span class="p">(</span><span class="n">jsonData</span><span class="p">,</span> <span class="nl">options:</span> <span class="n">NSJSONReadingOptions</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nl">error:</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">let</span> <span class="n">jsonParsed</span> <span class="o">=</span> <span class="n">JSONValue</span><span class="p">.</span><span class="n">fromObject</span><span class="p">(</span><span class="n">parsed</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// Actual JSON parsing section</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">jsonParsed</span><span class="p">[</span><span class="s">&quot;success&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="n">bool</span> <span class="o">==</span> <span class="n">true</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">let</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">jsonParsed</span><span class="p">[</span><span class="s">&quot;data&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">[</span><span class="s">&quot;numbers&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="n">array</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">let</span> <span class="n">animal</span> <span class="o">=</span> <span class="n">jsonParsed</span><span class="p">[</span><span class="s">&quot;data&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">[</span><span class="s">&quot;animal&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="n">string</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">print</span><span class="p">(</span><span class="n">animal</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CALayer&amp;CoreAnimation]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/09/calayer-and-coreanimation/"/>
    <updated>2015-11-09T10:18:03+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/09/calayer-and-coreanimation</id>
    <content type="html"><![CDATA[<p>这两天打算系统的整理一下CALayer和CoreAnimation相关的知识，之前开发中只是在具体场景中使用时才会去找相应的解决方法，而没有系统的进行整理，所以打算开一篇专门介绍。这一篇<a href="http://www.cnblogs.com/kenshincui/p/3972100.html">博客</a>也做了详尽的介绍，本文的思路也与其基本一致，另外会记录自己的一些理解。</p>

<!--more-->


<h2>CALayer相关</h2>

<p>CALayer包含在QuartzCore框架中。它与UIView的区别是，UIView是UIResponder的子类，是可以接受事件并做出响应的，而CALayer是NSObject的子类，它只是用来展示内容的类。而UIView有一个layer属性就是用来绘制其图像的，而复杂的图层结构在CALayer中是以树的形式存储的，而CoreAnimation中的动画都是在CALayer上进行操作的，可能我们在开发中大部分是直接在UIView组织动画，而这些其实是CoreAnimation在UIView层的封装，本质还是对其layer属性进行操作。</p>

<p><img src="http://lucifer1988.github.io/images/CALayerTree.png"></p>

<h3>CALayer属性</h3>

<p>下表列出了CALayer常用的一些属性：</p>

<table>
<thead>
<tr>
<th></th>
<th> 属性 </th>
<th> 说明 </th>
<th align="center"> 是否支持隐式动画 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> anchorPoint </td>
<td> 锚点，CGPoint类型，默认为(0.5,0.5)，可以理解为layer的重心，始终与position位置重合 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> backgroundColor </td>
<td> 背景色  </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> borderColor </td>
<td> 边框颜色  </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> borderWidth </td>
<td> 边框宽度  </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> bounds </td>
<td> 范围大小  </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> contents </td>
<td> id类型，layer显示内容，通常是CGImageRef类型 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> contentsRect </td>
<td> layer内容的位置和范围  </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> cornerRadius </td>
<td> 圆角半径 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> doubleSided </td>
<td> 图层背面是否显示，默认YES  </td>
<td align="center"> 否 </td>
</tr>
<tr>
<td></td>
<td> frame </td>
<td> layer的位置和范围，由于不支持隐式动画，所以改变layer的位置和大小，通常使用修改bounds和position来替代 </td>
<td align="center"> 否 </td>
</tr>
<tr>
<td></td>
<td> hidden </td>
<td> 是否隐藏 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> mask </td>
<td> 图层蒙版 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> maskToBounds </td>
<td> 子图层是否剪切图层边界，默认NO </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> opacity </td>
<td> 透明度，类似UIView的alpha </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> position </td>
<td> layer中心位置，类似UIView的center </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> shadowColor </td>
<td> 阴影颜色 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> shadowOffset </td>
<td> 阴影偏移量 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> shadowOpacity </td>
<td> 阴影透明度，默认为0，所以设置阴影时必须设置此值 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> shadowPath</td>
<td> 阴影形状 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> shadowRadius </td>
<td> 阴影模糊半径 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> sublayers </td>
<td> 子图层数组 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> sublayerTransform </td>
<td> 子图层形变 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> transform </td>
<td> 图层形变 </td>
<td align="center"> 是 </td>
</tr>
</tbody>
</table>


<h3>隐式动画</h3>

<p>CALayer很多属性在修改时就能形成动画，被称为隐式动画，但是需要注意UIView的根视图layer的属性修改并不会形成动画，因为根图层一般是作为容器来使用，修改它的属性可能会直接影响子图层。另外，UIView的根图层是由系统创建的，而无法重新创建，但可以添加子图层。</p>

<p>隐式动画的本质是这些属性的变化默认实现了CABasicAnimation，具体见<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/AnimatableProperties/AnimatableProperties.html#//apple_ref/doc/uid/TP40004514-CH11-SW2">Apple文档</a>，具体示例见<a href="https://github.com/lucifer1988/AnimationCase">AnimationCase</a>中的AnimatablePropertiesTest。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">ACAnimatablePropertiesViewController</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CALayer</span> <span class="o">*</span><span class="n">layer</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="n">CGFloat</span> <span class="n">width</span> <span class="o">=</span> <span class="mf">150.0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ACAnimatablePropertiesViewController</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// Do any additional setup after loading the view.</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">layer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CALayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">blueColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">shadowColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">grayColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">shadowOffset</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">shadowOpacity</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">borderWidth</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">borderColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">greenColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">layer</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesEnded:</span><span class="p">(</span><span class="n">NSSet</span><span class="o">&lt;</span><span class="n">UITouch</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UITouch</span> <span class="o">*</span><span class="n">touch</span> <span class="o">=</span> <span class="p">[</span><span class="n">touches</span> <span class="n">anyObject</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">randWidth</span> <span class="o">=</span> <span class="n">arc4random</span><span class="p">()</span><span class="o">%</span><span class="mi">200</span><span class="o">+</span><span class="mi">100</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">randWidth</span><span class="p">,</span> <span class="n">randWidth</span><span class="p">);</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">randWidth</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="n">touch</span> <span class="nl">locationInView:</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nl">colorWithRed:</span><span class="n">arc4random</span><span class="p">()</span><span class="o">%</span><span class="mi">225</span><span class="o">/</span><span class="mf">225.0</span> <span class="nl">green:</span><span class="n">arc4random</span><span class="p">()</span><span class="o">%</span><span class="mi">225</span><span class="o">/</span><span class="mf">225.0</span> <span class="nl">blue:</span><span class="n">arc4random</span><span class="p">()</span><span class="o">%</span><span class="mi">225</span><span class="o">/</span><span class="mf">225.0</span> <span class="nl">alpha:</span><span class="mf">1.0</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">borderColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nl">colorWithRed:</span><span class="n">arc4random</span><span class="p">()</span><span class="o">%</span><span class="mi">225</span><span class="o">/</span><span class="mf">225.0</span> <span class="nl">green:</span><span class="n">arc4random</span><span class="p">()</span><span class="o">%</span><span class="mi">225</span><span class="o">/</span><span class="mf">225.0</span> <span class="nl">blue:</span><span class="n">arc4random</span><span class="p">()</span><span class="o">%</span><span class="mi">225</span><span class="o">/</span><span class="mf">225.0</span> <span class="nl">alpha:</span><span class="mf">1.0</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Reference/CALayer_class/index.html#//apple_ref/occ/instp/CALayer/anchorPoint">AnchorPoint</a>的作用：图层的锚点，范围在（0~1,0~1）表示在x、y轴的比例，这个点永远可以同position重合，当图层中心点固定后，调整anchorPoint即可达到调整图层显示位置的作用（因为它永远和position重合），类似旋转动画中，改变anchorPoint的值可以改变旋转的中心位置，详见<a href="https://github.com/lucifer1988/AnimationCase">AnimationCase</a>中的AnchorPointTest。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">ACAnchorPointViewController</span> <span class="p">()</span> <span class="o">&lt;</span><span class="n">UITextFieldDelegate</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CALayer</span> <span class="o">*</span><span class="n">layer</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">weak</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="kt">IBOutlet</span> <span class="n">UITextField</span> <span class="o">*</span><span class="n">xField</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">weak</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="kt">IBOutlet</span> <span class="n">UITextField</span> <span class="o">*</span><span class="n">yField</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ACAnchorPointViewController</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// Do any additional setup after loading the view.</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">layer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CALayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">lightGrayColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">150.0</span><span class="p">,</span> <span class="mf">150.0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">rotationAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="nl">animationWithKeyPath:</span><span class="s">@&quot;transform.rotation.z&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">rotationAnimation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">rotationAnimation</span><span class="p">.</span><span class="n">repeatCount</span> <span class="o">=</span> <span class="n">HUGE_VALF</span><span class="p">;</span>
</span><span class='line'>    <span class="n">rotationAnimation</span><span class="p">.</span><span class="n">removedOnCompletion</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="n">rotationAnimation</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithFloat:</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>    <span class="n">rotationAnimation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithFloat:</span><span class="mf">3.1415926</span><span class="o">*</span><span class="mi">2</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">layer</span> <span class="nl">addAnimation:</span><span class="n">rotationAnimation</span> <span class="nl">forKey:</span><span class="s">@&quot;rotationTransform&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">layer</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - UITextFieldDelegate</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">textFieldShouldReturn:</span><span class="p">(</span><span class="n">UITextField</span> <span class="o">*</span><span class="p">)</span><span class="nv">textField</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">double</span> <span class="n">value</span> <span class="o">=</span> <span class="n">textField</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="n">length</span> <span class="o">?</span> <span class="n">textField</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="n">doubleValue</span> <span class="o">:</span> <span class="mf">0.5</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">UIAlertController</span> <span class="o">*</span><span class="n">alert</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIAlertController</span> <span class="nl">alertControllerWithTitle:</span><span class="s">@&quot;输入值必须介于0到1&quot;</span> <span class="nl">message:</span><span class="nb">nil</span> <span class="nl">preferredStyle:</span><span class="n">UIAlertControllerStyleAlert</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">alert</span> <span class="nl">addAction:</span><span class="p">[</span><span class="n">UIAlertAction</span> <span class="nl">actionWithTitle:</span><span class="s">@&quot;我知道了&quot;</span> <span class="nl">style:</span><span class="n">UIAlertActionStyleCancel</span> <span class="nl">handler:</span><span class="nb">nil</span><span class="p">]];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span> <span class="nl">presentViewController:</span><span class="n">alert</span> <span class="nl">animated:</span><span class="n">YES</span> <span class="nl">completion:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">textField</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="n">xField</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CGPoint</span> <span class="n">point</span> <span class="o">=</span> <span class="n">layer</span><span class="p">.</span><span class="n">anchorPoint</span><span class="p">;</span>
</span><span class='line'>        <span class="n">point</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'>        <span class="n">layer</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">point</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CGPoint</span> <span class="n">point</span> <span class="o">=</span> <span class="n">layer</span><span class="p">.</span><span class="n">anchorPoint</span><span class="p">;</span>
</span><span class='line'>        <span class="n">point</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'>        <span class="n">layer</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">point</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">[</span><span class="n">textField</span> <span class="n">resignFirstResponder</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>CALayer绘图</h3>

<p>CALayer的绘图方法主要有两种，不过都需要调用layer的setNeedDisplay方法（需要注意的是必须是layer调用，而不是UIView，因为UIView也有一个setNeedDisplay方法）。</p>

<ul>
<li>通过实现代理方法<strong>drawLayer:inContext:</strong>来绘制</li>
<li>通过自定义图层<strong>drawInContext:</strong>来绘制</li>
</ul>


<h4>实现代理方法绘制layer</h4>

<p>通过代理方法进行图层绘图只要指定图层的代理，然后在代理对象中重写-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx方法即可。需要注意这个方法虽然是代理方法但是不用手动实现CALayerDelegate，因为CALayer定义中给NSObject做了分类扩展，所有的NSObject都包含这个方法。另外设置完代理后必须要调用图层的setNeedDisplay方法，否则绘制的内容无法显示。</p>

<p>使用代理方法绘制图形、图像时在drawLayer:inContext:方法中可以通过事件参数获得绘制的图层和图形上下文。在这个方法中绘图时所有的位置都是相对于图层而言的，图形上下文指的也是当前图层的图形上下文，详见<a href="https://github.com/lucifer1988/AnimationCase">AnimationCase</a>中的DrawLayerByDelegateTest。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">ACDrawLayerByDelegateViewController</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CALayer</span> <span class="o">*</span><span class="n">layer</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="n">CGFloat</span> <span class="n">width</span> <span class="o">=</span> <span class="mf">150.0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ACDrawLayerByDelegateViewController</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// Do any additional setup after loading the view.</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">layer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CALayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">blueColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">masksToBounds</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">borderWidth</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">borderColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">grayColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">layer</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">layer</span> <span class="n">setNeedsDisplay</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - layer delegate</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawLayer:</span><span class="p">(</span><span class="n">CALayer</span> <span class="o">*</span><span class="p">)</span><span class="nv">layer</span> <span class="nf">inContext:</span><span class="p">(</span><span class="n">CGContextRef</span><span class="p">)</span><span class="nv">ctx</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CGContextSaveGState</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGContextScaleCTM</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">width</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;avatar.png&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="n">image</span><span class="p">.</span><span class="n">CGImage</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGContextRestoreGState</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外需要注意的是上面代码中绘制图片圆形裁切效果时如果不设置masksToBounds是无法显示圆形，但是对于其他图形却没有这个限制。原因就是当绘制一张图片到图层上的时候会重新创建一个图层添加到当前图层，这样一来如果设置了圆角之后虽然底图层有圆角效果，但是子图层还是矩形，只有设置了masksToBounds为YES让子图层按底图层剪切才能显示圆角效果。同样的，有些朋友经常在网上提问说为什么使用UIImageView的layer设置圆角后图片无法显示圆角，只有设置masksToBounds才能出现效果，也是类似的问题。</p>

<h4>自定义layer来绘制</h4>

<p>在自定义图层中绘图时只要自己编写一个类继承于CALayer然后在drawInContext:中绘图即可。同前面在代理方法绘图一样，要显示图层中绘制的内容也要调用图层的setNeedDisplay方法，否则drawInContext方法将不会调用，详见<a href="https://github.com/lucifer1988/AnimationCase">AnimationCase</a>中的DrawLayerByCustomTest。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@implementation</span> <span class="nc">ACCustomLayer</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawInContext:</span><span class="p">(</span><span class="n">CGContextRef</span><span class="p">)</span><span class="nv">ctx</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CGContextSetRGBFillColor</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mf">135.0</span><span class="o">/</span><span class="mf">255.0</span><span class="p">,</span> <span class="mf">232.0</span><span class="o">/</span><span class="mf">255.0</span><span class="p">,</span> <span class="mf">84.0</span><span class="o">/</span><span class="mf">255.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGContextSetRGBStrokeColor</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mf">135.0</span><span class="o">/</span><span class="mf">255.0</span><span class="p">,</span> <span class="mf">232.0</span><span class="o">/</span><span class="mf">255.0</span><span class="p">,</span> <span class="mf">84.0</span><span class="o">/</span><span class="mf">255.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGPoint</span> <span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="mf">60.0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CGFloat</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">60.0</span> <span class="o">*</span> <span class="n">sinf</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">M_PI</span> <span class="o">/</span> <span class="mf">5.0</span><span class="p">);</span>
</span><span class='line'>        <span class="n">CGFloat</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">60.0</span> <span class="o">*</span> <span class="n">cosf</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">M_PI</span> <span class="o">/</span> <span class="mf">5.0</span><span class="p">);</span>
</span><span class='line'>        <span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">y</span><span class="p">);</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;x:%f, y:%f&quot;</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">y</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGContextClosePath</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGContextDrawPath</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">kCGPathFillStroke</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">ACDrawLayerCustomViewController</span> <span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ACDrawLayerCustomViewController</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// Do any additional setup after loading the view.</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">ACCustomLayer</span> <span class="o">*</span><span class="n">layer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ACCustomLayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">blueColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">layer</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">layer</span> <span class="n">setNeedsDisplay</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>带阴影效果的圆形图片裁切</h3>

<p>如果设置了masksToBounds=YES之后确实可以显示图片圆角效果，但遗憾的是设置了这个属性之后就无法设置阴影效果。因为masksToBounds=YES就意味着外边框不能显示，而阴影恰恰作为外边框绘制的，这样两个设置就产生了矛盾。要解决这个问题不妨换个思路:使用两个大小一样的图层，下面的图层负责绘制阴影，上面的图层用来显示图片。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">ACCircleAvatarWithShadowViewController</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CALayer</span> <span class="o">*</span><span class="n">layer</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="n">CGFloat</span> <span class="n">width</span> <span class="o">=</span> <span class="mf">150.0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ACCircleAvatarWithShadowViewController</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// Do any additional setup after loading the view.</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CALayer</span> <span class="o">*</span><span class="n">shadowLayer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CALayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">shadowLayer</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
</span><span class='line'>    <span class="n">shadowLayer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="n">shadowLayer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">whiteColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'>    <span class="n">shadowLayer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">shadowLayer</span><span class="p">.</span><span class="n">shadowOffset</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="n">shadowLayer</span><span class="p">.</span><span class="n">shadowColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">grayColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'>    <span class="n">shadowLayer</span><span class="p">.</span><span class="n">shadowOpacity</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">shadowLayer</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">layer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CALayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">blueColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">masksToBounds</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">borderWidth</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">borderColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">grayColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">layer</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">layer</span> <span class="n">setNeedsDisplay</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - layer delegate</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawLayer:</span><span class="p">(</span><span class="n">CALayer</span> <span class="o">*</span><span class="p">)</span><span class="nv">layer</span> <span class="nf">inContext:</span><span class="p">(</span><span class="n">CGContextRef</span><span class="p">)</span><span class="nv">ctx</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CGContextSaveGState</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGContextScaleCTM</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">width</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;avatar.png&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="n">image</span><span class="p">.</span><span class="n">CGImage</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGContextRestoreGState</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>CALayer形变</h3>

<p>从上面代码中大家不难发现使用Core Graphics绘制图片时会倒立显示，对图层的图形上下文进行了反转。可以控制图层直接旋转而不用借助于图形上下文的形变操作。对于上面的程序，只需要设置图层的transform属性即可。需要注意的是transform是CATransform3D类型，形变可以在三个维度上进行，而且都有对应的形变设置方法（如：CATransform3DMakeTranslation()、CATransform3DMakeScale()、CATransform3DMakeRotation()）。</p>

<p>事实上如果仅仅就显示一张图片在图层中当然没有必要那么麻烦，直接设置图层contents就可以了，不牵涉到绘图也就没有倒立的问题了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//Plan B</span>
</span><span class='line'><span class="n">CALayer</span> <span class="o">*</span><span class="n">anotherlayer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CALayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="n">anotherlayer</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
</span><span class='line'><span class="n">center</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">width</span><span class="p">;</span>
</span><span class='line'><span class="n">anotherlayer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">center</span><span class="p">;</span>
</span><span class='line'><span class="n">anotherlayer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">blueColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'><span class="n">anotherlayer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'><span class="n">anotherlayer</span><span class="p">.</span><span class="n">masksToBounds</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'><span class="n">anotherlayer</span><span class="p">.</span><span class="n">borderColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">grayColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'><span class="n">anotherlayer</span><span class="p">.</span><span class="n">borderWidth</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
</span><span class='line'><span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span><span class="o">=</span><span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;avatar.png&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">anotherlayer</span> <span class="nl">setContents:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">image</span><span class="p">.</span><span class="n">CGImage</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">anotherlayer</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>在动画开发中形变往往不是直接设置transform，而是通过keyPath进行设置。这种方法设置形变的本质和前面没有区别，只是利用了KVC可以动态修改其属性值而已，但是这种方式在动画中确实很常用的，因为它可以很方便的将几种形变组合到一起使用。key path的所有设置类型，见<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html#//apple_ref/doc/uid/TP40004514-CH12-SW1">Apple文档</a>，同样是解决动画旋转问题，只要将前面的旋转代码改为下面的代码即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">[</span><span class="n">layer</span> <span class="nl">setValue:</span><span class="err">@</span><span class="n">M_PI</span> <span class="nl">forKeyPath:</span><span class="s">@&quot;transform.rotation.x&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h2>CoreAnimation相关</h2>

<p>在iOS中CoreAnimation分为几类：基础动画、关键帧动画、动画组、转场动画。各个类的关系大致如下：</p>

<p><img src="http://lucifer1988.github.io/images/CAAnimationTree.png"></p>

<ul>
<li>CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议。</li>
<li>CAPropertyAnimation：属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用。</li>
<li>CAAnimationGroup：动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行。</li>
<li>CATransition：转场动画，主要通过滤镜进行动画效果设置。</li>
<li>CABasicAnimation：基础动画，通过属性修改进行动画参数控制，只有初始状态和结束状态。</li>
<li>CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制。</li>
</ul>


<p>基础动画、关键帧动画都属于属性动画，就是通过修改属性值产生动画效果，开发人员只需要设置初始值和结束值，中间的过程动画（又叫“补间动画”）由系统自动计算产生。和基础动画不同的是关键帧动画可以设置多个属性值，每两个属性中间的补间动画由系统自动完成，因此从这个角度而言基础动画又可以看成是有两个关键帧的关键帧动画。</p>

<h3>基础动画</h3>

<p>在开发过程中很多情况下通过基础动画就可以满足开发需求，使用的UIView代码块制作的动画也是基础动画（在iOS7中UIView也对关键帧动画进行了封装），只是UIView装饰方法隐藏了更多的细节。如果不使用UIView封装的方法，动画创建一般分为以下几步：</p>

<ol>
<li><p>初始化动画并设置动画属性</p></li>
<li><p>设置动画属性初始值（可以省略）、结束值以及其他动画属性</p></li>
<li><p>给图层添加动画</p></li>
</ol>


<h4>移动动画</h4>

<p>下面以一个移动动画为例进行演示，在这个例子中点击屏幕哪个位置落花将飞向哪里：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">ACMoveAnimationViewController</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CALayer</span> <span class="o">*</span><span class="n">petalLayer</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ACMoveAnimationViewController</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// Do any additional setup after loading the view.</span>
</span><span class='line'>    <span class="n">UIImage</span> <span class="o">*</span><span class="n">backgroundImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;background.jpg&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">backgroundImage</span><span class="p">.</span><span class="n">CGImage</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">petalLayer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CALayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="p">)[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;petal.png&quot;</span><span class="p">].</span><span class="n">CGImage</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">petalLayer</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesEnded:</span><span class="p">(</span><span class="n">NSSet</span><span class="o">&lt;</span><span class="n">UITouch</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UITouch</span> <span class="o">*</span><span class="n">touch</span> <span class="o">=</span> <span class="n">touches</span><span class="p">.</span><span class="n">anyObject</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">animationMoveTo:</span><span class="p">[</span><span class="n">touch</span> <span class="nl">locationInView:</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">]];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - Animation</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animationMoveTo:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">location</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">moveAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="nl">animationWithKeyPath:</span><span class="s">@&quot;position&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">moveAnimation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGPoint:</span><span class="n">location</span><span class="p">];</span>
</span><span class='line'>    <span class="n">moveAnimation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">moveAnimation</span><span class="p">.</span><span class="n">repeatCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">moveAnimation</span><span class="p">.</span><span class="n">removedOnCompletion</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">petalLayer</span> <span class="nl">addAnimation:</span><span class="n">moveAnimation</span> <span class="nl">forKey:</span><span class="s">@&quot;petalLayer_moveAnimation&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h4>完整移动动画</h4>

<p>上面实现了一个基本动画效果，但是这个动画存在一个问题：动画结束后动画图层回到了原来的位置。</p>

<p>图层动画的本质就是将图层内部的内容转化为位图经硬件操作形成一种动画效果，其实图层本身并没有任何的变化。上面的动画中图层并没有因为动画效果而改变它的位置（对于缩放动画其大小也是不会改变的），所以动画完成之后图层还是在原来的显示位置没有任何变化，如果这个图层在一个UIView中你会发现在UIView移动过程中你要触发UIView的点击事件也只能点击原来的位置（即使它已经运动到了别的位置），因为它的位置从来没有变过。</p>

<p>通过给动画设置一个代理去监听动画的开始和结束事件，在动画开始前给动画添加一个自定义属性“petalLayer_moveAnimation_destination”存储动画终点位置，然后在动画结束后设置动画的位置为终点位置。在<strong>&ndash; (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag</strong>中设置代码关闭了position的隐式动画，否则会导致两次移动，另外添加了使花瓣匀速移动的时间计算，和防止多次点击的flag控制。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">ACMoveAnimationFullEditionViewController</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CALayer</span> <span class="o">*</span><span class="n">petalLayer</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">isMoving</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ACMoveAnimationFullEditionViewController</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">isMoving</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="n">UIImage</span> <span class="o">*</span><span class="n">backgroundImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;background.jpg&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">backgroundImage</span><span class="p">.</span><span class="n">CGImage</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">petalLayer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CALayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="p">)[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;petal.png&quot;</span><span class="p">].</span><span class="n">CGImage</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">petalLayer</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">didReceiveMemoryWarning</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">didReceiveMemoryWarning</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// Dispose of any resources that can be recreated.</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesEnded:</span><span class="p">(</span><span class="n">NSSet</span><span class="o">&lt;</span><span class="n">UITouch</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">isMoving</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">UITouch</span> <span class="o">*</span><span class="n">touch</span> <span class="o">=</span> <span class="n">touches</span><span class="p">.</span><span class="n">anyObject</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">animationMoveTo:</span><span class="p">[</span><span class="n">touch</span> <span class="nl">locationInView:</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">]];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - Animation</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animationMoveTo:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">location</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">moveAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="nl">animationWithKeyPath:</span><span class="s">@&quot;position&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">moveAnimation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGPoint:</span><span class="n">location</span><span class="p">];</span>
</span><span class='line'>    <span class="n">moveAnimation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">petalMoveDuring:</span><span class="n">location</span><span class="p">];</span>
</span><span class='line'>    <span class="n">moveAnimation</span><span class="p">.</span><span class="n">repeatCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">moveAnimation</span><span class="p">.</span><span class="n">removedOnCompletion</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">moveAnimation</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">moveAnimation</span> <span class="nl">setValue:</span><span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGPoint:</span><span class="n">location</span><span class="p">]</span> <span class="nl">forKey:</span><span class="s">@&quot;petalLayer_moveAnimation_destination&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">petalLayer</span> <span class="nl">addAnimation:</span><span class="n">moveAnimation</span> <span class="nl">forKey:</span><span class="s">@&quot;petalLayer_moveAnimation&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nf">petalMoveDuring:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">destination</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">deltaX</span> <span class="o">=</span> <span class="n">destination</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">petalLayer</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">deltaY</span> <span class="o">=</span> <span class="n">destination</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">petalLayer</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">deltaX</span><span class="o">*</span><span class="n">deltaX</span> <span class="o">+</span> <span class="n">deltaY</span><span class="o">*</span><span class="n">deltaY</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="n">distance</span><span class="o">/</span><span class="mf">50.0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - Animation Delegate</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animationDidStart:</span><span class="p">(</span><span class="n">CAAnimation</span> <span class="o">*</span><span class="p">)</span><span class="nv">anim</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">isMoving</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animationDidStop:</span><span class="p">(</span><span class="n">CAAnimation</span> <span class="o">*</span><span class="p">)</span><span class="nv">anim</span> <span class="nf">finished:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">flag</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">CATransaction</span> <span class="n">begin</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">//禁用隐式动画</span>
</span><span class='line'>    <span class="p">[</span><span class="n">CATransaction</span> <span class="nl">setDisableActions:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">position</span><span class="o">=</span><span class="p">[[</span><span class="n">anim</span> <span class="nl">valueForKey:</span><span class="s">@&quot;petalLayer_moveAnimation_destination&quot;</span><span class="p">]</span> <span class="n">CGPointValue</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">CATransaction</span> <span class="n">commit</span><span class="p">];</span>
</span><span class='line'>    <span class="n">isMoving</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h4>旋转动画</h4>

<p>图层的形变都是基于锚点进行的。例如旋转，旋转的中心点就是图层的锚点，这在最开始的锚点例子中也有介绍。</p>

<p>需要注意的是只给移动动画设置了代理，在旋转动画中并没有设置代理，否则代理方法会执行两遍。由于旋转动画会无限循环执行（上面设置了重复次数无穷大），并且两个动画的执行时间没有必然的关系，这样一来移动停止后可能还在旋转，为了让移动动画停止后旋转动画停止就需要使用到动画的暂停和恢复方法。</p>

<p>核心动画的运行有一个媒体时间的概念，假设将一个旋转动画设置旋转一周用时60秒的话，那么当动画旋转90度后媒体时间就是15秒。如果此时要将动画暂停只需要让媒体时间偏移量设置为15秒即可，并把动画运行速度设置为0使其停止运动。类似的，如果又过了60秒后需要恢复动画（此时媒体时间为75秒），这时只要将动画开始开始时间设置为当前媒体时间75秒减去暂停时的时间（也就是之前定格动画时的偏移量）15秒（开始时间=75-15=60秒），那么动画就会重新计算60秒后的状态再开始运行，与此同时将偏移量重新设置为0并且把运行速度设置1。这个过程中真正起到暂停动画和恢复动画的其实是动画速度的调整，媒体时间偏移量以及恢复时的开始时间设置主要为了让动画更加连贯。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animationRotate</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">rotateAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="nl">animationWithKeyPath:</span><span class="s">@&quot;transform.rotation.z&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">rotateAnimation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span><span class='line'>    <span class="n">rotateAnimation</span><span class="p">.</span><span class="n">repeatCount</span> <span class="o">=</span> <span class="n">HUGE_VALF</span><span class="p">;</span>
</span><span class='line'>    <span class="n">rotateAnimation</span><span class="p">.</span><span class="n">removedOnCompletion</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="n">rotateAnimation</span><span class="p">.</span><span class="n">autoreverses</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="n">rotateAnimation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithFloat:</span><span class="n">M_PI_2</span><span class="o">*</span><span class="mi">3</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">petalLayer</span> <span class="nl">addAnimation:</span><span class="n">rotateAnimation</span> <span class="nl">forKey:</span><span class="s">@&quot;petalLayer_rotationAnimation&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animationPause</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">//取得指定图层动画的媒体时间，后面参数用于指定子图层，这里不需要</span>
</span><span class='line'>    <span class="n">CFTimeInterval</span> <span class="n">interval</span> <span class="o">=</span> <span class="p">[</span><span class="n">petalLayer</span> <span class="nl">convertTime:</span><span class="n">CACurrentMediaTime</span><span class="p">()</span> <span class="nl">fromLayer:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">//设置时间偏移量，保证暂停时停留在旋转的位置</span>
</span><span class='line'>    <span class="p">[</span><span class="n">petalLayer</span> <span class="nl">setTimeOffset:</span><span class="n">interval</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">//速度设置为0，暂停动画</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animationResume</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">//获得暂停的时间</span>
</span><span class='line'>    <span class="n">CFTimeInterval</span> <span class="n">beginTime</span> <span class="o">=</span> <span class="n">CACurrentMediaTime</span><span class="p">()</span> <span class="o">-</span> <span class="n">petalLayer</span><span class="p">.</span><span class="n">timeOffset</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">//设置偏移量</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">timeOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">//设置开始时间</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">beginTime</span> <span class="o">=</span> <span class="n">beginTime</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">//设置动画速度，开始运动</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>关键帧动画</h3>

<p>熟悉flash开发的朋友对于关键帧动画应该不陌生，这种动画方式在flash开发中经常用到。关键帧动画就是在动画控制过程中开发者指定主要的动画状态，至于各个状态间动画如何进行则由系统自动运算补充（每两个关键帧之间系统形成的动画称为“补间动画”），这种动画的好处就是开发者不用逐个控制每个动画帧，而只要关心几个关键帧的状态即可。</p>

<p>关键帧动画开发分为两种形式：一种是通过设置不同的属性值进行关键帧控制，另一种是通过绘制路径进行关键帧控制。后者优先级高于前者，如果设置了路径则属性值就不再起作用。</p>

<h4>设置属性值的关键帧控制</h4>

<p>对于前面的落花动画效果而言其实落花的过程并不自然，很显然实际生活中它不可能沿着直线下落，这里我们不妨通过关键帧动画的values属性控制它在下落过程中的属性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">ACKeyFrameAnimationViewController</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CALayer</span> <span class="o">*</span><span class="n">petalLayer</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ACKeyFrameAnimationViewController</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// Do any additional setup after loading the view.</span>
</span><span class='line'>    <span class="n">UIImage</span> <span class="o">*</span><span class="n">backgroundImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;background.jpg&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">backgroundImage</span><span class="p">.</span><span class="n">CGImage</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">petalLayer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CALayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="p">)[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;petal.png&quot;</span><span class="p">].</span><span class="n">CGImage</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">petalLayer</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="n">addKeyframeMoveAnimation</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">didReceiveMemoryWarning</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">didReceiveMemoryWarning</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// Dispose of any resources that can be recreated.</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - animation</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addKeyframeMoveAnimation</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CAKeyframeAnimation</span> <span class="o">*</span><span class="n">keyframeAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAKeyframeAnimation</span> <span class="nl">animationWithKeyPath:</span><span class="s">@&quot;position&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">//关键帧动画的初始值不能省略</span>
</span><span class='line'>    <span class="n">NSValue</span> <span class="o">*</span><span class="n">key1</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGPoint:</span><span class="n">petalLayer</span><span class="p">.</span><span class="n">position</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSValue</span> <span class="o">*</span><span class="n">key2</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="mi">320</span><span class="p">)];</span>
</span><span class='line'>    <span class="n">NSValue</span> <span class="o">*</span><span class="n">key3</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="mi">400</span><span class="p">)];</span>
</span><span class='line'>    <span class="n">NSValue</span> <span class="o">*</span><span class="n">key4</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">55</span><span class="p">,</span> <span class="mi">500</span><span class="p">)];</span>
</span><span class='line'>    <span class="n">NSArray</span> <span class="o">*</span><span class="n">values</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="n">key1</span><span class="p">,</span> <span class="n">key2</span><span class="p">,</span> <span class="n">key3</span><span class="p">,</span> <span class="n">key4</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">keyframeAnimation</span><span class="p">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">;</span>
</span><span class='line'>    <span class="n">keyframeAnimation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">8.0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">keyframeAnimation</span><span class="p">.</span><span class="n">beginTime</span> <span class="o">=</span> <span class="n">CACurrentMediaTime</span><span class="p">()</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">keyframeAnimation</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">keyframeAnimation</span> <span class="nl">setValue:</span><span class="n">key4</span> <span class="nl">forKey:</span><span class="s">@&quot;petalLayer_keyframeAnimation_destination&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">petalLayer</span> <span class="nl">addAnimation:</span><span class="n">keyframeAnimation</span> <span class="nl">forKey:</span><span class="s">@&quot;petalLayer_keyframeAnimation_position&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - animation delegate</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animationDidStart:</span><span class="p">(</span><span class="n">CAAnimation</span> <span class="o">*</span><span class="p">)</span><span class="nv">anim</span> <span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animationDidStop:</span><span class="p">(</span><span class="n">CAAnimation</span> <span class="o">*</span><span class="p">)</span><span class="nv">anim</span> <span class="nf">finished:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">flag</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">CATransaction</span> <span class="n">begin</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">CATransaction</span> <span class="nl">setDisableActions:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="p">[[</span><span class="n">anim</span> <span class="nl">valueForKey:</span><span class="s">@&quot;petalLayer_keyframeAnimation_destination&quot;</span><span class="p">]</span> <span class="n">CGPointValue</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">CATransaction</span> <span class="n">commit</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h4>通过设置路径的关键帧控制</h4>

<p>上面的方式固然比前面使用基础动画效果要好一些，但其实还是存在问题，那就是落花飞落的路径是直线的，当然这个直线是根据程序中设置的四个关键帧自动形成的，那么如何让它沿着曲线飘落呢？这就是第二种类型的关键帧动画，通过描绘路径进行关键帧动画控制。假设让落花沿着一条贝塞尔曲线飘落：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addKeyframeMoveAnimation</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CAKeyframeAnimation</span> <span class="o">*</span><span class="n">keyframeAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAKeyframeAnimation</span> <span class="nl">animationWithKeyPath:</span><span class="s">@&quot;position&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGMutablePathRef</span> <span class="n">path</span> <span class="o">=</span> <span class="n">CGPathCreateMutable</span><span class="p">();</span>
</span><span class='line'>    <span class="n">CGPathMoveToPoint</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">petalLayer</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">petalLayer</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGPathAddCurveToPoint</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">450</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">550</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">keyframeAnimation</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGPathRelease</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span><span class='line'>    <span class="n">keyframeAnimation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">8.0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">keyframeAnimation</span><span class="p">.</span><span class="n">beginTime</span> <span class="o">=</span> <span class="n">CACurrentMediaTime</span><span class="p">()</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">keyframeAnimation</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">keyframeAnimation</span> <span class="nl">setValue:</span><span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">550</span><span class="p">)]</span> <span class="nl">forKey:</span><span class="s">@&quot;petalLayer_keyframeAnimation_destination&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">petalLayer</span> <span class="nl">addAnimation:</span><span class="n">keyframeAnimation</span> <span class="nl">forKey:</span><span class="s">@&quot;petalLayer_keyframeAnimation_position&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>关键帧动画的其他重要属性</h4>

<ul>
<li>keyTimes：各个关键帧的时间控制。前面使用values设置了四个关键帧，默认情况下每两帧之间的间隔为:8/(4-1)秒。如果想要控制动画从第一帧到第二针占用时间4秒，从第二帧到第三帧时间为2秒，而从第三帧到第四帧时间2秒的话，就可以通过keyTimes进行设置。keyTimes中存储的是时间占用比例点，此时可以设置keyTimes的值为0.0，0.5，0.75，1.0（当然必须转换为NSNumber），也就是说1到2帧运行到总时间的50%，2到3帧运行到总时间的75%，3到4帧运行到8秒结束。</li>
<li>caculationMode：动画计算模式。还拿上面keyValues动画举例，之所以1到2帧能形成连贯性动画而不是直接从第1帧经过8/3秒到第2帧是因为动画模式是连续的（值为kCAAnimationLinear，这是计算模式的默认值）；而如果指定了动画模式为kCAAnimationDiscrete离散的那么你会看到动画从第1帧经过8/3秒直接到第2帧，中间没有任何过渡。其他动画模式还有：kCAAnimationPaced（均匀执行，会忽略keyTimes）、kCAAnimationCubic（平滑执行，对于位置变动关键帧动画运行轨迹更平滑）、kCAAnimationCubicPaced（平滑均匀执行）。</li>
</ul>


<p><img src="http://lucifer1988.github.io/images/caculationMode.png"></p>

<h3>组合动画</h3>

<p>实际开发中一个物体的运动往往是复合运动，单一属性的运动情况比较少，但恰恰属性动画每次进行动画设置时一次只能设置一个属性进行动画控制(不管是基础动画还是关键帧动画都是如此)，这样一来要做一个复合运动的动画就必须创建多个属性动画进行组合。对于一两种动画的组合或许处理起来还比较容易，但是对于更多动画的组合控制往往会变得很麻烦，动画组的产生就是基于这样一种情况而产生的。动画组是一系列动画的组合，凡是添加到动画组中的动画都受控于动画组，这样一来各类动画公共的行为就可以统一进行控制而不必单独设置，而且放到动画组中的各个动画可以并发执行，共同构建出复杂的动画效果。</p>

<p>动画组使用起来并不复杂，首先单独创建单个动画（可以是基础动画也可以是关键帧动画），然后将基础动画添加到动画组，最后将动画组添加到图层即可。</p>

<p>前面关键帧动画部分，路径动画看起来效果虽然很流畅，但是落花本身的旋转运动没有了，这里不妨将基础动画部分的旋转动画和路径关键帧动画进行组合使得整个动画看起来更加的和谐、顺畅。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">ACGroupAnimationViewController</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CALayer</span> <span class="o">*</span><span class="n">petalLayer</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ACGroupAnimationViewController</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// Do any additional setup after loading the view.</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">UIImage</span> <span class="o">*</span><span class="n">backgroundImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;background.jpg&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">backgroundImage</span><span class="p">.</span><span class="n">CGImage</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">petalLayer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CALayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="p">)[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;petal.png&quot;</span><span class="p">].</span><span class="n">CGImage</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">petalLayer</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="n">addAnimationGroup</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addAnimationGroup</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CAAnimationGroup</span> <span class="o">*</span><span class="n">animationGroup</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAAnimationGroup</span> <span class="n">animation</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">rotateAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">rotateAnimation</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CAKeyframeAnimation</span> <span class="o">*</span><span class="n">keyframeMoveAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">keyframeMoveAnimation</span><span class="p">];</span>
</span><span class='line'>    <span class="n">animationGroup</span><span class="p">.</span><span class="n">animations</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="n">rotateAnimation</span><span class="p">,</span> <span class="n">keyframeMoveAnimation</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">animationGroup</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'>    <span class="n">animationGroup</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">8.0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">animationGroup</span><span class="p">.</span><span class="n">beginTime</span> <span class="o">=</span> <span class="n">CACurrentMediaTime</span><span class="p">()</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">petalLayer</span> <span class="nl">addAnimation:</span><span class="n">animationGroup</span> <span class="nl">forKey:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">CAKeyframeAnimation</span> <span class="o">*</span><span class="p">)</span><span class="nf">keyframeMoveAnimation</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CAKeyframeAnimation</span> <span class="o">*</span><span class="n">keyframeAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAKeyframeAnimation</span> <span class="nl">animationWithKeyPath:</span><span class="s">@&quot;position&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGMutablePathRef</span> <span class="n">path</span> <span class="o">=</span> <span class="n">CGPathCreateMutable</span><span class="p">();</span>
</span><span class='line'>    <span class="n">CGPathMoveToPoint</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">petalLayer</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">petalLayer</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGPathAddCurveToPoint</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">450</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">550</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">keyframeAnimation</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGPathRelease</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">keyframeAnimation</span> <span class="nl">setValue:</span><span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">550</span><span class="p">)]</span> <span class="nl">forKey:</span><span class="s">@&quot;petalLayer_keyframeAnimation_destination&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">keyframeAnimation</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">CABasicAnimation</span> <span class="o">*</span><span class="p">)</span><span class="nf">rotateAnimation</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">rotateAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="nl">animationWithKeyPath:</span><span class="s">@&quot;transform.rotation.z&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">rotateAnimation</span><span class="p">.</span><span class="n">repeatCount</span> <span class="o">=</span> <span class="n">HUGE_VALF</span><span class="p">;</span>
</span><span class='line'>    <span class="n">rotateAnimation</span><span class="p">.</span><span class="n">removedOnCompletion</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="n">rotateAnimation</span><span class="p">.</span><span class="n">autoreverses</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="n">rotateAnimation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithFloat:</span><span class="n">M_PI_2</span><span class="o">*</span><span class="mi">3</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">rotateAnimation</span> <span class="nl">setValue:</span><span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithFloat:</span><span class="n">M_PI_2</span><span class="o">*</span><span class="mi">3</span><span class="p">]</span> <span class="nl">forKey:</span><span class="s">@&quot;rotateAnimation_toValue&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">rotateAnimation</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - animation delegate</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animationDidStop:</span><span class="p">(</span><span class="n">CAAnimation</span> <span class="o">*</span><span class="p">)</span><span class="nv">anim</span> <span class="nf">finished:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">flag</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CAAnimationGroup</span> <span class="o">*</span><span class="n">animationGroup</span> <span class="o">=</span> <span class="p">(</span><span class="n">CAAnimationGroup</span> <span class="o">*</span><span class="p">)</span><span class="n">anim</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">rotateAnimation</span> <span class="o">=</span> <span class="p">(</span><span class="n">CABasicAnimation</span> <span class="o">*</span><span class="p">)</span><span class="n">animationGroup</span><span class="p">.</span><span class="n">animations</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CAKeyframeAnimation</span> <span class="o">*</span><span class="n">keyframeMoveAnimation</span> <span class="o">=</span> <span class="p">(</span><span class="n">CAKeyframeAnimation</span> <span class="o">*</span><span class="p">)</span><span class="n">animationGroup</span><span class="p">.</span><span class="n">animations</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">toValue</span> <span class="o">=</span> <span class="p">[[</span><span class="n">rotateAnimation</span> <span class="nl">valueForKey:</span><span class="s">@&quot;rotateAnimation_toValue&quot;</span><span class="p">]</span> <span class="n">floatValue</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGPoint</span> <span class="n">toPoint</span> <span class="o">=</span> <span class="p">[[</span><span class="n">keyframeMoveAnimation</span> <span class="nl">valueForKey:</span><span class="s">@&quot;petalLayer_keyframeAnimation_destination&quot;</span><span class="p">]</span> <span class="n">CGPointValue</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">CATransaction</span> <span class="n">begin</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">CATransaction</span> <span class="nl">setDisableActions:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">toPoint</span><span class="p">;</span>
</span><span class='line'>    <span class="n">petalLayer</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CATransform3DMakeRotation</span><span class="p">(</span><span class="n">toValue</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">CATransaction</span> <span class="n">commit</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>转场动画</h3>

<p>转场动画就是从一个场景以动画的形式过渡到另一个场景。转场动画的使用一般分为以下几个步骤：</p>

<ol>
<li>创建转场动画</li>
<li>设置转场类型、子类型（可选）及其他属性</li>
<li>设置转场后的新视图并添加动画到图层</li>
</ol>


<p>Apple公开的只有四个转场动画类型：</p>

<ol>
<li>fade(kCATransitionFade，支持方向)</li>
<li>moveIn(kCATransitionMoveIn，支持方向)</li>
<li>push(kCATransitionPush，支持方向)</li>
<li>reveal(kCATransitionReveal，支持方向)</li>
</ol>


<p>另外还有一些私有API可以使用，但是只能用字符串来设置：</p>

<ol>
<li>cube(支持方向)</li>
<li>oglFlip(支持方向)</li>
<li>suckEffect(不支持方向)</li>
<li>rippleEffect(不支持方向)</li>
<li>pageCurl(支持方向)</li>
<li>pageUnCurl(支持方向)</li>
<li>cameraIrisHollowOpen(不支持方向)</li>
<li>cameraIrisHollowClose(不支持方向)</li>
</ol>


<p>支持方向的类型还可以选择四个subtype：</p>

<ol>
<li>kCATransitionFromRight</li>
<li>kCATransitionFromLeft</li>
<li>kCATransitionFromTop</li>
<li>kCATransitionFromBottom</li>
</ol>


<p>下面代码展示了全部效果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">ACTransitionAnimationViewController</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UIImageView</span> <span class="o">*</span><span class="n">imageView</span><span class="p">;</span>
</span><span class='line'>    <span class="n">NSArray</span> <span class="o">*</span><span class="n">transitionTypes</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">transitionTypeIndex</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ACTransitionAnimationViewController</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// Do any additional setup after loading the view.</span>
</span><span class='line'>    <span class="n">transitionTypes</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="s">@&quot;fade&quot;</span><span class="p">,</span> <span class="s">@&quot;moveIn&quot;</span><span class="p">,</span> <span class="s">@&quot;push&quot;</span><span class="p">,</span> <span class="s">@&quot;reveal&quot;</span><span class="p">,</span> <span class="s">@&quot;cube&quot;</span><span class="p">,</span> <span class="s">@&quot;oglFlip&quot;</span><span class="p">,</span> <span class="s">@&quot;suckEffect&quot;</span><span class="p">,</span> <span class="s">@&quot;rippleEffect&quot;</span><span class="p">,</span> <span class="s">@&quot;pageCurl&quot;</span><span class="p">,</span> <span class="s">@&quot;pageUnCurl&quot;</span><span class="p">,</span> <span class="s">@&quot;cameraIrisHollowOpen&quot;</span><span class="p">,</span> <span class="s">@&quot;cameraIrisHollowClose&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">transitionTypeIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">imageView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIImageView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame:</span><span class="p">[</span><span class="n">UIScreen</span> <span class="n">mainScreen</span><span class="p">].</span><span class="n">bounds</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">imageView</span> <span class="nl">setImage:</span><span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;background.jpg&quot;</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview:</span><span class="n">imageView</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">UISwipeGestureRecognizer</span> <span class="o">*</span><span class="n">swipeGesture</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UISwipeGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget:</span><span class="n">self</span> <span class="nl">action:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">swipe:</span><span class="p">)];</span>
</span><span class='line'>    <span class="n">swipeGesture</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">UISwipeGestureRecognizerDirectionLeft</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addGestureRecognizer:</span><span class="n">swipeGesture</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">swipe:</span><span class="p">(</span><span class="n">UISwipeGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">gestureRecognizer</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">transitionTypeIndex</span> <span class="o">&gt;</span> <span class="mi">11</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">transitionTypeIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">CATransition</span> <span class="o">*</span><span class="n">transition</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CATransition</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">transition</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">transitionTypes</span><span class="p">[</span><span class="n">transitionTypeIndex</span><span class="p">];</span>
</span><span class='line'>    <span class="n">transition</span><span class="p">.</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">kCATransitionFromRight</span><span class="p">;</span>
</span><span class='line'>    <span class="n">transition</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">imageView</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addAnimation:</span><span class="n">transition</span> <span class="nl">forKey:</span><span class="s">@&quot;imageView_transition&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">transitionTypeIndex</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>逐帧动画</h3>

<p>前面介绍了核心动画中大部分动画类型，但是做过动画处理的朋友都知道，在动画制作中还有一种动画类型“逐帧动画”。说到逐帧动画相信很多朋友第一个想到的就是UIImageView，通过设置UIImageView的animationImages属性，然后调用它的startAnimating方法去播放这组图片。当然这种方法在某些场景下是可以达到逐帧的动画效果，但是它也存在着很大的性能问题，并且这种方法一旦设置完图片中间的过程就无法控制了。</p>

<p>虽然在CoreAnimation中没有直接提供逐帧动画类型，但是却提供了用于完成逐帧动画的相关对象CADisplayLink。CADisplayLink是一个计时器，但是同NSTimer不同的是，CADisplayLink的刷新周期同屏幕完全一致。例如在iOS中屏幕刷新周期是60次/秒，CADisplayLink刷新周期同屏幕刷新一致也是60次/秒，这样一来使用它完成的逐帧动画（又称为“时钟动画”）完全感觉不到动画的停滞情况。</p>

<p>要将CADisplayLink加入到主线程的Runloop，它的时钟周期就和主运行循环保持一致，而主运行循环周期就是屏幕刷新周期。在CADisplayLink加入到主运行循环队列后就会循环调用目标方法，在这个方法中更新视图内容就可以完成逐帧动画。</p>

<p>当然这里不得不强调的是逐帧动画性能势必较低，但是对于一些事物的运动又不得不选择使用逐帧动画，例如人的运动，这是一个高度复杂的运动，基本动画、关键帧动画是不可能解决的。所大家一定要注意在循环方法中尽可能的降低算法复杂度，同时保证循环过程中内存峰值尽可能低。下面以一个鱼的运动为例为大家演示一下逐帧动画。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">ACFrameByFrameAnimationViewController</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UIImageView</span> <span class="o">*</span><span class="n">imageView</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CALayer</span> <span class="o">*</span><span class="n">layer</span><span class="p">;</span>
</span><span class='line'>    <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">imageArray</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">frameIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ACFrameByFrameAnimationViewController</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// Do any additional setup after loading the view.</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">UIImage</span> <span class="o">*</span><span class="n">backgroundImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;background1.png&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">backgroundImage</span><span class="p">.</span><span class="n">CGImage</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">imageArray</span> <span class="o">=</span> <span class="p">[</span><span class="err">@</span><span class="p">[]</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;fish%d.png&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">]];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">imageArray</span> <span class="nl">addObject:</span><span class="n">image</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//PlanA use UIImageView&#39;s AnimationImages</span>
</span><span class='line'><span class="c1">//    imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 87, 32)];</span>
</span><span class='line'><span class="c1">//    imageView.center = self.view.center;</span>
</span><span class='line'><span class="c1">//    imageView.animationDuration = imageArray.count/30;</span>
</span><span class='line'><span class="c1">//    [imageView setAnimationImages:imageArray];</span>
</span><span class='line'><span class="c1">//    [self.view addSubview:imageView];</span>
</span><span class='line'><span class="c1">//    [imageView startAnimating];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//PlanB use CADisplayLink</span>
</span><span class='line'>    <span class="n">layer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CALayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">87</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">layer</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CADisplayLink</span> <span class="o">*</span><span class="n">displayLink</span> <span class="o">=</span> <span class="p">[</span><span class="n">CADisplayLink</span> <span class="nl">displayLinkWithTarget:</span><span class="n">self</span> <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="n">nextFrame</span><span class="p">)];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">displayLink</span> <span class="nl">addToRunLoop:</span><span class="p">[</span><span class="n">NSRunLoop</span> <span class="n">mainRunLoop</span><span class="p">]</span> <span class="nl">forMode:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//60fps</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">nextFrame</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">//30fps</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="n">imageArray</span><span class="p">[</span><span class="n">frameIndex</span><span class="p">];</span>
</span><span class='line'>        <span class="n">layer</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">image</span><span class="p">.</span><span class="n">CGImage</span><span class="p">;</span>
</span><span class='line'>        <span class="n">frameIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">frameIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h2>UIView动画封装</h2>

<p>其实UIView本身对于基本动画和关键帧动画、转场动画都有相应的封装，在对动画细节没有特殊要求的情况下使用起来也要简单的多。可以说在日常开发中90%以上的情况使用UIView的动画封装方法都可以搞定，因此在熟悉了核心动画的原理之后还是有必要给大家简单介绍一下UIView中各类动画使用方法的。</p>

<h3>基本动画</h3>

<h4>移动动画</h4>

<p>下面是之前移动动画在UIView层的封装，使用了block封装，也可以选用之前的beginAnimations单独设置，效果是一样的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">ACViewMoveAnimationViewController</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UIImageView</span> <span class="o">*</span><span class="n">petalView</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ACViewMoveAnimationViewController</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// Do any additional setup after loading the view.</span>
</span><span class='line'>    <span class="n">UIImage</span> <span class="o">*</span><span class="n">backgroundImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;background.jpg&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">backgroundImage</span><span class="p">.</span><span class="n">CGImage</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">petalView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIImageView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithImage:</span><span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;petal.png&quot;</span><span class="p">]];</span>
</span><span class='line'>    <span class="n">petalView</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview:</span><span class="n">petalView</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesEnded:</span><span class="p">(</span><span class="n">NSSet</span><span class="o">&lt;</span><span class="n">UITouch</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UITouch</span> <span class="o">*</span><span class="n">touch</span> <span class="o">=</span> <span class="n">touches</span><span class="p">.</span><span class="n">anyObject</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGPoint</span> <span class="n">location</span> <span class="o">=</span> <span class="p">[</span><span class="n">touch</span> <span class="nl">locationInView:</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">//方法1：block方式</span>
</span><span class='line'>    <span class="cm">/*开始动画，UIView的动画方法执行完后动画会停留在重点位置，而不需要进行任何特殊处理</span>
</span><span class='line'><span class="cm">     duration:执行时间</span>
</span><span class='line'><span class="cm">     delay:延迟时间</span>
</span><span class='line'><span class="cm">     options:动画设置，例如自动恢复、匀速运动等</span>
</span><span class='line'><span class="cm">     completion:动画完成回调方法</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="p">[</span><span class="n">UIView</span> <span class="nl">animateWithDuration:</span><span class="p">[</span><span class="n">self</span> <span class="nl">petalMoveDuring:</span><span class="p">[</span><span class="n">touch</span> <span class="nl">locationInView:</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">]]</span> <span class="nl">delay:</span><span class="mf">0.0</span> <span class="nl">options:</span><span class="n">UIViewAnimationOptionCurveLinear</span> <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">petalView</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">location</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="nl">completion:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">//方法2：静态方法</span>
</span><span class='line'>    <span class="c1">//开始动画</span>
</span><span class='line'>    <span class="c1">//[UIView beginAnimations:@&quot;KCBasicAnimation&quot; context:nil];</span>
</span><span class='line'>    <span class="c1">//[UIView setAnimationDuration:5.0];</span>
</span><span class='line'>    <span class="c1">//[UIView setAnimationDelay:1.0];//设置延迟</span>
</span><span class='line'>    <span class="c1">//[UIView setAnimationRepeatAutoreverses:NO];//是否回复</span>
</span><span class='line'>    <span class="c1">//[UIView setAnimationRepeatCount:10];//重复次数</span>
</span><span class='line'>    <span class="c1">//[UIView setAnimationStartDate:(NSDate *)];//设置动画开始运行的时间</span>
</span><span class='line'>    <span class="c1">//[UIView setAnimationDelegate:self];//设置代理</span>
</span><span class='line'>    <span class="c1">//[UIView setAnimationWillStartSelector:(SEL)];//设置动画开始运动的执行方法</span>
</span><span class='line'>    <span class="c1">//[UIView setAnimationDidStopSelector:(SEL)];//设置动画运行结束后的执行方法</span>
</span><span class='line'>    <span class="c1">//petalView.center = location;</span>
</span><span class='line'>    <span class="c1">//开始动画</span>
</span><span class='line'>    <span class="c1">//[UIView commitAnimations];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nf">petalMoveDuring:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">destination</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">deltaX</span> <span class="o">=</span> <span class="n">destination</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">petalView</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">deltaY</span> <span class="o">=</span> <span class="n">destination</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">petalView</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">deltaX</span><span class="o">*</span><span class="n">deltaX</span> <span class="o">+</span> <span class="n">deltaY</span><span class="o">*</span><span class="n">deltaY</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%f&quot;</span><span class="p">,</span> <span class="n">distance</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="n">distance</span><span class="o">/</span><span class="mf">50.0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h4>弹簧动画效果</h4>

<p>iOS7新加入了一个弹性动画的接口，具体实现见代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">ACViewSpringAnimationViewController</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UIImageView</span> <span class="o">*</span><span class="n">ballView</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ACViewSpringAnimationViewController</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// Do any additional setup after loading the view.</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">ballView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIImageView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithImage:</span><span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;ball&quot;</span><span class="p">]];</span>
</span><span class='line'>    <span class="n">ballView</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview:</span><span class="n">ballView</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesEnded:</span><span class="p">(</span><span class="n">NSSet</span><span class="o">&lt;</span><span class="n">UITouch</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UITouch</span> <span class="o">*</span><span class="n">touch</span> <span class="o">=</span> <span class="n">touches</span><span class="p">.</span><span class="n">anyObject</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGPoint</span> <span class="n">location</span> <span class="o">=</span> <span class="p">[</span><span class="n">touch</span> <span class="nl">locationInView:</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'>    <span class="cm">/*创建弹性动画</span>
</span><span class='line'><span class="cm">     damping:阻尼，范围0-1，阻尼越接近于0，弹性效果越明显</span>
</span><span class='line'><span class="cm">     velocity:弹性复位的速度</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="p">[</span><span class="n">UIView</span> <span class="nl">animateWithDuration:</span><span class="p">[</span><span class="n">self</span> <span class="nl">petalMoveDuring:</span><span class="n">location</span><span class="p">]</span> <span class="nl">delay:</span><span class="mi">0</span> <span class="nl">usingSpringWithDamping:</span><span class="mf">0.5</span> <span class="nl">initialSpringVelocity:</span><span class="mi">0</span> <span class="nl">options:</span><span class="n">UIViewAnimationOptionCurveLinear</span> <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">ballView</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">location</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="nl">completion:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nf">petalMoveDuring:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">destination</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">deltaX</span> <span class="o">=</span> <span class="n">destination</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">ballView</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">deltaY</span> <span class="o">=</span> <span class="n">destination</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">ballView</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">deltaX</span><span class="o">*</span><span class="n">deltaX</span> <span class="o">+</span> <span class="n">deltaY</span><span class="o">*</span><span class="n">deltaY</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%f&quot;</span><span class="p">,</span> <span class="n">distance</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="n">distance</span><span class="o">/</span><span class="mf">150.0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h4>UIView动画设置参数</h4>

<p>在动画方法中有一个NS_OPTION参数，UIViewAnimationOptions类型，它是一个枚举类型，动画参数分为三类，对应CoreAnimation的各类设置，可以组合使用：</p>

<ol>
<li>常规动画属性设置（可以同时选择多个进行设置）

<ul>
<li>UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。</li>
<li>UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。</li>
<li>UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。</li>
<li>UIViewAnimationOptionRepeat：重复运行动画。</li>
<li>UIViewAnimationOptionAutoreverse ：动画运行到结束点后仍然以动画方式回到初始点。</li>
<li>UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。</li>
<li>UIViewAnimationOptionOverrideInheritedCurve：忽略嵌套动画速度设置。</li>
<li>UIViewAnimationOptionAllowAnimatedContent：动画过程中重绘视图（注意仅仅适用于转场动画）。</li>
<li>UIViewAnimationOptionShowHideTransitionViews：视图切换时直接隐藏旧视图、显示新视图，而不是将旧视图从父视图移除（仅仅适用于转场动画）</li>
<li>UIViewAnimationOptionOverrideInheritedOptions ：不继承父动画设置或动画类型。</li>
</ul>
</li>
<li>动画速度控制（可从其中选择一个设置）

<ul>
<li>UIViewAnimationOptionCurveEaseInOut：动画先缓慢，然后逐渐加速。</li>
<li>UIViewAnimationOptionCurveEaseIn ：动画逐渐变慢。</li>
<li>UIViewAnimationOptionCurveEaseOut：动画逐渐加速。</li>
<li>UIViewAnimationOptionCurveLinear ：动画匀速执行，默认值。</li>
</ul>
</li>
<li>转场类型（仅适用于转场动画设置，可以从中选择一个进行设置，基本动画、关键帧动画不需要设置）

<ul>
<li>UIViewAnimationOptionTransitionNone：没有转场动画效果。</li>
<li>UIViewAnimationOptionTransitionFlipFromLeft ：从左侧翻转效果。</li>
<li>UIViewAnimationOptionTransitionFlipFromRight：从右侧翻转效果。</li>
<li>UIViewAnimationOptionTransitionCurlUp：向后翻页的动画过渡效果。</li>
<li>UIViewAnimationOptionTransitionCurlDown ：向前翻页的动画过渡效果。</li>
<li>UIViewAnimationOptionTransitionCrossDissolve：旧视图溶解消失显示下一个新视图的效果。</li>
<li>UIViewAnimationOptionTransitionFlipFromTop ：从上方翻转效果。</li>
<li>UIViewAnimationOptionTransitionFlipFromBottom：从底部翻转效果。</li>
</ul>
</li>
</ol>


<h3>UIView关键帧动画</h3>

<p>从iOS7开始UIView动画中封装了关键帧动画，下面就来看一下如何使用UIView封装方法进行关键帧动画控制，这里实现前面关键帧动画部分对于落花的控制。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">ACViewKeyframeAnimationViewController</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UIImageView</span> <span class="o">*</span><span class="n">petalView</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ACViewKeyframeAnimationViewController</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// Do any additional setup after loading the view.</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="p">)[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;background.jpg&quot;</span><span class="p">].</span><span class="n">CGImage</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">petalView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIImageView</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">petalView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">petalView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;petal&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">petalView</span> <span class="n">sizeToFit</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview:</span><span class="n">petalView</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="n">addKeyframeAnimation</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addKeyframeAnimation</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">UIView</span> <span class="nl">animateKeyframesWithDuration:</span><span class="mf">5.0</span> <span class="nl">delay:</span><span class="mf">0.0</span> <span class="nl">options:</span><span class="n">UIViewKeyframeAnimationOptionCalculationModeLinear</span> <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">UIView</span> <span class="nl">addKeyframeWithRelativeStartTime:</span><span class="mf">0.0</span> <span class="nl">relativeDuration:</span><span class="mf">0.5</span> <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>            <span class="n">petalView</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mf">80.0</span><span class="p">,</span> <span class="mf">220.0</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">UIView</span> <span class="nl">addKeyframeWithRelativeStartTime:</span><span class="mf">0.5</span> <span class="nl">relativeDuration:</span><span class="mf">0.25</span> <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>            <span class="n">petalView</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mf">45.0</span><span class="p">,</span> <span class="mf">300.0</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">UIView</span> <span class="nl">addKeyframeWithRelativeStartTime:</span><span class="mf">0.75</span> <span class="nl">relativeDuration:</span><span class="mf">0.25</span> <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>            <span class="n">petalView</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mf">55.0</span><span class="p">,</span> <span class="mf">400.0</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'>    <span class="p">}</span> <span class="nl">completion:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h4>UIView关键帧动画设置参数</h4>

<p>对于关键帧动画也有一些动画参数设置options，UIViewKeyframeAnimationOptions类型，和上面基本动画参数设置有些差别，关键帧动画设置参数分为两类，可以组合使用：</p>

<ol>
<li><p>常规动画属性设置（可以同时选择多个进行设置）</p>

<ul>
<li>UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。</li>
<li>UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。</li>
<li>UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。</li>
<li>UIViewAnimationOptionRepeat：重复运行动画。</li>
<li>UIViewAnimationOptionAutoreverse：动画运行到结束点后仍然以动画方式回到初始点。</li>
<li>UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。</li>
<li>UIViewAnimationOptionOverrideInheritedOptions：不继承父动画设置或动画类型。</li>
</ul>
</li>
<li><p>动画模式设置（同前面关键帧动画动画模式一一对应，可以从其中选择一个进行设置）</p>

<ul>
<li>UIViewKeyframeAnimationOptionCalculationModeLinear：连续运算模式。</li>
<li>UIViewKeyframeAnimationOptionCalculationModeDiscrete：离散运算模式。</li>
<li>UIViewKeyframeAnimationOptionCalculationModePaced：均匀执行运算模式。</li>
<li>UIViewKeyframeAnimationOptionCalculationModeCubic：平滑运算模式。</li>
<li>UIViewKeyframeAnimationOptionCalculationModeCubicPaced：平滑均匀运算模式。</li>
</ul>
</li>
</ol>


<p>注意：前面说过关键帧动画有两种形式，上面演示的是属性值关键帧动画，路径关键帧动画目前UIView还不支持。</p>

<h3>UIView转场动画</h3>

<p>从iOS4.0开始，UIView直接封装了转场动画。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">ACViewTransitionAnimationViewController</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UIImageView</span> <span class="o">*</span><span class="n">imageView</span><span class="p">;</span>
</span><span class='line'>    <span class="n">NSArray</span> <span class="o">*</span><span class="n">transitionTypes</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">transitionTypeIndex</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ACViewTransitionAnimationViewController</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// Do any additional setup after loading the view.</span>
</span><span class='line'>    <span class="n">transitionTypes</span> <span class="o">=</span> <span class="err">@</span><span class="p">[[</span><span class="n">NSNumber</span> <span class="nl">numberWithUnsignedInteger:</span><span class="n">UIViewAnimationOptionTransitionFlipFromRight</span><span class="p">],</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithUnsignedInteger:</span><span class="n">UIViewAnimationOptionTransitionCurlUp</span><span class="p">],</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithUnsignedInteger:</span><span class="n">UIViewAnimationOptionTransitionCrossDissolve</span><span class="p">],</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithUnsignedInteger:</span><span class="n">UIViewAnimationOptionTransitionFlipFromBottom</span><span class="p">]];</span>
</span><span class='line'>    <span class="n">transitionTypeIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">imageView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIImageView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame:</span><span class="p">[</span><span class="n">UIScreen</span> <span class="n">mainScreen</span><span class="p">].</span><span class="n">bounds</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">imageView</span> <span class="nl">setImage:</span><span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;background.jpg&quot;</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview:</span><span class="n">imageView</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">UISwipeGestureRecognizer</span> <span class="o">*</span><span class="n">swipeGesture</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UISwipeGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget:</span><span class="n">self</span> <span class="nl">action:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">swipe:</span><span class="p">)];</span>
</span><span class='line'>    <span class="n">swipeGesture</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">UISwipeGestureRecognizerDirectionLeft</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addGestureRecognizer:</span><span class="n">swipeGesture</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">swipe:</span><span class="p">(</span><span class="n">UISwipeGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">gestureRecognizer</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">transitionTypeIndex</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">transitionTypeIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">UIViewAnimationOptions</span> <span class="n">option</span><span class="p">;</span>
</span><span class='line'>    <span class="n">option</span> <span class="o">=</span> <span class="p">[</span><span class="n">transitionTypes</span><span class="p">[</span><span class="n">transitionTypeIndex</span><span class="p">]</span> <span class="n">unsignedIntegerValue</span><span class="p">];</span>
</span><span class='line'>    <span class="n">option</span> <span class="o">=</span> <span class="n">option</span><span class="o">|</span><span class="n">UIViewAnimationOptionCurveLinear</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">UIView</span> <span class="nl">transitionWithView:</span><span class="n">imageView</span> <span class="nl">duration:</span><span class="mf">1.0</span> <span class="nl">options:</span><span class="n">option</span> <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">imageView</span> <span class="nl">setImage:</span><span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;background.jpg&quot;</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">}</span> <span class="nl">completion:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">transitionTypeIndex</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果有两个完全不同的视图，并且每个视图布局都很复杂，此时要在这两个视图之间进行转场可以使用以下方法进行两个视图间的转场，需要注意的是默认情况下转出的视图会从父视图移除，转入后重新添加，可以通过UIViewAnimationOptionShowHideTransitionViews参数设置，设置此参数后转出的视图会隐藏（不会移除）转入后再显示。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">+</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">transitionFromView:</span><span class="p">(</span><span class="n">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nv">fromView</span> <span class="nf">toView:</span><span class="p">(</span><span class="n">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nv">toView</span> <span class="nf">duration:</span><span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">duration</span> <span class="nf">options:</span><span class="p">(</span><span class="n">UIViewAnimationOptions</span><span class="p">)</span><span class="nv">options</span> <span class="nf">completion:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">BOOL</span> <span class="n">finished</span><span class="p">))</span><span class="nv">completion</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：转场动画设置参数完全同基本动画参数设置；同直接使用转场动画不同的是使用UIView的装饰方法进行转场动画其动画效果较少，因为这里无法直接使用私有API。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发备忘录1]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/05/ioskai-fa-bei-wang-lu-1/"/>
    <updated>2015-11-05T13:41:03+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/05/ioskai-fa-bei-wang-lu-1</id>
    <content type="html"><![CDATA[<p>总结一些iOS开发必备的知识点，结构可能会比较杂，可以当做备忘录使用，不断更新中。</p>

<!--more-->


<h2>1.library和framework的比较</h2>

<p>library也就是我们常用的.a文件，而framework就是.framework文件，当然还有.dylib这样的文件。</p>

<h3>静态库和动态库的区别</h3>

<ul>
<li>静态库：链接时完整地拷贝至可执行文件夹中，被多次使用时会有多份冗余拷贝。</li>
<li>动态库：链接时不复制，程序运行是由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。</li>
</ul>


<h3>iOS库的形式</h3>

<ul>
<li>静态库：.a和.framework</li>
<li>动态库：.dylib和.framework</li>
<li>系统提供的.framework是动态的，而自己开发的.framework是静态的</li>
</ul>


<h3>.a和.framework区别</h3>

<ul>
<li>.a就是一个纯二进制的文件，而.framework还会包含头文件和资源文件</li>
<li>.a一般是要配合.h头文件使用的，.framework是可以直接使用的</li>
<li>实际上.framework = .a + .h + sourceFile</li>
</ul>


<h3>需要注意的问题</h3>

<ul>
<li>注意理解：无论是.a静态库还.framework静态库，我们需要的都是二进制文件+.h+其它资源文件的形式，不同的是，.a本身就是二进制文件，需要我们自己配上.h和其它文件才能使用，而.framework本身已经包含了.h和其它文件，可以直接使用。</li>
<li>图片资源的处理：两种静态库，一般都是把图片文件单独的放在一个.bundle文件中，一般.bundle的名字和.a或.framework的名字相同。.bundle文件很好弄，新建一个文件夹，把它改名为.bundle就可以了，右键，显示包内容可以向其中添加图片资源。</li>
<li>category是我们实际开发项目中经常用到的，把category打成静态库是没有问题的，但是在用这个静态库的工程中，调用category中的方法时会有找不到该方法的运行时错误（selector not recognized），解决办法是：在使用静态库的工程中配置other linker flags的值为-ObjC。</li>
<li>如果一个静态库很复杂，需要暴露的.h比较多的话，就可以在静态库的内部创建一个.h文件（一般这个.h文件的名字和静态库的名字相同），然后把所有需要暴露出来的.h文件都集中放在这个.h文件中，而那些原本需要暴露的.h都不需要再暴露了，只需要把.h暴露出来就可以了。</li>
<li>创建.a文件的一篇<a href="http://www.raywenderlich.com/41377/creating-a-static-library-in-ios-tutorial">博客</a>，创建.framework的一篇<a href="http://www.raywenderlich.com/65964/create-a-framework-for-ios">博客</a>。</li>
</ul>


<!--more-->


<h2>2.事件响应链The Responder Chain</h2>

<h3>事件的传递顺序</h3>

<p>当用户触发的一个事件发生，UIKit会创建一个包含要处理的事件信息的事件对象。然后她会将事件对象放入active app’s（应用程序对象，每个程序对应唯一一个）事件队列。对于触摸事件，事件对象就是UIEvent对象封装的一系列触摸集合。对于动作事件，这个事件对象依赖于使用的framework和你关心哪种动作事件。</p>

<h3>事件类型</h3>

<p>事件通过特殊的路径传递直到被传递到一个可以处理该事件的对象。首先，单例的UIApplication对象从顶层的队列中获取事件，然后分发。典型的，它将事件发送到App的key window对象，window则为了处理该事件而发送它到初始化对象（initial object），这个初始化对像依靠事件类型。</p>

<ul>
<li>触摸事件（Touch events）。对于触摸事件，window对象首先会尝试将事件传递给事件发生的view。这个view就是所谓的hit-test view。寻找hit-test view的方法叫hit-testing，具体描述见<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW4">Apple文档</a>。</li>
<li>动作事件和远程控制事件（Motion and remote control events）。在这些事件中，window对象发送事件到第一个响应器。第一个响应器的具体描述见<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW1">Apple文档</a>。</li>
</ul>


<p>事件传递路径的最终目的时找出能处理和响应该事件的对象。因此，UIKit给适合处理该事件的对象发送事件。对于触摸事件，这个对象就是hit-test view，对于其他事件，这个对象就是第一个响应器（first responder）。</p>

<h3>触摸事件的响应链</h3>

<p>iOS使用hit-testing寻找触摸的view。 Hit-Testing通过检查触摸点是否在关联的view边界内，如果在，则递归地（recursively）检查该view的所有子view。在层级上处于lowest（就是用户直接接触view）且边界范围包含触摸点的view成为hit-test view。确定hit-test view后，它传递触摸事件给该view。</p>

<p>举例说明，假设用户触摸了图中的view E。iOS通过如下顺序查找hit-test view。</p>

<p><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png" alt="image" /></p>

<ol>
<li>触摸点在view A中，所以要检查子view B和C。</li>
<li>触摸点不在view B中，但在C中，所以检查C的子view D和E。</li>
<li>触摸点不在D中，但在E中。</li>
</ol>


<p><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/hitTest:withEvent:">hitTest:withEvent:</a>方法通过传递进来CGPoint和UIEvent返回hit test view。该方法调用<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/pointInside:withEvent:">pointInside:withEvent:</a>方法，如果传入hitTest:withEvent:的point在view的边界范围内，则pointInside:withEvent:返回YES。然后，这个方法会在view的所有子view中递归的调用hitTest:withEvent:。</p>

<p>如果传入hitTest:withEvent:的point不在view的边界范围内，则pointInside:withEvent:返回NO。这个point会被忽略，hitTest:withEvent:返回nil。如果一个子view返回NO，则它所在的view的层级上的分支的子view都会被忽略。</p>

<p>Hit-test view是处理触摸事件的第一选择，如果hit-test view不能处理事件，该事件将从事件响应链中寻找响应器，直到系统找到一个处理事件的对象。</p>

<h3>响应器链</h3>

<p>一些类型的事件的传递依赖响应器链。响应器链（responder chain）是一系列相关的响应器对象。它开始于第一个响应器终止于应用对象（application object）。如果第一个responder不处理事件，则会根据responder chain将event传递给下一个responder。</p>

<p>Responder object，即可以响应和处理事件的对象。UIResponder类是所有responder对象的基类，它定义了动态的接口，不仅处理事件也包括处理响应行为。包括UIApplication，UIViewController，和UIView类都是responder，这意味着所有view和大部分关键的controller对象都是responder。但是Core Animation layers不是responders。</p>

<p>First responder被设计来第一个接收事件。典型的，first responder是一个view object。之所以成为第一个responder由于两个原因：</p>

<ol>
<li>覆盖canBecomeFirstResponder方法，返回YES。</li>
<li>接收becomeFirstResponder消息。如果必须，一个object能发送给自身这个消息。</li>
</ol>


<h3>响应器链的传输路径</h3>

<p>如果初始化对象（initial object）—— 即hit-test view或者first responder —— 不处理事件，UIKit会将事件传递给responder chain的下一个responder。每个responder决定它是传递事件还是通过nextResponder方法传递给它的下一个responder。这个操作继续直到一个responder处理event或者没有responder了。</p>

<p>Responder chain 序列在iOS确定一个事件并将它传递给initial object（通常是view）时开始。所以initial view有处理事件的第一个机会。下图描述了两个不同的事件传递路径（因为不同的app 设置）。一个App的事件传递路径由app特殊的构成决定，但事件传递路径会遵守相同的规则。</p>

<p><img src="http://lucifer1988.github.io/images/responser_chain.jpeg"></p>

<h3>手动指定当前view不响应事件</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">pointInside:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">point</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">UIView</span> <span class="o">*</span><span class="n">view</span> <span class="k">in</span> <span class="n">self</span><span class="p">.</span><span class="n">subviews</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">view</span><span class="p">.</span><span class="n">hidden</span> <span class="o">&amp;&amp;</span> <span class="n">view</span><span class="p">.</span><span class="n">userInteractionEnabled</span> <span class="o">&amp;&amp;</span> <span class="p">[</span><span class="n">view</span> <span class="nl">pointInside:</span><span class="p">[</span><span class="n">self</span> <span class="nl">convertPoint:</span><span class="n">point</span> <span class="nl">toView:</span><span class="n">view</span><span class="p">]</span> <span class="nl">withEvent:</span><span class="n">event</span><span class="p">])</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>总结</h3>

<p>事件的传递和响应分两个链：</p>

<ul>
<li>传递链：由系统向离用户最近的view传递。UIKit –> active app’s event queue –> window –> root view –>……–>lowest view</li>
<li>响应链：由离用户最近的view向系统传递。initial view –> super view –> …..–> view controller –> window –> Application</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回答Sunny的55道iOS面试题2]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/30/hui-da-sunnyde-55dao-iosmian-shi-ti-2/"/>
    <updated>2015-10-30T14:36:08+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/30/hui-da-sunnyde-55dao-iosmian-shi-ti-2</id>
    <content type="html"><![CDATA[<p>百度知道的<a href="http://weibo.com/u/1364395395">微博@我就叫Sunny怎么了</a>出了55道iOS的面试题，很多题目是很有深度，这次会将剩下的题目完成解答。</p>

<!--more-->


<h3>25. <code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？</h3>

<p><strong>我的解答：</strong></p>

<p><code>_objc_msgForward</code>用于消息的转发，直接调用会直接进入消息转发阶段。</p>

<p><strong>大神解答：</strong></p>

<blockquote><p><code>_objc_msgForward</code>是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p></blockquote>

<p>我们可以这样创建一个<code>_objc_msgForward</code>对象：</p>

<pre><code>IMP msgForwardIMP = _objc_msgForward;
</code></pre>

<p>在<a href="http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1/">上篇</a>中的《objc中向一个对象发送消息<code>[obj foo]</code>和<code>objc_msgSend()</code>函数之间有什么关系？》曾提到<code>objc_msgSend</code>在“消息传递”中的作用。在“消息传递”过程中，<code>objc_msgSend</code>的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用<code>_objc_msgForward</code>函数指针代替 IMP 。最后，执行这个 IMP 。</p>

<p>Objective-C运行时是开源的，所以我们可以看到它的实现。打开<a href="http://www.opensource.apple.com/tarballs/objc4/"> <strong><em>Apple Open Source 里Mac代码里的obj包</em></strong> </a>下载一个最新版本，找到 <code>objc-runtime-new.mm</code>，进入之后搜索<code>_objc_msgForward</code>。</p>

<p><img src="http://i.imgur.com/rGBfaoL.png" alt="enter image description here" /></p>

<p>里面有对<code>_objc_msgForward</code>的功能解释：</p>

<p><img src="http://i.imgur.com/vcThcdA.png" alt="enter image description here" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="cm">/***********************************************************************</span>
</span><span class='line'><span class="cm">* lookUpImpOrForward.</span>
</span><span class='line'><span class="cm">* The standard IMP lookup. </span>
</span><span class='line'><span class="cm">* initialize==NO tries to avoid +initialize (but sometimes fails)</span>
</span><span class='line'><span class="cm">* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)</span>
</span><span class='line'><span class="cm">* Most callers should use initialize==YES and cache==YES.</span>
</span><span class='line'><span class="cm">* inst is an instance of cls or a subclass thereof, or nil if none is known. </span>
</span><span class='line'><span class="cm">*   If cls is an un-initialized metaclass then a non-nil inst is faster.</span>
</span><span class='line'><span class="cm">* May return _objc_msgForward_impcache. IMPs destined for external use </span>
</span><span class='line'><span class="cm">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</span>
</span><span class='line'><span class="cm">*   If you don&#39;t want forwarding at all, use lookUpImpOrNil() instead.</span>
</span><span class='line'><span class="cm">**********************************************************************/</span>
</span></code></pre></td></tr></table></div></figure>


<p>对 <code>objc-runtime-new.mm</code>文件里与<code>_objc_msgForward</code>有关的三个函数使用伪代码展示下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//  objc-runtime-new.mm 文件里与 _objc_msgForward 有关的三个函数使用伪代码展示</span>
</span><span class='line'><span class="c1">//  Created by https://github.com/ChenYilong</span>
</span><span class='line'><span class="c1">//  Copyright (c)  微博@iOS程序犭袁(http://weibo.com/luohanchenyilong/). All rights reserved.</span>
</span><span class='line'><span class="c1">//  同时，这也是 obj_msgSend 的实现过程</span>
</span><span class='line'>
</span><span class='line'><span class="kt">id</span> <span class="nf">objc_msgSend</span><span class="p">(</span><span class="kt">id</span> <span class="n">self</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">op</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>  <span class="n">IMP</span> <span class="n">imp</span> <span class="o">=</span> <span class="n">class_getMethodImplementation</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">isa</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">op</span><span class="p">);</span>
</span><span class='line'>  <span class="n">imp</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="p">...);</span> <span class="c1">//调用这个函数，伪代码...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//查找IMP</span>
</span><span class='line'><span class="n">IMP</span> <span class="nf">class_getMethodImplementation</span><span class="p">(</span><span class="n">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">sel</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span> <span class="o">||</span> <span class="o">!</span><span class="n">sel</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="n">IMP</span> <span class="n">imp</span> <span class="o">=</span> <span class="n">lookUpImpOrNil</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">sel</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">imp</span><span class="p">)</span> <span class="k">return</span> <span class="n">_objc_msgForward</span><span class="p">;</span> <span class="c1">//_objc_msgForward 用于消息转发</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">imp</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">IMP</span> <span class="nf">lookUpImpOrNil</span><span class="p">(</span><span class="n">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">sel</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">_class_initialize</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Class</span> <span class="n">curClass</span> <span class="o">=</span> <span class="n">cls</span><span class="p">;</span>
</span><span class='line'>    <span class="n">IMP</span> <span class="n">imp</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="k">do</span> <span class="p">{</span> <span class="c1">//先查缓存,缓存没有时重建,仍旧没有则向父类查询</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curClass</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curClass</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">)</span> <span class="n">fill_cache</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">curClass</span><span class="p">);</span>
</span><span class='line'>        <span class="n">imp</span> <span class="o">=</span> <span class="n">cache_getImp</span><span class="p">(</span><span class="n">curClass</span><span class="p">,</span> <span class="n">sel</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">imp</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">curClass</span> <span class="o">=</span> <span class="n">curClass</span><span class="o">-&gt;</span><span class="n">superclass</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">imp</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然Apple没有公开<code>_objc_msgForward</code>的实现源码，但是我们还是能得出结论：</p>

<blockquote><p><code>_objc_msgForward</code>是一个函数指针（和 IMP 的类型一样），是用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p>

<p>在<a href="http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1/">上篇</a>中的《objc中向一个对象发送消息<code>[obj foo]</code>和<code>objc_msgSend()</code>函数之间有什么关系？》曾提到<code>objc_msgSend</code>在“消息传递”中的作用。在“消息传递”过程中，<code>objc_msgSend</code>的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用<code>_objc_msgForward</code>函数指针代替 IMP 。最后，执行这个 IMP 。</p></blockquote>

<p>为了展示消息转发的具体动作，这里尝试向一个对象发送一条错误的消息，并查看一下<code>_objc_msgForward</code>是如何进行转发的。</p>

<p>首先开启调试模式、打印出所有运行时发送的消息：
可以在代码里执行下面的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">instrumentObjcMessageSends</span><span class="p">(</span><span class="n">YES</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者断点暂停程序运行，并在 gdb 中输入下面的命令：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">call</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">instrumentObjcMessageSends</span><span class="p">(</span><span class="n">YES</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>以第二种为例，操作如下所示：</p>

<p><img src="http://i.imgur.com/uEwTCC4.png" alt="enter image description here" /></p>

<p>之后，运行时发送的所有消息都会打印到<code>/tmp/msgSend-xxxx</code>文件里了。</p>

<p>终端中输入命令前往：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">open</span> <span class="o">/</span><span class="n">private</span><span class="o">/</span><span class="n">tmp</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://i.imgur.com/Fh5hhCw.png" alt="enter image description here" /></p>

<p>可能看到有多条，找到最新生成的，双击打开</p>

<p>在模拟器上执行执行以下语句（这一套调试方案仅适用于模拟器，真机不可用，关于该调试方案的拓展链接：<a href="http://stackoverflow.com/a/10750398/3395008"> <strong><em>Can the messages sent to an object in Objective-C be monitored or printed out?</em></strong> </a>），向一个对象发送一条错误的消息：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">//  main.m</span>
</span><span class='line'><span class="c1">//  CYLObjcMsgForwardTest</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">//  Created by http://weibo.com/luohanchenyilong/.</span>
</span><span class='line'><span class="c1">//  Copyright (c) 2015年 微博@iOS程序犭袁. All rights reserved.</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#import &lt;UIKit/UIKit.h&gt;</span>
</span><span class='line'><span class="cp">#import &quot;AppDelegate.h&quot;</span>
</span><span class='line'><span class="cp">#import &quot;CYLTest.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="err">@</span><span class="n">autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CYLTest</span> <span class="o">*</span><span class="n">test</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CYLTest</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">test</span> <span class="nl">performSelector:</span><span class="p">(</span><span class="k">@selector</span><span class="p">(</span><span class="n">iOS</span><span class="err">程序犭袁</span><span class="p">))];</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">UIApplicationMain</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">AppDelegate</span> <span class="n">class</span><span class="p">]));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://i.imgur.com/UjbmVvB.png" alt="enter image description here" /></p>

<p>你可以在<code>/tmp/msgSend-xxxx</code>（我这一次是<code>/tmp/msgSend-9805</code>）文件里，看到打印出来：</p>

<p><img src="http://i.imgur.com/AAERz1T.png" alt="enter image description here" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">+</span> <span class="nf">CYLTest</span> <span class="n">NSObject</span> <span class="n">initialize</span>
</span><span class='line'><span class="o">+</span> <span class="n">CYLTest</span> <span class="n">NSObject</span> <span class="n">alloc</span>
</span><span class='line'><span class="o">-</span> <span class="n">CYLTest</span> <span class="n">NSObject</span> <span class="n">init</span>
</span><span class='line'><span class="o">-</span> <span class="n">CYLTest</span> <span class="n">NSObject</span> <span class="nl">performSelector:</span>
</span><span class='line'><span class="o">+</span> <span class="n">CYLTest</span> <span class="n">NSObject</span> <span class="nl">resolveInstanceMethod:</span>
</span><span class='line'><span class="o">+</span> <span class="n">CYLTest</span> <span class="n">NSObject</span> <span class="nl">resolveInstanceMethod:</span>
</span><span class='line'><span class="o">-</span> <span class="n">CYLTest</span> <span class="n">NSObject</span> <span class="nl">forwardingTargetForSelector:</span>
</span><span class='line'><span class="o">-</span> <span class="n">CYLTest</span> <span class="n">NSObject</span> <span class="nl">forwardingTargetForSelector:</span>
</span><span class='line'><span class="o">-</span> <span class="n">CYLTest</span> <span class="n">NSObject</span> <span class="nl">methodSignatureForSelector:</span>
</span><span class='line'><span class="o">-</span> <span class="n">CYLTest</span> <span class="n">NSObject</span> <span class="nl">methodSignatureForSelector:</span>
</span><span class='line'><span class="o">-</span> <span class="n">CYLTest</span> <span class="n">NSObject</span> <span class="n">class</span>
</span><span class='line'><span class="o">-</span> <span class="n">CYLTest</span> <span class="n">NSObject</span> <span class="nl">doesNotRecognizeSelector:</span>
</span><span class='line'><span class="o">-</span> <span class="n">CYLTest</span> <span class="n">NSObject</span> <span class="nl">doesNotRecognizeSelector:</span>
</span><span class='line'><span class="o">-</span> <span class="n">CYLTest</span> <span class="n">NSObject</span> <span class="n">class</span>
</span></code></pre></td></tr></table></div></figure>


<p>结合<a href="https://developer.apple.com/library/prerelease/watchos/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/#//apple_ref/doc/uid/20000050-SW11">《NSObject官方文档》</a>，排除掉 NSObject 做的事，剩下的就是<code>_objc_msgForward</code>消息转发做的几件事：</p>

<ol>
<li><p>调用<code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始<code>objc_msgSend</code>流程。这一次对象会响应这个选择器，一般是因为它已经调用过<code>class_addMethod</code>。如果仍没实现，继续下面的动作。</p></li>
<li><p>调用<code>forwardingTargetForSelector:</code>方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。</p></li>
<li><p>调用<code>methodSignatureForSelector:</code>方法，尝试获得一个方法签名。如果获取不到，则直接调用<code>doesNotRecognizeSelector</code>抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给<code>forwardInvocation:</code>。</p></li>
<li><p>调用<code>forwardInvocation:</code>方法，将第3步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。</p></li>
<li><p>调用<code>doesNotRecognizeSelector:</code> ，默认的实现是抛出异常。如果第3步没能获得一个方法签名，执行该步骤。</p></li>
</ol>


<p>上面前4个方法均是模板方法，开发者可以override，由 runtime 来调用。最常见的实现消息转发：就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的</p>

<p>也就是说<code>_objc_msgForward</code>在进行消息转发的过程中会涉及以下这几个方法：</p>

<ol>
<li><p><code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。</p></li>
<li><p><code>forwardingTargetForSelector:</code>方法</p></li>
<li><p><code>methodSignatureForSelector:</code>方法</p></li>
<li><p><code>forwardInvocation:</code>方法</p></li>
<li><p><code>doesNotRecognizeSelector:</code> 方法</p></li>
</ol>


<p>为了能更清晰地理解这些方法的作用，git仓库里也给出了一个Demo，名称叫“ <code>_objc_msgForward_demo</code> ”,可运行起来看看。</p>

<p>下面回答下第二个问题“直接<code>_objc_msgForward</code>调用它将会发生什么？”</p>

<p>直接调用<code>_objc_msgForward</code>是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。</p>

<p>就好像跑酷，干得好，叫“耍酷”，干不好就叫“作死”。</p>

<p>正如前文所说：</p>

<blockquote><p><code>_objc_msgForward</code>是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p></blockquote>

<p>如何调用<code>_objc_msgForward</code>？<br/>
<code>_objc_msgForward</code>隶属 C 语言，有三个参数 ：</p>

<table>
<thead>
<tr>
<th>序号</th>
<th> <code>_objc_msgForward</code>参数</th>
<th> 类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td> 1. </td>
<td> 所属对象 </td>
<td> id类型</td>
</tr>
<tr>
<td> 2. </td>
<td>方法名 </td>
<td> SEL类型 </td>
</tr>
<tr>
<td> 3. </td>
<td>可变参数 </td>
<td>可变参数类型</td>
</tr>
</tbody>
</table>


<p>首先了解下如何调用 IMP 类型的方法，IMP类型是如下格式：</p>

<p>为了直观，我们可以通过如下方式定义一个 IMP类型 ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">voidIMP</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">,</span> <span class="p">...)</span>
</span></code></pre></td></tr></table></div></figure>


<p>一旦调用<code>_objc_msgForward</code>，将跳过查找 IMP 的过程，直接触发“消息转发”，</p>

<p>如果调用了<code>_objc_msgForward</code>，即使这个对象确实已经实现了这个方法，你也会告诉<code>objc_msgSend</code>：</p>

<blockquote><p>“我没有在这个对象里找到这个方法的实现”</p></blockquote>

<p>想象下<code>objc_msgSend</code>会怎么做？通常情况下，下面这张图就是你正常走<code>objc_msgSend</code>过程，和直接调用<code>_objc_msgForward</code>的前后差别：</p>

<p><img src="http://ww1.sinaimg.cn/bmiddle/6628711bgw1eecx3jef23g206404tkbi.gif" alt="enter image description here" /></p>

<p>有哪些场景需要直接调用<code>_objc_msgForward</code>？最常见的场景是：你想获取某方法所对应的<code>NSInvocation</code>对象。举例说明：</p>

<p><a href="https://github.com/bang590/JSPatch">JSPatch （Github 链接）</a>就是直接调用<code>_objc_msgForward</code>来实现其核心功能的：</p>

<blockquote><p> JSPatch 以小巧的体积做到了让JS调用/替换任意OC方法，让iOS APP具备热更新的能力。</p></blockquote>

<p>作者的博文<a href="http://blog.cnbang.net/tech/2808/">《JSPatch实现原理详解》</a>详细记录了实现原理，有兴趣可以看下。</p>

<h3>26. runtime如何实现weak变量的自动置nil？</h3>

<p><strong>我的解答：</strong></p>

<p>原理不清楚。</p>

<p><strong>大神解答：</strong></p>

<blockquote><p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p></blockquote>

<p>在<a href="http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1/">上篇</a>中的《runtime 如何实现 weak 属性》有论述。（注：在<a href="http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1/">上篇</a>的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到<code>__weak</code>引用的解除时间。）</p>

<p>我们可以设计一个函数（伪代码）来表示上述机制：</p>

<p><code>objc_storeWeak(&amp;a, b)</code>函数：</p>

<p><code>objc_storeWeak</code>函数把第二个参数&mdash;赋值对象（b）的内存地址作为键值key，将第一个参数&mdash;weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，</p>

<p>你可以把<code>objc_storeWeak(&amp;a, b)</code>理解为：<code>objc_storeWeak(value, key)</code>，并且当key变nil，将value置nil。</p>

<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>

<p>而如果a是由assign修饰的，则：
在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。</p>

<p>下面我们将基于<code>objc_storeWeak(&amp;a, b)</code>函数，使用伪代码模拟“runtime如何实现weak属性”：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">// 使用伪代码模拟：runtime如何实现weak属性</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>
</span><span class='line'> <span class="kt">id</span> <span class="n">obj1</span><span class="p">;</span>
</span><span class='line'> <span class="n">objc_initWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="cm">/*obj引用计数变为0，变量作用域结束*/</span>
</span><span class='line'> <span class="n">objc_destroyWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面对用到的两个方法<code>objc_initWeak</code>和<code>objc_destroyWeak</code>做下解释：</p>

<p>总体说来，作用是：
通过<code>objc_initWeak</code>函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过<code>objc_destoryWeak</code>函数释放该变量（obj1）。</p>

<p>下面分别介绍下方法的内部实现：</p>

<p><code>objc_initWeak</code>函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用<code>objc_storeWeak</code>函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">obj1</span> <span class="o">=</span> <span class="mi">0</span><span class="err">；</span>
</span><span class='line'><span class="n">obj_storeWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>也就是说：</p>

<blockquote><p> weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）</p></blockquote>

<p>然后<code>obj_destroyWeak</code>函数将0（nil）作为参数，调用<code>objc_storeWeak</code>函数。</p>

<p><code>objc_storeWeak(&amp;obj1, 0);</code></p>

<p>前面的源代码与下列源代码相同。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">// 使用伪代码模拟：runtime如何实现weak属性</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>
</span><span class='line'><span class="kt">id</span> <span class="n">obj1</span><span class="p">;</span>
</span><span class='line'><span class="n">obj1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">objc_storeWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="cm">/* ... obj的引用计数变为0，被置nil ... */</span>
</span><span class='line'><span class="n">objc_storeWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>objc_storeWeak</code>函数把第二个参数&mdash;赋值对象（obj）的内存地址作为键值，将第一个参数&mdash;weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除。</p>

<h3>27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3>

<p><strong>我的解答：</strong></p>

<p>不能向编译后得到的类添加实例变量，可以向运行时创建的类添加实例变量，OC是动态语言，可以在运行时向类添加实例变量和方法，原理不知道。</p>

<p><strong>大神解答：</strong></p>

<ul>
<li>不能向编译后得到的类中增加实例变量；</li>
<li>能向运行时创建的类中添加实例变量；</li>
</ul>


<p>解释下：</p>

<ul>
<li><p>因为编译后的类已经注册在 runtime 中，类结构体中的 <code>objc_ivar_list</code> 实例变量的链表 和 <code>instance_size</code> 实例变量的内存大小已经确定，同时runtime 会调用 <code>class_setIvarLayout</code> 或 <code>class_setWeakIvarLayout</code> 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；</p></li>
<li><p>运行时创建的类是可以添加实例变量，调用 <code>class_addIvar</code> 函数。但是得在调用 <code>objc_allocateClassPair</code> 之后，<code>objc_registerClassPair</code> 之前，原因同上。</p></li>
</ul>


<h3>28. runloop和线程有什么关系？</h3>

<p><strong>我的解答：</strong></p>

<p>额，看大神的。</p>

<p><strong>大神解答：</strong></p>

<p>总的说来，Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分， Cocoa 和 CoreFundation 都提供了 run loop 对象方便配置和管理线程的 run loop （以下都以 Cocoa 为例）。每个线程，包括程序的主线程（ main thread ）都有与之相应的 run loop 对象。</p>

<p> runloop 和线程的关系：</p>

<ol>
<li>主线程的run loop默认是启动的。</li>
</ol>


<p> iOS的应用程序里面，程序启动后会有一个如下的main()函数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="err">@</span><span class="n">autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">UIApplicationMain</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">AppDelegate</span> <span class="n">class</span><span class="p">]));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p> 重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p>

<ol>
<li><p>对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。</p></li>
<li><p>在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。</p></li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSRunLoop</span> <span class="o">*</span><span class="n">runloop</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>参考链接：<a href="http://blog.csdn.net/wzzvictory/article/details/9237973">《Objective-C之run loop详解》</a>。</p>

<h3>29. runloop的mode作用是什么？</h3>

<p><strong>我的解答：</strong></p>

<p>额，继续看大神的。</p>

<p><strong>大神解答：</strong></p>

<p>model 主要是用来指定事件在运行循环中的优先级的，分为：</p>

<ul>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态</li>
<li>UITrackingRunLoopMode：ScrollView滑动时</li>
<li>UIInitializationRunLoopMode：启动时</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合</li>
</ul>


<p>苹果公开提供的 Mode 有两个：</p>

<ol>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）</li>
</ol>


<h3>30. 以+ scheduledTimerWithTimeInterval&hellip;的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3>

<p><strong>我的解答：</strong></p>

<p>应该和上面的Runloop的mode优先级有关，具体原因不明。</p>

<p><strong>大神解答：</strong></p>

<p>RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunLoopMode模式下处理的事件会影响scrllView的滑动。</p>

<p>如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候,
ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。</p>

<p>同时因为mode还是可定制的，所以：</p>

<p> Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决。代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">// </span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//将timer添加到NSDefaultRunLoopMode中</span>
</span><span class='line'><span class="n">NSTimer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nl">scheduledTimerWithTimeInterval:</span><span class="mf">1.0</span>
</span><span class='line'>     <span class="nl">target:</span><span class="n">self</span>
</span><span class='line'>     <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">timerTick:</span><span class="p">)</span>
</span><span class='line'>     <span class="nl">userInfo:</span><span class="nb">nil</span>
</span><span class='line'>     <span class="nl">repeats:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'><span class="c1">//然后再添加到NSRunLoopCommonModes里</span>
</span><span class='line'><span class="n">NSTimer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nl">timerWithTimeInterval:</span><span class="mf">1.0</span>
</span><span class='line'>     <span class="nl">target:</span><span class="n">self</span>
</span><span class='line'>     <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">timerTick:</span><span class="p">)</span>
</span><span class='line'>     <span class="nl">userInfo:</span><span class="nb">nil</span>
</span><span class='line'>     <span class="nl">repeats:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'><span class="p">[[</span><span class="n">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">addTimer:</span><span class="n">timer</span> <span class="nl">forMode:</span><span class="n">NSRunLoopCommonModes</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>31. 猜想runloop内部是如何实现的？</h3>

<p><strong>我的解答：</strong></p>

<p>额，继续看大神的。</p>

<p><strong>大神解答：</strong></p>

<blockquote><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑
是这样的：</p></blockquote>

<pre><code>function loop() {
    initialize();
    do {
        var message = get_next_message();
        process_message(message);
    } while (message != quit);
}
</code></pre>

<p>或使用伪代码来展示下:</p>

<pre><code>// 
// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)
// https://github.com/ChenYilong
int main(int argc, char * argv[]) {
 //程序一直运行状态
 while (AppIsRunning) {
      //睡眠状态，等待唤醒事件
      id whoWakesMe = SleepForWakingUp();
      //得到唤醒事件
      id event = GetEvent(whoWakesMe);
      //开始处理事件
      HandleEvent(event);
 }
 return 0;
}
</code></pre>

<p>参考链接：</p>

<ol>
<li><a href="http://blog.ibireme.com/2015/05/18/runloop/#base">《深入理解RunLoop》</a></li>
<li>摘自博文<a href="https://github.com/ming1016/study/wiki/CFRunLoop"><strong><em>CFRunLoop</em></strong></a>，原作者是<a href="http://weibo.com/u/1364395395">微博@我就叫Sunny怎么了</a></li>
</ol>


<h3>32. objc使用什么机制管理对象内存？</h3>

<p><strong>我的解答：</strong></p>

<p>通过retain count，即引用计数，来管理对象内存，当retain count大于0时对象内存就不会释放，而retain count为0时对象会自动释放内存，通过retain、release来增加/减少retain count。</p>

<p><strong>大神解答：</strong></p>

<p>通过 retainCount 的机制来决定对象是否需要释放。
每次 runloop 的时候，都会检查对象的 retainCount，如果retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。</p>

<h3>33. ARC通过什么方式帮助开发者管理内存？</h3>

<p><strong>我的解答：</strong></p>

<p>ARC引入了新的关键字strong、weak来描述对象的持有关系，更加简化了对象对内存的占有关系，而在实现时还是使用retain count机制，只是编译器会自动添加内存相关的代码，而且很多地方作了特殊的优化，比如：对象创建方法和普通方法返回对象时，会添加不同的内存关键字，所以ARC还是强烈推荐的。</p>

<p><strong>大神解答：</strong></p>

<p> <p><del>编译时根据代码上下文，插入 retain/release
</del></p>
ARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单。应该是编译期和运行期两部分共同帮助开发者管理内存。</p>

<p>在编译期，ARC用的是更底层的C接口实现的retain/release/autorelease，这样做性能更好，也是为什么不能在ARC环境下手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化（即忽略掉不必要的操作）；ARC也包含运行期组件，这个地方做的优化比较复杂，但也不能被忽略。【TODO:后续更新会详细描述下】</p>

<h3>34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h3>

<p><strong>我的解答：</strong></p>

<p>该对象加入最近创建的的autoreleasepool中，而该autoreleasepool会在当前runloop循环结束时，执行drain操作，而此时其内的对象都会被执行一次release操作。</p>

<p><strong>大神解答：</strong></p>

<p>分两种情况：手动干预释放时机、系统自动去释放。</p>

<ol>
<li>手动干预释放时机&mdash;指定autoreleasepool
就是所谓的：当前作用域大括号结束时释放。</li>
<li>系统自动去释放&mdash;不手动指定autoreleasepool</li>
</ol>


<p>  Autorelease对象出了作用域之后，会被添加到最近一次创建的自动释放池中，并会在当前的 runloop 迭代结束时释放。</p>

<p>释放的时机总结起来，可以用下图来表示：</p>

<p><img src="http://i61.tinypic.com/28kodwp.jpg" alt="autoreleasepool与 runloop 的关系图" /></p>

<p>下面对这张图进行详细的解释：</p>

<p>从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</p>

<p>我们都是知道：
<strong>所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。</strong></p>

<p>但是如果每次都放进应用程序的 <code>main.m</code> 中的 autoreleasepool 中，迟早有被撑满的一刻。这个过程中必定有一个释放的动作。何时？</p>

<p>在一次完整的运行循环结束之前，会被销毁。</p>

<p>那什么时间会创建自动释放池？运行循环检测到事件并启动后，就会创建自动释放池。</p>

<p>子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。</p>

<p>自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如： 自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。</p>

<p>但对于 blockOperation 和 invocationOperation 这种默认的Operation ，系统已经帮我们封装好了，不需要手动创建自动释放池。</p>

<p>@autoreleasepool 当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release 消息，释放自动释放池中的所有对象。</p>

<p> 如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。</p>

<p>参考链接：<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">《黑幕背后的Autorelease》</a></p>

<h3>35. BAD_ACCESS在什么情况下出现？</h3>

<p><strong>我的解答：</strong></p>

<p>当所访问的对象指针指向的内存已经释放，但指针没有置nil，成为野指针，会报BAD_ACCESS错误。</p>

<p><strong>大神解答：</strong></p>

<p>访问了野指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。</p>

<h3>36. 苹果是如何实现autoreleasepool的？</h3>

<p><strong>我的解答：</strong></p>

<p>autoreleasepool在内存中是以栈的形式储存的，在顶端的的pool会最先经行drain操作。</p>

<p><strong>大神解答：</strong></p>

<p>autoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成.</p>

<ol>
<li><code>objc_autoreleasepoolPush</code></li>
<li><code>objc_autoreleasepoolPop</code></li>
<li><code>objc_autorelease</code></li>
</ol>


<p>看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。</p>

<p>举例说明：我们都知道用类方法创建的对象都是 Autorelease 的，那么一旦 Person 出了作用域，当在 Person 的 dealloc 方法中打上断点，我们就可以看到这样的调用堆栈信息：</p>

<p> <img src="http://i60.tinypic.com/15mfj11.jpg" alt="enter image description here" /></p>

<h3>37. 使用block时什么情况会发生引用循环，如何解决？</h3>

<p><strong>我的解答：</strong></p>

<p>当block本身作为类的强引用，而在block内部又对self的属性进行的使用，因为block会默认retain包含的对象，所以此时block会与self相互引用，而导致循环引用，解决方法一般是声明__weak属性的self替代，而在block内部使用weak替代，这样block就不会对self有强引用，从而解除这一循环。</p>

<p><strong>大神解答：</strong></p>

<p>一个对象中强引用了block，在block中又使用了该对象，就会发射循环引用。
解决方法是将该对象使用<strong>weak或者</strong>block修饰符修饰之后再在block中使用。</p>

<ol>
<li>id weak weakSelf = self;
或者 weak __typeof(&amp;*self)weakSelf = self该方法可以设置宏</li>
<li>id __block weakSelf = self;</li>
</ol>


<h3>38. 在block内如何修改block外部变量？</h3>

<p><strong>我的解答：</strong></p>

<p>使用__block关键字来修饰需要改变的对象，该对象可在block内修改。</p>

<p><strong>大神解答：</strong></p>

<p>默认情况下，在block中访问的外部变量是复制过去的，即：<strong>写操作不对原变量生效</strong>。但是你可以加上<code>__block</code>来让其写操作生效，示例代码如下:</p>

<pre><code>__block int a = 0;
void  (^foo)(void) = ^{ 
    a = 1; 
}
f00(); 
//这里，a的值被修改为1
</code></pre>

<p>参考链接：<a href="http://weibo.com/tangqiaoboy">微博@唐巧_boy</a>的著作《iOS开发进阶》中的第11.2.3章节</p>

<h3>39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h3>

<p><strong>我的解答：</strong></p>

<p>不需要，因为这些block并不被当前类型实例持有，即使在内部使用了self的实例变量，也不会造成引用循环。</p>

<p><strong>大神解答：</strong></p>

<p>系统的某些block api中，UIView的block版本写动画时不需要考虑，但也有一些api 需要考虑：</p>

<p>所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block 强引用 self ）没有问题，比如这些：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">[</span><span class="n">UIView</span> <span class="nl">animateWithDuration:</span><span class="n">duration</span> <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">superview</span> <span class="n">layoutIfNeeded</span><span class="p">];</span> <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">[[</span><span class="n">NSOperationQueue</span> <span class="n">mainQueue</span><span class="p">]</span> <span class="nl">addOperationWithBlock:</span><span class="o">^</span><span class="p">{</span> <span class="n">self</span><span class="p">.</span><span class="n">someProperty</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">;</span> <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">addObserverForName:</span><span class="s">@&quot;someNotification&quot;</span>
</span><span class='line'>                                                  <span class="nl">object:</span><span class="nb">nil</span>
</span><span class='line'>                           <span class="nl">queue:</span><span class="p">[</span><span class="n">NSOperationQueue</span> <span class="n">mainQueue</span><span class="p">]</span>
</span><span class='line'>                                              <span class="nl">usingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSNotification</span> <span class="o">*</span> <span class="n">notification</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                                                    <span class="n">self</span><span class="p">.</span><span class="n">someProperty</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">;</span> <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>这些情况不需要考虑“引用循环”。</p>

<p>但如果你使用一些参数中可能含有 ivar 的系统 api ，如 GCD 、NSNotificationCenter就要小心一点：比如GCD 内部如果引用了 self，而且 GCD 的其他参数是 ivar，则要考虑到循环引用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">__weak</span> <span class="n">__typeof__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="n">weakSelf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">_operationsGroup</span><span class="p">,</span> <span class="n">_operationsQueue</span><span class="p">,</span> <span class="o">^</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="n">__typeof__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">strongSelf</span> <span class="n">doSomething</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">strongSelf</span> <span class="n">doSomethingElse</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>类似的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'>  <span class="n">__weak</span> <span class="n">__typeof__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="n">weakSelf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'>  <span class="n">_observer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">addObserverForName:</span><span class="s">@&quot;testKey&quot;</span>
</span><span class='line'>                                                                <span class="nl">object:</span><span class="nb">nil</span>
</span><span class='line'>                                                                 <span class="nl">queue:</span><span class="nb">nil</span>
</span><span class='line'>                                                            <span class="nl">usingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSNotification</span> <span class="o">*</span><span class="n">note</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">__typeof__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>
</span><span class='line'>      <span class="p">[</span><span class="n">strongSelf</span> <span class="nl">dismissModalViewControllerAnimated:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>self &mdash;> _observer &mdash;> block &mdash;> self 显然这也是一个循环引用。</p>

<h3>40. GCD的队列（<code>dispatch_queue_t</code>）分哪两种类型？</h3>

<p><strong>我的解答：</strong></p>

<p>执行的时候分同步和异步。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>串行队列Serial Dispatch Queue</li>
<li>并行队列Concurrent Dispatch Queue</li>
</ol>


<h3>41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h3>

<p><strong>我的解答：</strong></p>

<p>使用dispatch group技术，将多个dispatch queue加入同一group中，然后在group任务结束时，统一执行合成任务。</p>

<p><strong>大神解答：</strong></p>

<p>使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span> <span class="cm">/*加载图片1 */</span> <span class="p">});</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span> <span class="cm">/*加载图片2 */</span> <span class="p">});</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span> <span class="cm">/*加载图片3 */</span> <span class="p">});</span>
</span><span class='line'><span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="c1">// 合并图片</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<h3>42. <code>dispatch_barrier_async</code>的作用是什么？</h3>

<p><strong>我的解答：</strong></p>

<p>是用来阻塞当前queue内的并发线程，然后执行阻塞的任务，任务执行完后，继续并发操作。</p>

<p><strong>大神解答：</strong></p>

<p> 在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。
 <code>dispatch_barrier_async</code> 函数会等待追加到Concurrent Dispatch Queue并行队列中的操作全部执行完之后，然后再执行 <code>dispatch_barrier_async</code> 函数追加的处理，等 <code>dispatch_barrier_async</code> 追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。</p>

<p>打个比方：比如你们公司周末跟团旅游，高速休息站上，司机说：大家都去上厕所，速战速决，上完厕所就上高速。超大的公共厕所，大家同时去，程序猿很快就结束了，但程序媛就可能会慢一些，即使你第一个回来，司机也不会出发，司机要等待所有人都回来后，才能出发。 <code>dispatch_barrier_async</code> 函数追加的内容就如同 “上完厕所就上高速”这个动作。</p>

<p>（注意：使用 <code>dispatch_barrier_async</code> ，该函数只能搭配自定义并行队列 <code>dispatch_queue_t</code> 使用。不能使用： <code>dispatch_get_global_queue</code> ，否则 <code>dispatch_barrier_async</code> 的作用会和 <code>dispatch_async</code> 的作用一模一样。 ）</p>

<h3>43. 苹果为什么要废弃<code>dispatch_get_current_queue</code>？</h3>

<p><strong>我的解答：</strong></p>

<p>因为<code>dispatch_get_current_queue</code>并不能保证获取到的queue就是代码逻辑上正在运行的queue，尤其在dispatch互相嵌套时，按照<code>dispatch_get_current_queue</code>来判断，容易造成死锁。</p>

<p><strong>大神解答：</strong></p>

<p><code>dispatch_get_current_queue</code>容易造成死锁</p>

<h3>44. 以下代码运行结果如何？</h3>

<pre><code>- (void)viewDidLoad
{
    [super viewDidLoad];
    NSLog(@"1");
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@"2");
    });
    NSLog(@"3");
}
</code></pre>

<p><strong>我的解答：</strong></p>

<p>输出1，造成死锁。</p>

<p><strong>大神解答：</strong></p>

<p>只输出：1 。发生主线程锁死。</p>

<h3>45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h3>

<p><strong>我的解答：</strong></p>

<p>observer是监听者，keyPath是要监听的字段，option可以定义值以何种情况下改变触发监听，context不常用，实现的回调是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">observeValueForKeyPath:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">keyPath</span> <span class="nf">ofObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span> <span class="nf">change:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">change</span> <span class="nf">context:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>大神解答：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">// 添加键值观察</span>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm">1 观察者，负责处理监听事件的对象</span>
</span><span class='line'><span class="cm">2 观察的属性</span>
</span><span class='line'><span class="cm">3 观察的选项</span>
</span><span class='line'><span class="cm">4 上下文</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">person</span> <span class="nl">addObserver:</span><span class="n">self</span> <span class="nl">forKeyPath:</span><span class="s">@&quot;name&quot;</span> <span class="nl">options:</span><span class="n">NSKeyValueObservingOptionNew</span> <span class="o">|</span> <span class="n">NSKeyValueObservingOptionOld</span> <span class="nl">context:</span><span class="s">@&quot;Person Name&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>observer中需要实现一下方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">// 所有的 kvo 监听到事件，都会调用此方法</span>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> 1. 观察的属性</span>
</span><span class='line'><span class="cm"> 2. 观察的对象</span>
</span><span class='line'><span class="cm"> 3. change 属性变化字典（新／旧）</span>
</span><span class='line'><span class="cm"> 4. 上下文，与监听的时候传递的一致</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">observeValueForKeyPath:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">keyPath</span> <span class="nf">ofObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span> <span class="nf">change:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">change</span> <span class="nf">context:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>46. 如何手动触发一个value的KVO</h3>

<p><strong>我的解答：</strong></p>

<p>改变所监听属性的值即可触发。</p>

<p><strong>大神解答：</strong></p>

<p>所谓的“手动触发”是区别于“自动触发”：</p>

<p>自动触发是指类似这种场景：在注册 KVO 之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。</p>

<p>想知道如何手动触发，必须知道自动触发 KVO 的原理：</p>

<p>键值观察通知依赖于 NSObject 的两个方法:  <code>willChangeValueForKey:</code> 和 <code>didChangevlueForKey:</code> 。在一个被观察属性发生改变之前，  <code>willChangeValueForKey:</code> 一定会被调用，这就
会记录旧的值。而当改变发生后，  <code>didChangeValueForKey:</code> 会被调用，继而 <code>observeValueForKey:ofObject:change:context:</code> 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了。</p>

<p>那么“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。</p>

<p>具体做法如下：</p>

<p>如果这个  <code>value</code> 是  表示时间的 <code>self.now</code> ，那么代码如下：最后两行代码缺一不可。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//  .m文件</span>
</span><span class='line'><span class="c1">//  Created by https://github.com/ChenYilong</span>
</span><span class='line'><span class="c1">//  微博@iOS程序犭袁(http://weibo.com/luohanchenyilong/).</span>
</span><span class='line'><span class="c1">//  手动触发 value 的KVO，最后两行代码缺一不可。</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//@property (nonatomic, strong) NSDate *now;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">willChangeValueForKey:</span><span class="s">@&quot;now&quot;</span><span class="p">];</span> <span class="c1">// “手动触发self.now的KVO”，必写。</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">didChangeValueForKey:</span><span class="s">@&quot;now&quot;</span><span class="p">];</span> <span class="c1">// “手动触发self.now的KVO”，必写。</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是平时我们一般不会这么干，我们都是等系统去“自动触发”。“自动触发”的实现原理：</p>

<blockquote><p>比如调用 <code>setNow:</code> 时，系统还会以某种方式在中间插入 <code>wilChangeValueForKey:</code> 、 <code>didChangeValueForKey:</code>  和 <code>observeValueForKeyPath:ofObject:change:context:</code> 的调用。</p></blockquote>

<p>大家可能以为这是因为 <code>setNow:</code> 是合成方法，有时候我们也能看到人们这么写代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setNow:</span><span class="p">(</span><span class="n">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="nv">aDate</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">willChangeValueForKey:</span><span class="s">@&quot;now&quot;</span><span class="p">];</span> <span class="c1">// 没有必要</span>
</span><span class='line'>    <span class="n">_now</span> <span class="o">=</span> <span class="n">aDate</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">didChangeValueForKey:</span><span class="s">@&quot;now&quot;</span><span class="p">];</span><span class="c1">// 没有必要</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是完全没有必要的代码，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用 <code>willChangeValueForKey:</code>  ，之后总是调用 <code>didChangeValueForkey:</code> 。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。下文《apple用什么方式实现对一个对象的KVO？》会有详述。</p>

<p>参考链接： <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOCompliance.html#//apple_ref/doc/uid/20002178-SW3">Manual Change Notification&mdash;-Apple 官方文档</a></p>

<h3>47. 若一个类有实例变量 <code>NSString *_foo</code> ，调用setValue:forKey:时，可以以foo还是 <code>_foo</code> 作为key？</h3>

<p><strong>我的解答：</strong></p>

<p>都行。</p>

<p><strong>大神解答：</strong></p>

<p>都可以。</p>

<h3>48. KVC的keyPath中的集合运算符如何使用？</h3>

<p><strong>我的解答：</strong></p>

<p>没用过。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>必须用在集合对象上或普通对象的集合属性上</li>
<li>简单集合运算符有@avg， @count ， @max ， @min ，@sum，</li>
<li>格式 @&ldquo;@sum.age&#8221;或 @&#8221;集合属性.@max.age&rdquo;</li>
</ol>


<h3>49. KVC和KVO的keyPath一定是属性么？</h3>

<p><strong>我的解答：</strong></p>

<p>不清楚有其他类型。</p>

<p><strong>大神解答：</strong></p>

<p>KVO支持实例变量</p>

<h3>50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</h3>

<p><strong>我的解答：</strong></p>

<p>额，不知道。</p>

<p><strong>大神解答：</strong></p>

<p>不常用，大神也没解释，请参考：<a href="http://tech.glowing.com/cn/implement-kvo/">《如何自己动手实现 KVO》</a></p>

<h3>51. apple用什么方式实现对一个对象的KVO？</h3>

<p><strong>我的解答：</strong></p>

<p>额，不清楚。</p>

<p><strong>大神解答：</strong></p>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html">Apple 的文档</a>对 KVO 实现的描述：</p>

<blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling&hellip; When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class &hellip;</p></blockquote>

<p>从<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html">Apple 的文档</a>可以看出：Apple 并不希望过多暴露 KVO 的实现细节。不过，要是借助 runtime 提供的方法去深入挖掘，所有被掩盖的细节都会原形毕露：</p>

<blockquote><p>当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象：值的更改。最后通过 <code>isa 混写（isa-swizzling）</code> 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。我画了一张示意图，如下所示：</p></blockquote>

<p><img src="http://i62.tinypic.com/sy57ur.jpg" alt="enter image description here" /></p>

<p> KVO 确实有点黑魔法：</p>

<blockquote><p>Apple 使用了 <code>isa 混写（isa-swizzling）</code>来实现 KVO 。</p></blockquote>

<p>下面做下详细解释：</p>

<p>键值观察通知依赖于 NSObject 的两个方法:  <code>willChangeValueForKey:</code> 和 <code>didChangevlueForKey:</code> 。在一个被观察属性发生改变之前，  <code>willChangeValueForKey:</code> 一定会被调用，这就会记录旧的值。而当改变发生后，  <code>didChangeValueForKey:</code> 会被调用，继而 <code>observeValueForKey:ofObject:change:context:</code> 也会被调用。可以手动实现这些调用，但很少有人这么做。一般我们只在希望能控制回调的调用时机时才会这么做。大部分情况下，改变通知会自动调用。</p>

<p> 比如调用 <code>setNow:</code> 时，系统还会以某种方式在中间插入 <code>wilChangeValueForKey:</code> 、 <code>didChangeValueForKey:</code>  和 <code>observeValueForKeyPath:ofObject:change:context:</code> 的调用。大家可能以为这是因为 <code>setNow:</code> 是合成方法，有时候我们也能看到人们这么写代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setNow:</span><span class="p">(</span><span class="n">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="nv">aDate</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">willChangeValueForKey:</span><span class="s">@&quot;now&quot;</span><span class="p">];</span> <span class="c1">// 没有必要</span>
</span><span class='line'>    <span class="n">_now</span> <span class="o">=</span> <span class="n">aDate</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">didChangeValueForKey:</span><span class="s">@&quot;now&quot;</span><span class="p">];</span><span class="c1">// 没有必要</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是完全没有必要的代码，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用 <code>willChangeValueForKey:</code>  ，之后总是调用 <code>didChangeValueForkey:</code> 。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。第一次对一个对象调用 <code>addObserver:forKeyPath:options:context:</code> 时，框架会创建这个类的新的 KVO 子类，并将被观察对象转换为新子类的对象。在这个 KVO 特殊子类中， Cocoa 创建观察属性的 setter ，大致工作原理如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setNow:</span><span class="p">(</span><span class="n">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="nv">aDate</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">willChangeValueForKey:</span><span class="s">@&quot;now&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="nl">setValue:</span><span class="n">aDate</span> <span class="nl">forKey:</span><span class="s">@&quot;now&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">didChangeValueForKey:</span><span class="s">@&quot;now&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种继承和方法注入是在运行时而不是编译时实现的。这就是正确命名如此重要的原因。只有在使用KVC命名约定时，KVO才能做到这一点。</p>

<p>KVO 在实现中通过 <code>isa 混写（isa-swizzling）</code> 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。这在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html">Apple 的文档</a>可以得到印证：</p>

<blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling&hellip; When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class &hellip;</p></blockquote>

<p>然而 KVO 在实现中使用了 <code>isa 混写（ isa-swizzling）</code> ，这个的确不是很容易发现：Apple 还重写、覆盖了 <code>-class</code> 方法并返回原来的类。 企图欺骗我们：这个类没有变，就是原本那个类。。。</p>

<p>但是，假设“被监听的对象”的类对象是 <code>MYClass</code> ，有时候我们能看到对 <code>NSKVONotifying_MYClass</code> 的引用而不是对  <code>MYClass</code>  的引用。借此我们得以知道 Apple 使用了 <code>isa 混写（isa-swizzling）</code>。具体探究过程可参考<a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html"> 这篇博文 </a>。</p>

<h3>52. IBOutlet连出来的视图属性为什么可以被设置成weak?</h3>

<p><strong>我的解答：</strong></p>

<p>忘了。如果做成strong，需要手动去释放这些控件。</p>

<p><strong>大神解答：</strong></p>

<p>参考链接：<a href="http://stackoverflow.com/questions/7678469/should-iboutlets-be-strong-or-weak-under-arc"> <strong><em>Should IBOutlets be strong or weak under ARC?</em></strong> </a></p>

<p>文章告诉我们：</p>

<blockquote><p>因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了。</p></blockquote>

<p>不过这个回答漏了个重要知识，使用storyboard（xib不行）创建的vc，会有一个叫_topLevelObjectsToKeepAliveFromStoryboard的私有数组强引用所有top level的对象，所以这时即便outlet声明成weak也没关系</p>

<h3>53. IB中User Defined Runtime Attributes如何使用？</h3>

<p><strong>我的解答：</strong></p>

<p>可以对控件添加额外的属性。</p>

<p><strong>大神解答：</strong></p>

<p>它能够通过KVC的方式配置一些你在interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller</p>

<h3>54. 如何调试BAD_ACCESS错误</h3>

<p><strong>我的解答：</strong></p>

<p>通过开启NSZombies，可以在对象释放后创建其对应的Zombie对象，并记录对其发送的消息，然后打印给开发者，从而告知开发者造成内存泄露的对象类型和方法。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>重写object的respondsToSelector方法，现实出现EXEC_BAD_ACCESS前访问的最后一个object</li>
<li><p>通过 Zombie
<img src="http://i.stack.imgur.com/ZAdi0.png" alt="enter image description here" /></p></li>
<li><p>设置全局断点快速定位问题代码所在行</p></li>
<li>Xcode 7 已经集成了BAD_ACCESS捕获功能：<strong>Address Sanitizer</strong>。
用法如下：在配置中勾选✅Enable Address Sanitizer
<img src="https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Art/xc7-asan_2x.png" alt="enter image description here" /></li>
</ol>


<h3>55. lldb（gdb）常用的调试命令？</h3>

<p><strong>我的解答：</strong></p>

<p>用过po命令打印出当前对象的值。</p>

<p><strong>大神解答：</strong></p>

<ul>
<li>breakpoint 设置断点定位到某一个函数</li>
<li>n 断点指针下一步</li>
<li>po打印对象</li>
</ul>


<p>更多 lldb（gdb） 调试命令可查看</p>

<ol>
<li><a href="http://lldb.llvm.org/lldb-gdb.html"> <strong><em>The LLDB Debugger</em></strong> </a>；</li>
<li>苹果官方文档：<a href="https://developer.apple.com/library/ios/technotes/tn2239/_index.html"> <strong><em>iOS Debugging Magic</em></strong> </a>。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回答Sunny的55道iOS面试题1]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1/"/>
    <updated>2015-10-28T15:32:57+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1</id>
    <content type="html"><![CDATA[<p>百度知道的<a href="http://weibo.com/u/1364395395">微博@我就叫Sunny怎么了</a>出了55道iOS的面试题，很多题目是很有深度，现在自己尝试解一下这些题，并付上大神给出的答案。</p>

<!--more-->


<h3>1. 风格纠错题</h3>

<p><img src="http://i.imgur.com/O7Zev94.png" alt="enter image description here" /></p>

<p><strong>我的解答：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">typedef</span> <span class="nf">NS_ENUM</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">,</span> <span class="n">CCUserSex</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">CCUserSexMan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>  <span class="n">CCUserSexWoman</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">CCUser</span> : <span class="nc">NSObject</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span><span class="n">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span><span class="n">NSUInteger</span> <span class="n">age</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span><span class="n">CCUserSex</span> <span class="n">sex</span><span class="p">;</span>
</span><span class='line'><span class="k">+</span><span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">userWithName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">age:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">age</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">age:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">age</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">login</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>大神解答：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">// .h文件</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'><span class="c1">// 修改完的代码，这是第一种修改方法，后面会给出第二种修改方法</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="nf">NS_ENUM</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">,</span> <span class="n">CYLSex</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CYLSexMan</span><span class="p">,</span>
</span><span class='line'>    <span class="n">CYLSexWoman</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">CYLUser</span> : <span class="nc">NSObject</span><span class="o">&lt;</span><span class="n">NSCopying</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">NSUInteger</span> <span class="n">age</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">CYLSex</span> <span class="n">sex</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">age:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">age</span> <span class="nf">sex:</span><span class="p">(</span><span class="n">CYLSex</span><span class="p">)</span><span class="nv">sex</span><span class="p">;</span>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">userWithName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">age:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">age</span> <span class="nf">sex:</span><span class="p">(</span><span class="n">CYLSex</span><span class="p">)</span><span class="nv">sex</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p> 详解：</p>

<p> 1.enum建议使用NS_ENUM和NS_OPTIONS来定义，这是Apple推荐的枚举定义宏，主要是可以通过它来指定type的类型。<br/>
 2.数值型变量尽量使用Foundation的数据类型，而不要使用c的类型，主要是为了适配不同处理器而考虑的。<br/>
 3.大的工程必须在类前加前缀作为命名空间。<br/>
 4.命名习惯，通常情况下，即使有类似 withA:withB: 的命名需求，也通常是使用withA:andB: 这种命名，用来表示方法执行了两个相对独立的操作（从设计上来说，这时候也可以拆分成两个独立的方法），它不应该用作阐明有多个参数，比如下面的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'> <span class="c1">//错误，不要使用&quot;and&quot;来连接参数</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nf">runModalForDirectory:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">path</span> <span class="nf">andFile:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">andTypes:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">fileTypes</span><span class="p">;</span>
</span><span class='line'><span class="c1">//错误，不要使用&quot;and&quot;来阐明有多个参数</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithName:</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">name</span> <span class="nf">andAge:</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">age</span><span class="p">;</span>
</span><span class='line'><span class="c1">//正确，使用&quot;and&quot;来表示两个相对独立的操作</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">openFile:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">fullPath</span> <span class="nf">withApplication:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">appName</span> <span class="nf">andDeactivate:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">flag</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p> 5.一些有可变类型的类型，如NSString、NSArray、NSDictionary，经常使用copy来命名property，为了避免将可变类型赋给当前对象，然后在外部改变数值，而对当前类型产生影响。<br/>
 6.OC有designated和secondary初始化方法的概念。 designated初始化方法是提供所有的参数，secondary初始化方法是一个或多个，并且提供一个或者更多的默认参数来调用designated初始化方法的初始化方法。子类在继承父类时，可以添加新的secondary初始化方法，但必须在内部调用父类的designated初始化方法，而且也必须重写父类暴露的secondary初始化方法。</p>

<h3>2. 什么情况使用 weak 关键字，相比 assign 有什么不同？</h3>

<p> <strong>我的解答：</strong><br/>
weak关键字一般用于xib导出的IBOutlet类型控件的变量声明，和delegate的声明，主要用于避免循环引用。相比assign，weak也是不会改变对象的retain count，但是weak只能用于object的property声明，而assign一般用于数值型变量的property声明。</p>

<p> <strong>大神解答：</strong></p>

<ol>
<li>在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性</li>
<li>自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。</li>
</ol>


<p>不同点：</p>

<ol>
<li><p><code>weak</code> 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，
然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。
而 <code>assign</code> 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或
NSlnteger 等)的简单赋值操作。</p></li>
<li><p>assigin 可以用非 OC 对象,而 weak 必须用于 OC 对象</p></li>
</ol>


<h3>3. 怎么用 copy 关键字？</h3>

<p><strong>我的解答：</strong></p>

<ol>
<li>copy一般用于property时是用于NSString、NSArray、NSDictionary这些有可变类型，原因为了避免将可变类型赋给当前对象，然后在外部改变数值，而对当前类型产生影响。</li>
<li>然后也经常适用于block类型的property赋值，原因是block声明时是被存放在栈中，如果不使用copy对其操作，将其拷贝到堆上，那么该block会在其声明的作用域失效时被释放。</li>
</ol>


<p><strong>大神解答：</strong></p>

<ol>
<li>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</li>
<li>block 也经常使用 copy 关键字，具体原因见<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12">官方文档：<strong><em>Objects Use Properties to Keep Track of Blocks</em></strong></a>：</li>
</ol>


<p>  block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。</p>

<p><img src="http://i.imgur.com/VlVKl8L.png" alt="enter image description here" /></p>

<p>下面做下解释：
 copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。
当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>

<blockquote><p>用 <code>@property</code> 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p></blockquote>

<h3>4. 这个写法会出什么问题： <code>@property (copy) NSMutableArray *array;</code></h3>

<p><strong>我的解答：</strong></p>

<p>对NSMutableArray执行copy操作，会返回NSArray类型的对象，那么给array赋值一个NSMutabeArray后，再对其经行修改操作，会出现错误。</p>

<p><strong>大神解答：</strong></p>

<p>两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；2、使用了 atomic 属性会严重影响性能 ；</p>

<p>比如下面的代码就会发生崩溃</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">// .h文件</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'><span class="c1">// 下面的代码就会发生崩溃</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableArray</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">// .m文件</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'><span class="c1">// 下面的代码就会发生崩溃</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="nl">arrayWithObjects:</span><span class="err">@</span><span class="mi">1</span><span class="p">,</span><span class="err">@</span><span class="mi">2</span><span class="p">,</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">mutableArray</span> <span class="o">=</span> <span class="n">array</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">mutableArray</span> <span class="nl">removeObjectAtIndex:</span><span class="mi">0</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来就会崩溃：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'> <span class="o">-</span><span class="p">[</span><span class="n">__NSArrayI</span> <span class="nl">removeObjectAtIndex:</span><span class="p">]</span><span class="o">:</span> <span class="n">unrecognized</span> <span class="n">selector</span> <span class="n">sent</span> <span class="n">to</span> <span class="n">instance</span> <span class="mh">0x7fcd1bc30460</span>
</span></code></pre></td></tr></table></div></figure>


<p>第2条原因，如下：</p>

<blockquote><p>该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销。</p></blockquote>

<p>在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic))。</p>

<p>在iOS开发中，你会发现，几乎所有属性都声明为 nonatomic。</p>

<p>一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。</p>

<p>因此，开发iOS程序时一般都会使用 nonatomic 属性。但是在开发 Mac OS X 程序时，使用
 atomic 属性通常都不会有性能瓶颈。</p>

<h3>5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</h3>

<p><strong>我的解答：</strong></p>

<p>1.要让自己的类实现NSCopying协议的方法，也就是<strong>&ndash; (id)copyWithZone:(NSZone *)zone;</strong>方法。<br/>
2.重写copy的setter：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setCopyProperty:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">copyProperty</span><span class="p">{</span>
</span><span class='line'>  <span class="n">_copyProperty</span> <span class="o">=</span> <span class="p">[</span><span class="n">copyProperty</span> <span class="n">copy</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>大神解答：</strong></p>

<blockquote><p>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 <code>NSCopying</code> 与 <code>NSMutableCopying</code> 协议。</p></blockquote>

<p>具体步骤：</p>

<ol>
<li>需声明该类遵从 NSCopying 协议</li>
<li>实现 NSCopying 协议。该协议只有一个方法:</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">copyWithZone:</span><span class="p">(</span><span class="n">NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nv">zone</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。</p>

<p>以第一题的代码为例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">// .h文件</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'><span class="c1">// 修改完的代码</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="nf">NS_ENUM</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">,</span> <span class="n">CYLSex</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CYLSexMan</span><span class="p">,</span>
</span><span class='line'>    <span class="n">CYLSexWoman</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">CYLUser</span> : <span class="nc">NSObject</span><span class="o">&lt;</span><span class="n">NSCopying</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">NSUInteger</span> <span class="n">age</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">CYLSex</span> <span class="n">sex</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">age:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">age</span> <span class="nf">sex:</span><span class="p">(</span><span class="n">CYLSex</span><span class="p">)</span><span class="nv">sex</span><span class="p">;</span>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">userWithName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">age:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">age</span> <span class="nf">sex:</span><span class="p">(</span><span class="n">CYLSex</span><span class="p">)</span><span class="nv">sex</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后实现协议中规定的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">copyWithZone:</span><span class="p">(</span><span class="n">NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nv">zone</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">CYLUser</span> <span class="o">*</span><span class="n">copy</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">self</span> <span class="n">class</span><span class="p">]</span> <span class="nl">allocWithZone:</span><span class="n">zone</span><span class="p">]</span>
</span><span class='line'>                   <span class="nl">initWithName:</span><span class="n">_name</span>
</span><span class='line'>                                <span class="nl">age:</span><span class="n">_age</span>
</span><span class='line'>                                <span class="nl">sex:</span><span class="n">_sex</span><span class="p">];</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">copy</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如 CYLUser 中含有一个数组，与其他 CYLUser 对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">// .h文件</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'><span class="c1">// 以第一题《风格纠错题》里的代码为例</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="nf">NS_ENUM</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">,</span> <span class="n">CYLSex</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CYLSexMan</span><span class="p">,</span>
</span><span class='line'>    <span class="n">CYLSexWoman</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">CYLUser</span> : <span class="nc">NSObject</span><span class="o">&lt;</span><span class="n">NSCopying</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">NSUInteger</span> <span class="n">age</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">CYLSex</span> <span class="n">sex</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">age:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">age</span> <span class="nf">sex:</span><span class="p">(</span><span class="n">CYLSex</span><span class="p">)</span><span class="nv">sex</span><span class="p">;</span>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">userWithName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">age:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">age</span> <span class="nf">sex:</span><span class="p">(</span><span class="n">CYLSex</span><span class="p">)</span><span class="nv">sex</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addFriend:</span><span class="p">(</span><span class="n">CYLUser</span> <span class="o">*</span><span class="p">)</span><span class="nv">user</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeFriend:</span><span class="p">(</span><span class="n">CYLUser</span> <span class="o">*</span><span class="p">)</span><span class="nv">user</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>// .m文件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">// .m文件</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">CYLUser</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSMutableSet</span> <span class="o">*</span><span class="n">_friends</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">name</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="n">copy</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nl">initWithName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">name</span>
</span><span class='line'>                         <span class="nl">age:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="n">age</span>
</span><span class='line'>                         <span class="nl">sex:</span><span class="p">(</span><span class="n">CYLSex</span><span class="p">)</span><span class="n">sex</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="n">copy</span><span class="p">];</span>
</span><span class='line'>        <span class="n">_age</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
</span><span class='line'>        <span class="n">_sex</span> <span class="o">=</span> <span class="n">sex</span><span class="p">;</span>
</span><span class='line'>        <span class="n">_friends</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableSet</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">addFriend:</span><span class="p">(</span><span class="n">CYLUser</span> <span class="o">*</span><span class="p">)</span><span class="n">user</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">_friends</span> <span class="nl">addObject:</span><span class="n">user</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">removeFriend:</span><span class="p">(</span><span class="n">CYLUser</span> <span class="o">*</span><span class="p">)</span><span class="n">user</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">_friends</span> <span class="nl">removeObject:</span><span class="n">person</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nl">copyWithZone:</span><span class="p">(</span><span class="n">NSZone</span> <span class="o">*</span><span class="p">)</span><span class="n">zone</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CYLUser</span> <span class="o">*</span><span class="n">copy</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">self</span> <span class="n">class</span><span class="p">]</span> <span class="nl">allocWithZone:</span><span class="n">zone</span><span class="p">]</span>
</span><span class='line'>                     <span class="nl">initWithName:</span><span class="n">_name</span>
</span><span class='line'>                     <span class="nl">age:</span><span class="n">_age</span>
</span><span class='line'>                     <span class="nl">sex:</span><span class="n">_sex</span><span class="p">];</span>
</span><span class='line'>    <span class="n">copy</span><span class="o">-&gt;</span><span class="n">_friends</span> <span class="o">=</span> <span class="p">[</span><span class="n">_friends</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">copy</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">deepCopy</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CYLUser</span> <span class="o">*</span><span class="n">copy</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">self</span> <span class="n">class</span><span class="p">]</span> <span class="nl">allocWithZone:</span><span class="n">zone</span><span class="p">]</span>
</span><span class='line'>                     <span class="nl">initWithName:</span><span class="n">_name</span>
</span><span class='line'>                     <span class="nl">age:</span><span class="n">_age</span>
</span><span class='line'>                     <span class="nl">sex:</span><span class="n">_sex</span><span class="p">];</span>
</span><span class='line'>    <span class="n">copy</span><span class="o">-&gt;</span><span class="n">_friends</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableSet</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSet:</span><span class="n">_friends</span>
</span><span class='line'>                                             <span class="nl">copyItems:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">copy</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上做法能满足基本的需求，但是也有缺陷：</p>

<blockquote><p>如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。</p></blockquote>

<p>【注：深浅拷贝的概念，在下文中有介绍，详见下文的：<strong><em>用@property声明的 NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？</em></strong>】</p>

<p>在例子中，存放朋友对象的 set 是用 “copyWithZone:” 方法来拷贝的，这种浅拷贝方式不会逐个复制 set 中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">deepCopy</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CYLUser</span> <span class="o">*</span><span class="n">copy</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">self</span> <span class="n">class</span><span class="p">]</span> <span class="nl">allocWithZone:</span><span class="n">zone</span><span class="p">]</span>
</span><span class='line'>                     <span class="nl">initWithName:</span><span class="n">_name</span>
</span><span class='line'>                     <span class="nl">age:</span><span class="n">_age</span>
</span><span class='line'>                     <span class="nl">sex:</span><span class="n">_sex</span><span class="p">];</span>
</span><span class='line'>    <span class="n">copy</span><span class="o">-&gt;</span><span class="n">_friends</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableSet</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSet:</span><span class="n">_friends</span>
</span><span class='line'>                                             <span class="nl">copyItems:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">copy</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>至于<strong><em>如何重写带 copy 关键字的 setter</em></strong>这个问题，</p>

<p>如果抛开本例来回答的话，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">//[_name release];</span>
</span><span class='line'>    <span class="n">_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="n">copy</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>不过也有争议，有人说“苹果如果像下面这样干，是不是效率会高一些？”</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">_name</span> <span class="o">!=</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//[_name release];//MRC</span>
</span><span class='line'>        <span class="n">_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="n">copy</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样真得高效吗？不见得！这种写法“看上去很美、很合理”，但在实际开发中，它更像下图里的做法：</p>

<p><img src="http://i.imgur.com/UwV9oSn.jpeg" alt="enter image description here" /></p>

<p>克强总理这样评价你的代码风格：</p>

<p><img src="http://i.imgur.com/N77Lkic.png" alt="enter image description here" /></p>

<p>我和总理的意见基本一致：</p>

<blockquote><p>老百姓 copy 一下，咋就这么难？</p></blockquote>

<p>你可能会说：</p>

<p>之所以在这里做<code>if判断</code> 这个操作：是因为一个 if 可能避免一个耗时的copy，还是很划算的。
(在刚刚讲的：《如何让自己的类用 copy 修饰符？》里的那种复杂的copy，我们可以称之为 “耗时的copy”，但是对 NSString 的 copy 还称不上。)</p>

<p>但是你有没有考虑过代价：</p>

<blockquote><p>你每次调用 <code>setX:</code> 都会做 if 判断，这会让 <code>setX:</code> 变慢，如果你在 <code>setX:</code>写了一串复杂的 <code>if+elseif+elseif+...</code> 判断，将会更慢。</p></blockquote>

<p>要回答“哪个效率会高一些？”这个问题，不能脱离实际开发，就算 copy 操作十分耗时，if 判断也不见得一定会更快，除非你把一个“ @property他当前的值 ”赋给了他自己，代码看起来就像：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">[</span><span class="n">a</span> <span class="nl">setX:</span><span class="n">x1</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">a</span> <span class="nl">setX:</span><span class="n">x1</span><span class="p">];</span>    <span class="c1">//你确定你要这么干？与其在setter中判断，为什么不把代码写好？</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">[</span><span class="n">a</span> <span class="nl">setX:</span><span class="p">[</span><span class="n">a</span> <span class="n">x</span><span class="p">]];</span>   <span class="c1">//队友咆哮道：你在干嘛？！！</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>不要在 setter 里进行像 <code>if(_obj != newObj)</code> 这样的判断。（该观点参考链接：<a href="http://vgable.com/blog/tag/autorelease/"> <strong><em>How To Write Cocoa Object Setters： Principle 3: Only Optimize After You Measure</em></strong> </a>
）</p></blockquote>

<p>什么情况会在 copy setter 里做 if 判断？
例如，车速可能就有最高速的限制，车速也不可能出现负值，如果车子的最高速为300，则 setter 的方法就要改写成这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setSpeed:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">_speed</span><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">_speed</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">_speed</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">)</span> <span class="n">speed</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span>
</span><span class='line'>    <span class="n">_speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>回到这个题目，如果单单就上文的代码而言，我们不需要也不能重写 name 的 setter ：由于是 name 是只读属性，所以编译器不会为其创建对应的“设置方法”，用初始化方法设置好属性值之后，就不能再改变了。（ 在本例中，之所以还要声明属性的“内存管理语义”&mdash;copy，是因为：如果不写 copy，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而低效）。</p>

<p>那如何确保 name 被 copy？在初始化方法(initializer)中做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span>
</span><span class='line'>                           <span class="nf">age:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">age</span>
</span><span class='line'>                           <span class="nf">sex:</span><span class="p">(</span><span class="n">CYLSex</span><span class="p">)</span><span class="nv">sex</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">if</span><span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="n">copy</span><span class="p">];</span>
</span><span class='line'>      <span class="n">_age</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
</span><span class='line'>      <span class="n">_sex</span> <span class="o">=</span> <span class="n">sex</span><span class="p">;</span>
</span><span class='line'>      <span class="n">_friends</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableSet</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h3>

<p><strong>我的解答：</strong></p>

<ol>
<li>@property本质就是自动为变量创建对应的setter，getter的快捷语法。</li>
<li>额，不会。</li>
</ol>


<p><strong>大神解答：</strong></p>

<p><strong>@property 的本质是什么？</strong></p>

<blockquote><p>@property = ivar + getter + setter;</p></blockquote>

<p>下面解释下：</p>

<blockquote><p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p></blockquote>

<p>“属性” (property)作为 objectivec 的一项特性，主要的作用就在于封装对象中的数据。 objectivec 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 <code>objectivec 2.0</code> 的一部分。
而在正规的 objectivec 编码风格中，存取方法有着严格的命名规范。
正因为有了这种严格的命名规范，所以 objectivec 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p>

<blockquote><p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。
所以你也可以这么说：</p>

<p>@property = getter + setter;</p></blockquote>

<p>例如下面这个类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">Person</span> : <span class="nc">NSObject</span>
</span><span class='line'><span class="k">@property</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">firstName</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">lastName</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>上述代码写出来的类与下面这种写法等效：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">Person</span> : <span class="nc">NSObject</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">firstName</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setFirstName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">firstName</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">lastName</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setLastName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">lastName</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>ivar、getter、setter 是如何生成并添加到这个类中的?</strong></p>

<blockquote><p>“自动合成”( autosynthesis)</p></blockquote>

<p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译
器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为
 <code>_firstName</code> 与 <code>_lastName</code>。也可以在类的实现代码里通过
 <code>@synthesize</code> 语法来指定实例变量的名字.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@implementation</span> <span class="nc">Person</span>
</span><span class='line'><span class="k">@synthesize</span> <span class="n">firstName</span> <span class="o">=</span> <span class="n">_myFirstName</span><span class="p">;</span>
</span><span class='line'><span class="k">@synthesize</span> <span class="n">lastName</span> <span class="o">=</span> <span class="n">_myLastName</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西</p>

<ol>
<li><code>OBJC_IVAR_$类名$属性名称</code> ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。</li>
<li>setter 与 getter 方法对应的实现函数</li>
<li><code>ivar_list</code> ：成员变量列表</li>
<li><code>method_list</code> ：方法列表</li>
<li><code>prop_list</code> ：属性列表</li>
</ol>


<p>也就是说我们每次在增加一个属性,系统都会在 <code>ivar_list</code> 中添加一个成员变量的描述,在 <code>method_list</code> 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</p>

<h3>7. @protocol 和 category 中如何使用 @property</h3>

<p><strong>我的解答：</strong></p>

<p>理论上说@protocol和category是不能使用@property，主要是声明property后，不能自动合成setter、getter方法，所以无法使用变量，不过确实存在需要时，可以使用associated objects技术为其绑定对象，作为实例变量的代替。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性</li>
<li><p>category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：</p></li>
<li><p> <code>objc_setAssociatedObject</code></p></li>
<li> <code>objc_getAssociatedObject</code></li>
</ol>


<h3>8. runtime 如何实现 weak 属性</h3>

<p><strong>我的解答：</strong></p>

<p>额，不会。</p>

<p><strong>大神解答：</strong></p>

<p>要实现 weak 属性，首先要搞清楚 weak 属性的特点：</p>

<blockquote><p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p></blockquote>

<p>那么 runtime 如何实现 weak 变量的自动置nil？</p>

<blockquote><p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p></blockquote>

<h3>9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</h3>

<p><strong>我的解答：</strong></p>

<p>有atomic、nonatomic、retain、assign、copy、strong（ARC）、weak（ARC）、readonly、readwrite，另外有指定setter和getter方法的关键字setter=setXXX、getter=xxx，最后一个在BOOL型对象时常用getter=isXXX来替代getter方法。</p>

<p><strong>大神解答：</strong></p>

<p>属性可以拥有的特质分为四类:</p>

<ol>
<li><p>原子性&mdash;&ndash; <code>nonatomic</code> 特质</p>

<p>在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。</p></li>
<li><p>读/写权限&mdash;&ndash;<code>readwrite(读写)</code>、<code>readonly (只读)</code></p></li>
<li>内存管理语义&mdash;&ndash;<code>assign</code>、<code>strong</code>、 <code>weak</code>、<code>unsafe_unretained</code>、<code>copy</code></li>
<li>方法名&mdash;&ndash;<code>getter=&lt;name&gt;</code> 、<code>setter=&lt;name&gt;</code></li>
</ol>


<p>  <code>getter=&lt;name&gt;</code>的样式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'>    <span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">getter</span><span class="o">=</span><span class="n">isOn</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">on</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p> <p><del>（ <code>setter=&lt;name&gt;</code>这种不常用，也不推荐使用。故不在这里给出写法。）
</del></p></p>

<p> <code>setter=&lt;name&gt;</code>一般用在特殊的情境下，比如：</p>

<p>在数据反序列化、转模型的过程中，服务器返回的字段如果以 <code>init</code> 开头，所以你需要定义一个 <code>init</code> 开头的属性，但默认生成的 <code>setter</code> 与 <code>getter</code> 方法也会以 <code>init</code> 开头，而编译器会把所有以 <code>init</code> 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。</p>

<p>这时你就可以使用下面的方式来避免编译器报错：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@property</span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">,</span> <span class="n">getter</span><span class="o">=</span><span class="n">p_initBy</span><span class="p">,</span> <span class="n">setter</span><span class="o">=</span><span class="nl">setP_initBy:</span><span class="p">)</span><span class="n">NSString</span> <span class="o">*</span><span class="n">initBy</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外也可以用关键字进行特殊说明，来避免编译器报错：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@property</span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readwrite</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">null_resettable</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">initBy</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">initBy</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">objc_method_family</span><span class="p">(</span><span class="n">none</span><span class="p">)));</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>不常用的：<code>nonnull</code>,<code>null_resettable</code>,<code>nullable</code></li>
</ol>


<h3>10. weak属性需要在dealloc中置nil么？</h3>

<p><strong>我的解答：</strong></p>

<p>不需要，weak属性的变量，在其所指向内存释放后，会自动指向nil，成为空指针。</p>

<p><strong>大神解答：</strong></p>

<p>不需要。</p>

<blockquote><p>在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理</p></blockquote>

<p>即便是编译器不帮我们做这些，weak也不需要在 dealloc 中置nil：</p>

<p>正如上文的：<strong><em>runtime 如何实现 weak 属性</em></strong> 中提到的：</p>

<p>我们模拟下 weak 的 setter 方法，应该如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setObject:</span><span class="p">(</span><span class="n">NSObject</span> <span class="o">*</span><span class="p">)</span><span class="nv">object</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">&quot;object&quot;</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_ASSIGN</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">object</span> <span class="nl">cyl_runAtDealloc:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">_object</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>也即:</p>

<blockquote><p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p></blockquote>

<h3>11. @synthesize和@dynamic分别有什么作用？</h3>

<p><strong>我的解答：</strong></p>

<p>@synthesize用于合成声明的property的实例变量和其setter、getter方法，并可以在其后面声明对应的内部变量，目前已不需要手写@synthesize操作，系统会对property执行autosynthesize操作。而@dynamic声明的变量，是告诉系统该变量没有显式的setter、getter方法，但是会在运行时为其添加setter/getter方法，常用于CoreData变量的声明，不是很常用。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是<code>@syntheszie var = _var;</code></li>
<li>@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。</li>
<li>@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 <code>instance.var = someVar</code>，由于缺 setter 方法会导致程序崩溃；或者当运行到 <code>someVar = var</code> 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</li>
</ol>


<h3>12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h3>

<p><strong>我的解答：</strong></p>

<p>默认添加的关键字有atomic，readwrite，assign。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>对应基本数据类型默认关键字是<br/>
atomic,readwrite,assign</li>
<li>对于普通的 objectivec 对象<br/>
atomic,readwrite,strong</li>
</ol>


<p>参考链接：</p>

<ol>
<li><p><a href="http://stackoverflow.com/a/15541801/3395008"> <strong><em>objectivec ARC: strong vs retain and weak vs assign</em></strong> </a></p></li>
<li><p><a href="http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html"> <strong><em>Variable property attributes or Modifiers in iOS</em></strong> </a></p></li>
</ol>


<h3>13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h3>

<p><strong>我的解答：</strong></p>

<p>上面答过。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.</li>
<li>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.</li>
</ol>


<p> copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。
当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>

<p>举例说明：</p>

<p>定义一个以 strong 修饰的 array：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span> <span class="p">,</span><span class="n">readwrite</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSArray</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后进行下面的操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableArray</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span> <span class="err">@</span><span class="mi">1</span><span class="p">,</span> <span class="err">@</span><span class="mi">2</span><span class="p">,</span> <span class="err">@</span><span class="mi">3</span><span class="p">,</span> <span class="err">@</span><span class="mi">4</span> <span class="p">];</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">mutableArray</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">mutableArray</span> <span class="n">removeAllObjects</span><span class="p">];;</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">mutableArray</span> <span class="nl">addObjectsFromArray:</span><span class="n">array</span><span class="p">];</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="n">mutableArray</span> <span class="n">copy</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">mutableArray</span> <span class="n">removeAllObjects</span><span class="p">];;</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>打印结果如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mi">09</span><span class="o">-</span><span class="mi">27</span> <span class="mi">19</span><span class="o">:</span><span class="mi">10</span><span class="o">:</span><span class="mf">32.523</span> <span class="n">CYLArrayCopyDmo</span><span class="p">[</span><span class="mi">10681</span><span class="o">:</span><span class="mi">713670</span><span class="p">]</span> <span class="p">(</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mi">09</span><span class="o">-</span><span class="mi">27</span> <span class="mi">19</span><span class="o">:</span><span class="mi">10</span><span class="o">:</span><span class="mf">32.524</span> <span class="n">CYLArrayCopyDmo</span><span class="p">[</span><span class="mi">10681</span><span class="o">:</span><span class="mi">713670</span><span class="p">]</span> <span class="p">(</span>
</span><span class='line'>    <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>    <span class="mi">2</span><span class="p">,</span>
</span><span class='line'>    <span class="mi">3</span><span class="p">,</span>
</span><span class='line'>    <span class="mi">4</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>（详见仓库内附录的 Demo。）</p>

<p>为了理解这种做法，首先要知道，两种情况：</p>

<ol>
<li>对非集合类对象的 copy 与 mutableCopy 操作；</li>
<li>对集合类对象的 copy 与 mutableCopy 操作。</li>
</ol>


<h4>1. 对非集合类对象的copy操作：</h4>

<p>在非集合类对象中：对 immutable 对象进行 copy 操作，是指针复制，mutableCopy 操作时内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：</p>

<ul>
<li>[immutableObject copy] // 浅复制</li>
<li>[immutableObject mutableCopy] //深复制</li>
<li>[mutableObject copy] //深复制</li>
<li>[mutableObject mutableCopy] //深复制</li>
</ul>


<p>比如以下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSMutableString</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableString</span> <span class="nl">stringWithString:</span><span class="s">@&quot;origin&quot;</span><span class="p">];</span><span class="c1">//copy</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">stringCopy</span> <span class="o">=</span> <span class="p">[</span><span class="n">string</span> <span class="n">copy</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">[</span><span class="n">string</span> <span class="nl">appendString:</span><span class="s">@&quot;origion!&quot;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>stringCopy 的值也不会因此改变，但是如果不使用 copy，stringCopy 的值就会被改变。
  集合类对象以此类推。
所以，</p>

<blockquote><p>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p></blockquote>

<h4>2、集合类对象的copy与mutableCopy</h4>

<p>集合类对象是指 NSArray、NSDictionary、NSSet &hellip; 之类的对象。下面先看集合类immutable对象使用 copy 和 mutableCopy 的一个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="err">@</span><span class="p">[</span><span class="s">@&quot;a&quot;</span><span class="p">,</span> <span class="s">@&quot;b&quot;</span><span class="p">],</span> <span class="err">@</span><span class="p">[</span><span class="s">@&quot;c&quot;</span><span class="p">,</span> <span class="s">@&quot;d&quot;</span><span class="p">]];</span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">copyArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="n">copy</span><span class="p">];</span>
</span><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mCopyArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>查看内容，可以看到 copyArray 和 array 的地址是一样的，而 mCopyArray 和 array 的地址是不同的。说明 copy 操作进行了指针拷贝，mutableCopy 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 array 这个对象，array 集合内部的元素仍然是指针拷贝。这和上面的非集合 immutable 对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看 mutable 对象拷贝的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="nl">arrayWithObjects:</span><span class="p">[</span><span class="n">NSMutableString</span> <span class="nl">stringWithString:</span><span class="s">@&quot;a&quot;</span><span class="p">],</span><span class="s">@&quot;b&quot;</span><span class="p">,</span><span class="s">@&quot;c&quot;</span><span class="p">,</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">copyArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="n">copy</span><span class="p">];</span>
</span><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mCopyArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>查看内存，如我们所料，copyArray、mCopyArray和 array 的内存地址都不一样，说明 copyArray、mCopyArray 都对 array 进行了内容拷贝。同样，我们可以得出结论：</p>

<p>在集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">[</span><span class="n">immutableObject</span> <span class="n">copy</span><span class="p">]</span> <span class="c1">// 浅复制</span>
</span><span class='line'><span class="p">[</span><span class="n">immutableObject</span> <span class="n">mutableCopy</span><span class="p">]</span> <span class="c1">//单层深复制</span>
</span><span class='line'><span class="p">[</span><span class="n">mutableObject</span> <span class="n">copy</span><span class="p">]</span> <span class="c1">//单层深复制</span>
</span><span class='line'><span class="p">[</span><span class="n">mutableObject</span> <span class="n">mutableCopy</span><span class="p">]</span> <span class="c1">//单层深复制</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个代码结论和非集合类的非常相似。</p>

<p>参考链接：<a href="https://www.zybuluo.com/MicroCai/note/50592">iOS 集合的深复制与浅复制</a></p>

<h3>14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为<code>_foo</code>的实例变量，那么还会自动合成新变量么？</h3>

<p><strong>我的解答：</strong></p>

<p>额，规则不知道，感觉不会合成新变量。</p>

<p><strong>大神解答：</strong></p>

<p>在回答之前先说明下一个概念：</p>

<blockquote><p>实例变量 = 成员变量 ＝ ivar</p></blockquote>

<p>这些说法，笔者下文中，可能都会用到，指的是一个东西。</p>

<p>正如
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW6">Apple官方文档 <strong><em>You Can Customize Synthesized Instance Variable Names</em></strong></a> 所说：
<img src="http://i.imgur.com/D6d0zGJ.png" alt="enter image description here" /></p>

<p>如果使用了属性的话，那么编译器就会自动编写访问属性所需的方法，此过程叫做“自动合成”( auto synthesis)。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法” (synthesized method)的源代码。除了生成方法代码之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">CYLPerson</span> : <span class="nc">NSObject</span>
</span><span class='line'><span class="k">@property</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">firstName</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">lastName</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上例中，会生成两个实例变量，其名称分别为
 <code>_firstName</code> 与 <code>_lastName</code>。也可以在类的实现代码里通过 <code>@synthesize</code> 语法来指定实例变量的名字:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@implementation</span> <span class="nc">CYLPerson</span>
</span><span class='line'><span class="k">@synthesize</span> <span class="n">firstName</span> <span class="o">=</span> <span class="n">_myFirstName</span><span class="p">;</span>
</span><span class='line'><span class="k">@synthesize</span> <span class="n">lastName</span> <span class="o">=</span> <span class="n">_myLastName</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>上述语法会将生成的实例变量命名为 <code>_myFirstName</code> 与 <code>_myLastName</code> ，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>

<p>总结下 @synthesize 合成实例变量的规则，有以下几点：</p>

<ol>
<li><p>如果指定了成员变量的名称,会生成一个指定的名称的成员变量,</p></li>
<li><p>如果这个成员已经存在了就不再生成了.</p></li>
<li>如果是 <code>@synthesize foo;</code> 还会生成一个名称为foo的成员变量，也就是说：</li>
</ol>


<blockquote><p>如果没有指定成员变量的名称会自动生成一个属性同名的成员变量,</p></blockquote>

<ol>
<li>如果是 <code>@synthesize foo = _foo;</code> 就不会生成成员变量了.</li>
</ol>


<p>假如 property 名为 foo，存在一个名为 <code>_foo</code> 的实例变量，那么还会自动合成新变量么？
不会。如下图：</p>

<p><img src="http://i.imgur.com/t28ge4W.png" alt="enter image description here" /></p>

<h3>15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h3>

<p><strong>我的解答：</strong></p>

<p>额，为了指定内部变量的名称会用到，其他呢？为啥就和@synthesize干上了？</p>

<p><strong>大神解答：</strong></p>

<p>回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？</p>

<ol>
<li>同时重写了 setter 和 getter 时</li>
<li>重写了只读属性的 getter 时</li>
<li>使用了 @dynamic 时</li>
<li>在 @protocol 中定义的所有属性</li>
<li>在 category 中定义的所有属性</li>
<li>重载的属性</li>
</ol>


<p>当你在子类中重载了父类中的属性，你必须 使用 <code>@synthesize</code> 来手动合成ivar。</p>

<p>除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理 @property 的所有内容时，你就会尝试通过实现 @property 的所有“存取方法”（the accessor methods）或者使用 <code>@dynamic</code> 来达到这个目的，这时编译器就会认为你打算手动管理 @property，于是编译器就禁用了 autosynthesis（自动合成）。</p>

<p>因为有了 autosynthesis（自动合成），大部分开发者已经习惯不去手动定义ivar，而是依赖于 autosynthesis（自动合成），但是一旦你需要使用ivar，而 autosynthesis（自动合成）又失效了，如果不去手动定义ivar，那么你就得借助 <code>@synthesize</code> 来手动合成 ivar。</p>

<p>其实，<code>@synthesize</code> 语法还有一个应用场景，但是不太建议大家使用：</p>

<p>可以在类的实现代码里通过 <code>@synthesize</code> 语法来指定实例变量的名字:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@implementation</span> <span class="nc">CYLPerson</span>
</span><span class='line'><span class="k">@synthesize</span> <span class="n">firstName</span> <span class="o">=</span> <span class="n">_myFirstName</span><span class="p">;</span>
</span><span class='line'><span class="k">@synthesize</span> <span class="n">lastName</span> <span class="o">=</span> <span class="n">_myLastName</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>上述语法会将生成的实例变量命名为 <code>_myFirstName</code> 与 <code>_myLastName</code>，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>

<p>举例说明：应用场景：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">// .m文件</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'><span class="c1">// 打开第14行和第17行中任意一行，就可编译成功</span>
</span><span class='line'>
</span><span class='line'><span class="err">@</span><span class="n">import</span> <span class="n">Foundation</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">CYLObject</span> : <span class="nc">NSObject</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">title</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">CYLObject</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">//    NSString *_title;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//@synthesize title = _title;</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">_title</span> <span class="o">=</span> <span class="s">@&quot;微博@iOS程序犭袁&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">title</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_title</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setTitle:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">title</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">_title</span> <span class="o">=</span> <span class="p">[</span><span class="n">title</span> <span class="n">copy</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>结果编译器报错：
<img src="http://i.imgur.com/fAEGHIo.png" alt="enter image description here" /></p>

<p>当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择：</p>

<ol>
<li>要么如第14行：手动创建 ivar</li>
<li>要么如第17行：使用<code>@synthesize foo = _foo;</code> ，关联 @property 与 ivar。</li>
</ol>


<p>更多信息，请戳- 》<a href="http://stackoverflow.com/a/19821816/3395008"> <strong><em>When should I use @synthesize explicitly?</em></strong> </a></p>

<h3>16. objc中向一个nil对象发送消息将会发生什么？</h3>

<p><strong>我的解答：</strong></p>

<p>返回nil。</p>

<p><strong>大神解答：</strong></p>

<p>在 objectivec 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:</p>

<ol>
<li>如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">Person</span> <span class="o">*</span> <span class="n">motherInlaw</span> <span class="o">=</span> <span class="p">[[</span><span class="n">aPerson</span> <span class="n">spouse</span><span class="p">]</span> <span class="n">mother</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p> 如果 spouse 对象为 nil，那么发送给 nil 的消息 mother 也将返回 nil。
 2. 如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量，发送给 nil 的消息将返回0。
 2. 如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。
 2. 如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。</p>

<p>具体原因如下：</p>

<blockquote><p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p></blockquote>

<p>那么，为了方便理解这个内容，还是贴一个objc的源代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">// runtime.h（类在runtime中的定义）</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">objc_class</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Class</span> <span class="n">isa</span> <span class="n">OBJC_ISA_AVAILABILITY</span><span class="p">;</span> <span class="c1">//isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object</span>
</span><span class='line'>  <span class="err">#</span><span class="k">if</span> <span class="o">!</span><span class="n">__OBJC2__</span>
</span><span class='line'>  <span class="n">Class</span> <span class="n">super_class</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 父类</span>
</span><span class='line'>  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 类名</span>
</span><span class='line'>  <span class="kt">long</span> <span class="n">version</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 类的版本信息，默认为0</span>
</span><span class='line'>  <span class="kt">long</span> <span class="n">info</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 类信息，供运行期使用的一些位标识</span>
</span><span class='line'>  <span class="kt">long</span> <span class="n">instance_size</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 该类的实例变量大小</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">objc_ivar_list</span> <span class="o">*</span><span class="n">ivars</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 该类的成员变量链表</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">objc_method_list</span> <span class="o">**</span><span class="n">methodLists</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 方法定义的链表</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">objc_cache</span> <span class="o">*</span><span class="n">cache</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">objc_protocol_list</span> <span class="o">*</span><span class="n">protocols</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 协议链表</span>
</span><span class='line'>  <span class="err">#</span><span class="n">endif</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。
那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</p>

<h3>17. objc中向一个对象发送消息[obj foo]和<code>objc_msgSend()</code>函数之间有什么关系？</h3>

<p><strong>我的解答：</strong></p>

<p>编译期间[obj foo]会被编译为C代码，也就是objc_msgSend()方法，消息的接收者和消息名都会作为参数传到该方法中。</p>

<p><strong>大神解答：</strong></p>

<p>具体原因同上题：该方法编译之后就是<code>objc_msgSend()</code>函数调用.</p>

<p>我们用 clang 分析下，clang 提供一个命令，可以将objectivec的源码改写成C++语言，借此可以研究下[obj foo]和<code>objc_msgSend()</code>函数之间有什么关系。</p>

<p>以下面的代码为例，由于 clang 后的代码达到了10万多行，为了便于区分，添加了一个叫 iOSinit 方法，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">//  main.m</span>
</span><span class='line'><span class="c1">//  http://weibo.com/luohanchenyilong/</span>
</span><span class='line'><span class="c1">//  https://github.com/ChenYilong</span>
</span><span class='line'><span class="c1">//  Copyright (c) 2015年 微博@iOS程序犭袁. All rights reserved.</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">#import &quot;CYLTest.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="err">@</span><span class="n">autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CYLTest</span> <span class="o">*</span><span class="n">test</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CYLTest</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">test</span> <span class="nl">performSelector:</span><span class="p">(</span><span class="k">@selector</span><span class="p">(</span><span class="n">iOSinit</span><span class="p">))];</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在终端中输入</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">clang</span> <span class="o">-</span><span class="n">rewrite</span><span class="o">-</span><span class="n">objc</span> <span class="n">main</span><span class="p">.</span><span class="n">m</span>
</span></code></pre></td></tr></table></div></figure>


<p>就可以生成一个<code>main.cpp</code>的文件，在最低端（10万4千行左右）</p>

<p><img src="http://i.imgur.com/eAH5YWn.png" alt="enter image description here" /></p>

<p>我们可以看到大概是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">((</span><span class="kt">void</span> <span class="p">()(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)</span><span class="n">obj</span><span class="p">,</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>也就是说：</p>

<blockquote><p> [obj foo];在objc动态编译时，会被转意为：<code>objc_msgSend(obj, @selector(foo));</code>。</p></blockquote>

<h3>18. 什么时候会报unrecognized selector的异常？</h3>

<p><strong>我的解答：</strong></p>

<p>当向对象发送消息时，对象无法响应该消息，且在系统的转发后也无法响应时，最后会报错unrecognized selector。</p>

<p><strong>大神解答：</strong></p>

<p>简单来说：</p>

<blockquote><p>当调用该对象上某个方法,而该对象上没有实现这个方法的时候，
可以通过“消息转发”进行解决。</p></blockquote>

<p>简单的流程如下，在上一题中也提到过：</p>

<blockquote><p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p></blockquote>

<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：</p>

<ol>
<li>Method resolution</li>
</ol>


<p> objc运行时会调用<code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。</p>

<ol>
<li>Fast forwarding</li>
</ol>


<p> 如果目标对象实现了<code>-forwardingTargetForSelector:</code>，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。
只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。
这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。
 3. Normal forwarding</p>

<p> 这一步是Runtime最后一次给你挽救的机会。首先它会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果<code>-methodSignatureForSelector:</code>返回nil，Runtime则会发出<code>-doesNotRecognizeSelector:</code>消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送<code>-forwardInvocation:</code>消息给目标对象。</p>

<p>为了能更清晰地理解这些方法的作用，git仓库里也给出了一个Demo，名称叫“ <code>_objc_msgForward_demo</code> ”,可运行起来看看。</p>

<h3>19. 一个objc对象如何进行内存布局？（考虑有父类的情况）</h3>

<p><strong>我的解答：</strong></p>

<p>额，不好描述。</p>

<p><strong>大神解答：</strong></p>

<ul>
<li>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.</li>
<li><p>每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的</p></li>
<li><p> 对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）</p></li>
<li> 成员变量的列表,</li>
<li> 属性列表,</li>
</ul>


<p> 它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。</p>

<p>每个 objectivec 对象都有相同的结构，如下图所示：</p>

<p> <img src="http://i.imgur.com/7mJlUj1.png" alt="enter image description here" /></p>

<p>翻译过来就是</p>

<table>
<thead>
<tr>
<th></th>
<th>  objectivec 对象的结构图 </th>
<th> </th>
</tr>
</thead>
<tbody>
<tr>
<td> ISA指针 </td>
<td></td>
<td></td>
</tr>
<tr>
<td> 根类的实例变量 </td>
<td></td>
<td></td>
</tr>
<tr>
<td> 倒数第二层父类的实例变量 </td>
<td></td>
<td></td>
</tr>
<tr>
<td> &hellip; </td>
<td></td>
<td></td>
</tr>
<tr>
<td> 父类的实例变量 </td>
<td></td>
<td></td>
</tr>
<tr>
<td> 类的实例变量 </td>
<td> </td>
<td></td>
</tr>
</tbody>
</table>


<ul>
<li><p>根对象就是NSobject，它的superclass指针指向nil</p></li>
<li><p>类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。</p></li>
</ul>


<p>如图:
<img src="http://i.imgur.com/w6tzFxz.png" alt="enter image description here" /></p>

<h3>20. 一个objc对象的isa的指针指向什么？有什么作用？</h3>

<p><strong>我的解答：</strong></p>

<p>isa指针指向objc所属的类型的结构体，用于找到该类的方法列表。</p>

<p><strong>大神解答：</strong></p>

<p>指向他的类对象,从而可以找到对象上的方法。</p>

<h3>21. 下面的代码输出什么？</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@implementation</span> <span class="nc">Son</span> : <span class="nc">Father</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">self</span> <span class="n">class</span><span class="p">]));</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">super</span> <span class="n">class</span><span class="p">]));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>我的解答：</strong></p>

<p>son，son</p>

<p><strong>大神解答：</strong></p>

<p>都输出 Son</p>

<pre><code>NSStringFromClass([self class]) = Son
NSStringFromClass([super class]) = Son
</code></pre>

<p>这个题目主要是考察关于 objectivec 中对 self 和 super 的理解。</p>

<p>我们都知道：self 是类的隐藏参数，指向当前调用方法的这个类的实例。那 super 呢？</p>

<p>很多人会想当然的认为“ super 和 self 类似，应该是指向父类的指针吧！”。这是很普遍的一个误区。其实 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者！他们两个的不同点在于：super 会告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。</p>

<p>上面的例子不管调用<code>[self class]</code>还是<code>[super class]</code>，接受消息的对象都是当前 <code>Son ＊xxx</code> 这个对象。</p>

<p>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。</p>

<p>这也就是为什么说“不推荐在 init 方法中使用点语法”，如果想访问实例变量 iVar 应该使用下划线（ <code>_iVar</code> ），而非点语法（ <code>self.iVar</code> ）。</p>

<p>点语法（ <code>self.iVar</code> ）的坏处就是子类有可能覆写 setter 。假设 Person 有一个子类叫 ChenPerson，这个子类专门表示那些姓“陈”的人。该子类可能会覆写 lastName 属性所对应的设置方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">//  ChenPerson.m</span>
</span><span class='line'><span class="c1">//  </span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">//  Created by https://github.com/ChenYilong on 15/8/30.</span>
</span><span class='line'><span class="c1">//  Copyright (c) 2015年 http://weibo.com/luohanchenyilong/ 微博@iOS程序犭袁. All rights reserved.</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#import &quot;ChenPerson.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ChenPerson</span>
</span><span class='line'>
</span><span class='line'><span class="k">@synthesize</span> <span class="n">lastName</span> <span class="o">=</span> <span class="n">_lastName</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">init</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;</span><span class="p">,</span> <span class="n">__PRETTY_FUNCTION__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">self</span> <span class="n">class</span><span class="p">]));</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;</span><span class="p">,</span> <span class="n">__PRETTY_FUNCTION__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">super</span> <span class="n">class</span><span class="p">]));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setLastName:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">lastName</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//设置方法一：如果setter采用是这种方式，就可能引起崩溃</span>
</span><span class='line'><span class="c1">//    if (![lastName isEqualToString:@&quot;陈&quot;])</span>
</span><span class='line'><span class="c1">//    {</span>
</span><span class='line'><span class="c1">//        [NSException raise:NSInvalidArgumentException format:@&quot;姓不是陈&quot;];</span>
</span><span class='line'><span class="c1">//    }</span>
</span><span class='line'><span class="c1">//    _lastName = lastName;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//设置方法二：如果setter采用是这种方式，就不会引起崩溃</span>
</span><span class='line'>    <span class="n">_lastName</span> <span class="o">=</span> <span class="s">@&quot;陈&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;</span><span class="p">,</span> <span class="n">__PRETTY_FUNCTION__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="s">@&quot;会调用这个方法,想一下为什么？&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>在基类 Person 的默认初始化方法中，可能会将姓氏设为空字符串。此时若使用点语法（ <code>self.lastName</code> ）也即 setter 设置方法，那么调用将会是子类的设置方法，如果在刚刚的 setter 代码中采用设置方法一，那么就会抛出异常，</p>

<p>为了方便采用打印的方式展示，究竟发生了什么，我们使用设置方法二。</p>

<p>如果基类的代码是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">//  Person.m</span>
</span><span class='line'><span class="c1">//  nil对象调用点语法</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">//  Created by https://github.com/ChenYilong on 15/8/29.</span>
</span><span class='line'><span class="c1">//  Copyright (c) 2015年 http://weibo.com/luohanchenyilong/ 微博@iOS程序犭袁. All rights reserved.</span>
</span><span class='line'><span class="c1">//  </span>
</span><span class='line'>
</span><span class='line'><span class="cp">#import &quot;Person.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Person</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">init</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">lastName</span> <span class="o">=</span> <span class="s">@&quot;&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="c1">//NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([self class]));</span>
</span><span class='line'>        <span class="c1">//NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, self.lastName);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setLastName:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">lastName</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;</span><span class="p">,</span> <span class="n">__PRETTY_FUNCTION__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="s">@&quot;根本不会调用这个方法&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">_lastName</span> <span class="o">=</span> <span class="s">@&quot;炎黄&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么打印结果将会是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'> <span class="err">🔴类名与方法名：</span><span class="o">-</span><span class="p">[</span><span class="n">ChenPerson</span> <span class="nl">setLastName:</span><span class="p">]</span><span class="err">（在第</span><span class="mi">36</span><span class="err">行），描述：会调用这个方法</span><span class="p">,</span><span class="err">想一下为什么？</span>
</span><span class='line'> <span class="err">🔴类名与方法名：</span><span class="o">-</span><span class="p">[</span><span class="n">ChenPerson</span> <span class="n">init</span><span class="p">]</span><span class="err">（在第</span><span class="mi">19</span><span class="err">行），描述：</span><span class="n">ChenPerson</span>
</span><span class='line'> <span class="err">🔴类名与方法名：</span><span class="o">-</span><span class="p">[</span><span class="n">ChenPerson</span> <span class="n">init</span><span class="p">]</span><span class="err">（在第</span><span class="mi">20</span><span class="err">行），描述：</span><span class="n">ChenPerson</span>
</span></code></pre></td></tr></table></div></figure>


<p>我在仓库里也给出了一个相应的 Demo（名字叫：Demo_21题_下面的代码输出什么）。有兴趣可以跑起来看一下，主要看下他是怎么打印的，思考下为什么这么打印。</p>

<p>接下来让我们利用 runtime 的相关知识来验证一下 super 关键字的本质，使用clang重写命令:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">$</span> <span class="n">clang</span> <span class="o">-</span><span class="n">rewrite</span><span class="o">-</span><span class="n">objc</span> <span class="n">test</span><span class="p">.</span><span class="n">m</span>
</span></code></pre></td></tr></table></div></figure>


<p>将这道题目中给出的代码被转化为:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">(((</span><span class="n">Class</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)</span><span class="n">self</span><span class="p">,</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;class&quot;</span><span class="p">))));</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">(((</span><span class="n">Class</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__rw_objc_super</span> <span class="o">*</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSendSuper</span><span class="p">)((</span><span class="n">__rw_objc_super</span><span class="p">){</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">self</span><span class="p">,</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">class_getSuperclass</span><span class="p">(</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;Son&quot;</span><span class="p">))</span> <span class="p">},</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;class&quot;</span><span class="p">))));</span>
</span></code></pre></td></tr></table></div></figure>


<p>从上面的代码中，我们可以发现在调用 [self class] 时，会转化成 <code>objc_msgSend</code>函数。看下函数定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">id</span> <span class="n">objc_msgSend</span><span class="p">(</span><span class="kt">id</span> <span class="n">self</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">op</span><span class="p">,</span> <span class="p">...)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们把 self 做为第一个参数传递进去。</p>

<p>而在调用 [super class]时，会转化成 <code>objc_msgSendSuper</code>函数。看下函数定义:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">id</span> <span class="n">objc_msgSendSuper</span><span class="p">(</span><span class="k">struct</span> <span class="n">objc_super</span> <span class="o">*</span><span class="n">super</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">op</span><span class="p">,</span> <span class="p">...)</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个参数是 <code>objc_super</code> 这样一个结构体，其定义如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">struct</span> <span class="n">objc_super</span> <span class="p">{</span>
</span><span class='line'>     <span class="n">__unsafe_unretained</span> <span class="kt">id</span> <span class="n">receiver</span><span class="p">;</span>
</span><span class='line'>     <span class="n">__unsafe_unretained</span> <span class="n">Class</span> <span class="n">super_class</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>结构体有两个成员，第一个成员是 receiver, 类似于上面的 <code>objc_msgSend</code>函数第一个参数self 。第二个成员是记录当前类的父类是什么。</p>

<p>所以，当调用 ［self class] 时，实际先调用的是 <code>objc_msgSend</code>函数，第一个参数是 Son当前的这个实例，然后在 Son 这个类里面去找 &ndash; (Class)class这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 &ndash; (Class)class的实现就是返回self的类别，故上述输出结果为 Son。</p>

<p>objc Runtime开源代码对- (Class)class方法的实现:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">class</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">object_getClass</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而当调用 <code>[super class]</code>时，会转换成<code>objc_msgSendSuper函数</code>。第一步先构造 <code>objc_super</code> 结构体，结构体第一个成员就是 <code>self</code> 。
第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code> , 实际该函数输出结果为 Father。</p>

<p>第二步是去 Father这个类里去找 <code>- (Class)class</code>，没有，然后去NSObject类去找，找到了。最后内部是使用 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>去调用，</p>

<p>此时已经和<code>[self class]</code>调用相同了，故上述输出结果仍然返回 Son。</p>

<p>参考链接：<a href="http://weibo.com/junbbcom">微博@Chun_iOS</a>的博文<a href="http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1">刨根问底objectivec Runtime（1）－ Self &amp; Super</a>%5Bnil%5D-self-and-super/)</p>

<h3>22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h3>

<p><strong>我的解答：</strong></p>

<p>从类型的结构体中找到对应的实例方法列表中按照selector的名称去查找对应的方法，而类方法列表存储在类型的类型，即meta class当中。</p>

<p><strong>大神解答：</strong></p>

<p>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</p>

<h3>23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h3>

<p><strong>我的解答：</strong></p>

<p>不需要，原因不清楚。</p>

<p><strong>大神解答：</strong></p>

<ul>
<li>在ARC下不需要。</li>
<li><p><del> 在MRC中,对于使用retain或copy策略的需要 。</del></p>在MRC下也不需要</li>
</ul>


<blockquote><p>无论在MRC下还是ARC下均不需要。</p></blockquote>

<p><a href="https://web.archive.org/web/20120818164935/http://developer.apple.com/library/ios/#/web/20120820002100/http://developer.apple.com/library/ios/documentation/cocoa/conceptual/objectivec/Chapters/ocAssociativeReferences.html"> <strong><em>2011年版本的Apple API 官方文档 &ndash; Associative References</em></strong>  </a> 一节中有一个MRC环境下的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">// 在MRC下，使用runtime Associate方法关联的对象，不需要在主对象dealloc的时候释放</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'><span class="c1">// 摘自2011年版本的Apple API 官方文档 - Associative References </span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">char</span> <span class="n">overviewKey</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">NSArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithObjects:</span><span class="s">@&quot;One&quot;</span><span class="p">,</span> <span class="s">@&quot;Two&quot;</span><span class="p">,</span> <span class="s">@&quot;Three&quot;</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="c1">// For the purposes of illustration, use initWithFormat: to ensure</span>
</span><span class='line'><span class="c1">// the string can be deallocated</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">overview</span> <span class="o">=</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat:</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="s">@&quot;First three numbers&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">objc_setAssociatedObject</span> <span class="p">(</span>
</span><span class='line'>    <span class="n">array</span><span class="p">,</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">overviewKey</span><span class="p">,</span>
</span><span class='line'>    <span class="n">overview</span><span class="p">,</span>
</span><span class='line'>    <span class="n">OBJC_ASSOCIATION_RETAIN</span>
</span><span class='line'><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">overview</span> <span class="n">release</span><span class="p">];</span>
</span><span class='line'><span class="c1">// (1) overview valid</span>
</span><span class='line'><span class="p">[</span><span class="n">array</span> <span class="n">release</span><span class="p">];</span>
</span><span class='line'><span class="c1">// (2) overview invalid</span>
</span></code></pre></td></tr></table></div></figure>


<p>文档指出</p>

<blockquote><p>At point 1, the string <code>overview</code> is still valid because the <code>OBJC_ASSOCIATION_RETAIN</code> policy specifies that the array retains the associated object. When the array is deallocated, however (at point 2), <code>overview</code> is released and so in this case also deallocated.</p></blockquote>

<p>我们可以看到，在<code>[array release];</code>之后，overview就会被release释放掉了。</p>

<p>既然会被销毁，那么具体在什么时间点？</p>

<blockquote><p>根据<a href="https://developer.apple.com/videos/wwdc/2011/#322-video"> <strong><em>WWDC 2011, Session 322 (第36分22秒)</em></strong> </a>中发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的 object_dispose() 方法中释放。</p></blockquote>

<p>对象的内存销毁时间表，分四个步骤：</p>

<pre><code>// 对象的内存销毁时间表
// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)
// https://github.com/ChenYilong
// 根据 WWDC 2011, Session 322 (36分22秒)中发布的内存销毁时间表 

 1. 调用 -release ：引用计数变为零
     * 对象正在被销毁，生命周期即将结束.
     * 不能再有新的 __weak 弱引用， 否则将指向 nil.
     * 调用 [self dealloc] 
 2. 父类 调用 -dealloc
     * 继承关系中最底层的父类 在调用 -dealloc
     * 如果是 MRC 代码 则会手动释放实例变量们（iVars）
     * 继承关系中每一层的父类 都在调用 -dealloc
 3. NSObject 调 -dealloc
     * 只做一件事：调用 objectivec runtime 中的 object_dispose() 方法
 4. 调用 object_dispose()
     * 为 C++ 的实例变量们（iVars）调用 destructors 
     * 为 ARC 状态下的 实例变量们（iVars） 调用 -release 
     * 解除所有使用 runtime Associate方法关联的对象
     * 解除所有 __weak 引用
     * 调用 free()
</code></pre>

<p>对象的内存销毁时间表：<a href="http://stackoverflow.com/a/10843510/3395008">参考链接</a>。</p>

<h3>24. objc中的类方法和实例方法有什么本质区别和联系？</h3>

<p><strong>我的解答：</strong></p>

<ol>
<li>类方法是类型调用的，而实例方法是类的实例来调用的。</li>
<li>类方法中不能使用实例方法和实例变量，而实例方法中可以使用类方法。</li>
</ol>


<p><strong>大神解答：</strong></p>

<p>类方法：</p>

<ol>
<li>类方法是属于类对象的</li>
<li>类方法只能通过类对象调用</li>
<li>类方法中的self是类对象</li>
<li>类方法可以调用其他的类方法</li>
<li>类方法中不能访问成员变量</li>
<li>类方法中不定直接调用对象方法</li>
</ol>


<p>实例方法：</p>

<ol>
<li>实例方法是属于实例对象的</li>
<li>实例方法只能通过实例对象调用</li>
<li>实例方法中的self是实例对象</li>
<li>实例方法中可以访问成员变量</li>
<li>实例方法中直接调用实例方法</li>
<li>实例方法中也可以调用类方法(通过类名)</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native初探1]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/20/react-nativechu-tan-1/"/>
    <updated>2015-10-20T17:29:08+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/20/react-nativechu-tan-1</id>
    <content type="html"><![CDATA[<p>React Native是Facebook最近推出的一个框架，让开发者通过JavaScript来完成iOS或Android的Native App，类似的方案好像几年前就出现过，比如PhoneGap，但经过市场检验，其App的用户体验，尤其是UI方面，始终较Native App相距甚远，那么这次Facebook带来的解决方案又有什么不同呢？</p>

<!--more-->


<h2>React Native特点</h2>

<ol>
<li>使用React Native后，你的App的逻辑部分是用JavaScript完成的，而UI则是完全native的，所以也不用担心H5带来的体验下降。</li>
<li>React Native还为用户界面构建带来了一种全新的函数式构建方案，App的UI会用与app的状态有关的函数来呈现。</li>
<li>React Native的核心思路是将响应式编程引入移动开发，这并不像之前PhoneGap倡导的<em>write-once,run-anywhere</em>，而是<em>learn-once,write-anywhere</em>。</li>
<li>Swift中Apple倡导使用函数式编程来完成算法和业务逻辑，但是构建UI仍然是基于UIKit，并没有实现函数式实现，而React则引入了UI层的函数式编程。</li>
</ol>


<h2>React Native环境搭建</h2>

<p>React Native的源码开源在<a href="https://github.com/facebook/react-native">GitHub</a>上，不过如果只是开发使用，则推荐使用commend line interface（CLI）来创建项目。<br/>
1.React Native使用Node.js，JavaScript的runtime，来创建JS代码。这里推荐使用Homebrew来安装Node.js。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">brew</span> <span class="n">install</span> <span class="n">node</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.然后安装watchman，一个Facebook开发的文件监听器，React Native通过它来监视代码的改动并适时编译，类似在Xcode中保存一次文件，便会执行一次build。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">brew</span> <span class="n">install</span> <span class="n">watchman</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.然后利用安装好的Node.js带的Node Package Manager来安装React Native CLI工具。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">npm</span> <span class="n">install</span> <span class="o">-</span><span class="n">g</span> <span class="n">react</span><span class="o">-</span><span class="n">native</span><span class="o">-</span><span class="n">cli</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.这样环境就搭建完毕了，然后在目标文件夹，利用React Native的CLI创建新的项目。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">react</span><span class="o">-</span><span class="n">native</span> <span class="n">init</span> <span class="no">YourAppFolderName</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Hello Recact Native</h2>

<p>1.下面来创建一个“Hello World”的小程序，首先打开<strong>index.ios.js</strong>文件，删除测试代码，先添加以下代码，这段代码是开启了Strict Mode，主要为了提高JS的错误处理和禁用一些JS的语言特性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="s1">&#39;use strict&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.然后继续添加，这其实是导入了react-native模块，并将其赋值给了React，类似于#import或include。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">React</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;react-native&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.再添加一个样式，React Native使用了CSS来定义UI的样式，这和web开发是一致的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'> <span class="kd">var</span> <span class="nx">styles</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">StyleSheet</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span>
</span><span class='line'>  <span class="nx">text</span><span class="o">:</span><span class="p">{</span>
</span><span class='line'>      <span class="nx">color</span><span class="o">:</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">backgroundColor</span><span class="o">:</span><span class="s1">&#39;white&#39;</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">fontSize</span><span class="o">:</span><span class="mi">30</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">margin</span><span class="o">:</span><span class="mi">80</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'> <span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.创建一个JS的类，Class是在ES6中引入的，但web开发为了兼容旧版浏览器，一般不会使用类，React Native是基于JavaScriptCore，可以放心使用JS的新特性，而不用担心浏览器兼容的问题。PropertyFinderApp扩展了React.Component，它是React UI的基本构建块，包含了不可变的Properties、可变的状态变量和用于渲染的方法，这里由于程序简单，只有一个渲染方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kr">class</span> <span class="nx">PropertyFinderApp</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span><span class="p">{</span>
</span><span class='line'>  <span class="nx">render</span><span class="p">(){</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="nx">React</span><span class="p">.</span><span class="nx">Text</span><span class="p">,</span> <span class="p">{</span><span class="nx">style</span><span class="o">:</span><span class="nx">styles</span><span class="p">.</span><span class="nx">text</span><span class="p">},</span> <span class="s2">&quot;Hello World!&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.React.Component不是UIKit类，可以说是UIKit类的替代品，框架来负责将React components来转换为Native UI。最后再添加程序的入口，这里需要提供root component，也就是我们上面定义的PropertyFinderApp。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">React</span><span class="p">.</span><span class="nx">AppRegistry</span><span class="p">.</span><span class="nx">registerComponent</span><span class="p">(</span><span class="s2">&quot;RANTest&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span><span class="k">return</span> <span class="nx">PropertyFinderApp</span><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>6.然后运行程序，你会发现JS代码已经转化为Native元素，完全没有网页元素出现。</p>

<h2>React Native运作原理</h2>

<p>1.先来看一下OC的程序加载后做了什么，一个类为RCTRootView的对象被创建，它负责加载JS程序和渲染视图，它通过*<a href="http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true*%E6%9D%A5%E5%8A%A0%E8%BD%BDJS%E3%80%82">http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true*%E6%9D%A5%E5%8A%A0%E8%BD%BDJS%E3%80%82</a></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">didFinishLaunchingWithOptions:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">launchOptions</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">NSURL</span> <span class="o">*</span><span class="n">jsCodeLocation</span><span class="p">;</span>
</span><span class='line'>  <span class="n">jsCodeLocation</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURL</span> <span class="nl">URLWithString:</span><span class="s">@&quot;http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;</span><span class="p">];</span>
</span><span class='line'>  <span class="n">RCTRootView</span> <span class="o">*</span><span class="n">rootView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">RCTRootView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithBundleURL:</span><span class="n">jsCodeLocation</span>
</span><span class='line'>                                                      <span class="nl">moduleName:</span><span class="s">@&quot;RANTest&quot;</span>
</span><span class='line'>                                               <span class="nl">initialProperties:</span><span class="nb">nil</span>
</span><span class='line'>                                                   <span class="nl">launchOptions:</span><span class="n">launchOptions</span><span class="p">];</span>
</span><span class='line'>  <span class="n">self</span><span class="p">.</span><span class="n">window</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIWindow</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame:</span><span class="p">[</span><span class="n">UIScreen</span> <span class="n">mainScreen</span><span class="p">].</span><span class="n">bounds</span><span class="p">];</span>
</span><span class='line'>  <span class="n">UIViewController</span> <span class="o">*</span><span class="n">rootViewController</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIViewController</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>  <span class="n">rootViewController</span><span class="p">.</span><span class="n">view</span> <span class="o">=</span> <span class="n">rootView</span><span class="p">;</span>
</span><span class='line'>  <span class="n">self</span><span class="p">.</span><span class="n">window</span><span class="p">.</span><span class="n">rootViewController</span> <span class="o">=</span> <span class="n">rootViewController</span><span class="p">;</span>
</span><span class='line'>  <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">window</span> <span class="n">makeKeyAndVisible</span><span class="p">];</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.当你运行程序时，会打开一个终端窗口，就是为了开启一个packager和server来处理上述请求，在浏览器打开这一URL，也可以看到JS代码。<br/>
3.当app启动时，这些代码被载入，并被JavaScriptCore framework执行，将各个component载入，然后构建Native UIKit视图。</p>

<h2>Hello World JSX</h2>

<p>1.为了增加可读性和提高可维护性，可以使用HTML样式的JSX，也就是JavaScript syntax extension。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="k">return</span> <span class="o">&lt;</span><span class="nx">React</span><span class="p">.</span><span class="nx">Text</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">text</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Hello</span> <span class="nx">World</span><span class="p">(</span><span class="nx">Again</span><span class="p">)</span><span class="o">&lt;</span><span class="err">/React.Text&gt;;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>A Search React Native App1</h2>

<h3>Adding Navigation</h3>

<p>1.这一节构建一个OC的NavgationController，将之前的PropertyFinderApp类改为HelloWorld，然后新定义一个PropertyFinderApp类，initialRoute定为HelloWorld，routing技术是web开发中定义导航结构，即哪个页面（或route）对应哪个URL。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kr">class</span> <span class="nx">PropertyFinderApp</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="nx">React</span><span class="p">.</span><span class="nx">NavigatorIOS</span>
</span><span class='line'>        <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">container</span><span class="p">}</span>
</span><span class='line'>        <span class="nx">initialRoute</span><span class="o">=</span><span class="p">{</span> <span class="p">{</span>
</span><span class='line'>          <span class="nx">title</span><span class="o">:</span> <span class="s1">&#39;Property Finder&#39;</span><span class="p">,</span>
</span><span class='line'>          <span class="nx">component</span><span class="o">:</span> <span class="nx">HelloWorld</span><span class="p">,</span>
</span><span class='line'>        <span class="p">}</span> <span class="p">}</span><span class="o">/&gt;</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.然后添加container样式，这样，一个简单的导航控制器就完成了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">styles</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">StyleSheet</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span>
</span><span class='line'>  <span class="nx">text</span><span class="o">:</span><span class="p">{</span>
</span><span class='line'>      <span class="nx">color</span><span class="o">:</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">backgroundColor</span><span class="o">:</span><span class="s1">&#39;white&#39;</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">fontSize</span><span class="o">:</span><span class="mi">30</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">margin</span><span class="o">:</span><span class="mi">80</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="nx">container</span><span class="o">:</span><span class="p">{</span>
</span><span class='line'>      <span class="nx">flex</span><span class="o">:</span><span class="mi">1</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Building the Search Page</h3>

<p>1.这一节介绍如何添加自定义一个Search页面，并在其他文件中进行引用。首先新建一个SearchPage.js文件，并在文件中添加代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="s1">&#39;use strict&#39;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">React</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;react-native&#39;</span><span class="p">);</span>
</span><span class='line'><span class="kd">var</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">StyleSheet</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">Text</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">TextInput</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">View</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">TouchableHighlight</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">ActivityIndicatorIOS</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">Image</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">Component</span>
</span><span class='line'><span class="p">}</span> <span class="o">=</span> <span class="nx">React</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.这里使用了destructuring assignment，可以通过一行代码将多个对象属性一次性输出并将他们赋值给多个变量，这样你可以在之后的代码去掉React前缀，例如直接引用StyleSheet而不是React.StyleShet，这一技术在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">修改数组</a>时也经常用到，有点类似Swift的元组取值模式。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;one&quot;</span><span class="p">,</span> <span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="s2">&quot;three&quot;</span><span class="p">];</span>
</span><span class='line'><span class="c1">// without destructuring</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">one</span>   <span class="o">=</span> <span class="nx">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">two</span>   <span class="o">=</span> <span class="nx">foo</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">three</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class='line'><span class="c1">// with destructuring</span>
</span><span class='line'><span class="kd">var</span> <span class="p">[</span><span class="nx">one</span><span class="p">,</span> <span class="nx">two</span><span class="p">,</span> <span class="nx">three</span><span class="p">]</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.然后创建CSS样式，并创建SearchPage component，语法依然使用了JSX的结构。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">styles</span> <span class="o">=</span> <span class="nx">StyleSheet</span><span class="p">.</span><span class="nx">creat</span><span class="p">({</span>
</span><span class='line'>  <span class="nx">description</span><span class="o">:</span><span class="p">{</span>
</span><span class='line'>      <span class="nx">marginBottom</span><span class="o">:</span><span class="mi">20</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">fontSize</span><span class="o">:</span><span class="mi">18</span><span class="p">.</span>
</span><span class='line'>      <span class="nx">textAlign</span><span class="o">:</span><span class="s1">&#39;center&#39;</span><span class="p">.</span>
</span><span class='line'>      <span class="nx">color</span><span class="o">:</span><span class="s1">&#39;#656565&#39;</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="nx">container</span><span class="o">:</span><span class="p">{</span>
</span><span class='line'>      <span class="nx">padding</span><span class="o">:</span><span class="mi">30</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">marginTop</span><span class="o">:</span><span class="mi">65</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">alignItems</span><span class="o">:</span><span class="s1">&#39;center&#39;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kr">class</span> <span class="nx">SearchPage</span> <span class="kr">extends</span> <span class="nx">Component</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span><span class="p">(</span>
</span><span class='line'>       <span class="o">&lt;</span><span class="nx">View</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">container</span><span class="p">}</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="nx">Text</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">description</span><span class="p">}</span><span class="o">&gt;</span>
</span><span class='line'>         <span class="nx">Search</span> <span class="k">for</span> <span class="nx">houses</span> <span class="nx">to</span> <span class="nx">buy</span><span class="o">!</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="err">/Text&gt;</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="nx">Text</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">description</span><span class="p">}</span><span class="o">&gt;</span>
</span><span class='line'>         <span class="nx">Search</span> <span class="nx">by</span> <span class="nx">place</span><span class="o">-</span><span class="nx">name</span><span class="p">,</span> <span class="nx">postcode</span> <span class="nx">or</span> <span class="nx">search</span> <span class="nx">near</span> <span class="nx">your</span> <span class="nx">location</span><span class="p">.</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="err">/Text&gt;</span>
</span><span class='line'>       <span class="o">&lt;</span><span class="err">/View&gt;</span>
</span><span class='line'>      <span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.最后在文件结尾将SearchPage作为输出，并在index.ios.js中导入SearchPage，然后将之前render方法中的PropertyFinderApp类中的initialRoute更新。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">SearchPage</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">SearchPage</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./SearchPage&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">initialRoute</span><span class="o">=</span><span class="p">{</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">title</span><span class="o">:</span> <span class="s1">&#39;Property Finder&#39;</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">component</span><span class="o">:</span> <span class="nx">SearchPage</span><span class="p">,</span>
</span><span class='line'><span class="p">}</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Styling with Flexbox</h3>

<p>1.flexbox是CSS最近加入的新特性，用于页面的布局（类似Autolayout），React Native使用了<a href="http://https://github.com/facebook/css-layout">css-layout</a>库，该库是Facebook自己开发的一个使用了flexbox标准的JS库，而这一标准对于C(iOS)和Java(Android)都是可接受的，这里有一篇专门讲解<a href="http://blog.scottlogic.com/2015/02/02/svg-layout-flexbox.html">flexbox layout to SVG</a>的文章，也是该作者写的。<br/>
2.在这个app中，container默认是列方向布局，也就是垂直方向布局（这与Android的布局方式是相同的），同时container也可以决定他的子视图的布局方向。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&lt;</span><span class="nx">View</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">flowRight</span><span class="p">}</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="nx">TextInput</span>
</span><span class='line'>    <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">searchInput</span><span class="p">}</span>
</span><span class='line'>    <span class="nx">placeholder</span><span class="o">=</span><span class="s1">&#39;Search via name or postcode&#39;</span><span class="o">/&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="nx">TouchableHighlight</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">button</span><span class="p">}</span>
</span><span class='line'>      <span class="nx">underlayColor</span><span class="o">=</span><span class="s1">&#39;#99d9f4&#39;</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="nx">Text</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">buttonText</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Go</span><span class="o">&lt;</span><span class="err">/Text&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="err">/TouchableHighlight&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/View&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="nx">TouchableHighlight</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">button</span><span class="p">}</span>
</span><span class='line'>    <span class="nx">underlayColor</span><span class="o">=</span><span class="s1">&#39;#99d9f4&#39;</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="nx">Text</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">buttonText</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Location</span><span class="o">&lt;</span><span class="err">/Text&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/TouchableHighlight&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.添加新的样式，记得在每个样式后要添加逗号分开，flex值是为了划分同一container下子视图的占位比，如这里的Go button和input view的flex分别为1和4，那么就按照1:4来划分，另外，这里的button是使用了TouchableHighlight。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">flowRight</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">flexDirection</span><span class="o">:</span> <span class="s1">&#39;row&#39;</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">alignItems</span><span class="o">:</span> <span class="s1">&#39;center&#39;</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">alignSelf</span><span class="o">:</span> <span class="s1">&#39;stretch&#39;</span>
</span><span class='line'><span class="p">},</span>
</span><span class='line'><span class="nx">buttonText</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">fontSize</span><span class="o">:</span> <span class="mi">18</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">color</span><span class="o">:</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">alignSelf</span><span class="o">:</span> <span class="s1">&#39;center&#39;</span>
</span><span class='line'><span class="p">},</span>
</span><span class='line'><span class="nx">button</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">height</span><span class="o">:</span> <span class="mi">36</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">flex</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">flexDirection</span><span class="o">:</span> <span class="s1">&#39;row&#39;</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">backgroundColor</span><span class="o">:</span> <span class="s1">&#39;#48BBEC&#39;</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">borderColor</span><span class="o">:</span> <span class="s1">&#39;#48BBEC&#39;</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">borderWidth</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">borderRadius</span><span class="o">:</span> <span class="mi">8</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">marginBottom</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">alignSelf</span><span class="o">:</span> <span class="s1">&#39;stretch&#39;</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">justifyContent</span><span class="o">:</span> <span class="s1">&#39;center&#39;</span>
</span><span class='line'><span class="p">},</span>
</span><span class='line'><span class="nx">searchInput</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">height</span><span class="o">:</span> <span class="mi">36</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">padding</span><span class="o">:</span> <span class="mi">4</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">marginRight</span><span class="o">:</span> <span class="mi">5</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">flex</span><span class="o">:</span> <span class="mi">4</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">fontSize</span><span class="o">:</span> <span class="mi">18</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">borderWidth</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">borderColor</span><span class="o">:</span> <span class="s1">&#39;#48BBEC&#39;</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">borderRadius</span><span class="o">:</span> <span class="mi">8</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">color</span><span class="o">:</span> <span class="s1">&#39;#48BBEC&#39;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.然后添加一张图片，图片资源依然要添加到Xcode的Images.xcassets，使用require(&lsquo;image!house&rsquo;)来加载图片，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&lt;</span><span class="nx">Image</span> <span class="nx">source</span><span class="o">=</span><span class="p">{</span><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;image!house&#39;</span><span class="p">)}</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">image</span><span class="p">}</span><span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">image</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">width</span><span class="o">:</span> <span class="mi">217</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">height</span><span class="o">:</span> <span class="mi">138</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>A Search React Native App2</h2>

<h3>Adding Component State</h3>

<p>1.这一节，让我们来处理TextInput的输入，首先，我们来初始化SearchPage Component，下列代码添加到render()之前，这里有了新变量state以及searchString，并对TextInput赋该值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
</span><span class='line'>  <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">searchString</span><span class="o">:</span> <span class="s1">&#39;london&#39;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&lt;</span><span class="nx">TextInput</span>
</span><span class='line'>  <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">searchInput</span><span class="p">}</span>
</span><span class='line'>  <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">searchString</span><span class="p">}</span>
</span><span class='line'>  <span class="nx">placeholder</span><span class="o">=</span><span class="s1">&#39;Search via name or postcode&#39;</span><span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.然后在SearchPage Class添加一个方法，作为TextInput的回调，并将其与TextInput绑定，这一过程在OC中是以delegate的形式实现的，需要说明下的是这里的this是指向所在component的实例的指针。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">onSearchTextChanged</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;onSearchTextChanged&#39;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="nx">searchString</span><span class="o">:</span> <span class="nx">event</span><span class="p">.</span><span class="nx">nativeEvent</span><span class="p">.</span><span class="nx">text</span> <span class="p">});</span>
</span><span class='line'>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">searchString</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&lt;</span><span class="nx">TextInput</span>
</span><span class='line'>  <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">searchInput</span><span class="p">}</span>
</span><span class='line'>  <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">searchString</span><span class="p">}</span>
</span><span class='line'>  <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onSearchTextChanged</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">)}</span>
</span><span class='line'>  <span class="nx">placeholder</span><span class="o">=</span><span class="s1">&#39;Search via name or postcode&#39;</span><span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.通过实验TextInput我们发现，每次TextIput的状态发生改变，整个component就会重新render一次，这一机制将渲染逻辑和与UI有关的状态改变彻底分开。在大部分UI框架中，一般都是开发者根据app状态改变来手动刷新UI（比如OC或Swift），或者使用隐式链接来绑定app的状态和UI刷新完成自动刷新（比如ReactiveCocoa），但是在React Native中，你不用再去手动处理这些逻辑，整个UI就是app状态的一个函数表示！这就是响应式编程的核心理念。<br/>
4.不过你可能会担心效率问题，频繁刷新整个UI当然是不明智的，React在每次刷新时，它会从render方法获取整个视图树，然后与现在的UIKit视图进行比较，比较的结果就是一个简单的更新表，React按照这个表去更新当前视图，所以只有需要更新的UI才会去更新。<br/>
5.这一理念的应用，将虚拟DOM和一致性引入了App开发，也是React的独特之处。</p>

<h3>Initiating a Search</h3>

<p>1.这一节为Search页面添加搜索功能，首先在state中加入isLoading变量，再在render中添加spinner变量告知用户搜索在进行，它依据isLoading变量来添加一个spinner或空视图，并将{spinner}加入return方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">searchString</span><span class="o">:</span> <span class="s1">&#39;london&#39;</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">isLoading</span><span class="o">:</span> <span class="kc">false</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">spinner</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">isLoading</span> <span class="o">?</span>
</span><span class='line'>  <span class="p">(</span> <span class="o">&lt;</span><span class="nx">ActivityIndicatorIOS</span>
</span><span class='line'>      <span class="nx">hidden</span><span class="o">=</span><span class="s1">&#39;true&#39;</span>
</span><span class='line'>      <span class="nx">size</span><span class="o">=</span><span class="s1">&#39;large&#39;</span><span class="o">/&gt;</span> <span class="p">)</span> <span class="o">:</span>
</span><span class='line'>  <span class="p">(</span> <span class="o">&lt;</span><span class="nx">View</span><span class="o">/&gt;</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="p">{</span><span class="nx">spinner</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.在Go Button绑定onPress事件回调，并添加回调方法，注意Javascript的类没有访问器，所以也没有私有方法，所以一般用<em>_</em>前缀来标识私有方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">onPress</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onSearchPressed</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">)}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">_executeQuery</span><span class="p">(</span><span class="nx">query</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">query</span><span class="p">);</span>
</span><span class='line'>  <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="nx">isLoading</span><span class="o">:</span> <span class="kc">true</span> <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">onSearchPressed</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">query</span> <span class="o">=</span> <span class="nx">urlForQueryAndPage</span><span class="p">(</span><span class="s1">&#39;place_name&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">searchString</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="k">this</span><span class="p">.</span><span class="nx">_executeQuery</span><span class="p">(</span><span class="nx">query</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.在SearchPage外单独定义urlForQueryAndPage()方法，这里做了URL的拼接，用到了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">JS的方法</a> 。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">urlForQueryAndPage</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">pageNumber</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">country</span><span class="o">:</span> <span class="s1">&#39;uk&#39;</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">pretty</span><span class="o">:</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">encoding</span><span class="o">:</span> <span class="s1">&#39;json&#39;</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">listing_type</span><span class="o">:</span> <span class="s1">&#39;buy&#39;</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">action</span><span class="o">:</span> <span class="s1">&#39;search_listings&#39;</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">page</span><span class="o">:</span> <span class="nx">pageNumber</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>  <span class="nx">data</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">querystring</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
</span><span class='line'>    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">key</span> <span class="o">=&gt;</span> <span class="nx">key</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">key</span><span class="p">]))</span>
</span><span class='line'>    <span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="s1">&#39;http://api.nestoria.co.uk/api?&#39;</span> <span class="o">+</span> <span class="nx">querystring</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.=>是JS中对函数指针的缩写，可理解为OC中的block，这里先用map将其原字典的keys映射为新的数组，然后用&amp;相连，产生URL的参数String。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span>
</span><span class='line'>  <span class="s2">&quot;Hydrogen&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="s2">&quot;Helium&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="s2">&quot;Lithium&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="s2">&quot;Beryl­lium&quot;</span>
</span><span class='line'><span class="p">];</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">a2</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">s</span><span class="p">){</span> <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span> <span class="p">});</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">a3</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span> <span class="nx">s</span> <span class="o">=&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Performing an API Request</h3>

<p>1.在state添加message变量，并在render添加Text，用以显示请求错误信息，并在_excuteQuery()中添加请求的代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">searchString</span><span class="o">:</span> <span class="s1">&#39;london&#39;</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">isLoading</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">message</span><span class="o">:</span> <span class="s1">&#39;&#39;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&lt;</span><span class="nx">Text</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">description</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">message</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/Text&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.请求代码使用了fetch函数，这是<a href="https://fetch.spec.whatwg.org">Fetch API</a>中的函数，相比XMLHttpRequest，有很大提升，使用了promise规范。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">fetch</span><span class="p">(</span><span class="nx">query</span><span class="p">)</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span> <span class="o">=&gt;</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">())</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">json</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">_handleResponse</span><span class="p">(</span><span class="nx">json</span><span class="p">.</span><span class="nx">response</span><span class="p">))</span>
</span><span class='line'>  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span>
</span><span class='line'>     <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
</span><span class='line'>      <span class="nx">isLoading</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">message</span><span class="o">:</span> <span class="s1">&#39;Something bad happened &#39;</span> <span class="o">+</span> <span class="nx">error</span>
</span><span class='line'>   <span class="p">}));</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.success的回调处理，先对response code做了判断，然后打印出了listings的长度，可以看出JSON在JS开发中是直接使用的，而省去了转化为Model的步骤。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">_handleResponse</span><span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="nx">isLoading</span><span class="o">:</span> <span class="kc">false</span> <span class="p">,</span> <span class="nx">message</span><span class="o">:</span> <span class="s1">&#39;&#39;</span> <span class="p">});</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">application_response_code</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">===</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Properties found: &#39;</span> <span class="o">+</span> <span class="nx">response</span><span class="p">.</span><span class="nx">listings</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="nx">message</span><span class="o">:</span> <span class="s1">&#39;Location not recognized; please try again.&#39;</span><span class="p">});</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Displaying the Results</h3>

<p>1.新建SearchResult.js，新建SearchResults component，代码中使用到了ListView，类似OC的UITableView，通过dataSource来提供数据源，renderRow来渲染每个cell。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kr">class</span> <span class="nx">SearchResults</span> <span class="kr">extends</span> <span class="nx">Component</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">dataSource</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListView</span><span class="p">.</span><span class="nx">DataSource</span><span class="p">(</span>
</span><span class='line'>      <span class="p">{</span><span class="nx">rowHasChanged</span><span class="o">:</span> <span class="p">(</span><span class="nx">r1</span><span class="p">,</span> <span class="nx">r2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r1</span><span class="p">.</span><span class="nx">guid</span> <span class="o">!==</span> <span class="nx">r2</span><span class="p">.</span><span class="nx">guid</span><span class="p">});</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">dataSource</span><span class="o">:</span> <span class="nx">dataSource</span><span class="p">.</span><span class="nx">cloneWithRows</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">listings</span><span class="p">)</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">renderRow</span><span class="p">(</span><span class="nx">rowData</span><span class="p">,</span> <span class="nx">sectionID</span><span class="p">,</span> <span class="nx">rowID</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="nx">TouchableHighlight</span>
</span><span class='line'>          <span class="nx">underlayColor</span><span class="o">=</span><span class="s1">&#39;#dddddd&#39;</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="nx">View</span><span class="o">&gt;</span>
</span><span class='line'>          <span class="o">&lt;</span><span class="nx">Text</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">rowData</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/Text&gt;</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="err">/View&gt;</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="err">/TouchableHighlight&gt;</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="nx">ListView</span>
</span><span class='line'>        <span class="nx">dataSource</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">dataSource</span><span class="p">}</span>
</span><span class='line'>        <span class="nx">renderRow</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">renderRow</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">)}</span><span class="o">/&gt;</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.构建数据源时，提供了一个方法来比较row之间的id是否相同，ListView在更新时调用它，来确定数据源是否改变，本例中通过数据的guid来达到这个目的，然后在SearchPage的_handleResponse中添加导航方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">navigator</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
</span><span class='line'>  <span class="nx">title</span><span class="o">:</span> <span class="s1">&#39;Results&#39;</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">component</span><span class="o">:</span> <span class="nx">SearchResults</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">passProps</span><span class="o">:</span> <span class="p">{</span><span class="nx">listings</span><span class="o">:</span> <span class="nx">response</span><span class="p">.</span><span class="nx">listings</span><span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<h3>A Touch of Style</h3>

<p>1.添加样式，更新renderRow()方法，price为了去掉GBP后缀，做了字符串裁剪，同时这次的Image数据源为url，JS可直接赋值，而React Native会自动后台一步下载。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">styles</span> <span class="o">=</span> <span class="nx">StyleSheet</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span>
</span><span class='line'>  <span class="nx">thumb</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">width</span><span class="o">:</span> <span class="mi">80</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">height</span><span class="o">:</span> <span class="mi">80</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">marginRight</span><span class="o">:</span> <span class="mi">10</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="nx">textContainer</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">flex</span><span class="o">:</span> <span class="mi">1</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="nx">separator</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">height</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">backgroundColor</span><span class="o">:</span> <span class="s1">&#39;#dddddd&#39;</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="nx">price</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">fontSize</span><span class="o">:</span> <span class="mi">25</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">fontWeight</span><span class="o">:</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">color</span><span class="o">:</span> <span class="s1">&#39;#48BBEC&#39;</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="nx">title</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">fontSize</span><span class="o">:</span> <span class="mi">20</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">color</span><span class="o">:</span> <span class="s1">&#39;#656565&#39;</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="nx">rowContainer</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">flexDirection</span><span class="o">:</span> <span class="s1">&#39;row&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">padding</span><span class="o">:</span> <span class="mi">10</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">renderRow</span><span class="p">(</span><span class="nx">rowData</span><span class="p">,</span> <span class="nx">sectionID</span><span class="p">,</span> <span class="nx">rowID</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">price</span> <span class="o">=</span> <span class="nx">rowData</span><span class="p">.</span><span class="nx">price_formatted</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="nx">TouchableHighlight</span> <span class="nx">onPress</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">rowPressed</span><span class="p">(</span><span class="nx">rowData</span><span class="p">.</span><span class="nx">guid</span><span class="p">)}</span>
</span><span class='line'>        <span class="nx">underlayColor</span><span class="o">=</span><span class="s1">&#39;#dddddd&#39;</span><span class="o">&gt;</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="nx">View</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="nx">View</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">rowContainer</span><span class="p">}</span><span class="o">&gt;</span>
</span><span class='line'>          <span class="o">&lt;</span><span class="nx">Image</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">thumb</span><span class="p">}</span> <span class="nx">source</span><span class="o">=</span><span class="p">{</span> <span class="p">{</span> <span class="nx">uri</span><span class="o">:</span> <span class="nx">rowData</span><span class="p">.</span><span class="nx">img_url</span> <span class="p">}</span> <span class="p">}</span> <span class="o">/&gt;</span>
</span><span class='line'>          <span class="o">&lt;</span><span class="nx">View</span>  <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">textContainer</span><span class="p">}</span><span class="o">&gt;</span>
</span><span class='line'>            <span class="o">&lt;</span><span class="nx">Text</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">price</span><span class="p">}</span><span class="o">&gt;</span><span class="err">£</span><span class="p">{</span><span class="nx">price</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/Text&gt;</span>
</span><span class='line'>            <span class="o">&lt;</span><span class="nx">Text</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span>
</span><span class='line'>                  <span class="nx">numberOfLines</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">rowData</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/Text&gt;</span>
</span><span class='line'>          <span class="o">&lt;</span><span class="err">/View&gt;</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="err">/View&gt;</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="nx">View</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">separator</span><span class="p">}</span><span class="o">/&gt;</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="err">/View&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="err">/TouchableHighlight&gt;</span>
</span><span class='line'>  <span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.然后添加点击cell的回调，可以看到数据源始终还是最原始的数据源，做了一步过滤操作（因为这里的cell没有index的概念，所以只能过滤，但是必须保证guid唯一才可以）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">rowPressed</span><span class="p">(</span><span class="nx">propertyGuid</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">property</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">listings</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">prop</span> <span class="o">=&gt;</span> <span class="nx">prop</span><span class="p">.</span><span class="nx">guid</span> <span class="o">===</span> <span class="nx">propertyGuid</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Property Details View</h3>

<p>1.添加详情页，PropertyView，首先对房屋的配置信息做了整理，然后就是常规的视图布局。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kr">class</span> <span class="nx">PropertyView</span> <span class="kr">extends</span> <span class="nx">Component</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">property</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">property</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">stats</span> <span class="o">=</span> <span class="nx">property</span><span class="p">.</span><span class="nx">bedroom_number</span> <span class="o">+</span> <span class="s1">&#39; bed &#39;</span> <span class="o">+</span> <span class="nx">property</span><span class="p">.</span><span class="nx">property_type</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">property</span><span class="p">.</span><span class="nx">bathroom_number</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">stats</span> <span class="o">+=</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="nx">property</span><span class="p">.</span><span class="nx">bathroom_number</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">property</span><span class="p">.</span><span class="nx">bathroom_number</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="s1">&#39;bathrooms&#39;</span> <span class="o">:</span> <span class="s1">&#39;bathroom&#39;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">price</span> <span class="o">=</span> <span class="nx">property</span><span class="p">.</span><span class="nx">price_formatted</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="nx">View</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">container</span><span class="p">}</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="nx">Image</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">image</span><span class="p">}</span>
</span><span class='line'>            <span class="nx">source</span><span class="o">=</span><span class="p">{</span> <span class="p">{</span><span class="nx">uri</span><span class="o">:</span> <span class="nx">property</span><span class="p">.</span><span class="nx">img_url</span><span class="p">}</span> <span class="p">}</span> <span class="o">/&gt;</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="nx">View</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">heading</span><span class="p">}</span><span class="o">&gt;</span>
</span><span class='line'>          <span class="o">&lt;</span><span class="nx">Text</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">price</span><span class="p">}</span><span class="o">&gt;</span><span class="err">£</span><span class="p">{</span><span class="nx">price</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/Text&gt;</span>
</span><span class='line'>          <span class="o">&lt;</span><span class="nx">Text</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">property</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/Text&gt;</span>
</span><span class='line'>          <span class="o">&lt;</span><span class="nx">View</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">separator</span><span class="p">}</span><span class="o">/&gt;</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="err">/View&gt;</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="nx">Text</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">description</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">stats</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/Text&gt;</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="nx">Text</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">description</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">property</span><span class="p">.</span><span class="nx">summary</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/Text&gt;</span>
</span><span class='line'>      <span class="o">&lt;</span><span class="err">/View&gt;</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.最后从SearchResults，推入PropertyView。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">rowPressed</span><span class="p">(</span><span class="nx">propertyGuid</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">property</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">listings</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">prop</span> <span class="o">=&gt;</span> <span class="nx">prop</span><span class="p">.</span><span class="nx">guid</span> <span class="o">===</span> <span class="nx">propertyGuid</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">navigator</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
</span><span class='line'>    <span class="nx">title</span><span class="o">:</span> <span class="s2">&quot;Property&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">component</span><span class="o">:</span> <span class="nx">PropertyView</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">passProps</span><span class="o">:</span> <span class="p">{</span><span class="nx">property</span><span class="o">:</span> <span class="nx">property</span><span class="p">}</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Geolocation Search</h3>

<p>1.增加自动定位并搜索周边房屋的功能，在SearchPage的Location按钮添加该功能，前提在Xcode的工程的Plist中添加NSLocationWhenInUseUsageDescription来添加请求允许定位的描述。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">onPress</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onLocationPressed</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">)}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">onLocationPressed</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">navigator</span><span class="p">.</span><span class="nx">geolocation</span><span class="p">.</span><span class="nx">getCurrentPosition</span><span class="p">(</span>
</span><span class='line'>    <span class="nx">location</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>      <span class="kd">var</span> <span class="nx">search</span> <span class="o">=</span> <span class="nx">location</span><span class="p">.</span><span class="nx">coords</span><span class="p">.</span><span class="nx">latitude</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span> <span class="o">+</span> <span class="nx">location</span><span class="p">.</span><span class="nx">coords</span><span class="p">.</span><span class="nx">longitude</span><span class="p">;</span>
</span><span class='line'>      <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="nx">searchString</span><span class="o">:</span> <span class="nx">search</span> <span class="p">});</span>
</span><span class='line'>      <span class="kd">var</span> <span class="nx">query</span> <span class="o">=</span> <span class="nx">urlForQueryAndPage</span><span class="p">(</span><span class="s1">&#39;centre_point&#39;</span><span class="p">,</span> <span class="nx">search</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>      <span class="k">this</span><span class="p">.</span><span class="nx">_executeQuery</span><span class="p">(</span><span class="nx">query</span><span class="p">);</span>
</span><span class='line'>    <span class="p">},</span>
</span><span class='line'>    <span class="nx">error</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
</span><span class='line'>        <span class="nx">message</span><span class="o">:</span> <span class="s1">&#39;There was a problem with obtaining your location: &#39;</span> <span class="o">+</span> <span class="nx">error</span>
</span><span class='line'>      <span class="p">});</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Functions and Closures]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/20/swift-by-tutorials-functions-and-closures/"/>
    <updated>2015-10-20T17:28:15+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/20/swift-by-tutorials-functions-and-closures</id>
    <content type="html"><![CDATA[<p>函数是现代编程的一个重要部分，它将执行一个特定任务的逻辑打包到一个单元，可以复用，也可以提供给其他开发者作为黑盒接入使用。Swift支持全局的函数和类以及结构体的方法，还支持闭包，可以当做对象来传递。在这一章，会深入介绍Swift的函数，包括语法、类型及参数，还有Swift的命名习惯如何受OC的影响。最后，还有巧妙和灵活的闭包，这也是Swift作为一个函数式语言的重要原因。</p>

<!--more-->


<h2>Functions</h2>

<h3>Your first functon</h3>

<p>1.定义一个全局函数，Swift的函数全部是全局的，而方法是被定义在类或结构体中的，这与其他绝大多数语言室相同的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">square</span><span class="p">(</span><span class="nl">number:</span> <span class="n">Double</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Double</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">number</span> <span class="o">*</span> <span class="n">number</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Functions are first-class</h3>

<p>1.函数在Swift中是一级对象，也就意味着它可以赋值，可以作为函数参数，也可以作为函数结果返回，这也是第七章要讲的函数式编程的基础。<br/>
2.从前面几章得知，Swift是非常强调类型的安全性，那么函数的类型是什么呢？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">operation</span> <span class="o">=</span> <span class="n">square</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="nl">operation:</span><span class="p">(</span><span class="n">Double</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Double</span> <span class="o">=</span> <span class="n">square</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.面对一些函数类型中嵌套过于复杂，可以考虑使用typealias来梳理代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">doMath</span><span class="p">(</span><span class="nl">operation:</span><span class="p">(</span><span class="n">Double</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Double</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Double</span> <span class="p">{...}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">typealias</span> <span class="n">OperationType</span> <span class="o">=</span> <span class="p">(</span><span class="n">Double</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Double</span>
</span><span class='line'><span class="n">func</span> <span class="n">doMath</span><span class="p">(</span><span class="nl">operation:</span><span class="n">OperationType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Double</span> <span class="p">{...}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Function syntax</h3>

<p>1.除了一些常见的参数和返回结果这些必须条件，Swift函数无返回值时，<strong>Void</strong>并不是一个关键字，而是一个类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">logDouble</span><span class="p">(</span><span class="nl">number:</span> <span class="n">Double</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Void</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="nl">format:</span> <span class="s">&quot;%.2f&quot;</span><span class="p">,</span> <span class="n">number</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">typealias</span> <span class="n">Void</span> <span class="o">=</span> <span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.所以你可以将返回空的函数返回值写为<strong>()</strong>，其实也可以不写返回符号和类型，但是函数类型没变，还是<strong>(Double) &ndash;> ()</strong>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">logDouble</span><span class="p">(</span><span class="nl">number:</span> <span class="n">Double</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="nl">format:</span> <span class="s">&quot;%.2f&quot;</span><span class="p">,</span> <span class="n">number</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">logDouble</span><span class="p">(</span><span class="nl">number:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="nl">format:</span> <span class="s">&quot;%.2f&quot;</span><span class="p">,</span> <span class="n">number</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Overloading and generics</h3>

<p>1.Swift是支持重载的，如下两个方法是可以共存的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">checkAreEqual</span><span class="p">(</span><span class="nl">value:</span> <span class="n">Int</span><span class="p">,</span> <span class="nl">expected:</span> <span class="n">Int</span><span class="p">,</span> <span class="nl">message:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">expected</span> <span class="o">!=</span> <span class="n">value</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">func</span> <span class="nf">checkAreEqual</span><span class="p">(</span><span class="nl">value:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">expected:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">message:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">expected</span> <span class="o">!=</span> <span class="n">value</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.这里复习下重载（overload）和重写（override）的区别，overload是指在同一类中同样方法名，但参数与返回结果可以不同；而重写是指子类覆盖父类的方法，方法名、参数、返回都相同，实现不同，重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。<br/>
3.但是其实更好的解决方案是泛型，上一章也介绍过。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">checkAreEqual</span><span class="o">&lt;</span><span class="nl">T:</span> <span class="n">Equatable</span><span class="o">&gt;</span> <span class="p">(</span><span class="nl">value:</span> <span class="n">T</span><span class="p">,</span> <span class="nl">expected:</span> <span class="n">T</span><span class="p">,</span> <span class="nl">message:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="n">expected</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.经测试会出现这一现象，这一现象出现的原因是checkAreEqual会对前两个参数类型进行检查，一是其类型必须遵循Equatable协议，二是两个参数类型必须相同，第一个出现error就是因为类型不同造成的，而后者成功是因为45并没有指明类型，所以Swift通过&#8221;cat&#8221;推测出T应该是String类型，所以45也被推测为String类型，所以通过。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//error</span>
</span><span class='line'><span class="n">checkAreEqual</span><span class="p">(</span><span class="n">Int</span><span class="p">(</span><span class="mi">45</span><span class="p">),</span> <span class="nl">expected:</span> <span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="nl">message:</span> <span class="s">&quot;is not cat&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">//success</span>
</span><span class='line'><span class="n">checkAreEqual</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="nl">expected:</span> <span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="nl">message:</span> <span class="s">&quot;is not cat&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>In-out variables</h3>

<p>1.开发中有些情况是需要我们改变参数值的，比如下面的square方法</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">square</span><span class="p">(</span><span class="nl">number:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">number</span> <span class="o">=</span> <span class="n">number</span><span class="o">*</span><span class="n">number</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.但是这么写会直接报错，因为Swift中传入方法的参数类型默认都是let常量，是不可改变的，所以我们先将number改为var类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">square</span><span class="p">(</span><span class="n">var</span> <span class="nl">number:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">number</span> <span class="o">=</span> <span class="n">number</span><span class="o">*</span><span class="n">number</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.这次编译通过了，但是结果测试不对，仍输出原值，其实这里Swift与其他主流语言（OC、Java、C#、JS）一样，虽然表面上允许参数值修改，但是其实修改的是参数的本地copy，并不影响原值。<br/>
4.但是Swift还是支持直接修改原参数的，通过添加inout关键字，就可以将参数的指针地址直接传入，从而修改参数，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">square</span><span class="p">(</span><span class="n">inout</span> <span class="nl">number:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">number</span> <span class="o">=</span> <span class="n">number</span><span class="o">*</span><span class="n">number</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">5.0</span>
</span><span class='line'><span class="n">square</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.但是作者还是推荐谨慎使用，尤其在调用者对该技术不了解时，可能会造成困惑。</p>

<h3>Classes and structures as function parameters</h3>

<p>1.这一节讨论下类和结构体作为函数参数时的区别，首先看下Class作为参数的情况。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">class</span> <span class="n">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">34</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Colin&quot;</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">growOlder</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">age</span><span class="o">++</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">func</span> <span class="n">celebrateBirthday</span><span class="p">(</span><span class="nl">person:</span> <span class="n">Person</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Happy Birthday \(person.name)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">person</span><span class="p">.</span><span class="n">growOlder</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">person</span> <span class="o">=</span> <span class="n">Person</span><span class="p">()</span>
</span><span class='line'><span class="n">celebrateBirthday</span><span class="p">(</span><span class="n">person</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">person</span><span class="p">.</span><span class="n">age</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.结果person成功完成了age的增加，因为函数参数person和声明的实例person都是常量，并引用了相同的实例，当函数将class作为参数类型时，swift会将该类的实例的指针传入函数。<br/>
3.再看下结构体的实现，显然结构体和上一节的基本数据类型是一样的，仍需要声明参数为inout，而且在修改自身变量时需要在方法前加mutating关键字。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">struct</span> <span class="n">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">34</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Colin&quot;</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="n">growOlder</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">age</span><span class="o">++</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">func</span> <span class="n">celebrateBirthday</span><span class="p">(</span><span class="n">inout</span> <span class="nl">person:</span> <span class="n">Person</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Happy Birthday \(person.name)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">person</span><span class="p">.</span><span class="n">growOlder</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="n">person</span> <span class="o">=</span> <span class="n">Person</span><span class="p">()</span>
</span><span class='line'><span class="n">celebrateBirthday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">person</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">person</span><span class="p">.</span><span class="n">age</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.另外由于array和dictionary都是struct，所以需要在函数中，他们作为参数并允许被修改时，也需要inout关键字。</p>

<h3>Variadics</h3>

<p>1.这一节来讨论有变长参数的函数类型，下面就是一个用例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">longestWord</span><span class="p">(</span><span class="nl">words:</span> <span class="n">String</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">String</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">currentLongest:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">word</span> <span class="k">in</span> <span class="n">words</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">currentLongest</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">word</span><span class="p">.</span><span class="n">characters</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">currentLongest</span><span class="o">!</span><span class="p">.</span><span class="n">characters</span><span class="p">.</span><span class="n">count</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">currentLongest</span> <span class="o">=</span> <span class="n">word</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">currentLongest</span> <span class="o">=</span> <span class="n">word</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">currentLongest</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="kt">long</span> <span class="o">=</span> <span class="n">longestWord</span><span class="p">(</span><span class="s">&quot;chick&quot;</span><span class="p">,</span> <span class="s">&quot;fish&quot;</span><span class="p">,</span> <span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="s">&quot;elephant&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.words相当于一个常量数组，在函数中可以直接使用for-in来遍历其成员，可变长参数可能并不常用，但是在特定场景下还是一种比较优雅的实现方式。<br/>
3.这里补充一点，计算String长度的函数已经从<strong>countElements(word)【Swift1.0】</strong> &ndash;> <strong>count(word)【Swift1.2】</strong> &ndash;> <strong>word.characters.count【Swift2.0】</strong>，经历了这一变化。<br/>
4.如果结合第七章要讲的函数式编程，其实该方法可以用reduce函数来实现，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">longestWord</span><span class="p">(</span><span class="nl">words:</span> <span class="n">String</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">String</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">words</span><span class="p">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">String</span><span class="o">?</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">(</span><span class="n">longest</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span> <span class="k">in</span>
</span><span class='line'>    <span class="n">longest</span> <span class="o">==</span> <span class="nb">nil</span> <span class="o">||</span> <span class="n">word</span><span class="p">.</span><span class="n">characters</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">longest</span><span class="o">!</span><span class="p">.</span><span class="n">characters</span><span class="p">.</span><span class="n">count</span>
</span><span class='line'>        <span class="o">?</span> <span class="n">word</span> <span class="o">:</span> <span class="n">longest</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>External parameter names</h3>

<p>1.有时一些参数的作用表示的不是很明确，Swift不像OC，习惯在每个参数前写一段方法名，比如上述的比较字符串输入验证，光从调用来看无法得知那个是需要的名称。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">checkAreEqual</span><span class="p">(</span><span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="s">&quot;dog&quot;</span><span class="p">,</span> <span class="s">&quot;Incorrect input&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.为了解决这一问题，Swift允许开发者添加供外部使用的参数名，可以和内部的参数名共存，内部外部各自使用不同的参数名：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">checkAreEqual</span><span class="p">(</span><span class="n">value</span> <span class="nl">val:</span> <span class="n">String</span><span class="p">,</span> <span class="n">expected</span> <span class="nl">exp:</span> <span class="n">String</span><span class="p">,</span> <span class="n">message</span> <span class="nl">msg:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">exp</span> <span class="o">!=</span> <span class="n">val</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">checkAreEqual</span><span class="p">(</span><span class="nl">value:</span> <span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="nl">expected:</span> <span class="s">&quot;dog&quot;</span><span class="p">,</span> <span class="nl">message:</span> <span class="s">&quot;Incorrect input&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.但是需要注意的是，即使是使用了另外一套参数名，调用的顺序还是要和原来一致，像下面的调用是不会成功的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">checkAreEqual</span><span class="p">(</span><span class="nl">expected:</span> <span class="s">&quot;dog&quot;</span><span class="p">,</span> <span class="nl">value:</span> <span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="nl">message:</span> <span class="s">&quot;Incorrect input&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.如果你的内外部参数名一致，而且也确实需要外部参数名，可以在参数名前加#来使内外部参数名相同。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">checkAreEqual</span><span class="p">(</span><span class="err">#</span><span class="nl">value:</span> <span class="n">String</span><span class="p">,</span> <span class="err">#</span><span class="nl">expected:</span> <span class="n">String</span><span class="p">,</span> <span class="err">#</span><span class="nl">message:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">expected</span> <span class="o">!=</span> <span class="n">value</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">println</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">checkAreEqual</span><span class="p">(</span><span class="nl">value:</span> <span class="s">&quot;dog&quot;</span><span class="p">,</span> <span class="nl">expected:</span> <span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="nl">message:</span><span class="s">&quot;Incorrect input&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.当然这是一些场景下的问题，很多方法其实从函数名即可推断出参数的意义，而有些方法则是必须加参数名的，这一决定由具体情况来决定，<strong>大部分需要添加的属于有多个相同类型的参数</strong>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//purpose is clear</span>
</span><span class='line'><span class="n">dateFromString</span><span class="p">(</span><span class="s">&quot;2014-03-14&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">//not clear, which is row? which is colume?</span>
</span><span class='line'><span class="n">convertCellAt</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
</span><span class='line'><span class="c1">//to be clear</span>
</span><span class='line'><span class="n">convertCellAt</span><span class="p">(</span><span class="nl">column:</span> <span class="mi">42</span><span class="p">,</span> <span class="nl">row:</span> <span class="mi">13</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Methods</h2>

<p>与函数相对的是方法，方法是与类、结构体、枚举关联的函数，本章会对各类方法进行讨论。</p>

<h3>Instance methods</h3>

<p>1.下面是一个名叫cell的类，其中包含单个参数和多个参数的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">class</span> <span class="nl">Cell:</span> <span class="n">CustomStringConvertible</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">private</span><span class="p">(</span><span class="n">set</span><span class="p">)</span> <span class="n">var</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="n">private</span><span class="p">(</span><span class="n">set</span><span class="p">)</span> <span class="n">var</span> <span class="n">column</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">move</span><span class="p">(</span><span class="nl">x:</span> <span class="n">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nl">y:</span> <span class="n">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">row</span> <span class="o">+=</span> <span class="n">y</span>
</span><span class='line'>        <span class="n">column</span> <span class="o">+=</span> <span class="n">x</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">moveByX</span><span class="p">(</span><span class="nl">x:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">column</span> <span class="o">+=</span> <span class="n">x</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">moveByY</span><span class="p">(</span><span class="nl">y:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">row</span> <span class="o">+=</span> <span class="n">y</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">description:</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">get</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="s">&quot;Cell [row=\(row), col=\(column)]&quot;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.调用单个参数方法与函数没有区别，而调用多参数时需要在第二个参数后加上外部变量名，这与函数是不同的。其原因是函数默认是不添加外部参数名的，而方法除了第一个参数，后面的参数都是默认添加外部参数名，且与内部参数名一致，这一点也是从OC的命名风格继承而来。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">()</span>
</span><span class='line'><span class="n">cell</span><span class="p">.</span><span class="n">moveByX</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span><span class='line'><span class="n">cell</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nl">y:</span> <span class="mi">7</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.你可以通过在参数前加<strong> _ </strong>来禁止这一默认添加外部参数名的行为，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">move</span><span class="p">(</span><span class="nl">x:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nl">y:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">row</span> <span class="o">+=</span> <span class="n">y</span>
</span><span class='line'>  <span class="n">column</span> <span class="o">+=</span> <span class="n">x</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">cell</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.还有一个酷的特性是可以为参数赋默认值，这样调用时可以只输入单个参数，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">move</span><span class="p">(</span><span class="nl">x:</span> <span class="n">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nl">y:</span> <span class="n">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">row</span> <span class="o">+=</span> <span class="n">y</span>
</span><span class='line'>    <span class="n">column</span> <span class="o">+=</span> <span class="n">x</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">cell</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nl">y:</span> <span class="mi">7</span><span class="p">)</span>
</span><span class='line'><span class="n">cell</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="n">cell</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="nl">y:</span> <span class="mi">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Methods are first-class,too</h3>

<p>1.与function类似，Method也是第一类对象，同样可以作为参数、返回结果、或则赋值给其他变量。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">()</span>
</span><span class='line'><span class="n">var</span> <span class="n">instanceFunc</span> <span class="o">=</span> <span class="n">cell</span><span class="p">.</span><span class="n">moveByY</span>
</span><span class='line'><span class="n">instanceFunc</span><span class="p">(</span><span class="mi">34</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.除此之外，还有一个函数式编程的特性，直接通过类获取方法，在调用时需要绑定一个类的实例，这被称为柯里化函数，会在第七章的函数式编程介绍。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">()</span>
</span><span class='line'><span class="n">var</span> <span class="n">moveFunc</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">.</span><span class="n">moveByY</span>
</span><span class='line'><span class="n">moveFunc</span><span class="p">(</span><span class="n">cell</span><span class="p">)(</span><span class="mi">34</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Closures</h2>

<p>闭包如同函数和方法一样，是一组代码，可以被调用或传递，但是闭包是匿名的，而且它会将它范围内的值进行持有，这是它的特性。</p>

<h3>Closure expressions as anonymous function</h3>

<p>之前说过function和method都是第一类对象，他们是可以作为参数的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">sort</span><span class="p">(</span><span class="nl">isOrderedBefore:</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个常见的Array排序方法，要传入一个(T, T) &ndash;> Bool类型的比较方法，正常来说我们可以按照以下方式使用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">animals</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;fish&quot;</span><span class="p">,</span> <span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="s">&quot;chicken&quot;</span><span class="p">,</span> <span class="s">&quot;dog&quot;</span><span class="p">]</span>
</span><span class='line'><span class="n">func</span> <span class="n">isBefore</span><span class="p">(</span><span class="nl">one:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">two:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">one</span> <span class="o">&gt;</span> <span class="n">two</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">sortedStrings</span> <span class="o">=</span> <span class="n">animals</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">isBefore</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是如果使用闭包结构，那么我们完全不需要声明isBefore函数，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">animals</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;fish&quot;</span><span class="p">,</span> <span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="s">&quot;chicken&quot;</span><span class="p">,</span> <span class="s">&quot;dog&quot;</span><span class="p">]</span>
</span><span class='line'><span class="n">let</span> <span class="n">sortedStrings</span> <span class="o">=</span> <span class="n">animals</span><span class="p">.</span><span class="n">sort</span><span class="p">({</span>
</span><span class='line'>  <span class="p">(</span><span class="nl">one:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">two:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="k">in</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">one</span> <span class="o">&gt;</span> <span class="n">two</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以将闭包理解为匿名函数，通过in关键字来表明函数的实现部分，但是这一结构在实际开发中也可以进行继续简化，这得利与Swift的type inference特性。首先，系统可以推断出闭包中参数的类型和返回值类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">sortedStrings</span> <span class="o">=</span> <span class="n">animals</span><span class="p">.</span><span class="n">sort</span><span class="p">({</span>
</span><span class='line'>  <span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">)</span> <span class="k">in</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">one</span> <span class="o">&gt;</span> <span class="n">two</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>同时可以省略return和括号：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">sortedStrings</span> <span class="o">=</span> <span class="n">animals</span><span class="p">.</span><span class="n">sort</span><span class="p">({</span>
</span><span class='line'>  <span class="n">one</span><span class="p">,</span> <span class="n">two</span> <span class="k">in</span>
</span><span class='line'>  <span class="n">one</span> <span class="o">&gt;</span> <span class="n">two</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后，如果想进一步简化，可以利用Swift的简写本地常量来替代参数，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">sortedStrings</span> <span class="o">=</span> <span class="n">animals</span><span class="p">.</span><span class="n">sort</span><span class="p">({</span> <span class="n">$0</span> <span class="o">&gt;</span> <span class="n">$1</span> <span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>也可以将闭包拿到方法之外，作为trailing closure，也可将()删除：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">sortedStrings</span> <span class="o">=</span> <span class="n">animals</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span> <span class="p">{</span> <span class="n">$0</span> <span class="o">&gt;</span> <span class="n">$1</span> <span class="p">}</span>
</span><span class='line'><span class="c1">//or</span>
</span><span class='line'><span class="n">let</span> <span class="n">sortedStrings</span> <span class="o">=</span> <span class="n">animals</span><span class="p">.</span><span class="n">sorted</span> <span class="p">{</span> <span class="n">$0</span> <span class="o">&gt;</span> <span class="n">$1</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>终极简化，直接将参数也省去，这也与逻辑上的最简达成了一致，sort()方法只需要知道你想排序的方式。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">sortedStrings</span> <span class="o">=</span> <span class="n">animals</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="o">&gt;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外需要注意的是，如果你打算自己声明这个闭包的变量，再赋值给sort()，也可以，但是就不能做简化，因为系统无法推断出所需的类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">isBefore</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">(</span><span class="nl">one:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">two:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="k">in</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">one</span> <span class="o">&gt;</span> <span class="n">two</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">sortedStrings</span> <span class="o">=</span> <span class="n">animals</span><span class="p">.</span><span class="n">sorted</span><span class="p">(</span><span class="n">isBefore</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Capturing values</h3>

<p>闭包会对内部使用的外部变量进行占据，下面就举例说明这一现象，在makeStateMachine()返回StateMachineType类型的函数后，照理说其内部变量currentState的作用域也结束了，但是在使用该函数时，仍然没有报错，说明闭包对外部变量进行了占据，这类似于OC中的block对引用的外部变量的retain操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">typealias</span> <span class="n">StateMachineType</span> <span class="o">=</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Int</span>
</span><span class='line'>
</span><span class='line'><span class="n">func</span> <span class="n">makeStateMachine</span><span class="p">(</span><span class="nl">maxState:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StateMachineType</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">currentState</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">currentState</span><span class="o">++</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">currentState</span> <span class="o">&gt;</span> <span class="n">maxState</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">currentState</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">currentState</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">let</span> <span class="n">tristate</span> <span class="o">=</span> <span class="n">makeStateMachine</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">tristate</span><span class="p">())</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Memory leaks and capture lists</h3>

<p>下面先介绍一个导致closure内存泄露的例子，源代码中actionClosure为let类型，实际开发中会出现<a href="http://stackoverflow.com/questions/27038889/why-do-i-get-a-variable-used-before-being-initialized-error-on-the-line-that-i">error</a>，这里改为了var类型，也说明了问题。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">class</span> <span class="n">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">name:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">private</span> <span class="n">var</span> <span class="nl">actionClosure:</span> <span class="p">(()</span> <span class="o">-&gt;</span> <span class="p">())</span><span class="o">!</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">actionClosure</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">print</span><span class="p">(</span><span class="s">&quot;I am \(self.name)&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">func</span> <span class="n">performAction</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">actionClosure</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">deinit</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;\(name) is being deinitialized&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在ViewController的viewDidLoad()调用以下代码，这时会出现person的引用循环，viewDidLoad()方法结束了，没有指向person的指针，而person又与自己的actionClosure变量互相引用，无法释放，造成内存泄露。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">override</span> <span class="n">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>
</span><span class='line'>    <span class="c1">// Do any additional setup after loading the view, typically from a nib.</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">let</span> <span class="n">person</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="nl">name:</span> <span class="s">&quot;bob&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">person</span><span class="p">.</span><span class="n">performAction</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这与OC中block的引用循环是一样的，在OC里常用以下方式，用weak类型的替代来避免强引用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">__weak</span> <span class="n">typeof</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="n">weakSelf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">context</span> <span class="nl">performBlock:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="n">__strong</span> <span class="n">typeof</span><span class="p">(</span><span class="n">weakSelf</span><span class="p">)</span><span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// do something with strongSelf</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>而在Swift中有更优雅的解决方案，可以定义一个capture list，这里将self标记为unowned，当然也可以标记为weak，关于二者的区别，会附加一节进行介绍。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">actionClosure</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="n">unowned</span> <span class="n">self</span><span class="p">]</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="k">in</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="s">&quot;I am \(self.name)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">actionClosure</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="n">weak</span> <span class="n">self</span><span class="p">]</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="k">in</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="s">&quot;I am \(self.name)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>补充：关于weak和unowned</h3>

<p>unowned可以类比为OC当中unsafe_unretained，即即使内容被释放了，但指针并不会指向nil，而weak与OC当中的weak是一致的，都会在内容释放后，自动指向nil。所以unowned不是Optional类型，也不会被置为nil。而weak则是Optional类型，因为它需要在引用对象释放时置为nil。Apple的建议是能确保访问期间不被释放的话，使用unowned，如果可能被释放，就是用weak。</p>

<p>实际开发过程中经常使用弱引用的场景有两个：</p>

<ul>
<li>设置delegate时</li>
<li>闭包中对self属性进行引用，同时闭包自身也被self持有</li>
</ul>


<p>delegate我们一般选择使用weak关键字，如下述代码，因为网络请求中，可能出现等待过久，用户取消访问的情况，有可能RequestManager会被释放，所以这里采用了weak，而不是unowned。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">// RequestManager.swift</span>
</span><span class='line'><span class="n">class</span> <span class="nl">RequestManager:</span> <span class="n">RequestHandler</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">func</span> <span class="n">requestFinished</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;请求完成&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">func</span> <span class="n">sendRequest</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">req</span> <span class="o">=</span> <span class="n">Request</span><span class="p">()</span>
</span><span class='line'>        <span class="n">req</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">req</span><span class="p">.</span><span class="n">send</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Request.swift</span>
</span><span class='line'><span class="err">@</span><span class="n">objc</span> <span class="n">protocol</span> <span class="n">RequestHandler</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">optional</span> <span class="n">func</span> <span class="n">requestFinished</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">class</span> <span class="n">Request</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">weak</span> <span class="n">var</span> <span class="nl">delegate:</span> <span class="n">RequestHandler</span><span class="o">!</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">func</span> <span class="nf">send</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 发送请求</span>
</span><span class='line'>        <span class="c1">// 一般来说会将 req 的引用传递给网络框架</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">func</span> <span class="nf">gotResponse</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 请求返回</span>
</span><span class='line'>        <span class="n">delegate</span><span class="o">?</span><span class="p">.</span><span class="n">requestFinished</span><span class="o">?</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而闭包循环引用的例子，就如上一节的例子，那么，如果我们能确保self不会在访问actionClosure过程中释放，那么就是用unowned，如果不能确保（比如该closure被外部变量持有了，然后self释放，但仍可访问到closure），那么就要使用weak。</p>

<p>如果需要标注多个元素，那么需要用逗号隔开。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">// 标注前</span>
</span><span class='line'><span class="p">{</span> <span class="p">(</span><span class="nl">number:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="k">in</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">true</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 标注后</span>
</span><span class='line'><span class="p">{</span> <span class="p">[</span><span class="n">unowned</span> <span class="n">self</span><span class="p">,</span> <span class="n">weak</span> <span class="n">someObject</span><span class="p">]</span> <span class="p">(</span><span class="nl">number:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="k">in</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">true</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Generics]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/15/swift-by-tutorials-generics/"/>
    <updated>2015-10-15T11:05:56+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/15/swift-by-tutorials-generics</id>
    <content type="html"><![CDATA[<p>经过前三章，基本对Swift的基本语法有了较全面的介绍，接下来会分别就Swift比较重要的几个技术要点介绍，这一节将讨论一个比较流行的语言特性，generics，即泛型。对于类型安全的编程语言，希望代码可以在一个场景下运行，但又想要在其他场景中也可以是合法的，比如对于一个加法函数，Int和Float类型的函数形式是一样的，只是变量类型不同，在强调类型的语言中，你必须分开定义这两个方法。很多语言为这一问题提供了解决方案，C++是使用了模板，而Swift、Java、C#是使用了泛型，也就是这一章的主角，配合主题这一章将创建一个Flickr照片搜素App来实践这一技术。</p>

<!--more-->


<h2>Introducing generics</h2>

<p>1.泛型是什么？举例来说Array和Dictionary就是类型安全的泛型应用实例。在OC中Array和Dictionary是可以存放不同类型的对象的，当然这有时是提供了很多方便，但当你去使用一个Array或Dictionary时，你如何知道其中的类型？只能通过文档或其他代码，而且没有任何办法去控制在runtime中出现数据异常。<br/>
2.而Swift中对Array和Dictionary中类型是固定的，编译器会完成类型检查，而你的代码本身也对自己做了注释，比较下处理点击的方法在OC和Swift中的区别，在OC中调用这一方法，你一般是需要将set中的对象转化为UITouch类型，而Swift不仅省去你这一操作，代码可读性也更优。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//in OC</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesBegan:</span><span class="p">(</span><span class="n">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span><span class="p">;</span>
</span><span class='line'><span class="c1">//in Swift</span>
</span><span class='line'><span class="n">func</span> <span class="n">touchesBegan</span><span class="p">(</span><span class="nl">touches:</span> <span class="p">[</span><span class="n">UITouch</span><span class="p">]</span><span class="o">!</span><span class="p">,</span> <span class="n">withEvent</span> <span class="nl">event:</span> <span class="n">UIEvent</span><span class="o">!</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.所以说泛型就是类似Array这样，所有的Array运作方式都是一致的，都是将数据存在一张有序的表中，但泛型的Array将值的类型作为了参数，也就是不论Array中类型如何，都可以执行Array的方法。</p>

<!--more-->


<h2>Generics in action</h2>

<p>1.本章的实例项目是要从Flickr的搜索接口获取对应图片，并进行展示的一个App，其中网络访问部分大神已经写好了。</p>

<!--more-->


<h2>Ordered dictionaries</h2>

<p>1.第一个需求就是希望将用户最近搜索的图片放在前面，那么如果正常来讲，我们要用Array来存数据源，而不是Dictionary或Set，因为后两者是无序的，而这里为了应用泛型，打算自己创建一个有序的Dictionary，实际上就是想把key作为顺序。</p>

<h3>The initial data structure</h3>

<p>1.首先声明有序字典为Struct类型，并声明它的泛型类型参数，KeyType和ValueType并不是真实的类型，只是两个你用来替代类型的参数，一般用T来表示，如果单词表示的话用驼峰式大写首字母来表示。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">struct</span> <span class="n">OrderedDictionary</span><span class="o">&lt;</span><span class="n">KeyType</span><span class="p">,</span> <span class="n">ValueType</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.创建一个有序字典最简单的方法是，在内部同时维护一个Dictionary和Array，这里使用了typealias分别给[KeyType]和[KeyType: ValueType]做了类型名替代，这样下面声明Array和Dictionary就可以直接用替代类型名来定义，同理这个也可以用在替换函数类型和闭包等比较长的类型的替换。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">typealias</span> <span class="n">ArrayType</span> <span class="o">=</span> <span class="p">[</span><span class="n">KeyType</span><span class="p">]</span>
</span><span class='line'><span class="n">typealias</span> <span class="n">DictionaryType</span> <span class="o">=</span> <span class="p">[</span><span class="nl">KeyType:</span> <span class="n">ValueType</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">var</span> <span class="n">array</span> <span class="o">=</span> <span class="n">ArrayType</span><span class="p">()</span>
</span><span class='line'><span class="n">var</span> <span class="n">dictionary</span> <span class="o">=</span> <span class="n">DictionaryType</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.对比Dictionary的定义，KeyType需要遵循Hashable协议，因为Dictionary需要对key做hash，所以在定义泛型那儿要加上遵循该协议。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">struct</span> <span class="n">OrderedDictionary</span><span class="o">&lt;</span><span class="nl">KeyType:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">ValueType</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Keys, values and all that jazz</h3>

<p>1.第一个要加入的方法是insert方法，因为是有序字典，所以有所不同。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">mutating</span> <span class="n">func</span> <span class="n">insert</span><span class="p">(</span><span class="nl">value:</span> <span class="n">ValueType</span><span class="p">,</span> <span class="n">forKey</span> <span class="nl">key:</span> <span class="n">KeyType</span><span class="p">,</span> <span class="n">atIndex</span> <span class="nl">index:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">var</span> <span class="n">adjustedIndex</span> <span class="o">=</span> <span class="n">index</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">let</span> <span class="n">existingValue</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">existingValue</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">existingIndex</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">indexOf</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">!</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">existingIndex</span> <span class="o">&lt;</span> <span class="n">index</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">adjustedIndex</span><span class="o">--</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">removeAtIndex</span><span class="p">(</span><span class="n">existingIndex</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nl">atIndex:</span><span class="n">adjustedIndex</span><span class="p">)</span>
</span><span class='line'>  <span class="n">self</span><span class="p">.</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="n">existingValue</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.有几点需要说明，首先，该方法前的mutating关键字，因为Struct默认是不可变的，也就是是说你不能在实例方法中修改struct的成员变量，加上mutating是为了告诉编译器该方法可以修改struct成员变量，使编译器在适当的时候对struct做copy操作(前面说过，实际上是copy-on-write)，同时也增加了可读性。<br/>
3.然后是remove方法，这里先对index是否越界做了判断，可以像OC中使用Assertions断言，也可以如下使用precondition，如果失败，会退出App。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">mutating</span> <span class="n">func</span> <span class="nf">removeAtIndex</span><span class="p">(</span><span class="nl">index:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">KeyType</span><span class="p">,</span> <span class="n">ValueType</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">precondition</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="s">&quot;Index out-of-bounds&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">removeAtIndex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
</span><span class='line'>  <span class="n">let</span> <span class="n">value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">dictionary</span><span class="p">.</span><span class="n">removeValueForKey</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">!</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.这里在结束后会返回一个元组类型的删除值，使之与Swift的Array和Dictionary的remove方法保持一致。</p>

<h3>Accessing values</h3>

<p>1.上一节为有序字典添加了写入的方法，接下来添加一些读取的方法，首先是获取count的方法，如下，使用了前面提到的computed property技术。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="nl">count:</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">count</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.在Swift中我们一般使用subscript来访问变量，类似dictionary[1]，一般是见于Array和Dictionary，不过我们计划在我们的有序字典也加入这一特性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">subscript</span><span class="p">(</span><span class="nl">key:</span> <span class="n">KeyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">get</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">set</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">let</span> <span class="n">index</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">indexOf</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">newValue</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.上述代码就是如何在自己的Struct中加入subscript行为，类似computed property，subscript有两个闭包，分别是getter和setter。<br/>
4.因为这是一个有序数组，我们打算让他支持通过index来访问，需要注意的是：一，无论setter，getter都需要判断index是否越界；二，setter中输入的值newValue是一个元组类型，所以需要用let (key, value) = newValue将键值取出来。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">subscript</span><span class="p">(</span><span class="nl">index:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">KeyType</span><span class="p">,</span> <span class="n">ValueType</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">get</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">precondition</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="s">&quot;Index out-of-bounds&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">!</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">set</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">precondition</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="s">&quot;Index out-of-bounds&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">let</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="n">newValue</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">originalKey</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">dictionary</span><span class="p">[</span><span class="n">originalKey</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.这里可能有个疑问，就是如果使用者使用Int作为KeyType呢？因为Int也遵循hashable，完全可以作为key，那么编译器如何判断该用哪组方法呢？遇到这种情况，setter方法当然没问题，因为赋值也不同，那么getter方法只能在取值时就声明返回值的类型，这样编译器会通过这个类型选择使用哪个方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">dict</span> <span class="o">=</span> <span class="n">OrderedDictionary</span><span class="o">&lt;</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span><span class="p">()</span>
</span><span class='line'><span class="n">dict</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&quot;dog&quot;</span><span class="p">,</span> <span class="nl">forKey:</span> <span class="mi">1</span><span class="p">,</span> <span class="nl">atIndex:</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="n">dict</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="nl">forKey:</span> <span class="mi">2</span><span class="p">,</span> <span class="nl">atIndex:</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">description</span> <span class="o">+</span> <span class="s">&quot; : &quot;</span> <span class="o">+</span> <span class="n">dict</span><span class="p">.</span><span class="n">dictionary</span><span class="p">.</span><span class="n">description</span><span class="p">)</span>
</span><span class='line'><span class="c1">//&quot;[1, 2] : [2: &quot;cat&quot;, 1: &quot;dog&quot;]&quot;</span>
</span><span class='line'><span class="n">var</span> <span class="nl">byIndex:</span> <span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span> <span class="o">=</span> <span class="n">dict</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">byIndex</span><span class="p">)</span>
</span><span class='line'><span class="c1">//&quot;(1, &quot;dog&quot;)&quot;</span>
</span><span class='line'><span class="n">var</span> <span class="nl">byKey:</span> <span class="n">String</span><span class="o">?</span> <span class="o">=</span> <span class="n">dict</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">byKey</span><span class="p">)</span>
</span><span class='line'><span class="c1">//&quot;Optional(&quot;cat&quot;)&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>6.在使用type interface时，编译器需要明确知道返回值的类型，如果出现上述相同方法，返回值类型不同的情况，必须caller指明类型，否则编译器是不会知道该返回那个值的。</p>

<!--more-->


<h2>Aside: Assertions &amp; preconditions</h2>

<p>1.assertions和precondition都是判断程序是否能继续执行时的判断条件，不同的是，assertion是不会在release build时编译的，而precondition可以；assertion是被用于在开发时获取bug，而precondition是用于当一个条件不满足时，抛出严重异常的。<br/>
2.assertion的一个使用场景是有多个创建view的方法共同来构建页面，但其中一些依赖于另一些完成，这时要使用assertion。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">private</span> <span class="n">func</span> <span class="nf">configureTableView</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">self</span><span class="p">.</span><span class="n">tableView</span> <span class="o">=</span> <span class="n">UITableView</span><span class="p">(</span><span class="nl">frame:</span> <span class="n">CGRectZero</span><span class="p">)</span>
</span><span class='line'>  <span class="n">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span>
</span><span class='line'>  <span class="n">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="n">self</span>
</span><span class='line'>  <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">private</span> <span class="n">func</span> <span class="nf">configureHeader</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">tableView</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>  <span class="n">let</span> <span class="n">headerView</span> <span class="o">=</span> <span class="n">UIView</span><span class="p">(</span><span class="nl">frame:</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
</span><span class='line'>  <span class="n">headerView</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="n">UIColor</span><span class="p">.</span><span class="n">clearColor</span><span class="p">()</span>
</span><span class='line'>  <span class="n">let</span> <span class="n">label</span> <span class="o">=</span> <span class="n">UILabel</span><span class="p">(</span><span class="nl">frame:</span> <span class="n">CGRectZero</span><span class="p">)</span>
</span><span class='line'>  <span class="n">label</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">&quot;My Table&quot;</span>
</span><span class='line'>  <span class="n">label</span><span class="p">.</span><span class="n">sizeToFit</span><span class="p">()</span>
</span><span class='line'>  <span class="n">label</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">label</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">)</span> <span class="n">headerView</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
</span><span class='line'>  <span class="n">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">.</span><span class="n">tableHeaderView</span> <span class="o">=</span> <span class="n">headerView</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.关于assertion一个有趣的现象是编译器允许在release build时假设assertion是true，有时也会导致一些bug，如下，输入0时，在debug下没问题，会触发断言；而在release中，编译器自动认为assertion是true，然后optimizer就会跳过if，直接进入>0的分支。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">foo</span><span class="p">(</span><span class="nl">value:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;Yes, it&#39;s greater than zero&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;Nope&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.再来看下precondition，它和assertion做的是一样的工作，但是可以在release下运行，使用它是为了确保一些必要的条件，如下例，数组越界即使不加precondition，也会crash，但是通过precondition，可以获取到自定义的log信息，方便调试。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">fetchPeopleBetweenIndexes</span><span class="p">(</span><span class="nl">start:</span> <span class="n">Int</span><span class="p">,</span> <span class="nl">end:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">Person</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">precondition</span><span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
</span><span class='line'>  <span class="n">precondition</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>  <span class="n">precondition</span><span class="p">(</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">self</span><span class="p">.</span><span class="n">people</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">people</span><span class="p">[</span><span class="n">start</span><span class="p">..</span><span class="o">&lt;</span><span class="n">end</span><span class="p">])</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.一般的经验是，在你release时可以跳过，但是希望在debug阶段获取失败信息时使用assertion；而在将会导致数据损坏或者其他严重问题前，使用precondition。同时在你开发一些第三方库时，在容易出现数据输入错误这些位置可以使用precondition来提示开发者。</p>

<!--more-->


<h2>Adding image search</h2>

<p>1.创建App的数据源，使用的就是之前自定义的有序字典，你可能注意到使用了Flickr.photo，Photo是一个定义在Flickr中的类，这样的机制非常有用，在保持类名尽量短的基础上实现了命名空间，在Flickr类中，可以单独使用Photo类。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">searches</span> <span class="o">=</span> <span class="n">OrderedDictionary</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="p">[</span><span class="n">Flickr</span><span class="p">.</span><span class="n">Photo</span><span class="p">]</span><span class="o">&gt;</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.然后实现tableView的委托和数据源协议。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">tableView</span><span class="p">(</span><span class="nl">tableView:</span> <span class="n">UITableView</span><span class="p">,</span> <span class="n">numberOfRowsInSection</span> <span class="nl">section:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">searches</span><span class="p">.</span><span class="n">count</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">func</span> <span class="n">tableView</span><span class="p">(</span><span class="nl">tableView:</span> <span class="n">UITableView</span><span class="p">,</span> <span class="n">cellForRowAtIndexPath</span> <span class="nl">indexPath:</span> <span class="n">NSIndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UITableViewCell</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">let</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">tableView</span><span class="p">.</span><span class="n">dequeueReusableCellWithIdentifier</span><span class="p">(</span><span class="s">&quot;Cell&quot;</span><span class="p">,</span> <span class="nl">forIndexPath:</span> <span class="n">indexPath</span><span class="p">)</span> <span class="n">as</span> <span class="n">UITableViewCell</span>
</span><span class='line'>  <span class="n">let</span> <span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">photos</span><span class="p">)</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">searches</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]</span>
</span><span class='line'>  <span class="n">cell</span><span class="p">.</span><span class="n">textLabel</span><span class="o">!</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">&quot;\(term) (\(photos.count))&quot;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">cell</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.然后是UISearchBarDelegate，这里调用Flickr的search方法是使用了Trailing Closures技术，即如果closure作为一个方法最后一个变量，那么可以写到所调用方法的外面（后面），如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">searchBarSearchButtonClicked</span><span class="p">(</span><span class="nl">searchBar:</span> <span class="n">UISearchBar</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">searchBar</span><span class="p">.</span><span class="n">resignFirstResponder</span><span class="p">()</span>
</span><span class='line'>  <span class="n">let</span> <span class="n">searchTerm</span> <span class="o">=</span> <span class="n">searchBar</span><span class="p">.</span><span class="n">text</span>
</span><span class='line'>  <span class="n">Flickr</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="n">searchTerm</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">switch</span> <span class="p">(</span><span class="n">$0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="nl">Error:</span>
</span><span class='line'>      <span class="k">break</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="n">Results</span><span class="p">(</span><span class="n">let</span> <span class="n">results</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="n">self</span><span class="p">.</span><span class="n">searches</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="nl">forKey:</span> <span class="n">searchTerm</span><span class="o">!</span><span class="p">,</span> <span class="nl">atIndex:</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">.</span><span class="n">reloadData</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">someFunctionThatTakesAClosure</span><span class="p">(</span><span class="nl">closure:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// function body goes here</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// here&#39;s how you call this function without using a trailing closure:</span>
</span><span class='line'><span class="n">someFunctionThatTakesAClosure</span><span class="p">({</span>
</span><span class='line'>    <span class="c1">// closure&#39;s body goes here</span>
</span><span class='line'><span class="p">})</span>
</span><span class='line'><span class="c1">// here&#39;s how you call this function with a trailing closure instead:</span>
</span><span class='line'><span class="n">someFunctionThatTakesAClosure</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// trailing closure&#39;s body goes here</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Show me the photos!</h3>

<p>1.这一节来完成详情页，先是在prepareForSegue方法中设置DetailViewController。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">override</span> <span class="n">func</span> <span class="nf">prepareForSegue</span><span class="p">(</span><span class="nl">segue:</span> <span class="n">UIStoryboardSegue</span><span class="p">,</span> <span class="nl">sender:</span> <span class="n">AnyObject</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">segue</span><span class="p">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="s">&quot;showDetail&quot;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">let</span> <span class="n">indexPath</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">.</span><span class="n">indexPathForSelectedRow</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">photos</span><span class="p">)</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">searches</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]</span>
</span><span class='line'>      <span class="p">(</span><span class="n">segue</span><span class="p">.</span><span class="n">destinationViewController</span> <span class="n">as</span><span class="o">!</span> <span class="n">DetailViewController</span><span class="p">).</span><span class="n">photos</span> <span class="o">=</span> <span class="n">photos</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Deleting searches</h3>

<p>1.为搜索页添加滑动删除功能。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">navigationItem</span><span class="p">.</span><span class="n">leftBarButtonItem</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">editButtonItem</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">override</span> <span class="n">func</span> <span class="nf">setEditing</span><span class="p">(</span><span class="nl">editing:</span> <span class="n">Bool</span><span class="p">,</span> <span class="nl">animated:</span> <span class="n">Bool</span><span class="p">)</span>  <span class="p">{</span>
</span><span class='line'>  <span class="n">super</span><span class="p">.</span><span class="n">setEditing</span><span class="p">(</span><span class="n">editing</span><span class="p">,</span> <span class="nl">animated:</span> <span class="n">animated</span><span class="p">)</span>
</span><span class='line'>  <span class="n">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">.</span><span class="n">setEditing</span><span class="p">(</span><span class="n">editing</span><span class="p">,</span> <span class="nl">animated:</span> <span class="n">animated</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">tableView</span><span class="p">(</span><span class="nl">tableView:</span> <span class="n">UITableView</span><span class="p">,</span> <span class="n">canEditRowAtIndexPath</span> <span class="nl">indexPath:</span> <span class="n">NSIndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">true</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="nl">tableView:</span> <span class="n">UITableView</span><span class="p">,</span> <span class="n">commitEditingStyle</span> <span class="nl">editingStyle:</span> <span class="n">UITableViewCellEditingStyle</span><span class="p">,</span> <span class="n">forRowAtIndexPath</span> <span class="nl">indexPath:</span> <span class="n">NSIndexPath</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">editingStyle</span> <span class="o">==</span> <span class="p">.</span><span class="n">Delete</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">searches</span><span class="p">.</span><span class="n">removeAtIndex</span><span class="p">(</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">)</span>
</span><span class='line'>    <span class="n">tableView</span><span class="p">.</span><span class="n">deleteRowsAtIndexPaths</span><span class="p">([</span><span class="n">indexPath</span><span class="p">],</span> <span class="nl">withRowAnimation:</span> <span class="p">.</span><span class="n">Fade</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Generic functions and protocols</h2>

<p>1.这一节介绍泛型的函数和协议，之前一直使用的find方法就是一个泛型方法，这是一个全局方法，泛型参数C定义了domain参数，也间接定义了value参数的类型，且返回值也和C有关：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">find</span><span class="o">&lt;</span><span class="nl">C:</span> <span class="n">Collection</span> <span class="n">where</span> <span class="n">C</span><span class="p">.</span><span class="n">GeneratorType</span><span class="p">.</span><span class="nl">Element:</span> <span class="n">Equatable</span><span class="o">&gt;</span> <span class="p">(</span><span class="nl">domain:</span> <span class="n">C</span><span class="p">,</span> <span class="nl">value:</span> <span class="n">C</span><span class="p">.</span><span class="n">GeneratorType</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">C</span><span class="p">.</span><span class="n">IndexType</span><span class="o">?</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.我们之前定义的有序字典的insert方法中这么使用了find()，没有指出C，其实这又是type interface的体现，通过第一个参数推断出了C的类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">existingIndex</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span><span class="o">!</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.那么GeneratorType是什么？上述的Collection协议，同时也遵从于SequenceType协议，如下，要实现该协议，必须有个typealias名为Generator，且遵从于GeneratorType协议，同时实现generate()方法返回Generator类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">protocol</span> <span class="n">SequenceType</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">typealias</span> <span class="n">Generator</span> <span class="o">:</span> <span class="n">GeneratorType</span>
</span><span class='line'>  <span class="n">public</span> <span class="n">func</span> <span class="n">generate</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">.</span><span class="n">Generator</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.那么在自定义的有序数组上实验下SeqenceType，首先定义typealias名为Generator，使用AnyGenerator这个泛型类。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">extension</span> <span class="nl">OrderedDictionary:</span> <span class="n">SequenceType</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">typealias</span> <span class="n">Generator</span> <span class="o">=</span> <span class="n">AnyGenerator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">KeyType</span><span class="p">,</span> <span class="n">ValueType</span><span class="p">)</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">generate</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">AnyGenerator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">KeyType</span><span class="p">,</span> <span class="n">ValueType</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">anyGenerator</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">count</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">!</span><span class="p">)</span>
</span><span class='line'>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.而在实现generate()方法中，通过调用了anyGenerator方法，该方法只有一个closure参数，所以使用了Trailing Closures技术，这个closure会在每次调用next()时调用，在closure中，你完成自己的遍历方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">public</span> <span class="n">func</span> <span class="n">anyGenerator</span><span class="o">&lt;</span><span class="n">Element</span><span class="o">&gt;</span><span class="p">(</span><span class="nl">body:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Element</span><span class="o">?</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyGenerator</span><span class="o">&lt;</span><span class="n">Element</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>6.实现了SequenceType Protocol，你可以使用for-in来遍历字典，其实typealias Generator = AnyGenerator&lt;(KeyType, ValueType)>这句可以删除，因为Swift从func generate() &ndash;> AnyGenerator&lt;(KeyType, ValueType)>()返回值推断出了该类型。<br/>
7.实际上SequenceType Protocol就是一个泛型协议，只不过因为protocol不能使用&lt;>关键字，而像Java和C#是可以的，原因也很简单，Protocols本身就是定义给class或struct实现的，这本身就是带有泛型的性质，Swift的思想就是protocol定义接口，而class和struct定义类型、泛型或其他。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Classes and Structs]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/12/swift-by-tutorials-classes-and-structs/"/>
    <updated>2015-10-12T15:26:48+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/12/swift-by-tutorials-classes-and-structs</id>
    <content type="html"><![CDATA[<p>继上两章对Swift的基本类型的学习，这一章开始介绍Swift中的Class和Struct，Class对所有面向对象的语言都不陌生，而Struct可能用的比较少，因为大部分用于C中，但Swift中的Struct与C还有很多不同，这章会一一介绍，而且同时会讲到Class与Struct之间的不同与使用场景，以及它们的扩展，也是这一章的重点。</p>

<!--more-->


<h2>Getting started</h2>

<h3>The class concept</h3>

<p>1.类是通过总结一些对象的共同特点，定义基本类型，通过继承来创建具体使用的子类型，它拥有自己的数据和方法，可以视为数据的容器。</p>

<h2>My first class</h2>

<p>1.介绍示例项目的Class设计。</p>

<h3>Creating the class</h3>

<p>1.import语句用于导入Swift的库文件，记性好的话，之前Apple在OC中加入了@import来替代#import（如：@import Foundation;替代#import &lt;Foundation/Foundation.h>），其实Swift中的import是和这个一致的。<br/>
2.定义一个类如下即可，但是如果如下，有未初始化赋值的非optional变量，那么会提示你增加初始化方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">class</span> <span class="n">Treasure</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">let</span> <span class="nl">what:</span> <span class="n">String</span>
</span><span class='line'>  <span class="n">let</span> <span class="nl">latitude:</span> <span class="n">Double</span>
</span><span class='line'>  <span class="n">let</span> <span class="nl">longitude:</span><span class="n">Double</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">init</span><span class="p">(</span><span class="nl">what:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">latitude:</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">longitude:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">self</span><span class="p">.</span><span class="n">what</span> <span class="o">=</span> <span class="n">waht</span>
</span><span class='line'>  <span class="n">self</span><span class="p">.</span><span class="n">latitude</span> <span class="o">=</span> <span class="n">latitude</span>
</span><span class='line'>  <span class="n">self</span><span class="p">.</span><span class="n">longitude</span> <span class="o">=</span> <span class="n">longitude</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>A struct-ural improvement</h3>

<p>1.下一步的优化是把经纬度信息做成一个结构体，那么就涉及到了Swift中的Struct，Swift中Struct和Class一样，都可以存储数据和拥有自己的方法，但要记住Struct始终是一个数值型的容器，它的用途只是持有数据，不要让它承担更多的功能。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">struct</span> <span class="n">GeoLocation</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">var</span> <span class="nl">latitude:</span> <span class="n">Double</span>
</span><span class='line'>  <span class="n">var</span> <span class="nl">longitude:</span> <span class="n">Double</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.在Swift中，在工程中的文件是相互自动import的，所以你不用再去手动导入，这一点在你开发library和framework也是一样的。</p>

<h3>Reference types vs. value types</h3>

<p>1.Swift中，Struct与Class的最大区别是，Class在本质上是指针引用类型，而Struct是值类型，在赋值过程中，Class传递的是指针，而Struct则会copy一份新值，从如下的例子即可看出。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">struct</span> <span class="n">MyStruct</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">var</span> <span class="nl">foo:</span> <span class="n">Double</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">class</span> <span class="n">MyClass</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">var</span> <span class="nl">foo:</span> <span class="n">Double</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="n">structA</span> <span class="o">=</span> <span class="n">MyStruct</span><span class="p">()</span>
</span><span class='line'><span class="n">var</span> <span class="n">structB</span> <span class="o">=</span> <span class="n">structA</span>
</span><span class='line'><span class="n">structB</span><span class="p">.</span><span class="n">foo</span> <span class="o">=</span> <span class="mf">1.0</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">structA</span><span class="p">.</span><span class="n">foo</span><span class="p">)</span>
</span><span class='line'><span class="c1">//0.0</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">structB</span><span class="p">.</span><span class="n">foo</span><span class="p">)</span>
</span><span class='line'><span class="c1">//1.0</span>
</span><span class='line'><span class="n">var</span> <span class="n">classA</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</span><span class='line'><span class="n">var</span> <span class="n">classB</span> <span class="o">=</span> <span class="n">classA</span>
</span><span class='line'><span class="n">classB</span><span class="p">.</span><span class="n">foo</span> <span class="o">=</span> <span class="mf">1.0</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">classA</span><span class="p">.</span><span class="n">foo</span><span class="p">)</span>
</span><span class='line'><span class="c1">//1.0</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">classB</span><span class="p">.</span><span class="n">foo</span><span class="p">)</span>
</span><span class='line'><span class="c1">//0.0</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.需要说明的一点，Swift在copy一个Struct时是很智能的，只会在确定必要的时候copy，也就是说structB = structA并不会创建出拷贝，只有你开始改变其中一个值时，runtime会开始执行copy。<br/>
3.另外关于let类型的Struct和Class还有一些细微的区别，对于二者的var实例，是没有区别的，都可以改变各自的属性或将自身赋值给其他实例，但对于let实例，Class依然可以修改自己的属性变量，但是不能将自己赋值给其他实例，而Struct既不能改变自己的属性变量，也不能将自己赋值给其他实例，这也是为什么Array和Dictionary是Struct而不是Class。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">struct</span> <span class="n">MyStruct</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">var</span> <span class="nl">foo:</span> <span class="n">Double</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">class</span> <span class="n">MyClass</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">var</span> <span class="nl">foo:</span> <span class="n">Double</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="n">classA</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</span><span class='line'><span class="n">let</span> <span class="n">classB</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</span><span class='line'><span class="n">classA</span><span class="p">.</span><span class="n">foo</span> <span class="o">=</span> <span class="mf">1.0</span>
</span><span class='line'><span class="n">classB</span><span class="p">.</span><span class="n">foo</span> <span class="o">=</span> <span class="mf">1.0</span>
</span><span class='line'><span class="n">classB</span> <span class="o">=</span> <span class="n">classA</span>
</span><span class='line'><span class="c1">//error</span>
</span><span class='line'><span class="n">var</span> <span class="n">structA</span> <span class="o">=</span> <span class="n">MyStruct</span><span class="p">()</span>
</span><span class='line'><span class="n">let</span> <span class="n">structB</span> <span class="o">=</span> <span class="n">MyStruct</span><span class="p">()</span>
</span><span class='line'><span class="n">structA</span><span class="p">.</span><span class="n">foo</span> <span class="o">=</span> <span class="mf">1.0</span>
</span><span class='line'><span class="n">structB</span><span class="p">.</span><span class="n">foo</span> <span class="o">=</span> <span class="mf">1.0</span>
</span><span class='line'><span class="c1">//error</span>
</span><span class='line'><span class="n">structB</span> <span class="o">=</span> <span class="n">structA</span>
</span><span class='line'><span class="c1">//error</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Convenience initializers</h3>

<p>1.在实例中其实还是不必要将GeoLocation暴露给使用者，可以直接给出更方便的初始化方法，这就用到了convenience initializer，在该初始化方法中跳转到了原初始化方法中，也称为designated initializer。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">convenience</span> <span class="nf">init</span><span class="p">(</span><span class="nl">what:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">latitude:</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">longitude:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">let</span> <span class="n">location</span> <span class="o">=</span> <span class="n">GeoLocation</span><span class="p">(</span><span class="nl">latitude:</span> <span class="n">latitude</span><span class="p">,</span> <span class="nl">longitude:</span> <span class="n">longitude</span><span class="p">)</span>
</span><span class='line'>  <span class="n">self</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="nl">what:</span> <span class="n">what</span><span class="p">,</span> <span class="nl">location:</span> <span class="n">location</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.Struct不需要显式的初始化方法，Swift为你自动添加了，你只需要按Struct的属性顺序一一初始化就行了，这也是为什么上述方法中可以自动初始化GeoLocation。</p>

<h3>Class inheritance</h3>

<p>1.Swift中的继承是怎样的？如下例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">class</span> <span class="nl">HistoryTreasure:</span> <span class="n">Treasure</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">let</span> <span class="nl">yaer:</span> <span class="n">Int</span>
</span><span class='line'>  <span class="n">init</span><span class="p">(</span><span class="nl">what:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">year:</span> <span class="n">Int</span><span class="p">,</span> <span class="nl">latitude:</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">longitude:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">self</span><span class="p">.</span><span class="n">year</span> <span class="o">=</span> <span class="n">year</span>
</span><span class='line'>      <span class="n">let</span> <span class="n">location</span> <span class="o">=</span> <span class="n">GeoLocation</span><span class="p">(</span><span class="nl">latitude:</span> <span class="n">latitude</span><span class="p">,</span> <span class="nl">longitude:</span> <span class="n">longitude</span><span class="p">)</span>
</span><span class='line'>      <span class="n">super</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="nl">what:</span> <span class="n">what</span><span class="p">,</span> <span class="nl">location:</span> <span class="n">location</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.子类如果有自己新的属性时，需要自己的designated initializer，而子类的designated initializer必须引用父类的一个designated initializer（注意不可以是convenience initializer），所以和上一节比较相当于做了重复工作。<br/>
3.这里有与OC不同的一点，在OC中子类的init()方法中，是先调用父类的init()，再进行子类属性的赋值，而在Swift中是最后调用父类的init()，因为在Swift中是initializer来初始化所有属性，最后交给父类来处理，父类的init()要放在最后，是因为它不知道子类中声明的新属性，必须在它之前把这些新属性初始化。</p>

<!--more-->


<h2>Swift and MapKit</h2>

<p>1.重写父类方法，Swift中需要在方法前加上override关键字，增加了可读性，同时如果你写的方法不存在于父类，那么编译器会报error通知你。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">override</span> <span class="n">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Class extensions and computed properties</h3>

<p>1.示例中需要将Treasure类型的变量显示在MKMapView上，那么就要使Treasure遵循MKAnnotation协议，我们使用了extension来实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">import</span> <span class="n">MapKit</span>
</span><span class='line'><span class="n">extension</span> <span class="nl">Treasure:</span> <span class="n">MKAnnotation</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">var</span> <span class="nl">coordinate:</span> <span class="n">CLLocationCoordinate2D</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">coordinate</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">var</span> <span class="nl">title:</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">what</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.extension类似OC的category，都是扩展类的技术，但是优于category，因为extension不但可以添加方法，还可以添加新属性。<br/>
3.这里添加的两个property有些特别，它们是Swift中的computed properties，每次访问它们都会执行后面的方法，用法与普通的properties是一致的。</p>

<h3>Your first struct extension</h3>

<p>1.Struct也可以添加extension，下例中的extension起到了分割代码，增加可读性的作用，这是extension的习惯用法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">import</span> <span class="n">MapKit</span>
</span><span class='line'><span class="n">extension</span> <span class="n">GeoLocation</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">var</span> <span class="nl">coordinate:</span> <span class="n">CLLocationCoordinate2D</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">CLLocationCoordinate2DMake</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">latitude</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">longitude</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">var</span> <span class="nl">mapPoint:</span> <span class="n">MKMapPoint</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">MKMapPointForCoordinate</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">coordinate</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Inheriting from NSObject</h3>

<p>1.类遵循MKAnnotation同时，也应该遵循NSObject协议，因为MKAnnotation继承自NSObject协议。</p>

<h3>Pinning the map</h3>

<p>1.在viewDidLoad()中添加以下代码，完成mapView上打点的工作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">mapView</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">mapView</span><span class="p">.</span><span class="n">addAnnotations</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">treasures</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.然后添加viewController的extension，并实现MKMapViewDelegate的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">extension</span> <span class="nl">ViewController:</span> <span class="n">MKMapViewDelegate</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">mapView</span><span class="p">(</span><span class="nl">mapView:</span> <span class="n">MKMapView</span><span class="p">,</span> <span class="n">viewForAnnotation</span> <span class="nl">annotation:</span> <span class="n">MKAnnotation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MKAnnotationView</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">let</span> <span class="n">treasure</span> <span class="o">=</span> <span class="n">annotation</span> <span class="n">as</span><span class="o">?</span> <span class="n">Treasure</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">var</span> <span class="n">view</span> <span class="o">=</span> <span class="n">mapView</span><span class="p">.</span><span class="n">dequeueReusableAnnotationViewWithIdentifier</span><span class="p">(</span><span class="s">&quot;pin&quot;</span><span class="p">)</span> <span class="n">as</span><span class="o">!</span> <span class="n">MKPinAnnotationView</span><span class="o">!</span>
</span><span class='line'>          <span class="k">if</span> <span class="n">view</span> <span class="o">=</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">view</span> <span class="o">=</span> <span class="n">MKPinAnnotationView</span><span class="p">(</span><span class="nl">annotation:</span> <span class="n">annotation</span><span class="p">,</span> <span class="nl">reuseIdentifier:</span> <span class="s">&quot;pin&quot;</span><span class="p">)</span>
</span><span class='line'>              <span class="n">view</span><span class="p">.</span><span class="n">canShowCallout</span> <span class="o">=</span> <span class="n">true</span>
</span><span class='line'>              <span class="n">view</span><span class="p">.</span><span class="n">animatesDrop</span> <span class="o">=</span> <span class="n">false</span>
</span><span class='line'>              <span class="n">view</span><span class="p">.</span><span class="n">calloutOffset</span> <span class="o">=</span> <span class="n">CGPoint</span><span class="p">(</span><span class="nl">x:</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="nl">y:</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'>              <span class="n">view</span><span class="p">.</span><span class="n">rightCalloutAccessoryView</span> <span class="o">=</span> <span class="n">UIButton</span><span class="p">(</span><span class="nl">type:</span> <span class="p">.</span><span class="n">DetailDisclosure</span><span class="p">)</span> <span class="n">as</span> <span class="n">UIView</span>
</span><span class='line'>          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">view</span><span class="p">.</span><span class="n">annotation</span> <span class="o">=</span> <span class="n">annotation</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>          <span class="k">return</span> <span class="n">view</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.在实现的mapView:viewForAnnotation方法中，annotation参数类型为MKAnnotation!，是一个隐式拆解的optional类型，但是我们还是进行了if/let的检查，因为这个方法是OC的API，是没有optional的，所以为了兼容Swift只能声明为这个类型，所以还需要显式拆解。<br/>
4.同时除了检查是否为nil，我们还要注意传入的类型是否为Treasure类型，这儿用到了inline downcasting技术，也是Swift的一种简写语法，if let treasure = annotation as？ Treasure{}，如果annotation不是Treasure类型，那么也不会进入if，这是Swift中确保类型正确的一种技术。<br/>
5.获取MKPinAnnotationView利用了一贯的复用技术，另外此处又一次用到了downcast技术，只不过因为返回的类型肯定可以确定都是MKPinAnnotationView，所以用了非optional版本。</p>

<h3>The reduce algorithm</h3>

<p>1.这一节是为了解决app载入后不能直接定位到目标位置，而要先定位自己的位置这个bug。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">rectToDisplay</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">treasures</span><span class="p">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">MKMapRectNull</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">(</span><span class="nl">mapRect:</span> <span class="n">MKMapRect</span><span class="p">,</span> <span class="nl">treasure:</span> <span class="n">Treasure</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MKMapRect</span> <span class="k">in</span>
</span><span class='line'>  <span class="n">let</span> <span class="n">treasurePointRect</span> <span class="o">=</span> <span class="n">MKMapRect</span><span class="p">(</span><span class="nl">origin:</span> <span class="n">treasure</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">mapPoint</span><span class="p">,</span> <span class="nl">size:</span> <span class="n">MKMapSize</span><span class="p">(</span><span class="nl">width:</span> <span class="mi">0</span><span class="p">,</span> <span class="nl">height:</span> <span class="mi">0</span><span class="p">))</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">MKMapRectUnion</span><span class="p">(</span><span class="n">mapRect</span><span class="p">,</span> <span class="n">treasurePointRect</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">mapView</span><span class="p">.</span><span class="n">setVisibleMapRect</span><span class="p">(</span><span class="n">rectToDisplay</span><span class="p">,</span> <span class="nl">edgePadding:</span> <span class="n">UIEdgeInsetsMake</span><span class="p">(</span><span class="mi">74</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="nl">animated:</span> <span class="n">false</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.为了达到这一优化，实际就是要获取可以展示全部treasures的最小地图范围，然后在地图绘制这一区域。而输入是一个数组，需要一个它们逐个计算的结果，这里使用了函数式编程中的Reduce函数，这是处理这一问题的最佳方案，下面是Swift中reduce的原型，需要一个初始值initial，这里对应的是MKMapRectNull，是一个空区域，然后combine的方法是(mapRect: MKMapRect, treasure: Treasure) &ndash;> MKMapRect类型的方法，mapRect是每次执行后的返回值，初始值就是initial，而treasure是array每个元素的遍历，最后可以得到一个MKMapRect类型的区域，包含了所有元素的最小区域，然后setVisibleMapRect()，并加了边距来适应其他页面元素，最终达到了目的，Swift中的函数式编程还会在第七章继续讲解。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">reduce</span><span class="p">(</span><span class="nl">initial:</span> <span class="n">U</span><span class="p">,</span> <span class="nl">combine:</span> <span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">U</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">U</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Polymorphism</h2>

<p>1.现在又有新需求了，需要不同类型的Treasure在地图上显示Annotation颜色不同，这可以通过多态来实现，首先在父类中添加方法，再在子类中重写该方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//in parent class</span>
</span><span class='line'><span class="n">func</span> <span class="n">pinColor</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">MKPinAnnotationColor</span>  <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">MKPinAnnotationColor</span><span class="p">.</span><span class="n">Red</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//in subclass</span>
</span><span class='line'><span class="n">override</span> <span class="n">func</span> <span class="n">pinColor</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">MKPinAnnotationColor</span>  <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">MKPinAnnotationColor</span><span class="p">.</span><span class="n">Purple</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.然后在绘制MKPinAnnotationView那儿调用该方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">view</span><span class="p">.</span><span class="n">pinColor</span> <span class="o">=</span> <span class="n">treasure</span><span class="p">.</span><span class="n">pinColor</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Dynamic dispatch and final classes</h3>

<p>1.对于上面的Treasure多态，runtime是怎么执行的呢？是靠dynamic dispatch实现的，这一技术其实在OC里用的很普遍，OC作为动态语言，可以在runtime修改所传递的消息，甚至消息的接收者，都是靠动态分发(详细过程可参照前一部的Effective Objective-C2.0的笔记)。<br/>
2.Dynamic dispatch在Swift中依然存在，就是为了实现多态这类特性，不同于OC的消息分发机制，Swift的分发更像C++，它通过virtual tables(简称vtables)来实现。<br/>
3.如上例，当编译器遇到pinColor()调用，因为Treasure有很多子类，它便会去使用vtable去查找，而如果是Treasure的子类调用pinColor()，编译器依然会去先去查找vtable，而不是直接去调用pinColor()方法，因为它并不知道有没有类继续在继承，虽然开发者知道它是没有子类的。<br/>
4.所以通过告知编译器某些类没有子类，会提高app的效率，缩短运行时间，我们可以通过在类型前加final关键字来告知编译器这一信息。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">final</span> <span class="n">class</span> <span class="nl">HistoryTreasure:</span> <span class="n">Treasure</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Adding annotations</h2>

<p>1.继续，新的需求是用户点击每个annotation时弹出一个alertView来告知用户一些信息。因为每个alert提示的信息不同，所以打算将生成alert的任务交给treasure，然后viewController负责显示，采用的是利用protocol技术。<br/>
2.首先在Treasure.swift文件中声明Alertable协议，然后Treasure的子类分别遵循并实现其中的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="err">@</span><span class="n">objc</span> <span class="n">protocol</span> <span class="n">Alertable</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">fun</span> <span class="n">alert</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">UIAlertController</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">extension</span> <span class="nl">HistoryTreasure:</span> <span class="n">Alertable</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">alert</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">UIAlertController</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">alert</span> <span class="o">=</span> <span class="n">UIAlertController</span><span class="p">(</span><span class="nl">title:</span> <span class="s">&quot;History&quot;</span><span class="p">,</span> <span class="nl">message:</span> <span class="s">&quot;From \(self.year):</span><span class="se">\n</span><span class="s">\(self.what)&quot;</span><span class="p">,</span> <span class="nl">preferredStyle:</span> <span class="n">UIAlertControllerStyle</span><span class="p">.</span><span class="n">Alert</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">alert</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.然后在viewController中实现MapView点击Annotation的委托方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="nf">mapView</span><span class="p">(</span><span class="nl">mapView:</span> <span class="n">MKMapView</span><span class="p">,</span> <span class="n">annotationView</span> <span class="nl">view:</span> <span class="n">MKAnnotationView</span><span class="p">,</span> <span class="n">calloutAccessoryControlTapped</span> <span class="nl">control:</span> <span class="n">UIControl</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">let</span> <span class="n">treasure</span> <span class="o">=</span> <span class="n">view</span><span class="p">.</span><span class="n">annotation</span> <span class="n">as</span><span class="o">?</span> <span class="n">Treasure</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">let</span> <span class="n">alertable</span> <span class="o">=</span> <span class="n">treasure</span> <span class="n">as</span><span class="o">?</span> <span class="n">Alertable</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">let</span> <span class="n">alert</span> <span class="o">=</span> <span class="n">alertable</span><span class="p">.</span><span class="n">alert</span><span class="p">()</span>
</span><span class='line'>      <span class="n">alert</span><span class="p">.</span><span class="n">addAction</span><span class="p">(</span><span class="n">UIAlertAction</span><span class="p">(</span><span class="nl">title:</span> <span class="s">&quot;OK&quot;</span><span class="p">,</span> <span class="nl">style:</span> <span class="n">UIAlertActionStyle</span><span class="p">.</span><span class="n">Default</span><span class="p">,</span> <span class="nl">handler:</span> <span class="nb">nil</span><span class="p">))</span>
</span><span class='line'>      <span class="n">self</span><span class="p">.</span><span class="n">presentViewController</span><span class="p">(</span><span class="n">alert</span><span class="p">,</span> <span class="nl">animated:</span> <span class="n">true</span><span class="p">,</span> <span class="nl">completion:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Sorting an array</h2>

<p>1.新需求，用户可以在找到第一个treasure后能有选项可以使其找到下一个最近的treasure。首先我们给GeoLocation添加一个计算点之间的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">distanceBetween</span><span class="p">(</span><span class="nl">other:</span> <span class="n">GeoLocation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Double</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">let</span> <span class="n">locationA</span> <span class="o">=</span> <span class="n">CLLocation</span><span class="p">(</span><span class="nl">latitude:</span> <span class="n">self</span><span class="p">.</span><span class="n">latitude</span><span class="p">,</span> <span class="nl">longitude:</span> <span class="n">self</span><span class="p">.</span><span class="n">longitude</span><span class="p">)</span>
</span><span class='line'>  <span class="n">let</span> <span class="n">locationB</span> <span class="o">=</span> <span class="n">CLLocation</span><span class="p">(</span><span class="nl">latitude:</span> <span class="n">other</span><span class="p">.</span><span class="n">latitude</span><span class="p">,</span> <span class="nl">longitude:</span> <span class="n">other</span><span class="p">.</span><span class="n">longitude</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">locationA</span><span class="p">.</span><span class="n">distanceFromLocation</span><span class="p">(</span><span class="n">locationB</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.该方法是直接定义在struct的定义中的，Swift中的Struct可以定义方法，这也是它与C的Struct的最大区别，C中的Struct只能定义变量，导致与之相关的方法只能定义为全局方法，而如何按照类型归纳这些方法就需要开发者手工将其写到一个头文件中，这显然费时也不合理，而Swift真正实现了Struct中可以真正拥有自己的方法。<br/>
3.像用户点击Annotation后弹出的alert再添加一个Find Nearest的选项，并实现找到离该点最近的Treasure。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">alert</span><span class="p">.</span><span class="n">addAction</span><span class="p">(</span><span class="n">UIAlertAction</span><span class="p">(</span><span class="nl">title:</span> <span class="s">&quot;Find Nearest&quot;</span><span class="p">,</span> <span class="nl">style:</span> <span class="n">UIAlertActionStyle</span><span class="p">.</span><span class="n">Default</span><span class="p">)</span> <span class="p">{</span> <span class="n">action</span> <span class="k">in</span>
</span><span class='line'>  <span class="n">var</span> <span class="n">sortedTreasures</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">treasures</span>
</span><span class='line'>  <span class="n">sortedTreasures</span><span class="p">.</span><span class="n">sortInPlace</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">distanceA</span> <span class="o">=</span> <span class="n">treasure</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">distanceBetween</span><span class="p">(</span><span class="n">$0</span><span class="p">.</span><span class="n">location</span><span class="p">)</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">distanceB</span> <span class="o">=</span> <span class="n">treasure</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">distanceBetween</span><span class="p">(</span><span class="n">$1</span><span class="p">.</span><span class="n">location</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">distanceA</span> <span class="o">&lt;</span> <span class="n">distanceB</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">mapView</span><span class="p">.</span><span class="n">deselectAnnotation</span><span class="p">(</span><span class="n">treasure</span><span class="p">,</span> <span class="nl">animated:</span> <span class="n">true</span><span class="p">)</span>
</span><span class='line'>  <span class="n">mapView</span><span class="p">.</span><span class="n">selectAnnotation</span><span class="p">(</span><span class="n">sortedTreasures</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nl">animated:</span> <span class="n">true</span><span class="p">)</span>
</span><span class='line'>  <span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.上述代码的核心是sortedTreasures的排序，利用了sort()方法(Swift中改为sortInPlace())，$1和$2分别代表了传入方法的第一和第二参数，是简写形式，分别计算出两点距离当前treasure的距离，然后返回Bool告知是否已按照小大顺序排好，最后数组排序后，展示第二个元素，来展示最近的treasure。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">public</span> <span class="n">mutating</span> <span class="n">func</span> <span class="n">sortInPlace</span><span class="p">(</span><span class="err">@</span><span class="n">noescape</span> <span class="nl">isOrderedBefore:</span> <span class="p">(</span><span class="n">Self</span><span class="p">.</span><span class="n">Generator</span><span class="p">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">Self</span><span class="p">.</span><span class="n">Generator</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Equality and operator overload</h2>

<p>1.照例，新需求，需要标记用户发现treasure的路径并在用户在已发现的treasure上操作时提示用户。<br/>
2.创建已找到Treasure的数组和要绘制的地图线，并实现MKMapViewDelegate的一个方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">private</span> <span class="n">var</span> <span class="nl">foundLocations:</span> <span class="p">[</span><span class="n">GeoLocation</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'><span class="n">private</span> <span class="n">var</span> <span class="nl">polyline:</span> <span class="n">MKPolyline</span><span class="o">!</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">func</span> <span class="n">mapView</span><span class="p">(</span><span class="nl">mapView:</span> <span class="n">MKMapView</span><span class="p">,</span> <span class="n">rendererForOverlay</span> <span class="nl">overlay:</span> <span class="n">MKOverlay</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MKOverlayRenderer</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">let</span> <span class="n">polylineOverlay</span> <span class="o">=</span> <span class="n">overlay</span> <span class="n">as</span><span class="o">?</span> <span class="n">MKPolyline</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">renderer</span> <span class="o">=</span> <span class="n">MKPolylineRenderer</span><span class="p">(</span><span class="nl">polyline:</span> <span class="n">polylineOverlay</span><span class="p">)</span>
</span><span class='line'>    <span class="n">renderer</span><span class="p">.</span><span class="n">strokeColor</span> <span class="o">=</span> <span class="n">UIColor</span><span class="p">.</span><span class="n">blueColor</span><span class="p">()</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">renderer</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.在上一节添加alert的位置再添加Found项，再创建markTreasureAsFound()方法来标记已找到的Treasure，并绘制新的MKPolyline。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">alert</span><span class="p">.</span><span class="n">addAction</span><span class="p">(</span><span class="n">UIAlertAction</span><span class="p">(</span><span class="nl">title:</span> <span class="s">&quot;Found&quot;</span><span class="p">,</span> <span class="nl">style:</span> <span class="n">UIAlertActionStyle</span><span class="p">.</span><span class="n">Default</span><span class="p">)</span> <span class="p">{</span> <span class="n">action</span> <span class="k">in</span>
</span><span class='line'>  <span class="n">self</span><span class="p">.</span><span class="n">markTreasureAsFound</span><span class="p">(</span><span class="n">treasure</span><span class="p">)</span>
</span><span class='line'>  <span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">private</span> <span class="n">func</span> <span class="nf">markTreasureAsFound</span><span class="p">(</span><span class="nl">treasure:</span> <span class="n">Treasure</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">let</span> <span class="n">index</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">foundLocations</span><span class="p">.</span><span class="n">indexOf</span><span class="p">(</span><span class="n">treasure</span><span class="p">.</span><span class="n">location</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">alert</span> <span class="o">=</span> <span class="n">UIAlertController</span><span class="p">(</span><span class="nl">title:</span> <span class="s">&quot;Oops!&quot;</span><span class="p">,</span> <span class="nl">message:</span> <span class="s">&quot;You&#39;ve already found this treasure (at step \(index + 1))! Try again!&quot;</span><span class="p">,</span> <span class="nl">preferredStyle:</span> <span class="p">.</span><span class="n">Alert</span><span class="p">)</span>
</span><span class='line'>    <span class="n">alert</span><span class="p">.</span><span class="n">addAction</span><span class="p">(</span><span class="n">UIAlertAction</span><span class="p">(</span><span class="nl">title:</span> <span class="s">&quot;OK&quot;</span><span class="p">,</span> <span class="nl">style:</span> <span class="p">.</span><span class="n">Default</span><span class="p">,</span> <span class="nl">handler:</span> <span class="nb">nil</span><span class="p">))</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">presentViewController</span><span class="p">(</span><span class="n">alert</span><span class="p">,</span> <span class="nl">animated:</span> <span class="n">true</span><span class="p">,</span> <span class="nl">completion:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">foundLocations</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">treasure</span><span class="p">.</span><span class="n">location</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">polyline</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">self</span><span class="p">.</span><span class="n">mapView</span><span class="p">.</span><span class="n">removeOverlay</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">polyline</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">coordinates</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">foundLocations</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">$0</span><span class="p">.</span><span class="n">coordinate</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">polyline</span> <span class="o">=</span> <span class="n">MKPolyline</span><span class="p">(</span><span class="nl">coordinates:</span> <span class="o">&amp;</span><span class="n">coordinates</span><span class="p">,</span> <span class="nl">count:</span> <span class="n">coordinates</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">mapView</span><span class="p">.</span><span class="n">addOverlay</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">polyline</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.首先利用find()函数（Swift2.0已弃用，改为collection的indexOf()方法）来获取目前位置是否已在foundLocations中，返回值为optional类型，所以需要if/let判断，这里就体现了这一技术的便利。<br/>
5.在创建MKPolyline时，先对foundLocations使用了map方法，map如前面提到的reduce一样，也是函数式编程的一种，它的作用是从一个数组中获取另外一个数组，这里就是从foundLocations得到了由其中每一个location的coordinate组成的新数组，$0代表每一个location。<br/>
6.这里需要实现find()方法（实际在Swift2.0已弃用），需要在GeoLocation中遵循Equatable协议，，因为find()中比较每个元素是通过==来比较的（类似OC中的isEqual()），而Class和Struc默认是不能用==比较的。这里用到了Swift的又一新特性，operator overload，既可以直接重写==这样的操作符，但需要注意下面对==的重写，并没有包含在extension中，因为operation overload都必须在定义在全局中，因为它本身并不属于某个类，它只是与一个类有关，基于要比较的的两个参数是这个类的实例。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">protocol</span> <span class="n">Equatable</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">func</span> <span class="o">==</span><span class="p">(</span><span class="nl">lhs:</span> <span class="n">Self</span><span class="p">,</span> <span class="nl">rhs:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">extension</span> <span class="nl">GeoLocation:</span> <span class="n">Equatable</span> <span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">func</span> <span class="o">==</span><span class="p">(</span><span class="nl">lhs:</span> <span class="n">GeoLocation</span><span class="p">,</span> <span class="nl">rhs:</span> <span class="n">GeoLocation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">latitude</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">latitude</span> <span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">.</span><span class="n">longitude</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">longitude</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Access Control</h2>

<p>1.目前为止所有变量和方法都是public的，但Swift提供了访问权限的关键字，包括：Public(所有代码均可访问)、Internal(只在该target(library或app)下的代码可以访问，是默认权限)、Private(只有该文件可以访问)。<br/>
2.例如有一些类中的帮助方法，你不希望暴露在外，因为他们可以改变着一些不该暴露的内部状态信息。<br/>
3.需要注意的是Unit test通常是另外一个Target，如果你的代码有部分需要单元测试，那么需要声明为public。<br/>
4.与OC相比，OC是没有绝对的私有方法的，因为即使没有暴露在在头文件中，也可以通过runtime注入来访问私有方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">private</span> <span class="n">func</span> <span class="n">markTreasureAsFound</span><span class="p">(</span><span class="nl">treasure:</span> <span class="n">Treasure</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">private</span> <span class="n">var</span> <span class="nl">treasures:</span> <span class="p">[</span><span class="n">Treasure</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'><span class="n">private</span> <span class="n">var</span> <span class="nl">foundLocations:</span> <span class="p">[</span><span class="n">GeoLocation</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'><span class="n">private</span> <span class="n">var</span> <span class="nl">polyline:</span> <span class="n">MKPolyline</span><span class="o">!</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.internal一般是不会显式声明的，如果是一个library被多个app使用，你可能会将内部类声明为internal，这样就不会被其他app中的代码使用了。<br/>
6.访问控制标志是表达你代码意图的很好的方式，可以使代码更易维护，也会减少Bug，</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Language Basics II]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/10/swift-by-tutorials-language-basics-ii/"/>
    <updated>2015-10-10T14:41:12+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/10/swift-by-tutorials-language-basics-ii</id>
    <content type="html"><![CDATA[<p>继上一篇后，本章将继续介绍Swift的基础知识，但是相比第一章会有所提升，包括了Optional类型对象的用法、Swift中的Collection类型用法以及与OC的Collection的不同之处。</p>

<!--more-->


<h2>Optionals</h2>

<p>1.空指针是一个困扰着各类语言的常见问题，在Java中，调用了空指针会直接抛出异常，在OC中向nil指针发送消息会返回nil，也就是说空指针是安全的，但有很多时候你并不希望指针为空，一般会加判断对象是否为nil的断言判断，但在Swift中，针对这个问题，有了新的解决方案。<br/>
2.Swift在对没有初始化赋值的变量使用时，会直接报错，而且像String类型也不能初始化直接赋nil值，这也保证了空指针不会出现。但是如果我们真的需要一个空值的变量怎么办呢？可以使用optional机制，它是用来指明一个变量是可能有值的，相当于给变量一个nil的默认值，这也是空指针的问题所在，它是一个合法的指针，但没有指向一个合法的对象。</p>

<h3>Declaring optionals</h3>

<p>1.使用optional很简单，如下，不赋值的话str默认为nil，在这里你可以把String?理解为一个不同于String的类型，所以能给String?直接赋值String类型实际上是Swift在内部进行了封装，Swift将String的值封装到了一个String?类型的实例中，然后再赋值给了str。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//no assignment</span>
</span><span class='line'><span class="n">var</span> <span class="nl">str:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'><span class="c1">//an assignment</span>
</span><span class='line'><span class="n">var</span> <span class="nl">str:</span> <span class="n">String</span><span class="o">?</span> <span class="o">=</span> <span class="s">&quot;Swift by Tutorials!&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.如果你现在对str使用uppercaseString方法，会报错，这也验证了上面所说String?已是另一个类型的说法，那么如何让str使用String的方法呢？如下即可，通过if语句对str进行解封，并将其赋值给一个let型的String，这就是optional和if在Swift中的经典配合，这么做的好处就是让开发者可以在必选确认指针不为空的时候强制去进行空指针的检查。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">unwrappedStr</span> <span class="o">=</span> <span class="n">str</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="s">&quot;Unwrapped! \(unwrappedStr.uppercaseString)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="s">&quot;Was nil&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Forced unwrapping</h3>

<p>1.在你了解optional机制下，在一些optional中你确定有值的时候，你可以使用强制解封，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="nl">str:</span> <span class="n">String</span><span class="o">?</span> <span class="o">=</span> <span class="s">&quot;Swift by Tutorials!&quot;</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;Force unwrapped! \(str!.uppercaseString)&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.但是需要注意的是，如果optional类型中的是nil值，那么会出现runtime error，所以使用强制解封，<strong>一定要在你100%确定你的optional对象不是空值</strong>。</p>

<h3>Implicit unwrapping</h3>

<p>1.你也可以不用!或者let来进行optional解封，使用以下方法，可以直接对变量使用方法，这看起来和没使用optional差不多，但是它在实质上和上述两种解封方法是一致的，只是语法不通而已，如果不去初始化赋值，那么你会得到和强制解封一个nil的optional的值一样的error。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="nl">str:</span> <span class="n">String</span><span class="o">!</span> <span class="o">=</span> <span class="s">&quot;Swift by Tutorials!&quot;</span>
</span><span class='line'><span class="n">str</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">lowercaseString</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.你也可以通过if来检查隐式解封的optional值，但你会发现这和OC中的做法一样，只不过在OC中你拿nil作为一个false的判断条件，而在Swift中你将nil作为一个无值的状态来判断。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">if</span> <span class="n">str</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">str</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">lowercaseString</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.<strong>最后注意，你要将隐式解封和强制解封一样重视，因为除了声明的地方，它和普通变量是一样的，这很容易忽视。</strong></p>

<h3>Optional chaining</h3>

<p>1.最后要介绍的是Optional chaining，这是上述三个解封方式之外的另一种optional来执行方法的方式，它的设计参照了OC中常用的delegate模式，即在optional类型变量执行方法时会先判断它是否为nil，不是nil的话直接执行，而如果是nil的话，则直接返回nil，其实和OC中对nil发送消息的处理是一样的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="nl">maybeString:</span> <span class="n">String</span><span class="o">?</span> <span class="o">=</span> <span class="s">&quot;Swift by Tutorials!&quot;</span>
</span><span class='line'><span class="n">let</span> <span class="n">uppercase</span> <span class="o">=</span> <span class="n">maybeString</span><span class="o">?</span><span class="p">.</span><span class="n">uppercaseString</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.由于在对象声明和方法执行时两次使用optional，所以形成了Optional chaining。</p>

<!--more-->


<h2>Collection</h2>

<p>1.任何语言都会有集合类型，OC中有NSArray、NSDictionary、NSSet，其中包含可变和不可变类型，而在Swift中只保留了Array和Dictionary两种类型。</p>

<h3>Arrays</h3>

<p>1.Swift的Array有着其他语言中共同的特性，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//initialize array</span>
</span><span class='line'><span class="n">var</span> <span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</span><span class='line'><span class="c1">//add an element</span>
</span><span class='line'><span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.Swift中你可以通过添加一个序列来扩展一个Array，比如上一节提到的Range。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//add 7,8,9,10</span>
</span><span class='line'><span class="c1">//Swift2.0中将extend()改为了appendContentsOf()</span>
</span><span class='line'><span class="c1">//array.extend(7...10)</span>
</span><span class='line'><span class="n">array</span><span class="p">.</span><span class="n">appendContentsOf</span><span class="p">(</span><span class="mf">7.</span><span class="p">.</span><span class="mf">.10</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.在上述数组中试图添加一个String，会直接报错，这在OC中可能是很正常的需求，可以在一个数组中添加不同类型的对象，但在Swift中只能在一个数组中添加同一类型的对象，在上面的Array初始化中是使用了type interface，如果制定类型声明的话应该是<em>var array: Array<Int> = [1, 2, 3, 4, 5]</em>（会在第四章详细说明），不过更常见的写法是<em>var arrray: [Int] = [1, 2, 3, 4, 5]</em>，这是Apple的语法糖，用来简化语法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//Array Initializer</span>
</span><span class='line'><span class="n">var</span> <span class="nl">array:</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span><span class='line'><span class="n">var</span> <span class="nl">arrray:</span> <span class="p">[</span><span class="n">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.当然也可以让Array像NSArray那样工作，可以将类型声明为Array<Any>，但是仍然不推荐这么做，因为这样Swift的很多Array方法会因为类型不一而不能使用，而且也会失去Swift的提供的安全性保护。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//add multiple type instance</span>
</span><span class='line'><span class="n">var</span> <span class="nl">array:</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Any</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'><span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</span><span class='line'><span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Swift By Tutorials!&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Dictionaries</h3>

<p>1.Swift的Dictionary与OC的NSDicionary大致相同，只是语法上略有变化，但需要注意的是，Dictionary也存在只能添加固定类型的键值对的情况，与上述的Array相同。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">dictionary</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">:</span> <span class="s">&quot;Dog&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span> <span class="s">&quot;Cat&quot;</span><span class="p">]</span>
</span><span class='line'><span class="c1">//Another Initializer</span>
</span><span class='line'><span class="c1">//var dictionary: Dictionary&lt;Int:String&gt; = [1: &quot;Dog&quot;, 2: &quot;Cat&quot;]</span>
</span><span class='line'><span class="c1">//var dictionary: [Int:String] = [1: &quot;Dog&quot;, 2: &quot;Cat&quot;]</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span><span class='line'><span class="n">dictionary</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Mouse&quot;</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">dictionary</span><span class="p">)</span>
</span><span class='line'><span class="n">dictionary</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">dictionary</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.从Dictionary中通过key直接获取值时，该值是optional类型的，因为有可能是不存在该key对应的值的，所以推荐读取Dictionary时还是使用上一章中介绍的安全拆解的方法，这又是Swift强制开发者随时考虑安全问题的一个表现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">value</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="s">&quot;Value is \(value)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Reference and copies</h3>

<p>1.这一节讨论Dictionary和Array在Swift中与OC所不同的内存管理策略，如下，从结果发现，Swift中将一个Dictionary直接赋值给另外的变量或常量，都是执行copy操作的，即改变新变量，并不会影响原来的Dictionary。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">dictionaryA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="o">:</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="o">:</span> <span class="mi">16</span><span class="p">]</span>
</span><span class='line'><span class="n">var</span> <span class="n">dictionaryB</span> <span class="o">=</span> <span class="n">dictionaryA</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">dictionaryA</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">dictionaryB</span><span class="p">)</span>
</span><span class='line'><span class="n">dictionaryB</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">dictionaryA</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">dictionaryB</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.那么关于Array呢？答案是一样的，Array也是会执行copy操作，这与OC中的NSDictionary和NSArray的指针赋值是完全不同的，所以单独强调一下。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">arrayA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span><span class='line'><span class="n">var</span> <span class="n">arrayB</span> <span class="o">=</span> <span class="n">arrayA</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">arrayA</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">arrayB</span><span class="p">)</span>
</span><span class='line'><span class="n">arrayB</span><span class="p">.</span><span class="n">removeAtIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">arrayA</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">arrayB</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Constant collection</h3>

<p>1.上面都是定义的var类型的Dictionary和Array，那么如果定义为let的话，Dictionary和Array是不能进行任何修改操作的（其实就是OC中的不可变类型）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">constantArray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span><span class='line'><span class="c1">//error</span>
</span><span class='line'><span class="n">constantArray</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</span><span class='line'><span class="n">constantArray</span><span class="p">.</span><span class="n">removeAtIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Language Basics I]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/08/swift-by-tutorials-language-basics-i/"/>
    <updated>2015-10-08T14:26:37+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/08/swift-by-tutorials-language-basics-i</id>
    <content type="html"><![CDATA[<p>Swift更新到2.0了，是时候来一波Swift的集中学习了，这次用的教材是raywenderlich出版的Swift by Tutorials，我手里的版本是2014年12月份的，可能有些在Swift2.0中发生了变化，我会尽量标注出来。开始第一章，介绍一些Swift的基本语法。</p>

<!--more-->


<h2>Variables,constants and strings</h2>

<p>1.Playground是Xcode新加入的一种文件，实际上就是一个可以自动编译的swift文件，可以用来测试一些简单的代码，也能显示一些资源文件，下面是申明一个string类型，可以直接在playground运行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="nl">greeting:</span> <span class="n">String</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span>
</span><span class='line'><span class="c1">//也可以不指名类型</span>
</span><span class='line'><span class="c1">//var greeting = &quot;Hello&quot;</span>
</span><span class='line'><span class="c1">//如对greeting赋值int型，会报错</span>
</span><span class='line'><span class="c1">//greeting = 9</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.string可以不声明类型，即可运行，是源于Swift的type interface的特性，即通过赋值自动确定变量的类型，但是之后再对其赋值整形，则会报错。因为Swift是静态输入语言，编译期间会进行类型检查。<strong>type interface是推荐使用的，可以使代码简洁，增加可读性</strong>。<br/>
3.Swift的string类型是可变的，而且改变方式不像NSMutableString那么复杂，直接使用+=方式即可。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span>
</span><span class='line'><span class="n">greeting</span> <span class="o">+=</span> <span class="s">&quot;World&quot;</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.如果想声明不可变String，只需添加let关键字即可。在Swift中，控制内建类型的可变性是通过添加let或var关键字来实现的，这不同于OC，需要两种类型来实现。<strong>你应该尽量使用不可变类型，这不仅使你的程序更加健壮，也会使编译器做更多优化，实际上let使用的场景是远远多于var的</strong>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.let关键字不仅限于Swift内建类型，自定义的结构体和类也可以使用，但有些细微不同，这将在第三章中详细讲到。<br/>
6.改变string也可以利用append()方法，这是Swift String自带的一些API，但是数量不多。幸运的是，Swift String与OC的NSString是可转换的，NSString的全部方法，String也可全部使用，但是还是推荐尽量使用String自带的API，比较简洁。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//Swift String API</span>
</span><span class='line'><span class="n">greeting</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Character</span><span class="p">(</span><span class="s">&quot;!&quot;</span><span class="p">))</span>
</span><span class='line'><span class="c1">//bridge to NSString</span>
</span><span class='line'><span class="c1">//logout Hello World</span>
</span><span class='line'><span class="n">import</span> <span class="n">Foundation</span>
</span><span class='line'>
</span><span class='line'><span class="n">var</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;hello world&quot;</span><span class="p">.</span><span class="n">capitalizedString</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span>
</span><span class='line'><span class="c1">//NSString style append</span>
</span><span class='line'><span class="n">import</span> <span class="n">Foundation</span>
</span><span class='line'>
</span><span class='line'><span class="n">var</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="p">.</span><span class="n">stringByAppendingString</span><span class="p">(</span><span class="s">&quot; world&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>7.Swift String是一个值类型，当它被赋值给变量、常量、或者作为参数传入方法时，它的值是被copy的，如下例，改变alternateGreeting不会影响greeting的值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">alternateGreeting</span> <span class="o">=</span> <span class="n">greeting</span>
</span><span class='line'><span class="n">alternateGreeting</span> <span class="o">+=</span> <span class="s">&quot; and beyond!&quot;</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">alternateGreeting</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Semicolons(分号)</h2>

<ol>
<li>Swift中分号只有在同一行中添加多条代码时才强制使用，其他情况可以省略不写，<strong>这又是Swift代码简洁的一大表现</strong>。</li>
</ol>


<!--more-->


<h2>Numeric types and conversion</h2>

<p>1.这一节主要讲Swift的数值类型，下面创建了两个变量，Int类型的radius和Double类型的pi，Swift还有很多其他类型，如Int8、UInt16、Float等。除非你有特殊需求，那么Int和Double类型是你的首选，这两个类型有广泛的使用，而且编译器会自动选择Int的最佳长度，32或64，基于机器的字长，来生成最高效的代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">radius</span> <span class="o">=</span> <span class="mi">4</span>
</span><span class='line'><span class="n">let</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.14159</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.在Swift中，你可以使用<strong>_</strong>来作为千分号，如下。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">milion</span> <span class="o">=</span> <span class="mi">1</span><span class="n">_000_000</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.以下代码会报错，是因为*无法直接将Int和Double相乘，而Swift中也不会隐式转化，需要开发者显式转化，需要注意这里并不是类型转化，而是新生成了一个Double类型，在第三章中会详细讲解初始化方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//error</span>
</span><span class='line'><span class="n">var</span> <span class="n">area</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">pi</span>
</span><span class='line'><span class="c1">//soluation</span>
</span><span class='line'><span class="n">var</span> <span class="n">area</span> <span class="o">=</span> <span class="n">Double</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">*</span> <span class="n">Double</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.显式转化变量是Swift的安全策略之一，另外一个是越界检查，下列代码在其他语言中可能会生成一个负数，而在Swift中会直接将其视为一个runtime error。同时，为了避免integer的越界计算error，Apple提供了&amp;+、&amp;-、&amp;*、&amp;/、&amp;%这些越界运算符，使用后会像常规计算一样，生成负数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">overflow</span> <span class="o">=</span> <span class="n">Int</span><span class="p">.</span><span class="n">max</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'><span class="c1">//overflow operators</span>
</span><span class='line'><span class="n">var</span> <span class="n">overflow</span> <span class="o">=</span> <span class="n">Int</span><span class="p">.</span><span class="n">max</span> <span class="o">&amp;+</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Booleans</h2>

<p>1.Swift的布尔类型为Bool，值为true或false，需要说明的一点是，作为Swift的安全特性之一，控制流中需要进行布尔判断的只能使用Bool类型，而不同于在OC中，可以将任意非零值作为判断条件，例如你不能在Swift中使用一个整数当做判断条件。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">alwaysTrue</span> <span class="o">=</span> <span class="n">true</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Tuples(元组)</h2>

<p>1.元组用来将多个值组成一个类型，但是不像类和结构体，你不需要显式的定义这个类型，如下，你可以通过索引来访问每个值，也可以通过索引来改变每个值（前提是你得元组的是可变的），而越界访问，编译器会报error。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="mi">742</span><span class="p">,</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">address</span><span class="mf">.0</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">address</span><span class="mf">.1</span><span class="p">)</span>
</span><span class='line'><span class="n">address</span><span class="mf">.0</span> <span class="o">=</span> <span class="mi">744</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.你也可以声明元组的类型，如下。如果想将元组的Int值类型改为Double有三种方式，同如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="nl">address:</span> <span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">742</span><span class="p">,</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">//change Int to Double</span>
</span><span class='line'><span class="c1">//1)using a type annotation</span>
</span><span class='line'><span class="n">var</span> <span class="nl">address1:</span> <span class="p">(</span><span class="n">Double</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">742</span><span class="p">,</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">//2)by explicit creation of a Double</span>
</span><span class='line'><span class="n">var</span> <span class="n">address2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Double</span><span class="p">(</span><span class="mi">742</span><span class="p">),</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">//3)by using a double literal value</span>
</span><span class='line'><span class="n">var</span> <span class="n">address3</span> <span class="o">=</span> <span class="p">(</span><span class="mf">742.0</span><span class="p">,</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.你也可以把元组解析成单个元素，而这也是一个copy操作，改变新值不会影响原始的元组值，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="mi">742</span><span class="p">,</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="p">(</span><span class="n">house</span><span class="p">,</span> <span class="n">street</span><span class="p">)</span> <span class="o">=</span> <span class="n">address</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">house</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">street</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.此外，你可以为元组的每个值加一个key，提高可读性，同时上述的访问方法依然有效。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="nl">number:</span> <span class="mi">742</span><span class="p">,</span> <span class="nl">street:</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">number</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">street</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.元组只是一个类型，也可以进行嵌套，元组作为其他元组的一个元素，类和结构体虽然包含了元组的所有功能，但是在一些轻量的场景下，元组可以更加快速简单地去构建一个复合类型。</p>

<!--more-->


<h2>String interpolation</h2>

<p>1.打印出一个类的信息，是常见的需求，例如OC中NSObject的description方法，如果我们想打印出上一节中元组的信息，我们可能这么做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="mi">742</span><span class="p">,</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="p">(</span><span class="n">house</span><span class="p">,</span> <span class="n">street</span><span class="p">)</span> <span class="o">=</span> <span class="n">address</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;I live at &quot;</span> <span class="o">+</span> <span class="n">String</span><span class="p">(</span><span class="n">house</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;, &quot;</span> <span class="o">+</span> <span class="n">street</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.这利用了Swift的+拼接字符串的技术，不过在Swift中有更加方便的字符串拼接技术来处理这一场景，string interpolation，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="mi">742</span><span class="p">,</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="p">(</span><span class="n">house</span><span class="p">,</span> <span class="n">street</span><span class="p">)</span> <span class="o">=</span> <span class="n">address</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;I live at \(house), \(street)&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.当然这不是打印日志专用的，在你需要从一系列变量中构建String时，都可使用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">import</span> <span class="n">Foundation</span>
</span><span class='line'>
</span><span class='line'><span class="n">var</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="mi">742</span><span class="p">,</span> <span class="s">&quot;Evergreen Terrace&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="p">(</span><span class="n">house</span><span class="p">,</span> <span class="n">street</span><span class="p">)</span> <span class="o">=</span> <span class="n">address</span>
</span><span class='line'><span class="n">let</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&quot;I live at \(house+10), \(street.uppercaseString)&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.最后，如果想只打印出\时，请用&#92;转义。</p>

<!--more-->


<h2>Control flow</h2>

<h3>For loops</h3>

<p>1.首先要介绍的Swift中的for循环的新特性是closed range operator，即闭区间运算符，例子如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;Swift by Tutorials!&quot;</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">.</span><span class="mf">.5</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="s">&quot;\(i) - \(greeting)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.注意，其中的i并不是一个var类型的变量，而是每次循环创建一个let的常量，是不可被赋值的。<br/>
3.1&hellip;5是一个Range类型，与for循环并无关系，下例说明了这一问题：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">range</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">.</span><span class="mf">.5</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">range</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="s">&quot;\(i) - \(greeting)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//what&#39;s 1..5?</span>
</span><span class='line'><span class="n">var</span> <span class="n">range</span> <span class="o">=</span> <span class="n">Range</span><span class="p">(</span><span class="nl">start:</span> <span class="mi">1</span><span class="p">,</span> <span class="nl">end:</span> <span class="mi">6</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.x&hellip;y只是Range类型的一个简化的语法糖，你可以用x..&lt;y来创建半开半闭的区间，最后一个值为y-1。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//means 1,2,3,4,5</span>
</span><span class='line'><span class="n">var</span> <span class="n">range1</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">.</span><span class="mf">.5</span>
</span><span class='line'><span class="c1">//means 1,2,3,4</span>
</span><span class='line'><span class="n">var</span> <span class="n">range2</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">.</span><span class="o">&lt;</span><span class="mi">5</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.那么还有个问题，for循环是怎么处理这个Range的？从而实现循环？其实是这样的，for循环可以处理很多可遍历的Swift类型，例如array、dictionary，还比如string也可以，所以range只是这些可遍历类型的其中之一而已。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="s">&quot;Swift&quot;</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>6.<strong>再挖的深一点，为什么String和Range一样可以被遍历？去看一下它们的定义就可以得知，它们都遵循了Sequence protocol，通过实现协议中的方法，就可以得到generator，继而循环请求其中的值，在第四章我们将自己创建类型来实现这一协议和利用generator。</strong></p>

<h3>While loops</h3>

<p>1.Swift同时支持while循环和do-while循环(<strong>Swift2.0将do-while改为了repeat-while</strong>)。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//while loop</span>
</span><span class='line'><span class="n">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;Swift by Tutorials!&quot;</span>
</span><span class='line'><span class="n">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="s">&quot;\(i) - \(greeting)&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">i</span><span class="o">++</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//repeat-while loop</span>
</span><span class='line'><span class="n">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;Swift by Tutorials!&quot;</span>
</span><span class='line'><span class="n">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="n">repeat</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="s">&quot;\(i) - \(greeting)&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">i</span><span class="o">++</span>
</span><span class='line'><span class="p">}</span> <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span>
</span></code></pre></td></tr></table></div></figure>


<h3>If statements</h3>

<p>1.Swift支持常规的if-else用法，需要注意的就是前面提到过的，if的条件必须是Bool类型，而且<strong>还有一点就是即使只有一条执行的语句，也要用{}，这是Swift和其他语言if的一个区别，不然会报错，这也是为了避免{}误用或少写导致的bug</strong>，此外，还有一个和if有关的关于optional value的技巧会在下一章讲到。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">import</span> <span class="n">Foundation</span>
</span><span class='line'>
</span><span class='line'><span class="n">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;Swift by Tutorials!&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">.</span><span class="mf">.5</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">5</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">.</span><span class="n">uppercaseString</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Switch statements</h3>

<p>1.Swift支持常规的switch语句，与OC不同的是，Swift的switch条件可以使任意类型，而OC只是原始类型，编译器来确保每个case的条件与switch条件类型一致。<br/>
2.第二点，Swift中的switch不需要在每个case后添加break，这是因为在Swift中，每个case执行完后，会自动跳出switch，所以不需要手动添加break，同时这也是安全策略之一。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">direction</span> <span class="o">=</span> <span class="s">&quot;up&quot;</span>
</span><span class='line'><span class="k">switch</span> <span class="n">direction</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="s">&quot;down&quot;</span><span class="o">:</span>
</span><span class='line'>      <span class="n">println</span><span class="p">(</span><span class="s">&quot;Going Down!&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="s">&quot;up&quot;</span><span class="o">:</span>
</span><span class='line'>      <span class="n">println</span><span class="p">(</span><span class="s">&quot;Going Up!&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>      <span class="n">println</span><span class="p">(</span><span class="s">&quot;Going Nowhere&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.第三，Swift的switch相当智能，如果你提供的switch条件的可能值没有在case中被全部覆盖，会提示你添加default，如上例的String类型，不然会报error；而如果你的case覆盖了switch条件的所有值，如enum类型，那么不添加default也不会报错。<br/>
4.如何在switch在一个case中匹配多个值，参照下例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">direction</span> <span class="o">=</span> <span class="s">&quot;up&quot;</span>
</span><span class='line'><span class="k">switch</span> <span class="n">direction</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="s">&quot;down&quot;</span><span class="p">,</span> <span class="s">&quot;up&quot;</span><span class="o">:</span>
</span><span class='line'>      <span class="n">println</span><span class="p">(</span><span class="s">&quot;Going Somewhere!&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>      <span class="n">println</span><span class="p">(</span><span class="s">&quot;Going Nowhere&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.可以利用上一节介绍的Range来实现case的区间匹配：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">var</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">570</span>
</span><span class='line'>
</span><span class='line'><span class="k">switch</span> <span class="n">score</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="mf">1.</span><span class="p">.</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;novice&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="mf">10.</span><span class="p">.</span><span class="o">&lt;</span><span class="mi">100</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;proficient&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="mf">100.</span><span class="p">.</span><span class="o">&lt;</span><span class="mi">1000</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;rock-star&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;awesome&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>6.另外switch与元组的结合，可以创造出更加复杂的场景处理：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">somePoint</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="k">switch</span> <span class="n">somePoint</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;(0, 0) is at the origin&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(somePoint.0), 0) is on the x-axis&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;(0,\(somePoint.1)) is on the y-axis&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.</span><span class="p">.</span><span class="mf">.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">.</span><span class="mf">.2</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(somePoint.0), \(somePoint.1)) is inside the box&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(somePoint.0), \(somePoint.1)) is outside the box&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>7.利用value binding技术，可以在判断期间将tuple的元素赋值给let变量（当然也可以声明为var类型，且它的作用范围只存在该case中）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">anotherPoint</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="k">switch</span> <span class="n">anotherPoint</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">(</span><span class="n">let</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;on the x-axis with an x value of \(x)&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">let</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;on the y-axis with an y value of \(y)&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;somewhere else at (\(x), \(y))&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>8.switch可以添加where语句，为每个case添加额外的判断条件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">let</span> <span class="n">yetAnotherPoint</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="k">switch</span> <span class="n">yetAnotherPoint</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="n">where</span> <span class="n">x</span> <span class="o">==</span> <span class="nl">y:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(x), \(y)) is on the line x == y&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="n">where</span> <span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="nl">y:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(x), \(y)) is on the line x == -y&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">let</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(x), \(y)) is just some arbitrary point&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记7]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/09/16/effective-objective-cdu-shu-bi-ji-7/"/>
    <updated>2015-09-16T15:42:34+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/09/16/effective-objective-cdu-shu-bi-ji-7</id>
    <content type="html"><![CDATA[<p>这是本书的最后一章了，集中讲解了有关Cocoa自带的system framework，这是开发中必须要使用的基本库，没有这些封装，很多基本的功能都无法实现，没有集合，也没有基类NSObject，可谓寸步难行，一些新的Api有时会节省我们很多工作量，同时这些库中的很多设计也是我们自己的代码需要学习的。</p>

<!--more-->


<h2>Item47 Familiarize Yourself with the System Frameworks</h2>

<ol>
<li>一个framework是将代码打包成一个动态库，会有头文件来描述接口，有时候也会有一些第三方的静态库（即.a文件），这些不能作为真正意义上的框架，但是被常常当做框架来用，所有的系统框架都使用了动态库。</li>
<li>Cocoa或Cocoa Touch是框架集，其中的基本框架就是Foundation框架，Foundation Framework不但提供了基本类型和基本集合，而且还有很多复杂功能，比如字符串处理。</li>
<li>除了另一个基础库是CoreFoundation，几乎就是Foundation的镜像库，只不过内部都是C接口和结构体，OC提供了一个名为toll-free bridging的转换特性，可以使OC对象和CF对象自由转化，toll-free bridging自身比较复杂，所以不建议自己去实现这一转化功能。除了上述两个基础框架，还有以下一些常用框架：</li>
<li>CFNetwork：基于C的网络请求基本框架，基于BSD socket提供了很多易用的请求工具，Foundation通过对它的部分封装，提供了OC类型的网络接口。</li>
<li>CoreAudio：提供了基于C的音频设备访问接口，本身是很复杂的，但OC的抽象将其变得易用不少。</li>
<li>AVFoundation：提供了用于播放和录制音视频的OC对象，例如播放视频的UI类。</li>
<li>CoreData：提供了用于数据持久化的OC对象，CoreData处理数据的存取，并能在Mac OS X与iOS之间通用。</li>
<li>CoreText：提供了基于C的文字高效的类型设置和渲染的接口。</li>
<li>使用一些C类型的框架，有时是必要的，因为通过绕过runtime，速度会更快，但是需要更加关注内存管理。</li>
<li>AppKit和UIKit分别是Mac OS X 和iOS的UI框架，提供了基于Foundation和CoreFoundation的OC类型，在它的下面是CoreAnimation和CoreGraphics在支持。</li>
<li>CoreAnimation基于OC类型，提供了渲染图像和展示动画的工具，它不是一个独立的框架，还是QuartzCore框架的一部分，但是很多情况CoreAnimation还是被优先使用。</li>
<li>CoreGraphics是基于C类型的，提供了用于2D渲染的必不可少的结构体和函数，CGPoint，CGSize，CGRect都是在这儿定义的。</li>
<li>UIKit的上层还有很多更高级的框架，例如：MapKit，Social framework。</li>
</ol>


<!--more-->


<h2>Item48 Prefer Block Enumeration to for Loops</h2>

<p>1.遍历一个集合类型是常见需求，，而OC也有很多方式，从标准的C的for循环，到OC 1.0的NSEnumerator，到OC 2.0的快速遍历，block加入OC后，又出现了遍历直接传入block进行对象处理的新方法。<br/>
2.For Loops：沿用最原始的C语言的循环，定义一个int型index，然后按照index去遍历每个对象，对于NSArray来说影响还不大，但是对于NSDictionary，NSSet来说，因为都是无序的，所以必须额外生成中间数组，这是额外的内存消耗，但倒序遍历只需要改变index为递减即可，还算方便。<br/>
3.OC 1.0 NSEnumerator：NSEnumerator是一个基类，需要重写-(NSArray*)allObjects,&ndash;(id)nextObject两个方法，而Foundation框架的集合类型都支持了NSEnumerator，可以通过不断执行nextObject()来完成遍历，它的优势是所有的集合类型的遍历方式都是类似的，而且也支持不同的enumerator来实现不同顺序来遍历，缺点是还是需要额外的enumerator，而且不能得知当前的index。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//NSArray enumerator</span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">anArray</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="n">NSEnumerator</span> <span class="o">*</span><span class="n">enumerator</span> <span class="o">=</span> <span class="p">[</span><span class="n">anArray</span> <span class="n">objectEnumerator</span><span class="p">];</span>
</span><span class='line'><span class="kt">id</span> <span class="n">object</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">((</span><span class="n">object</span> <span class="o">=</span> <span class="p">[</span><span class="n">enumerator</span> <span class="n">nextObject</span><span class="p">])</span><span class="o">!=</span><span class="nb">nil</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">//Do something with &#39;object&#39;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//NSDictionary enumerator</span>
</span><span class='line'><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">aDictionary</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="kt">id</span> <span class="n">key</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">((</span><span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">enumerator</span> <span class="n">nextObject</span><span class="p">])</span><span class="o">!=</span><span class="nb">nil</span><span class="p">){</span>
</span><span class='line'>  <span class="kt">id</span> <span class="n">value</span> <span class="o">=</span> <span class="n">aDictionary</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
</span><span class='line'>  <span class="c1">//Do something with &#39;key&#39; and &#39;value&#39;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//NSArray reverse enumerator</span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">anArray</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="n">NSEnumerator</span> <span class="o">*</span><span class="n">enumerator</span> <span class="o">=</span> <span class="p">[</span><span class="n">anArray</span> <span class="n">reverseObjectEnumerator</span><span class="p">];</span>
</span><span class='line'><span class="kt">id</span> <span class="n">object</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">((</span><span class="n">object</span> <span class="o">=</span> <span class="p">[</span><span class="n">enumerator</span> <span class="n">nextObject</span><span class="p">])</span><span class="o">!=</span><span class="nb">nil</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">//Do something with &#39;object&#39;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.Fast Enumeration：OC2.0引入了快速遍历，快速遍历详单与结合了for-loop和enumerator的双重特点，同时极大的简化了语法。实现这一技术是采用了NSFastEnumeration这一协议（只有一个方法），集合类型通过遵循这一协议，从而支持了快速遍历，实现协议中的方法使得类可以同时返回多个对象：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//NSFastEnumeration</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">countByEnumeratingWithState:</span><span class="p">(</span><span class="n">NSFastEnumerationState</span><span class="o">*</span><span class="p">)</span><span class="nv">state</span> <span class="nf">objects:</span><span class="p">(</span><span class="kt">id</span><span class="o">*</span><span class="p">)</span><span class="nv">stackbuffer</span> <span class="nf">count:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">length</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//NSArray</span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">anArray</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span> <span class="k">in</span> <span class="n">anArray</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">//Do something with &#39;object&#39;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//NSDictionary</span>
</span><span class='line'><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">aDictionary</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">id</span> <span class="n">key</span> <span class="k">in</span> <span class="n">aDictionary</span><span class="p">){</span>
</span><span class='line'>  <span class="kt">id</span> <span class="n">value</span> <span class="o">=</span> <span class="n">aDictionary</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
</span><span class='line'>  <span class="c1">//Do something with &#39;key&#39; and value</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果需要反向遍历，可以通过下列方法，因为NSEnumerator也实现了NSFastEnumeration：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">anArray</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span> <span class="k">in</span> <span class="p">[</span><span class="n">anArray</span> <span class="n">reverseObjectEnumerator</span><span class="p">]){</span>
</span><span class='line'>  <span class="c1">//Do something with &#39;object&#39;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>快速遍历的优点是效率很高，而且代码简洁，但是依然有两个缺陷，NSDictionary如果同时需要key和value的话，还是需要两步；同时index也是无法直接获取。</p>

<p>5.Block-Based Enumeration：是在OC引入block后的遍历集合的最新方法，下面是NSArray的基本block遍历方法，前两个参数很明显，第三个参数是用来停止遍历的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//NSArray</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">enumerateObjectsUsingBlock:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span><span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span><span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span>
</span><span class='line'><span class="c1">//NSDictionary</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">enumerateLeysAndObjectsUsingBlock:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">id</span> <span class="n">key</span><span class="p">,</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span><span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span>
</span><span class='line'><span class="c1">//example</span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">aArray</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">aArray</span> <span class="nl">enumerateObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span><span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span><span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">//Do something with &#39;object&#39;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">shouldStop</span><span class="p">){</span>
</span><span class='line'>      <span class="o">*</span><span class="n">stop</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>block遍历虽然看起来语法比快速遍历更复杂了，但是代码还是很整洁的，而且提供了方便的停止遍历的方法，而在其他方式中需要自己添加break，另外你可以现在一次性获得所有的信息，包括：NSArray的index，NSDictionary的key和value。</p>

<p>如果NSDictionary的键值类型是确定的，那么你可以重写block中的id类型，也可以在类型出现异常时抛出警告，所以如果类型确定，还是推荐这么写的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">aDictionary</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">aDictionary</span> <span class="nl">enumerateKeysAndObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span><span class="n">NSString</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span><span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">//Do Something with &#39;key&#39; and &#39;obj&#39;</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>除了这些，还有个最大的特点是，block遍历可以通过设置option（枚举类型）来实现各种各样的遍历方式，例如通过NSEnumerationConcurrent实现对集合中的对象并发执行方法（内部应该是利用了GCD的dispatch group），通过NSEnumerationReverse实现集合的逆向遍历，而且也可以通过位与操作，同时实现这两个option。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//NSArray</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">enumerateObjectsWithOptions:</span><span class="p">(</span><span class="n">NSEnumerationOptions</span><span class="p">)</span><span class="nv">options</span> <span class="nf">usingBlock:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span><span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span><span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span>
</span><span class='line'><span class="c1">//NSDictionary</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">enumerateLeysAndObjectsWithOptions:</span><span class="p">(</span><span class="n">NSEnumerationOptions</span><span class="p">)</span><span class="nv">options</span> <span class="nf">usingBlock:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">id</span> <span class="n">key</span><span class="p">,</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span><span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>综上，block遍历虽然语法不及快速遍历简洁，但是对于NSArray获得index，对于NSDictionary获得key和value这些信息，通过option获得并发执行遍历，都是优于其他遍历方法的。</p>

<!--more-->


<h2>Item49 Using Toll-Free Bridging for Collections with Custom Memory-Management Semantics</h2>

<p>1.Toll-Free Bridging是OC用来在Foundation定义的OC对象和CoreFoundation定义的对应的C结构体之间相互转化，使用了<strong>bridge关键字，相当于ARC依然持有OC对象，如果使用了</strong>bridge_retained，那么ARC就要交出持有权，那么在我们使用完CF指针后要执行CFRelease(aCFArray)来释放内存，反之你需要将CF指针转化为OC对象，并需要转移持有权时，要加上__bridge_transfer关键字，这三个关键字非常重要。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">anNSArray</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="err">@</span><span class="mi">1</span><span class="p">,</span><span class="err">@</span><span class="mi">2</span><span class="p">,</span><span class="err">@</span><span class="mi">3</span><span class="p">,</span><span class="err">@</span><span class="mi">4</span><span class="p">,</span><span class="err">@</span><span class="mi">5</span><span class="p">];</span>
</span><span class='line'><span class="n">CFArrayRef</span> <span class="n">aCFArray</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">CFArrayRef</span><span class="p">)</span><span class="n">anNSArray</span><span class="p">;</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Size of array = %li&quot;</span><span class="p">,</span> <span class="n">CFArrayGetCount</span><span class="p">(</span><span class="n">aCFArray</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.为什么要去使用CF结构体指针？当然绝大部分情况我们是不会刻意去使用的，作者列举了一个特殊的场景：NSDictionary的key是copy类型，而value是retain类型，也就意味着，不支持copy协议的类是不能作为NSDictionary的key的，如果我们需要一个value和key都是retain类型的dictionary，那要怎么办呢？<br/>
3.作者列举了一种思路，重新构建一个CF的字典类型，因为在这一级，我们可以控制key和value的回调类型，然后再通过Toll-Free Bridging来转化为需要的NSMutableDictionary，从而达到目的。</p>

<!--more-->


<h2>Item50 Use NSCache Instead of NSDictionary for Caches</h2>

<p>1.在网络请求中做缓存是常见的需求，因为一般会将data和url或者request对象做成键值对存储，所以一些年轻的程序员就会考虑用NSDictionary来做缓存，但是作者建议用NSCache来做这类缓存。<br/>
2.NSCache的优势之一是，当系统资源吃紧时，cache会被自动释放，且会优先释放最近未被使用的缓存，如果NSDictionary想实现这一点，是需要做很多额外工作的。<br/>
3.NSCache的优势之二是，NSDictionary的key是copy类型，而value是retain类型，而NSCache的key和value都是retain类型，这就意味着，NSCache可以将不实现copy协议的对象作为key，虽然根据Item49的做法，也可以把NSDictionary做成这种类型，但是实现起来很复杂。另外，NSCache是线程安全的，你可以在多个线程同时插值，在做缓存时，在主线程读取缓存，然后缓存不存在，在后台线程下载并赋值是常见的场景。<br/>
4.你可以手动控制缓存的容量，通过设置缓存数量和大小来控制，如果缓存数量或大小超过限制，也会开始自动释放，但释放的顺序是不可控的，所以想通过改变最大容量来让缓存按照顺序释放是不现实的。<br/>
5.需要注意的是，设置缓存大小容量，是基于加入缓存的对象的大小易于计算，如果计算对象大小成本过高的话，这就会影响效率，因为每次加入都会进行计算。例如去硬盘计算文件大小或去数据库查找大小就是耗时的操作，但如果是NSData作为缓存对象，那么获取它的大小代价就很小，只是读取一个property而已。<br/>
6.下面是一个使用NSCache的实例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@implementation</span> <span class="nc">EOCClass</span><span class="p">{</span>
</span><span class='line'>  <span class="n">NSCache</span> <span class="o">*</span><span class="n">_cache</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">init</span><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">((</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">])){</span>
</span><span class='line'>      <span class="n">_cache</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSCache</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'>      <span class="n">_cache</span><span class="p">.</span><span class="n">countLimit</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span><span class='line'>      <span class="n">_cache</span><span class="p">.</span><span class="n">totalCostLimit</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">downloadDataForURL:</span><span class="p">(</span><span class="n">NSURL</span><span class="o">*</span><span class="p">)</span><span class="n">url</span><span class="p">{</span>
</span><span class='line'>  <span class="n">NSData</span> <span class="o">*</span><span class="n">cachedData</span> <span class="o">=</span> <span class="p">[</span><span class="n">_cache</span> <span class="nl">objectForKey:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">cacheData</span><span class="p">){</span>
</span><span class='line'>      <span class="c1">//Cache hit</span>
</span><span class='line'>      <span class="p">[</span><span class="n">self</span> <span class="nl">useData:</span><span class="n">cachedData</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">//Cache miss</span>
</span><span class='line'>      <span class="n">EOCNetworkFetcher</span> <span class="o">*</span><span class="n">fetcher</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EOCNetworkFetcher</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithURL:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'>      <span class="p">[</span><span class="n">fetcher</span> <span class="nl">startWithCompletionHandler:</span><span class="o">^</span><span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span>
</span><span class='line'>          <span class="p">[</span><span class="n">_cache</span> <span class="nl">setObject:</span><span class="n">data</span> <span class="nl">forKey:</span><span class="n">url</span> <span class="nl">cost:</span><span class="n">data</span><span class="p">.</span><span class="n">length</span><span class="p">];</span>
</span><span class='line'>          <span class="p">[</span><span class="n">self</span> <span class="nl">useData:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>7.除了NSData，另一种可以和NSCache搭配的是NSPurgeableData，它是NSMutableData的子类，实现了NSDiscardableContent协议，NSPurgeableData的内存会在系统资源紧张时自动释放，<em>isContentDiscard</em>是协议中的一个方法，返回内存是否已释放。<br/>
8.NSPurgeableData在使用之前要用<em>beginContentAccess</em>确保目前内存不被释放，然后使用完后调用<em>endContentAccess</em>告知系统可以被释放，这一对操作可以嵌套，类似retain/release。<br/>
9.如果NSPurgeableData添加到NSCache，释放的对象会自动移出cache，这可以被<em>evictsObjectsWithDiscardedContent</em>这一property关闭或开启。<br/>
10.下面是一个NSPurgeableData的实例，注意NSPurgeableData被创建时就相当于+1purge reference count与alloc类似，所以不必再加<em>beginContentAccess</em>，但用完要加<em>endContentAccess</em>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">downloadDataForURL:</span><span class="p">(</span><span class="n">NSURL</span><span class="o">*</span><span class="p">)</span><span class="nv">url</span><span class="p">{</span>
</span><span class='line'>  <span class="n">NSPurgeableData</span> <span class="o">*</span><span class="n">cacheData</span> <span class="o">=</span> <span class="p">[</span><span class="n">_cache</span> <span class="nl">objectForKey:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">cachedData</span><span class="p">){</span>
</span><span class='line'>      <span class="c1">//Stop the data being purged</span>
</span><span class='line'>      <span class="p">[</span><span class="n">cacheData</span> <span class="n">beginContentAccess</span><span class="p">];</span>
</span><span class='line'>      <span class="c1">//Use the cached data</span>
</span><span class='line'>      <span class="p">[</span><span class="n">self</span> <span class="nl">useData:</span><span class="n">cachedData</span><span class="p">];</span>
</span><span class='line'>      <span class="c1">//Mark that the data may be purged again</span>
</span><span class='line'>      <span class="p">[</span><span class="n">cacheData</span> <span class="n">endContentAccess</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">//Cache miss</span>
</span><span class='line'>      <span class="n">EOCNetworkFetcher</span> <span class="o">*</span><span class="n">fetcher</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EOCNetworkFetcher</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithURL:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'>      <span class="p">[</span><span class="n">fetcher</span> <span class="nl">startWithCompletionHandler:</span><span class="o">^</span><span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span>
</span><span class='line'>          <span class="n">NSPurgeableData</span> <span class="o">*</span><span class="n">purgeableData</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSPurgeableData</span> <span class="nl">dataWithData:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>          <span class="p">[</span><span class="n">_cache</span> <span class="nl">setObject:</span><span class="n">purgeableData</span> <span class="nl">forKey:</span><span class="n">url</span> <span class="nl">cost:</span><span class="n">purgeableData</span><span class="p">.</span><span class="n">length</span><span class="p">];</span>
</span><span class='line'>          <span class="c1">//Don&#39;t need to beginContentAccess as it begins with access already marked</span>
</span><span class='line'>          <span class="p">[</span><span class="n">self</span> <span class="nl">useData:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>          <span class="c1">//Mark that the data may be purged now</span>
</span><span class='line'>          <span class="p">[</span><span class="n">purgeable</span> <span class="n">endContentAccess</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Item51 Keep initialize and load Implementations Lean</h2>

<ol>
<li>一个类总会有有自己的初始化方法，由于OC中类型大部分继承于NSObject，所有有很多继承于NSObject的初始化方法，第一个就是<em>*(void)load</em>方法。</li>
<li><em>load</em>方法在每个class和category中会且只会被调用一次，这个方法发生在包含该类的library在加载后，一般是应用加载中，而且只是iOS代码的独有的，Mac OS X有更灵活的dynamic loading，可以使library在应用加载后加载，而category的load在其原class加载后加载。</li>
<li>想重写<em>load</em>方法的问题是，它运行时runtime处于不稳定的状态，所有父类的<em>load</em>方法是先于其他类的<em>load</em>调用的，所依赖库中的所有<em>load</em>方法会先调用。但在一个库中，这些类的<em>load</em>方法的调用顺序就是不可控的了。</li>
<li>作者举例：EOCClassB中实现了<em>load</em>方法，它导入了Foundation.h和EOCClassA.h头文件，而EOCClassA和它同属一个库，EOCClassB在其<em>load</em>方法中使用了NSLog输出NSString，也实例化了EOCClassA并进行了操作。那么NSLog和NSString的使用是没问题的，因为Foundation.h中的class肯定先于EOCClassB的<em>load</em>方法，但使用EOCClassA就有问题了，你不能保证EOCClassA的<em>load</em>是否已经在EOCClassB的<em>load</em>方法之前调用了，因为有可能EOCClassA在<em>load</em>之前是不可用的。</li>
<li><em>load</em>方法并不遵循于一般的继承规则，一个类没有实现<em>load</em>的话，是不会调用该方法的，即使它的父类实现了；<em>load</em>方法可同时存在于类和它的category中，且category的<em>load</em>会在本类的<em>load</em>之后调用。</li>
<li>所以综上，<em>load</em>方法并不适合我们自己做初始化工作，因为我们不能确保所有的类型都已经加载，所以实际上它的用途最好仅停留在测试层面，因为如果在<em>load</em>中加载过多任务，也会影响应用的加载时间，是很影响用户体验的。</li>
<li>第二个初始化方法是<em>+(void)initialize</em>方法，它也是会且只会被调用一次，它是被runtime调用的，而不能被直接调用，它与<em>load</em>有相似的地方，也有很多不同，概括有三点。</li>
<li>区别一是<em>initialize</em>是懒加载，只有一个类被第一次用到之前才会调用，因此会出现一个类的<em>initialize</em>永远没被调用过的情况，这也意味着不像<em>load</em>会出现所有的<em>load</em>方法在同一时间加载，而且会阻塞应用加载。</li>
<li>区别二是<em>initialize</em>在执行时，runtime是稳定状态，调用其他类的方法是安全的，而且runtime保证了<em>initialize</em>的线程安全，意味着只有执行<em>initialize</em>的线程可以和class和其实例交互，其他线程将会被阻塞，知道<em>initialize</em>完成。</li>
<li>区别三是<em>initialize</em>与其他消息一样，如果类的<em>initialize</em>没实现，但是父类实现了，那么父类的<em>initialize</em>会被调用。</li>
<li>作者举例父类实现了<em>initialize</em>，但是子类没有实现，但在log中会看到该方法被调用了两次，原因是使用一个类时，其父类的<em>initialize</em>会先调用，然后到子类时，由于没有实现该方法，所以继续沿响应链得知父类实现了该方法，所以又执行一次，为了避免这一问题，在<em>initialize</em>中加上<em>if(self == [EOCBaseClass class])</em>的判断就好了。</li>
<li>虽然<em>initialize</em>比<em>load</em>灵活一些了，但是作者依然不推荐在<em>initialize</em>中做很复杂的初始化工作，原因也有三。</li>
<li>原因一，一个类的<em>initialize</em>可能在任意线程，如果它发生在UI线程，而且<em>initialize</em>做了很多工作的话，可能导致主线程阻塞。预测哪个线程会先使用一个类是不可靠的，所以强制一个固定线程去触发类的<em>initialize</em>方法是不现实的。</li>
<li>原因二，你不能控制一个类什么时候<em>initialize</em>，它是确定会在一个类被第一次使用之前调用，但是假设它会在某个固定时间执行是不可靠的，runtime可能会有所更新，导致细微改变类的初始化方式，那么你对类已经初始化完毕的设想可能是错误的。</li>
<li>原因三，比较特殊，就是两个或多个类之间的初始化方法中出现了内部数据的相互调用，可能会出现，一个类需要另一个类初始化完毕，但是第二个类还依赖于第一个类的初始化完毕，造成了两个类之间的相互等待，和循环引用有一定程度的类似。</li>
<li>综上，<em>initialize</em>中并不适合做大量的工作，尤其是调用其他类或自己的方法，如果自己的方法必须依赖自己已经初始化完毕，那么也会出现上述问题，所以<em>initialize</em>的正确用法是去初始化那些，无法在编译期间赋值的全局静态变量和全局变量，比如static NSMutableArray *kSomeObjects，因为这些OC对象必须等到runtime激活后才能使用。</li>
<li>所以始终保持<em>initialize</em>和<em>load</em>方法简洁是一个好习惯，能避免大量的奇葩问题。</li>
</ol>


<!--more-->


<h2>Item52 Remember that NSTimer Retains Its Target</h2>

<p>1.NSTimer是一个常用的类，用来定时执行一些方法，或循环执行一些方法，它是需要和一个run loop关联的，你既可以在当前run loop预设置，也可以自己创建NSTimer对象自行设置。<br/>
2.NSTimer预设置的方法需要传入target和selector，timer会retain target，而会在timer失效时release它，一个timer可以通过直接调用invalidate（一般是循环的）或者启动后（一般是一次性的）就会失效。<br/>
3.因为timer会retain target，所以在循环执行时特别容易出现循环引用，如下，startPolling后，便会出现EOCClass和timer相互引用的结果，目前想解决这一问题，只能通过要求调用方自行调用stopPolling，但如果这时一个对外使用的类的话，这是不可控的；而寄希望于dealloc去解开这一循环，是不现实的，因为对于循环引用的两个对象，是不会出现一方先释放的。而且如果这一引用存在，会一直循环去执行这个任务，带来的问题不光是内存泄露。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'> <span class="err">#</span><span class="n">import</span> <span class="o">&lt;</span><span class="n">Foundation</span><span class="o">/</span><span class="n">Foundation</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">EOCClass</span>:<span class="nc">NSObject</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">startPolling</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">stopPolling</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">EOCClass</span><span class="p">{</span>
</span><span class='line'>  <span class="n">NSTimer</span> <span class="o">*</span><span class="n">_pollTimer</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">init</span><span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dealloc</span><span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="n">_pollTimer</span> <span class="n">invalidate</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">stopPolling</span><span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="n">_pollTimer</span> <span class="n">invalidate</span><span class="p">];</span>
</span><span class='line'>  <span class="n">_pollTimer</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">startPolling</span><span class="p">{</span>
</span><span class='line'>  <span class="n">_pollTimer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nl">scheduledTimerWithTimeInterval:</span><span class="mf">5.0</span> <span class="nl">target:</span><span class="n">self</span> <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="n">p_doPoll</span><span class="p">)</span> <span class="nl">userInfo:</span><span class="nb">nil</span> <span class="nl">repeats:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">p_doPoll</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//Poll the resource</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.那么要想解决这个问题，又不依赖外部，一个方案是做一个NSTimer的block分类，如下，block被设置为userInfo参数，timer也会对它retain，block要进行一次copy，从stack移到heap上，这在Item37说过，现在的target变成了NSTimer这个类本身，因为NSTimer作为一个类对象，是一个单例，所以不用担心释放问题，虽然也存在循环引用，但是没关系。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'> <span class="err">#</span><span class="n">import</span> <span class="o">&lt;</span><span class="n">Foundation</span><span class="o">/</span><span class="n">Foundation</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">NSTimer</span><span class="nl">(EOCBlockSupport)</span>
</span><span class='line'><span class="k">+</span><span class="p">(</span><span class="n">NSTimer</span><span class="o">*</span><span class="p">)</span><span class="nf">eoc_scheduledTimerWithTimeInterval:</span><span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">interval</span> <span class="nf">block:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">block</span> <span class="nf">repeats:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">repeats</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">NSTimer</span><span class="nl">(EOCBlockSupport)</span>
</span><span class='line'><span class="k">+</span><span class="p">(</span><span class="n">NSTimer</span><span class="o">*</span><span class="p">)</span><span class="nf">eoc_scheduledTimerWithTimeInterval:</span><span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">interval</span> <span class="nf">block:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">block</span> <span class="nf">repeats:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">repeats</span><span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="nl">scheduledTimerWithTimeInterval:</span><span class="n">interval</span> <span class="nl">target:</span><span class="n">self</span> <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">eoc_blockInvoke:</span><span class="p">)</span> <span class="nl">userInfo:</span><span class="p">[</span><span class="n">block</span> <span class="n">copy</span><span class="p">]</span> <span class="nl">repeats:</span><span class="n">repeats</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">+</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">eoc_blockInvoke:</span><span class="p">(</span><span class="n">NSTimer</span><span class="o">*</span><span class="p">)</span><span class="nv">timer</span><span class="p">{</span>
</span><span class='line'>  <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)()</span><span class="o">=</span><span class="n">timer</span><span class="p">.</span><span class="n">userInfo</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">block</span><span class="p">){</span>
</span><span class='line'>      <span class="n">block</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.回到新方法的使用，像下面这样直接调用的话，还是会导致循环引用，因为block会retain self，而timer会在userInfo处retain block，而timer本身被self引用，所以正确的做法是做一个self的weak变量，在block中再声明一个strong的临时变量，确保block retain一个weak对象，而在block内部又不会提前释放掉，这也是解决block retain cycle的常见策略。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//wrong</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">startPolling</span><span class="p">{</span>
</span><span class='line'>  <span class="n">_polTimer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nl">eoc_scheduledTimerWithTimeInterval:</span><span class="mf">5.0</span> <span class="nl">block:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="p">[</span><span class="n">self</span> <span class="n">p_doPoll</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nl">repeats:</span><span class="n">YES</span>
</span><span class='line'>  <span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//right</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">startPolling</span><span class="p">{</span>
</span><span class='line'>  <span class="n">__weak</span> <span class="n">__typeof</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="n">weakSelf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'>  <span class="n">_polTimer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nl">eoc_scheduledTimerWithTimeInterval:</span><span class="mf">5.0</span> <span class="nl">block:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">__strong</span> <span class="n">__typeof</span><span class="p">(</span><span class="n">weakSelf</span><span class="p">)</span><span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>
</span><span class='line'>      <span class="p">[</span><span class="n">strongSelf</span> <span class="n">p_doPoll</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nl">repeats:</span><span class="n">YES</span>
</span><span class='line'>  <span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记6]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/09/09/effective-objective-cdu-shu-bi-ji-6/"/>
    <updated>2015-09-09T16:29:01+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/09/09/effective-objective-cdu-shu-bi-ji-6</id>
    <content type="html"><![CDATA[<p>第六章的主要内容是Blocks和GCD，这可以说是Morden OC当中的三驾马车的其余两架，它们和ARC的出现，彻底改变了OC的开发模式。多线程是现代编程中任何语言都不可或缺的技术，在iOS中阻塞UI主线程往往是应用崩溃或用户体验差的重要原因，多线程就是解决这一问题的良方，而Blocks和GCD就是Apple给开发者带来的多线程解决方案。Blocks即OC中的闭包，它可以被当做一个对象，可以运行于其他上下文中。GCD基于dispatch queues提供了对线程的抽象，它会根据系统资源自动开辟、复用、销毁后台线程，同时GCD也对一些常见编程提供了简化方案，比如：创建单例、并发任务等等。</p>

<!--more-->


<h2>Item37 Understand Blocks</h2>

<p>1.Blocks作为了GCC的拓展，也存在于Clang的所有版本中。Blocks的runtime component在Mac OS X 10.4和iOS4被加入。由于是C级别的语言特性，所以可以被用于C,C++,OC当中。</p>

<h3>Block Basics</h3>

<p>1.Blcoks的类型写法类似函数指针，也可以直接当做函数来执行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">int</span><span class="p">(</span><span class="o">^</span><span class="n">addBlcok</span><span class="p">)(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kt">int</span> <span class="n">add</span> <span class="o">=</span> <span class="n">addBlcok</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span><span class="c1">//&lt;add=7</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.Blocks最重要的特性，它可以将它包含的所有内容进行复制，也就意味着范围内的任何变量都可以使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">int</span> <span class="n">additional</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span><span class="p">(</span><span class="o">^</span><span class="n">addBlcok</span><span class="p">)(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">additional</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kt">int</span> <span class="n">add</span> <span class="o">=</span> <span class="n">addBlcok</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span><span class="c1">//&lt;add=12</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.默认Blocks是不能改变外部变量的，但是可以通过添加__blcok关键字，来声明变量可以改变。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="err">@</span><span class="mi">0</span><span class="p">,</span><span class="err">@</span><span class="mi">1</span><span class="p">,</span><span class="err">@</span><span class="mi">2</span><span class="p">,</span><span class="err">@</span><span class="mi">3</span><span class="p">,</span><span class="err">@</span><span class="mi">4</span><span class="p">,</span><span class="err">@</span><span class="mi">5</span><span class="p">];</span>
</span><span class='line'><span class="n">__blcok</span> <span class="n">NSInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">array</span> <span class="nl">enumerateObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSNumber</span> <span class="o">*</span><span class="n">number</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">){</span>
</span><span class='line'>  <span class="k">if</span><span class="p">([</span><span class="n">number</span> <span class="nl">compare:</span><span class="err">@</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">NSOrderedAscending</span><span class="p">){</span>
</span><span class='line'>      <span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'><span class="c1">//count = 2</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.上例也说明了Block作为内联参数的使用，这也是它的重要用法，取代了之前传selector name这样的方式，增加了代码可读性。<br/>
5.Block内部引用的变量会被隐性添加retain，然后在block release时再调用一次release，所以blcok可以被理解为一个一般的OC对象，它也是有retain count的。<br/>
6.那么在一个类中的实例方法中声明使用block，然后在block中使用了类的实例变量，那么其实是对self进行了一次retain，如果这时这个block被self的变量再retain一次，那么就会形成循环引用，解决方法在Item40会详细说，其实就是声明一个self的__weak替代对象就好了。</p>

<h3>The Guts of Block</h3>

<ol>
<li>Block的实质，除了包含通常的isa（block的Class为void*），flags等，block的三个主要组成为：invoke、descriptor、Captured variables。</li>
<li>invoke是一个函数指针，类型为void(<em>)(void </em>,&hellip;)，至少包含的void *其实就是block自身，因为block的Captured variables包含了所有据有变量的copy，invoke指向的就是block的实现部分，所以也证明了block实质上就是Apple对函数指针的一次高级封装，便于开发者使用。</li>
<li>descriptor指向一个结构体，包含了：size（blcok总大小），copy和dispose（都是函数指针，copy在blcok被拷贝时执行，dispose在block retain或release据有的对象时执行）。</li>
<li>Captured variables就是block据有的所有变量的copy，注意这里的copy是指针拷贝。</li>
</ol>


<h3>Global，Stack，and Heap Blocks</h3>

<p>1.Block声明的时候是存在于stack上的，类似下面的代码是不安全的，因为if/else中声明的blcok是存在于stack上的，在if/else结束时，系统可能会收回这些内存重用，而且这个问题在编译中不会报出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">blcok</span><span class="p">)();</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="cm">/*some condition*/</span><span class="p">){</span>
</span><span class='line'>  <span class="n">blcok</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Block A&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">blcok</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Block B&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">block</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>2.解决这一问题的方法，就是对声明的block进行copy，这样的话，block被copy到了heap上，这样的block和其他一般对象就一样了，也不会出现上述问题，使用ARC的话，block会在之后自动释放，而MRC将要自己去添加release方法，这也是类在为block类型的property添加属性时，一般都是copy类型的。<br/>
3.所谓的global Block就是类似于之前说的NSString和NSNumber的常量声明，如果Block内部没有任何状态变化，也不依赖于外部的状态变化，在编译期间就可以知道其所需要的空间大小，系统就会对其做优化，生成一个global block，它是被声明在global memory上，而不是stack上，而且copy对于它也是一个空操作，也不会被释放，实际就是一个单例，类似：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)()</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;This is a global blcok!&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Item38 Create typedefs for Common Block Types</h2>

<p>1.由于Block的类型像函数指针一样，参数多的话会很长，而且类型名又在中间，很难使用和记住，所以我们可以使用C语言的typedef来做类型定义，这么做也方便将来可能的修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">typedef</span> <span class="nf">int</span><span class="p">(</span><span class="o">^</span><span class="n">EOCSomeBlock</span><span class="p">)(</span><span class="kt">BOOL</span> <span class="n">flag</span><span class="p">,</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'><span class="n">EOCSomeBlock</span> <span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">flag</span><span class="p">,</span><span class="kt">int</span> <span class="n">value</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">//Implementation</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.对block命名时还是要遵循OC的命名习惯，使用命名空间，也不要还害怕对相同类型使用多个命名，有时候这是必须的，一是命名更加清楚，二是方便将来重构。</p>

<!--more-->


<h2>Item39 Use Handler Blocks to Reduce Code Separation</h2>

<ol>
<li>异步多线程执行任务，之前一直是采用Delegate模式，但现在我们可以通过定义block作为handler来完成同样的任务，而且代码简洁，可读性强。</li>
<li>尤其出现一个类中同时使用多个同种类型的实例，采用一套回调时，那么使用Delegate则会大大增加代码的复杂度，会在很多地方出现switch的判断，而使用block则能避免这一问题。</li>
<li>作者列举了两个例子使用这一模式的场景，都是针对网络请求回调，一是，使用两个block分别处理失败和成功，二是使用一个block，使用error来判断失败和成功（这两种写法都在作者的AFNetworking里出现过）。</li>
<li>方案一的好处是，代码清晰，使用者只需对不同情况填空即可；方案二的好处是，可以更灵活的处理这一问题，如出现一些数据异常、下载中断这些情况，业务端也可以自行按失败来进行处理。</li>
<li>在设计API时，有时会出现，需要在特定线程执行代码的需求，这时我们可以在接口中加入(NSOperationQueue*)queue这样的参数，可以是缺省的。</li>
</ol>


<!--more-->


<h2>Item40 Avoid Retain Cycles Introduced by Blocks Referencing the Object Owning Them</h2>

<ol>
<li>block出现循环引用一般是因为ClassA使用了ClassB的实例，ClassB有block的实例，而ClassA在block中使用了自己的其他实例，造成了block retain了ClassA，ClassA retain了ClassB，ClassB retain了block，这样循环引用就形成了。</li>
<li>解决方案一是在block中完成所有操作时，将ClassB的实例置为nil，这样retain环就断裂了，但这么做也有问题，如果这段block代码没有被执行，那么retain环还存在。</li>
<li>还有一种更隐蔽的情况，ClassA不在把ClassB当做实例变量，只是用做局部变量，但在block中使用了ClassB的局部变量，这样会出现，block retain了ClassB，ClassB ratain了block，所以形成了二元retain环，不过解决很简单，在ClassB中完成对block的最终调用后，将它的block实例置为nil。</li>
<li>这样也凸显了不将block作为外部property的好处（使用者只能通过初始化方法赋值），如果block直接暴露给使用者，你只能要求使用者去清除block property，但这通常是不合理的设计。</li>
</ol>


<!--more-->


<h2>Item41 Prefer Dispatch Queues to Locks for Synchronization</h2>

<p>1.OC大部分线程操作都是默认多线程的，但如果有些情况需要单线程，就需要开发者自己实现，GCD之前有两种方式。<br/>
2.一是synchronization block，它将包含的代码进行加锁操作，参数是self，这可以实现类的不同实例可以分别运行这个方法，但缺点是如果过度使用，会导致性能问题，也会出现代码被不知名的锁所阻塞的问题。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">synchronizedMethod</span><span class="p">{</span>
</span><span class='line'>  <span class="k">@synchronized</span><span class="p">(</span><span class="n">self</span><span class="p">){</span>
</span><span class='line'>      <span class="c1">//Safe</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.二是NSLock，而且也有专门为递归设计的NSRecursiveLock，但是NSLock一个最大的问题是会出现死锁问题，所以二者都不是最佳方案。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">_lock</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSLock</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">synchronizedMethod</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="n">_lock</span> <span class="n">lock</span><span class="p">];</span>
</span><span class='line'>  <span class="c1">//Safe</span>
</span><span class='line'>  <span class="p">[</span><span class="n">_lock</span> <span class="n">unlock</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.那么对比使用atomic属性的property，Item6也说过，我们手动实现时，可以利用synchronization block来实现，但是问题就是当多个property这么做时，会出现propertys之间出现阻塞，而且在多次频繁访问一个property时，其他线程可能会对其修改，会造成返回值不同。<br/>
5.替代方案就是GCD的serial synchronization queue，它可以使读写property在一个队列中执行，也就避免了上述问题，代码更加简化，而且利用了GCD底层的优化，而且你不用担心对象之间的相互阻塞。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">_syncQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_creat</span><span class="p">(</span><span class="s">&quot;com.EOC.syncQueue&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nf">someString</span><span class="p">{</span>
</span><span class='line'>  <span class="n">__block</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">localSomeString</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">_syncQueue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">localSomeString</span> <span class="o">=</span> <span class="n">_someString</span><span class="p">;</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">localSomeString</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setSomeString:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">someString</span><span class="p">{</span>
</span><span class='line'>  <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">_syncQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">_someString</span> <span class="o">=</span> <span class="n">someString</span><span class="p">;</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>6.对于这一方案还有优化，优化一是可以将setter方法使用异步执行，因为setter方法不会有返回值，而且由于和getter还是在一个队列执行，还是能保持读取的同步，但是涉及到一个问题，异步需要将block copy到异步线程，那么如果block内容很简单，可能copy的时间和执行的时间差不多，也就达不到优化的效果，但是当block内容比较复杂时，这一手段还是有效地。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setSomeString:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">someString</span><span class="p">{</span>
</span><span class='line'>  <span class="n">dispatch_async</span><span class="p">(</span><span class="n">_syncQueue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">_someString</span> <span class="o">=</span> <span class="n">someString</span><span class="p">;</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>7.第二种优化想实现，可以同时并发执行多个getter，但同步执行setter，且它们还要在同一线程，这对于synchronization block或NSLock来说，都是极难实现的，但是我们利用GCD的特性dispatch_barrier_sync()可以轻松实现，getter可以并行执行，如果出现barrier的setter，那么线程会等之前的所有getter都执行完，然后单独执行setter，执行完之后照常并行执行getter操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">_syncQueue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nf">someString</span><span class="p">{</span>
</span><span class='line'>  <span class="n">__block</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">localSomeString</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">_syncQueue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">localSomeString</span> <span class="o">=</span> <span class="n">_someString</span><span class="p">;</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">localSomeString</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setSomeString:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">someString</span><span class="p">{</span>
</span><span class='line'>  <span class="n">dispatch_barrier_async</span><span class="p">(</span><span class="n">_syncQueue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">_someString</span> <span class="o">=</span> <span class="n">someString</span><span class="p">;</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Item42 Prefer GCD to performSelector and Friends</h2>

<ol>
<li>&ndash;(id)performSelector:(SEL)selector，曾作为延时执行方法和在特定线程执行方法这些场景中的主要手段，利用runtime，可以改变selector的名称，在运行时再决定执行那个方法，但使用这一方法是有风险的。</li>
<li>如果你使用if/else来决定赋值不同的selector，然后再执行，这样的话，ARC模式下会报内存泄露的警告，原因是编译器不知道那个方法会执行，所以也没办法确定有没有返回值，返回值是autoreleased还是caller自己释放，所以ARC会保守的添加autoreleased，如果这时返回值是caller自己释放的，那么就出现了内存泄露，这一警告MRC不会报出，但也更难发现，且静态分析器也检查不出，所以这是需要注意的一点。</li>
<li>&ndash;(id)performSelector:(SEL)selector以及它的族函数，它们的返回类型都是id类型，也就是说必须是一个指针，如果返回值是void、C结构体、或数值型，那么就有可能出问题，然后最多只能添加两个参数，而且也必须是id类型，超过两个参数或类型不对的也不能用，所以说局限性是非常大的。</li>
<li>&ndash;(id)performSelector:(SEL)selector的延时执行和在特定线程执行的族函数也是一样，缺陷很明显，只支持一个参数，所以使用者必选把所有参数打包，才能使用。</li>
<li>而结合使用Blocks和GCD，你可以实现上述所有的功能，且不会有约束，代码还简洁。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//Using dispatch_after</span>
</span><span class='line'><span class="n">dispatch_time_t</span> <span class="n">time</span> <span class="o">=</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,(</span><span class="n">INT64_t</span><span class="p">)(</span><span class="mf">5.0</span><span class="o">*</span><span class="n">NSEC_PER_SEC</span><span class="p">));</span>
</span><span class='line'><span class="n">dispatch_after</span><span class="p">(</span><span class="n">time</span><span class="p">,</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span><span class="o">^</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span><span class='line'>  <span class="p">[</span><span class="n">self</span> <span class="n">doSomething</span><span class="p">];</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="c1">//Using dispatch_async(or if waitUntileDone is YES,then dispatch_sync)</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="n">self</span> <span class="n">doSomething</span><span class="p">];</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Item43 Know When to Use GCD and When to Use Operation Queues</h2>

<ol>
<li>上面介绍了很多GCD的优点，GCD在的同步机制（Item41）和单例机制（Item45）是非常优秀的，但并不是说GCD就是所有OC线程问题的最优解，在它之前的NSOperationQueue有时更为合适。</li>
<li>GCD是C类型的Api，而operation queues则是OC对象；GCD中的任务是一个block，比较轻量，而operation queues中的任务是NSOperation的子类，比较重量；但这不意味着GCD一直是最优解，有时作为对象的优势也是非常明显的。</li>
<li>使用NSBlockOperation或NSOperationQueue的addOperationWithBlock:方法，可以使operation queues非常像GCD，下面是它的一些优势。</li>
</ol>


<h3>Cancelling operations</h3>

<ol>
<li>NSOperation很容易就可以实现cancel，执行它的cancel方法即可，但已经执行的operation就不能cancel了，但是对于GCD也一样，不能cancel一个已经在执行的block，这类机制就是“fire and forget”，但在GCD上实现cancel，需要自己去实现，而这需要很多工作。</li>
</ol>


<h3>Operation dependencies</h3>

<ol>
<li>operation可以实现依赖，这样开发者可以自己组织执行的优先顺序，例如下载一些文件之前需要先下载验证文件，下验证文件的operation就是其他下载operation的依赖，如果其他下载是并发的，那么它们会等下载完验证文件后再并发执行。</li>
</ol>


<h3>Key-Value Observing of operation properties</h3>

<ol>
<li>Operation的很多property是很适合KVO的，比如：<em>isCancelled，isFinished</em>去监测operation是否取消或完成，如果你的代码需要对operation做到如此细粒度的控制的话，那么更应该使用operation。</li>
</ol>


<h3>Operation priorities</h3>

<ol>
<li>operation可以设置优先级（即queuePriority，从verylow到veryhigh五个枚举值），高优先级的operation会先执行，GCD无法设置每个block的执行优先级，而只能设置整个queue的优先级，所以这也是operation的一大特性。另外，operation还有一个相关的线程优先级（即threadPriority，从0.0到1.0），可以指定operation执行时线程分配的优先级，我理解它和前者一个是时间上的优先级，一个是空间上的优先级，这两者均可通过operation的property直接设置。</li>
</ol>


<h3>Reuse of operation</h3>

<ol>
<li>除非你使用内建的NSOperation的子类，比如NSBlockOperation，你一般都需要自己继承NSOperation，所以这就意味着你可以添加实例和方法，和进行复用。</li>
<li>综上operation有这很多的优点，主要集中于你可以对单个operation进行更加细粒度的操作，而不用自己去组织相关代码，这是对比GCD的block的优势之处。</li>
<li>Apple的NSNotificationCenter有一个方法，如下，其中的NSOperationQueue可以换成dispatch queue的，但是开发者不想对GCD产生无谓的依赖，在这个实例中，两者是没什么区别的。总之，GCD和Operation queue都是视情况使用，而不是一味遵从使用高级接口或底层接口，各有好处。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">addObserverForName:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">object:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span> <span class="nf">queue:</span><span class="p">(</span><span class="n">NSOperationQueue</span><span class="o">*</span><span class="p">)</span><span class="nv">queue</span> <span class="nf">usingBlock:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSNotification</span><span class="o">*</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Item44 Use Dispatch Groups to Take Advantage of Platform Scaling</h2>

<p>1.Dispatch Groups是GCD的一个特性，为了方便开发者对任务进行分组，你可以等待一组任务完成或者通过回调来被通知一组任务完成了。当你想让一组方法并行执行，但同时希望在它们完成时得到通知，那么你该使用这一特性。例如批量压缩文件。<br/>
2.一个group是一个简单的结构体，也没有标识，下面是group的类型和将task和group关联的方法，其实只是在正常的dipatch执行方法上关联了group而已：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">dispatch_group_t</span> <span class="nf">dispatch_group_creat</span><span class="p">();</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">dispatch_group_async</span><span class="p">(</span><span class="n">dispatch_group_t</span> <span class="n">group</span><span class="p">,</span> <span class="n">dispatch_queue_t</span> <span class="n">queue</span><span class="p">,</span> <span class="n">dispatch_block_t</span> <span class="n">block</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.另一个方法是使用下面这对方法，enter和leave要配合使用，类似retain和release，必须保持平衡，如果缺少一个leave，那么这个group就永远不会结束了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span> <span class="nf">dispatch_group_enter</span><span class="p">(</span><span class="n">dispatch_group_t</span> <span class="n">group</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">dispatch_group_leave</span><span class="p">(</span><span class="n">dispatch_group_t</span> <span class="n">group</span><span class="p">);</span>
</span><span class='line'><span class="c1">//Example</span>
</span><span class='line'><span class="n">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="c1">//A</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="c1">//B</span>
</span><span class='line'><span class="n">dispatch_group_enter</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'>  <span class="n">dispatch_group_leave</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.下面的方法可以阻塞目前线程，等待group中的task全部完成，timeout可以设置为一个固定值，也可以设置为DISPATCH_TIME_FOREVER，如果group在timeout内完成，返回值为0，反之则会返回非0值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">long</span> <span class="nf">dispatch_group_wait</span><span class="p">(</span><span class="n">dispatch_group_t</span> <span class="n">group</span><span class="p">,</span> <span class="n">dispatch_time_t</span> <span class="n">timeout</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.这个方法则是wait方法的替代，该方法不会阻塞当前线程，而是允许你为group完成添加一个通知回调block，而且可以指定线程，一般在主线程中，肯定是不希望阻塞的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span> <span class="nf">dispatch_group_notify</span><span class="p">(</span><span class="n">dispatch_group_t</span> <span class="n">group</span><span class="p">,</span> <span class="n">dispatch_queue_t</span> <span class="n">queue</span><span class="p">,</span> <span class="n">dispatch_block_t</span> <span class="n">block</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>6.下面是一个对一个数组中的对象并发执行相同操作，并在全部完成后进行后续操作的实例，如果不希望阻塞主线程，那么要把wait换为notify，<a href="http://stackoverflow.com/questions/10643797/wait-until-multiple-networking-requests-have-all-executed-including-their-comp/10644282#comment13830651_10644282">StackOverflow另一实例</a>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
</span><span class='line'><span class="c1">//Plan A, block main queue</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span> <span class="k">in</span> <span class="n">collection</span><span class="p">){</span>
</span><span class='line'>  <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="p">[</span><span class="n">object</span> <span class="n">performTask</span><span class="p">];</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">dispatch_group_wait</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">DISPATCH_TIME_FOREVER</span><span class="p">);</span>
</span><span class='line'><span class="c1">//Continue processing after copleting tasks</span>
</span><span class='line'><span class="n">dispatch_release</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
</span><span class='line'><span class="c1">//Plan B, not block main queue</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span> <span class="k">in</span> <span class="n">collection</span><span class="p">){</span>
</span><span class='line'>  <span class="n">dispatch_group_enter</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
</span><span class='line'>  <span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="p">[</span><span class="n">object</span> <span class="n">performTask</span><span class="p">];</span>
</span><span class='line'>      <span class="n">dispatch_group_leave</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">notifyQueue</span> <span class="o">=</span> <span class="n">dispatch_get_main_queue</span><span class="p">();</span>
</span><span class='line'><span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">notifyQueue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//Continue processing after completing tasks</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>7.可以通过创建不同优先级的dispatch_queue，来实现task进行优先级分类，但是依然并发执行，并在全部完成后统一处理。<br/>
8.如果你在一个串行的queue中加入多个任务，那么group其实是不起作用的，因为本来这些任务就会串行执行，你只需要继续添加一个block，就可以实现所有任务完成后统一处理。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.EOC.queue&quot;</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span> <span class="k">in</span> <span class="n">collection</span><span class="p">){</span>
</span><span class='line'>  <span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="p">[</span><span class="n">object</span> <span class="n">performTask</span><span class="p">];</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//Continue processing after completing tasks</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>9.如果你不是自己创建queue，而是使用系统方法返回的queue，那么加入的task，系统会根据系统资源开辟一定数量的线程，来执行这些task，再配合group特性，你只需要关注你的业务逻辑即可，而不用去在如何安排和控制它们的线程开辟和同步上面花费精力。<br/>
10.类似上面多次执行相同的任务，还有一个专门的方法来实现它，如下，传入的iterations类似for循环的最大值，i会从0循环到最大值减一。但dispatch_apply的缺点是会阻塞当前线程，如果你希望在后台线程运行，那么还要使用group的notify方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span> <span class="nf">dispatch_apply</span><span class="p">(</span><span class="n">size_t</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">dispatch_queue_t</span> <span class="n">queue</span><span class="p">,</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="n">size_t</span><span class="p">));</span>
</span><span class='line'><span class="c1">//A serial</span>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.EOC.queue&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_apple</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//perform task</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="c1">//B concurrent</span>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_apply</span><span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="n">count</span><span class="p">,</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="p">){</span>
</span><span class='line'>  <span class="kt">id</span> <span class="n">object</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">object</span> <span class="n">peformTask</span><span class="p">];</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Item45 Use dispatch_once for Thread-Safe Single-Time Code Execution</h2>

<p>1.GCD之前的单例模式实现，使用了synchronization block是为了线程安全：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">+</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">sharedInstance</span><span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="n">EOCClass</span> <span class="o">*</span><span class="n">sharedInstance</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>  <span class="k">@synchronized</span><span class="p">(</span><span class="n">self</span><span class="p">){</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">sharedInstance</span><span class="p">){</span>
</span><span class='line'>          <span class="n">sharedInstance</span> <span class="o">=</span> <span class="p">[[</span><span class="n">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">sharedInstance</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.这是GCD之后的版本，使用了dispatch_once，新类型dispatch_once_t保证了，对于每一个该类型的token，dispatch_once只会执行它对应的block一次，而且是线程安全的，为了保证token的唯一性，token也必须声明为static或global类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span> <span class="nf">dispatch_once</span><span class="p">(</span><span class="n">dispatch_once_t</span> <span class="o">*</span><span class="n">token</span><span class="p">,</span><span class="n">dispatch_block_t</span> <span class="n">block</span><span class="p">);</span>
</span><span class='line'><span class="c1">//singleton</span>
</span><span class='line'><span class="k">+</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">sharedInstance</span><span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="n">EOCClass</span> <span class="o">*</span><span class="n">sharedInstance</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>  <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">sharedInstance</span> <span class="o">=</span> <span class="p">[[</span><span class="n">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">sharedInstance</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.相比较synchronization block的版本，dispatch_once版本效率更高，因为前者在每次运行这段代码时都会进行加锁操作，它对dispatch token进行了原子型的访问来确定代码是否执行过，作者测试使用dispatch_once较synchronization block快将近两倍。</p>

<!--more-->


<h2>Item46 Avoid dispatch_get_current_queue</h2>

<ol>
<li>使用GCD时，获得当前运行的queue是一个常见的需求，而Apple也提供了一个方法：<em>dispatch_queue_t dispatch_get_current_queue()</em>，但是作者告诉我们，这个方法像retainCount一样，并不可靠，iOS6已经将其弃用，目前只可以在debug模式下使用。</li>
<li>回想Item41的getter/setter最终方案，可能会出现这样的场景，就是调用getter的queue和getter中的synchronization queue是同一队列，这样就会产生死锁，dispatch_sync会一直等待queue可用，而这个queue实际上就是当前的queue，所以block永远不会执行。所以就会想到用dispatch_get_current_queue()来判断当前的queue是否是synchronization queue，如果是就直接执行block，不是的话用dispatch_sync()。</li>
<li>如果在简单场景下应该是没问题，如果考虑到一些特殊情况，比如queueA->queueB->queueA嵌套执行，且所有的操作都是同步操作，那么内部的queueA关联的block还是会出现死锁，因为外层的queueA block还未执行完。</li>
<li>所以这个例子中，使用dispatch_get_current_queue()并不是一个可靠地解决方法，而还是应该单独建立一个queue专门供synchronization使用，并确保该queue中会调用getter方法。</li>
<li>从更为普遍的角度讲，因为dispatch queues是存在等级划分的，也就是说在当前queueA中的block加入了在queueB中执行的block，那么queueB上执行的block同样执行与queueA上，而顶层的queue则是global concurrent queues的其中一个。</li>
<li>只有两个queue不存在这种包含关系，才可以并行执行，反之，如果两个queue存在包含的关系，那么在他们中执行同步操作，怎要特别关注死锁问题。这也就是dispatch_get_current_queue()这个方法意义不大的根本原因，因为它只能返回当前的queue，而无法得知整个queue的包含链。</li>
<li>最容易产生这个问题的场景是Api需要你传入想运行的queue，而Api内部在另一个queue上使用了串行同步操作，然后将它的结果在传入的queue中返回，使用者一般会假设dispatch_get_current_queue()会返回自己传入的queue，但结果会返回内部的同步queue。</li>
<li>Queue-specific data是解决上述问题的一个方案，它可以将任意数据和queue绑定，最重要的是，如果没发现与对应key绑定的值，系统会一直沿包含链向上，知道找到对应的queue被找到，或者到root queue。</li>
<li><em>dispatch_queue_set_specific()</em>方法是这一技术的核心，给queue关联的是一个类似键值对的结构，键值均为空指针类型，对于key来说，需要注意的是，作为key的是指针的值而不是指向内容的值，所以其实更像Item10中介绍的associated references。value也是空指针类型，所以理论上你可以将任何值作为value，但是你希望自己管理它的内存，如果在ARC下，使用OC对象就很难做到这一点，所以作者推荐使用了CFString，因为ARC不会管理CoreFoundation的对象，而且也可以很方便转化为OC对象，所以很合适。最后的参数希望传入一个函数指针，它将用作析构函数，将在value从key移除时调用，这可能是queue被释放或者value被赋新值时。dispatch_function_t的类型是只有一个指针且返回空值，示例中CFRelease作为了参数，对应传入的CFString，如果传入的是自己定义的对象，开发者也可以自己重写CFRelease函数，做一些清除工作。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span> <span class="nf">dispatch_queue_set_specific</span><span class="p">(</span><span class="n">dispatch_queue_t</span> <span class="n">queue</span><span class="p">,</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="n">dispatch_function_t</span> <span class="n">destructor</span><span class="p">);</span>
</span><span class='line'><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">*</span><span class="n">dispatch_function_t</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span>
</span><span class='line'><span class="c1">//Example</span>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queueA</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.EOC.queueA&quot;</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queueB</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.EOC.queueB&quot;</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_set_target_queue</span><span class="p">(</span><span class="n">queueB</span><span class="p">,</span><span class="n">queueA</span><span class="p">);</span>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">kQueueSpecific</span><span class="p">;</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">queueSpecificValue</span> <span class="o">=</span> <span class="n">CFSTR</span><span class="p">(</span><span class="s">&quot;queueA&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_queue_set_specific</span><span class="p">(</span><span class="n">queueA</span><span class="p">,</span><span class="o">&amp;</span><span class="n">kQueueSpecific</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">queueSpecificValue</span><span class="p">,(</span><span class="n">dispatch_function_t</span><span class="p">)</span><span class="n">CFRelease</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_sync</span><span class="p">(</span><span class="n">queueB</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="n">dispatch_block_t</span> <span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;No deadlock!&quot;</span><span class="p">);};</span>
</span><span class='line'>  <span class="n">CFStringRef</span> <span class="n">retrievedValue</span> <span class="o">=</span> <span class="n">dispatch_get_specific</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kQueueSpecific</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">retrievedValue</span><span class="p">){</span>
</span><span class='line'>      <span class="n">block</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">queueA</span><span class="p">,</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记5]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/08/28/effective-objective-cdu-shu-bi-ji-5/"/>
    <updated>2015-08-28T11:45:07+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/08/28/effective-objective-cdu-shu-bi-ji-5</id>
    <content type="html"><![CDATA[<p>第五部分开始将讨论OC的核心技术，Reference Counting，也就是使用引用计数来进行内存管理，这一部分涉及到底层内存管理机制，ARC相关技术细节和在开发中涉及到内存管理需要注意的常见问题。</p>

<!--more-->


<h2>Item29 Understand Reference Counting</h2>

<ol>
<li>Reference Counting是OC管理内存的方式，当一个对象的RC为0时，将被释放，iOS没有垃圾回收机制。</li>
</ol>


<h3>How Reference Counting Works</h3>

<ol>
<li>在NSObject Protocol中有三个方法可以改变RC，<em>retain,release,autorelease</em>。</li>
<li>retainCount这个方法可以查看对象当前的RC值，但是并不推荐使用，Item36会讨论。</li>
<li>对象之间往往是互相持有的，当该持有关系是<em>strong</em>时，被持有对象的RC加1，而持有链的最顶端是根对象，Mac OSX是NSApplication，iOS是UIApplication，都是应用创建的单例。</li>
<li>举例一个NSMutableArray添加一个NSNumber，虽然在array添加number后，释放number，number的RC还是1，调用number理论上是可以的，但是并不推荐这么做，因为如果任何其他原因使number的RC为0，这一做法会导致崩溃。</li>
<li>对象被释放后，它的内存将进入可用内存池，如果调用发生在内存被复写之前，不会发生错误，所以之类bug有时会很难复现，所以在MRC中往往在调用release后会赋值nil。</li>
</ol>


<h3>Memory Management in Property Accessors</h3>

<ol>
<li>strong命名的property的setter方法，是新值retain，然后旧值release，然后赋值，这一顺序不能错，因为如果先release再retain，且正好两个对象是同一个，可能会导致对象提前释放，RC为0，成为野指针，再调用retain则会出错。想按照这个顺序来，必须判断新旧两值是否是同一对象。</li>
</ol>


<h3>Autorelease Pools</h3>

<ol>
<li>借助autorelease pool替代release操作的autorelease，常用于需要返回新建对象的方法，具体释放时间在下一次事件循环（Item34将讨论）。</li>
<li>在直接调用该方法时不用额外的内存空间，直接调用即可。</li>
<li>但是如果返回对象需要持有时，比如赋值给一个实例变量，它需要retain一次，然后使用完后手动release，所以可以将autorelease理解为延长对象的生命周期，可以至少保证到方法调用的边界。</li>
</ol>


<h3>Retain Cycles</h3>

<ol>
<li>循环引用一般是指两个或多个对象直接互相存在强引用，而导致RC都不能为0，所有对象都不能释放。</li>
<li>在垃圾回收机制下，retain cycle会被定义为孤岛，而直接被全部释放，而在RC机制下，只能通过定义weak引用或者依靠外部帮助来使其中某个对象交出对其他对象的引用。</li>
</ol>


<!--more-->


<h2>Item30 Use ARC to Make Reference Counting Easier</h2>

<ol>
<li>Clang编译器带来了一个静态分析器，可以定位出现RC问题的位置，例如没有添加release，除此之外，该分析器可以为你自动添加retain，release这些操作，这也就是ARC技术的基础。</li>
<li>在ARC机制下，retain、release、autorelease、dealloc这些操作都是不允许的，因为这回影响编译器判断添加语句的位置。</li>
<li>事实上，ARC并没有直接调用上述这些方法，而是调用了他们的C的替代方法，例如objc_retain，这么做的好处是，因为这些操作会频繁调用，使用C方法可以提高效率。这也是为什么不允许直接重写retain，release这些方法，因为这方法并不是直接调用的。</li>
</ol>


<h3>Method-Naming Rules Applied by ARC</h3>

<ol>
<li>内存管理指定方法名在OC里一直是惯例，而ARC将其加强了，含有以下名称的方法：<em>alloc、new、copy、mutableCopy</em>，所返回的对象的所有者为方法的调用者，而其他方法返回的对象为autorelease，会保持到方法调用边界。</li>
<li>而ARC会依据方法名的开头添加响应的语句，例如上述四个关键字开头的，会直接返回，而一般方法，ARC会在返回对象前加上autorelease。</li>
<li>而在调用这些方法时，第一类方法返回的对象，ARC会在方法结束前添加release方法，而第二类方法因为有autorelease，所以不会添加操作。</li>
<li>ARC通过命名规范来规范内存管理，再加上之前的命名空间，OC是少有的如此强调命名的语言之一。</li>
<li>ARC可以做一些无法手动完成的优化，比如，它将在编译期间取消多余的retain和release操作。</li>
<li>ARC在runtime也有进行优化，举例：EOCPerson的一般初始化方法返回的值（添加了autorelease），被赋值给一个对象的strong属性实例，按照之前的原则，需要在返回的对象加retain，这里的autorelease和retain看起来是多余的，ARC确实可以为了性能，直接去掉autorelease这个方法，所有返回的对象都为RC+1，但为了兼容MRC，ARC还是需要特殊处理。</li>
<li>ARC确实对这种现象做了处理，在返回对象之前它调用了<em>objc_autoreleaseReturnValue</em>，如果被发现该对象是需要retain的，则会添加一个flag，而不是调用autorelease。同样的，调用者也会调用<em>objc_retainAutoreleasedReturnValue</em>，而不是retain，该方法也会先检测flag，如果存在，则不会retain，这样提高了效率：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//Within EOCPerson class</span>
</span><span class='line'><span class="k">+</span><span class="p">(</span><span class="n">EOCPerson</span><span class="o">*</span><span class="p">)</span><span class="nf">personWithName:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">EOCPerson</span> <span class="o">*</span><span class="n">person</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EOCPerson</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>  <span class="n">person</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'>  <span class="n">objc_autoreleaseReturnValue</span><span class="p">(</span><span class="n">person</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Code using EOCPerson class</span>
</span><span class='line'><span class="n">EOCPerson</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">EOCPerson</span> <span class="nl">personWithName:</span><span class="s">@&quot;Matt&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">_myPerson</span> <span class="o">=</span> <span class="n">objc_retainAutoreleasedReturnValue</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//objc_autoreleaseReturnValue</span>
</span><span class='line'><span class="kt">id</span> <span class="nf">objc_autoreleaseReturnValue</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="cm">/*caller will retain object*/</span><span class="p">){</span>
</span><span class='line'>      <span class="n">set_flag</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">object</span><span class="p">;</span><span class="c1">//no autorelease</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">[</span><span class="n">object</span> <span class="n">autorelease</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//objc_retainAutoreleasedReturnValue</span>
</span><span class='line'><span class="kt">id</span> <span class="nf">objc_retainAutoreleasedReturnValue</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">get_flag</span><span class="p">(</span><span class="n">object</span><span class="p">)){</span>
</span><span class='line'>      <span class="n">clear_flag</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">object</span><span class="p">;</span><span class="c1">//no retain</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">[</span><span class="n">object</span> <span class="n">retain</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Memory-Management Semantics of Variables</h3>

<ol>
<li>ARC也同时管理着本地变量和实例变量的内存，默认每个变量对于对象是strong引用。</li>
<li>在setter方法中，ARC中直接对旧值赋值即可，ARC会自动添加正确的代码。</li>
<li>声明实例变量时，也可以改变内存管理方式，<strong>strong（默认，赋值将被retain）、</strong>unsafe_retained（赋值同assign，但指针不会自动置空，可能出现野指针）、<strong>weak（赋值同assign，对象被释放时，指针会自动置为nil，所以是安全的，iOS5后可用）、</strong>autoreleasing（多用与方法的返回值）。</li>
<li>__weak用于本地变量时，常用于避免循环引用，比如在block中：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSURL</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURL</span> <span class="nl">URLWithString:</span><span class="s">@&quot;http://www.example.com/&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">EOCNetworkRetcher</span> <span class="o">*</span><span class="n">fetcher</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EOCNetworkFetcher</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithURL:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'><span class="n">EOCNetworkFetcher</span> <span class="o">*</span> <span class="n">__weak</span> <span class="n">weakFetcher</span> <span class="o">=</span> <span class="n">fetcher</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">fetcher</span> <span class="nl">startWithCompletion:</span><span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">success</span><span class="p">){</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finished fetching from %@&quot;</span><span class="p">,</span> <span class="n">weakFetcher</span><span class="p">.</span><span class="n">url</span><span class="p">);</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>ARC Handling of Instance Variables</h3>

<ol>
<li>在ARC中，你一般不需要再重写dealloc方法，ARC借用Objective-C++的特性，Objective-C++对象在释放时会调用所有持有对象的析构方法，当编译器发现对象包含C++对象时，会生成<em>.cxx_destruct</em>方法，ARC借助这个方法，在其中执行清除内存的代码。</li>
<li>但有时你仍需要重写dealloc方法，像CoreFoundation对象和堆上开辟的内存（如malloc），以及KVO、的解除，都需要手动释放，但注意<em>在ARC中，不需要在dealloc中写[super dealloc]</em>，因为ARC在<em>.cxx_destruct</em>中已经调用了这一方法。</li>
</ol>


<h3>Overriding the Memory-Management Methods</h3>

<ol>
<li>在MRC中，重写内存相关方法是允许的，比如单例常常重写release方法为一个空操作，这样单例就不会被释放。</li>
<li>但在ARC中是不允许的，一是会导致ARC对对象周期的误判，二是ARC对内存管理做了深度的优化，当需要执行retain、release、autorelease时，ARC在OC的message dispatch做了优化处理，不能重写或调用这些方法则是该优化的前提。</li>
</ol>


<!--more-->


<h2>Item31 Release References and Clean Up Observation State Only in dealloc</h2>

<p>1.dealloc方法会在对象的引用计数为0时自动调用，但什么时候调用并不能保证，即使是在MRC中，手动控制release也一样，因为很多库会在你不知道的情况下修改对象，这会导致调用dealloc的时间发生变化。所以你千万不要手动去调用dealloc，runtime会在合适的时间调用。<br/>
2.那么在ARC下，重写dealloc的话，一是用于释放CoreFoundation的对象，二是取消NSNotificationCenter中注册该对象的监听或KVO。<br/>
3.如果你的类中使用到了文件描述集，sockets、或者开辟了大块儿内存，由于dealloc的调用时间不明，你可能在你不需要使用的时候即可释放这些内存，而不用等到dealloc触发，这样需要自定义一个清除方法，该方法必须在dealloc之前调用，不然就算异常了。<br/>
4.清除资源需要另一个方法的原因是创建的对象并不是都会被调用dealloc，因为一部分对象在应用退出后台时并不会释放，它们只有在应用彻底被系统回收后才会释放，这是一种优化措施，但也会导致大量的资源被无故占用，所以在-(void)applicationWillTerminate:(UIApplication*)application中调用一些对象的clean方法是必要的。<br/>
5.有时可以在dealloc中也可以去调用clean方法，这可以避免忘记调用clean，但最好还是手动去先执行clean，所以还是要提示下或者严重的话直接直接抛出异常：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">close</span> <span class="p">{</span>
</span><span class='line'>  <span class="cm">/*clean up resources*/</span>
</span><span class='line'>  <span class="n">_close</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">_closed</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;ERROR:close was not called before dealloc!&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="p">[</span><span class="n">self</span> <span class="n">close</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>6.除了上述特例，一般是不允许在dealloc中调用类的其他实例方法，因为有可能导致方法执行前，该对象可能已经释放了。而且，dealloc方法是在导致对象最终释放的线程上执行的，所以需要在特定线程执行的方法在此调用，不能保证线程正确，即使是通过代码强制在某线程执行，也是不安全的，因为对象处于释放状态。
7.另外dealloc中也不可调用property的setter、getter方法，尤其是被重写的accessor，也有可能触发KVO的回调，导致未知的错误。</p>

<!--more-->


<h2>Item32 Beware of Memory Management with Exception-Safe Code</h2>

<ol>
<li>Exception是OC和C++中用于处理严重异常的对象，但有时你也需要通过代码处理这些异常，例如去注销一个KVO，但之前并没有注册过的情况。</li>
<li>在try/catch中创建对象，并需要自己释放时，需要将释放代码写到finally中，这样才能保证无论是否异常都能保证对象释放。</li>
<li>但在ARC中可以自动添加额外的处理代码，使用<em>-fobjc-arc-exceptions</em>这个flag来控制，但默认是关闭的，因为exception出现时application直接crash，资源也会回收，所以没必要再做处理，而且会带来性能问题，只有编译器处于Objective-C++时才会开启，因为OC++添加代码带来性能损耗没有ARC添加时那么大，另外OC++中Exception是被大量使用的。</li>
<li>如果在ARC下需要单独处理exception，那么可以开启flag，但如果你有很多exception处理，那么你该考虑NSError了，如Item21所讲。</li>
</ol>


<!--more-->


<h2>Item33 Use Weak References to Avoid Retain Cycles</h2>

<ol>
<li>循环引用带来的问题主要是，引用环中的对象将不能再被调用，但也不能释放，从而导致内存泄露。</li>
<li>Java会有垃圾回收来解决这类问题，但iOS和Mac OS X 10.8之后是没有垃圾回收的，所以只能开发者自己去避免。</li>
<li>使用unsafe_unretained可以避免这一问题，它类似assign，但assign一般用于数值型，而unsafe_unretained用于对象，但如字面意思一样，它不会因为所指向的对象被释放而置为空值，所以调用unsafe_unretained的对象，可能会因为所指对象不存在而崩溃，所以是不安全的。</li>
<li>在ARC中我们常用的是weak字段，该字段与unsafe_unretained功能一致，但是它会在所指对象释放后自动指向nil，所以是安全的。</li>
<li>关于循环引用，总的原则就是，如果你不持有一个对象，那么你就不该retain它（数组，集合不直接持有包含的对象，但是会retain它们，是个例外）。一般场景有，controller的UI控件（一般weak属性），一个对象的delegate属性（一般为weak属性）。</li>
</ol>


<!--more-->


<h2>Item34 Use Autorelease Pool Blocks to Reduce High-Memory Waterline</h2>

<p>1.<em>@autoreleasepool{}</em>这是OC中建立autorelease pool的方法，但我们一般不必去手动创建。<br/>
2.main函数中的autorelease pool并不是必须的，只是UIApplicationMain()函数中需要autorelease的对象没有对应的pool，但它们在程序终止时时肯定会被释放的。<br/>
3.autorelease pool可以嵌套，autorelease的对象总是被添加最里面的pool中。<br/>
4.利用上述特性，我们可以对一些大量循环执行一个可能产生很多autorelease对象的方法做优化，如下EOCPerson的创建可能产生大量autorelease对象，这样产生的autorelease对象会在自己建的autorelease pool结束时释放，而不是长期存在于线程自己的autorelease pool，避免了出现应用内存陡升陡降这种“瀑布现象”：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">databaseRecords</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">people</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">record</span> <span class="k">in</span> <span class="n">databaseRecords</span><span class="p">){</span>
</span><span class='line'>  <span class="err">@</span><span class="n">autoreleasepool</span><span class="p">{</span>
</span><span class='line'>      <span class="n">EOCPerson</span> <span class="o">*</span><span class="n">person</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EOCPerson</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithRecord:</span><span class="n">record</span><span class="p">];</span>
</span><span class='line'>      <span class="p">[</span><span class="n">people</span> <span class="nl">addObject:</span><span class="n">person</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.autorelease pool可以被理解为放入了一个栈中，新建的pool会在最顶端，当它释放后会被移出栈，当一个对象调用了autorelease，它将被添加到最顶端的autorelease pool。<br/>
6.使用autorelease pool来优化瀑布现象并不是必要的，这取决你的应用，如果确实导致了问题，那么去使用它，如果不必要使用，那么就不要添加多于的autorelease pool。<br/>
7.ARC之前使用autorelease pool是使用NSAutoreleasePool，因为它属于重量级对象，所以一般是隔段时间进行释放：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">databaseRecords</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">people</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">NSAutoreleasePool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSAutoreleasePool</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">record</span> <span class="k">in</span> <span class="n">databaseRecords</span><span class="p">){</span>
</span><span class='line'>  <span class="n">EOCPerson</span> <span class="o">*</span><span class="n">person</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EOCPerson</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithRecord:</span><span class="n">record</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">people</span> <span class="nl">addObject:</span><span class="n">person</span><span class="p">];</span>
</span><span class='line'>  <span class="c1">//Drain the pool only every 10 cycles</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">==</span> <span class="mi">10</span><span class="p">){</span>
</span><span class='line'>      <span class="p">[</span><span class="n">pool</span> <span class="n">drain</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Also drain at the end in case the loop is not multiple of 10</span>
</span><span class='line'><span class="p">[</span><span class="n">pool</span> <span class="n">drain</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>8.推荐使用新语法@autoreleasepool，更加轻量，而且一个重要特性，NSAutoreleasePool中创建的autoreleased对象在执行drain之后还能使用，这可能造成崩溃，且很多时候难以发现，而使用@autoreleasepool，这类代码不会被编过，也就及早避免了这一问题。</p>

<!--more-->


<h2>Item35 Use Zombies to Help Debug Memory-Management Problems</h2>

<p>1.内存问题一般很难处理，原因是被释放的那块内存不一定就很快被重写，或者正好被一个同类的对象重写，这样有时不会导致崩溃，有时却会，所以开发者有时会无从下手。<br/>
2.Cocoa的Zombies特性会帮助我们解决这一问题，当该模式启用，所有被释放的对象会转化为NSZombie对象，其占用过的内存也不会被重用，当该对象收到消息时，会抛出异常，告知开发者所收到的消息，原来的对象类型这些信息。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span> <span class="nf">PrintClassInfo</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">){</span>
</span><span class='line'>  <span class="n">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">object_getClass</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Class</span> <span class="n">superCls</span> <span class="o">=</span> <span class="n">class_getSuperclass</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;===%s:%s===&quot;</span><span class="p">,</span><span class="n">class_getName</span><span class="p">(</span><span class="n">cls</span><span class="p">),</span><span class="n">class_getName</span><span class="p">(</span><span class="n">superCls</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
</span><span class='line'>  <span class="n">EOCClass</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EOCClass</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Before release:&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">printClassInfo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>  <span class="p">[</span><span class="n">obj</span> <span class="n">release</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;After release&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">PrintClassInfo</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//result</span>
</span><span class='line'><span class="c1">//Before release:</span>
</span><span class='line'><span class="c1">//===EOCClass:NSObject===</span>
</span><span class='line'><span class="c1">//After release:</span>
</span><span class='line'><span class="c1">//===_NSZombie_EOCClass:nil===</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>3.通过上述手段我们得知obj在dealloc后变为了<em>NSZombie_EOCClass，但并没有它的父类，实际上，它是通过对原类型的类名修改，然后对</em>NSZombie<em>类型执行objc_duplicateClass()，完全拷贝zombie类并使用新类名（也可使用继承，但不如copy效率），制造出obj对应的zombie类，然后用objc_setClass()修改obj的isa指针，改变其类型，这一切都是利用runtime完成的（通过method swizzles对dealloc方法替换）。<br/>
4.由于</em>NSZombie<em>没有实现任何方法，所以向它或者它的copy类型发送任何消息，会直接进入forwarding mechanism，在寻求转发时如果发现类型名以</em>NSZombie_开头，那么直接抛出异常，并打印出message、原类型这些信息。</p>

<!--more-->


<h2>Item36 Avoid Using retainCount</h2>

<ol>
<li><em>retainCount</em>是NSObject Protocol的一个方法，用于返回对象目前的引用计数值，在ARC中已经弃用，但即使在MRC中，任然应该避免使用它。</li>
<li>原因一是<em>retainCount</em>返回的是实时的count值，也就是说像autorelease这样将要发生的count减少的情况，不会在该方法反映出来，所以依据该值去执行一些改变count的方法，往往会出问题。</li>
<li>有时retainCount会返回一个极大的值，这是NSString或NSNumber直接设置常量时，系统会将其作为一个单例的常量，而不是去创建一个对应的对象，这些对象的ratainCount是不会改变的，但只是对一些特例的优化。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记4]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/08/24/effective-objective-cdu-shu-bi-ji-4/"/>
    <updated>2015-08-24T11:35:10+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/08/24/effective-objective-cdu-shu-bi-ji-4</id>
    <content type="html"><![CDATA[<p>第四部分开始讨论OC的两大重要特性，Protocols和Categories。Protocols类似Java中的interfaces，弥补了OC没有多继承的缺点，常被用于实现OC委托模式，但还有很多其他方面的用途。Categories则是提供了不继承而向类添加拓展的方法，这要归功于OC动态语言特性，但同时了解它使用时的常见问题也非常重要。</p>

<!--more-->


<h2>Item23 Use Delegate and Data Source Protocols for Interobject Communication</h2>

<ol>
<li>Delegate是用于对象之间进行数据交互的设计模式，使用它的好处是可以让不同的业务逻辑解耦，实现代码模块化。而在OC中实现这一模式，主要依靠Protocols。</li>
<li>怎么使用Delegate不介绍了，注意点是：1）命名最好和你需要委托的类相关，例如UITableView,UITableViewDelegate；2）类的delegate property是weak属性，原因是接受委托的对象一般会持有需要委托的对象，如果delegate设置为strong，需要委托的对象也会持有接受委托的对象，这样就会出现retain cycle。</li>
<li>Delegate一般都定义为option，除非一些方法是一定要被委托者实现的，同时对于option的方法，委托者需要在调用之前使用<em>respondsToSelector:</em>来内省，确保被委托者实现了该方法。</li>
<li>Delegate中定义的方法一定要清楚，而且一定要包括被委托者自身作为其中一个参数，这样如果存在同类型多个实例对象时，委托者可以在同一个方法中区分这些实例变量。</li>
<li>Protocols还可以用于DataSource模式，与Delegate模式区别是，对于一个Class来说，Delegate的信息是流出Class的，而DataSource的信息是流入Class的，设计Protocols也可以参照这一原则。</li>
<li>对于option的方法要进行<em>respondsToSelector:</em>来检测，但是对于一些需要频繁调用的方法，采用这一方式非常影响性能，作者利用了C中的由多个1bit字段组成的结构体来标识被委托对象是否响应所有方法，这基于被委托对象一般不会动态改变对方法的响应：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">EOCNetworkFetcher</span><span class="p">(){</span>
</span><span class='line'>  <span class="n">struc</span> <span class="p">{</span>
</span><span class='line'>      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">didReceiveData:</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">didFailWithError:</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">didUpdateProgressTo:</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">_delegateFlags</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">EOCNetworkFetcher</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setDelegate:</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">EOCNetworkFetcherDelegate</span><span class="o">&gt;</span><span class="n">delegate</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">_delegate</span> <span class="o">=</span> <span class="n">delegate</span><span class="p">;</span>
</span><span class='line'>  <span class="n">_delegateFlags</span><span class="p">.</span><span class="n">didReceiveData</span> <span class="o">=</span> <span class="p">[</span><span class="n">delegate</span> <span class="nl">respondsToSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">networkFetcher:</span> <span class="nl">didReceiveData:</span><span class="p">)];</span>
</span><span class='line'>  <span class="n">_delegateFlags</span><span class="p">.</span><span class="n">didFailWithError</span> <span class="o">=</span> <span class="p">[</span><span class="n">delegate</span> <span class="nl">respondsToSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">networkFetcher:</span> <span class="nl">didFailWithError:</span><span class="p">)];</span>
</span><span class='line'>  <span class="n">_delegateFlags</span><span class="p">.</span><span class="n">didUpdateProgressTo</span> <span class="o">=</span> <span class="p">[</span><span class="n">delegate</span> <span class="nl">respondsToSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">networkFetcher:</span> <span class="nl">didUpdateProgressTo:</span><span class="p">)];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//调用委托时</span>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm">if(_delegateFlags.didUpdateProgressTo) {</span>
</span><span class='line'><span class="cm"> [_delegate networkFetcher:self didUpdateProgressTo:currentProgress];</span>
</span><span class='line'><span class="cm">}</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<!--more-->


<h2>Item24 Use Categories to Break Class Implementations into Manageable Segments</h2>

<ol>
<li>分类这一特性主要为了解决一个类在开发中无限膨胀的问题，将一个类的方法按照功能进行分类处理是常规做法。</li>
<li>第二种用途是为了对代码进行分割增加可读性，例如NSURLRequest想增加专门的HTTP请求，单纯继承不是一个很好的选择，原因是NSURLRequest封装了一组针对CFURLRequest的C方法，无法通过继承获得，而直接添加这些HTTP的方法则会导致一些代码理解错误，例如开发者使用FTP协议，去发现可以调用关于HTTP的方法，所以将HTTP部分的方法做成NSHTTPURLRequest的分类是最好的选择。</li>
<li>第三个用途是方便调试，原因是分类中的方法在日志里会显示为类似：<em>&ndash;[EOCPerson(Friendship) addFriend:]</em>，可以方便定位该方法。</li>
<li>另外，在做一个库时，把一些私有方法用名为Private的分类封装，这样这些方法不用暴露在外，而内部又可以随意调用，而且外部万一用到了，也可以在日志中看到private的标志，起到了文档的作用。</li>
</ol>


<!--more-->


<h2>Item25 Always Prefix Category Names on Third-Party Classes</h2>

<ol>
<li>为一个类添加分类后，运行时runtime会遍历category每个方法，顺便加入类的方法列表，如果这时category重写了类的某个方法，这将覆盖原有的方法，如果多个category都出现这个情况，那么最后被载入的那个分类的方法会被采用，这两种情况都将导致Bug，且难以定位。</li>
<li>解决这一问题的方法只能是添加namespace，规则参考Item15，最好就是公司+项目这样的方式，而且最好将分类的名字也加namespace，这样可以避免warning。</li>
<li>要记住添加到一个类的category中的方法，只要被添加，在所有类的示例都可以调用（这里还是需要导入这个category才可以），尤其在为Cocoa中的类添加分类时时刻注意添加命名空间，去刻意重写类中的方法是一个非常坏的习惯，它带来的问题可能比好处大得多。</li>
</ol>


<!--more-->


<h2>Item26 Avoid Properties in Categories</h2>

<ol>
<li>category默认是不支持添加property的（匿名分类除外），虽然这一做法可以在技术上实现，但是依然不推荐这么做。</li>
<li>category不支持property，主要是无法自动合成setter和getter方法，解决这一问题有两个方法：1）使用Item12的做法，用@dynamic声明，重写message-forwarding的方法，在runtime添加setter和getter方法；2）使用Item10，使用associated objects，自己在getter和setter进行关联。</li>
<li>上述两个方法均可行，但作者认为这两个方法都不完美，缺点有二：1）内存管理，你很容易忘记这个property的特殊性，而只去修改property的关键字，而忘记去修改setter方法；2）如果你想让自己的property对象在内部支持mutable，可以在内部声明一个，mutable拷贝，但是这又会出现一个进入源代码的混乱路径，所以在category中定义property的代价是很高的。</li>
<li>作者建议的方法是把所有的变量都放入原类中，而category只提供额外的方法。</li>
<li>但有时category中可以添加只读变量，而且也不涉及读写原类的变量，但是虽然不报错，还是推荐使用一个方法来完成，因为真的没必要这么做。</li>
</ol>


<!--more-->


<h2>Item27 Use the Class-Continuation Category to Hide Implementation Detail</h2>

<p>1.OC是没有真正的私有方法的，但我们还是不希望把不需要暴露的方法和变量暴露在外，所以匿名分类就是一种隐藏这些细节的手段。<br/>
2.你可以将实例变量声明在匿名变量或implementation中，可以完全不用暴露你要导入的头文件等一切信息，例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">EOCPerson</span><span class="p">(){</span>
</span><span class='line'>  <span class="n">NSString</span> <span class="o">*</span><span class="n">_anInstanceVariable</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Method declarations here</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="err">@</span><span class="n">implemenation</span> <span class="n">EOCPerson</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">_anotherInstanceVariable</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Method implemenations here</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.一般OC代码中使用C++一般两种情况：一些游戏相关的后端代码需要用C++，使用的第三方库使用了C++，而你作为使用者除非特殊情况，一定要使用匿名分类来使用C++，这样其他类使用你的类时，不用再因为C++的原因，将.m文件命名为.mm，而使编译器将其编为Objective-C++。Cocoa的web browser framework和CoreAnimation使用了这一模式。<br/>
4.还有一种应用就是在外部声明readonly的property，然后在匿名分类中再将其声明为readwrite，这样可以实现外部只能通过方法设置值，而内部可以正常使用该变量，可能会出现外部在访问，内部同时在赋值同步的问题，将在Item41讨论。<br/>
5.接下来就是可以在匿名分类声明私有方法，虽然这不是必须的，而作者比较推荐先列好方法，理清思路，再开始实现，如果是比较大的项目，还是需要这么干的。<br/>
6.最后就是可以在匿名分类添加委托。</p>

<!--more-->


<h2>Item28 Use a Protocol to Provide Anonymous Objects</h2>

<ol>
<li>利用Protocol可以实现创建一些匿名对象，例如：id<EOCDelegate> delegate。</li>
<li>例子1：来自多个第三方类库的数据库管理对象对应不同数据库类型，现在需要提供一个统一的Manager，来返回这些不同的对象，依靠基类继承是不可能的，只能通过定义一组数据库通用的操作作为Protocol，然后分别继承这些类，而新类则遵从这一protocol，这样Manager只需返回id<Protocol>类型的对象即可，而使用者也只需要知道它们实现了这些方法也足够了。</li>
<li>例子2：已确定只有一个类型，但其是一个内部使用的数据类型，不需要将其所有细节暴露，只需要暴露其中一部分方法即可，那么将这些方法声明为Protocol，然后返回类型定义为id<Protocol>即可，其实就是实现了对对象的大部分封装。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记3]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/08/17/effective-objective-cdu-shu-bi-ji-3/"/>
    <updated>2015-08-17T14:15:03+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/08/17/effective-objective-cdu-shu-bi-ji-3</id>
    <content type="html"><![CDATA[<p>第二部分主要讲了一些OC底层的运作机制，这一部分开始，主要涉及实践部分，第三部分的主题是：Interface and API Design。</p>

<!--more-->


<h2>Item15 Use Prefix Names to Avoid Namespace Clashes</h2>

<ol>
<li>OC是没有内建的命名空间的，所以必须采取措施避免这一问题。</li>
<li>解决方案是自己在所有类都添加自定义的前缀，一般是项目名缩写，但推荐使用三个字母，因为两个字母被苹果使用，所以重名的概率大。</li>
<li>在.m文件中的纯C函数和全局变量也有可能出现重名，所以定义时需格外注意，也要加上前缀。</li>
<li>还有一种可能，你自己封装的类库A和应用使用了同一类库B，而应用也使用了你的类库A，这样的话，只能手动将你自己使用的类库B的所有加上类库A的前缀，虽然麻烦，但是如果是大工程的话，必须这么做。</li>
</ol>


<!--more-->


<h2>Item16 Have a Designated Initializer</h2>

<ol>
<li>一个类可能有很多初始化方法，但其中基本初始化方法只需有一个，其他初始化方法只是参数变化，这样保证数据在一个方法中赋值，便于维护。</li>
<li>为了避免用户使用原始的<em>init:</em>方法而出现错误，该类中应该重写<em>init:</em>方法，可以做一个默认的赋值，或者直接抛出异常。</li>
<li>继承一个拥有基本初始化方法的类，子类的初始化方法要调用父类的基本初始化方法，而且需要重写父类的基本初始化方法，与上一条的理由一致。</li>
<li>有时可能需要两个基本初始化方法，特例比如遵循NSCoding的类，要有一个-(id)initWithCoder:(NSCoder*)decoder的初始化方法，而该类的子类也必须重写initWithCoder:，同时调用父类initWithCoder:。</li>
</ol>


<h2>Item17 Implement the description Method</h2>

<p>1.重写对象的-(NSString*)description方法，可以获得更多的实用信息，默认的只是类名和指针地址，这也是NSObject协议的其中一项。<br/>
2.这是一种将NSDictionary特性结合起来的description写法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;&lt;%@:%p,%@&gt;&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="p">[</span><span class="n">self</span> <span class="n">class</span><span class="p">],</span>
</span><span class='line'>  <span class="n">self</span><span class="p">,</span>
</span><span class='line'>  <span class="err">@</span><span class="p">{</span><span class="s">@&quot;title&quot;</span><span class="o">:</span> <span class="n">_title</span><span class="p">,</span>
</span><span class='line'>  <span class="s">@&quot;latitude&quot;</span><span class="o">:</span> <span class="err">@</span><span class="p">(</span><span class="n">_latitude</span><span class="p">),</span>
</span><span class='line'>  <span class="s">@&quot;longitude&quot;</span><span class="o">:</span> <span class="err">@</span><span class="p">(</span><span class="n">_longitude</span><span class="p">)}</span>
</span><span class='line'>  <span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>3.LLDB中的<em>po</em>命令会执行print-object函数，它返回的是NSObject协议的另一方法-(NSString *)debugDescription，而这一方法默认返回的是description的结果，如果需要隐藏部分信息，可以分别重写这两个方法，OC默认类型很多就是这么干的，例如NSArray。</p>

<!--more-->


<h2>Item18 Prefer Immutable Objects</h2>

<ol>
<li>设计类的时候，其中的property除非必须可变，都应设计为不可变只读类型，之前Item8也讨论过类似问题，一个可变集合加入两个可变数组，然后设法改变数组，可能会出现集合中有相同数组，而不会报错的问题。</li>
<li>解决这个问题的设计是在.h文件中设置property为readonly，而在.m文件中添加匿名分类，重新定义相同的property为readwrite，这样实现了对外只读，而内部可以进行修改。</li>
<li>如果需要对外提供修改变量的方法，也不建议直接把可变变量暴露，而是对外还是暴露只读变量，内部再定义一个可变的内部变量，外部的只读变量的getter方法返回内部可变变量的copy，而同时添加增删的外部方法来操作内部变量。</li>
</ol>


<!--more-->


<h2>Item19 Use Clear and Consistent Naming</h2>

<ol>
<li>OC命名方式是尽量详细，多使用一些介词，表明方法功能，同时使用驼峰命名法。</li>
</ol>


<h3>Method Naming</h3>

<ol>
<li>如果一个方法返回了一个新对象，那么方法一般以该对象的类型开头。</li>
<li>一个参数前需要加一个名词来描述他的类型。</li>
<li>一个方法描述对一个对象进行操作时，需要包含一个动词，然后每个参数前依旧需要名词描述。</li>
<li>避免使用缩写，而使用全称，例如：<em>str</em>和<em>string</em>。</li>
<li><em>Boolean</em>类型的property的getter方法用<em>is</em>前缀，返回<em>Boolean</em>的方法应该以<em>has</em>或<em>is</em>作为前缀。</li>
<li>保留<em>get</em>关键字，在方法并无返回值，但是通过传入的参数，进行值的返回时使用get，比如：-(void)getCharacters:(unichar *)buffer range:(NSRange)aRange。</li>
</ol>


<h3>Class and Protocol Naming</h3>

<ol>
<li>主要是注意你继承的类要以其类名结尾，但前缀不要，要加上自己的前缀，协议要以Delegate结尾。</li>
</ol>


<!--more-->


<h2>Item20 Prefix Private Method Names</h2>

<ol>
<li>用特殊前缀标记类的私有方法，会在调试时更加方便，Matt的方式是在方法前加<em>p_</em>前缀，例如：<em>&ndash;(void)p_privateMethod</em>，当然你最好定义自己的方式。</li>
<li>Apple的方式是在方法前加<em>_</em>来标识私有方法，但不推荐开发者这么做，因为如果你继承了Cocoa的类，很容易覆盖原来的私有方法。</li>
</ol>


<!--more-->


<h2>Item21 Understand the Objective-C Error Model</h2>

<p>1.抛出exception后，本来将要释放的对象将得不到释放，所以会造成内存泄露，所以抛异常时一定是非常严重的错误出现的场景。<br/>
2.场景一是基类的一些必须被子类重写的方法可以抛出异常已告知开发者去重写，因为OC没有基类的特殊概念。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">mustOverrideMethod</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">NSString</span> <span class="o">*</span><span class="n">reason</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;%@ must be overridden&quot;</span><span class="p">,</span> <span class="n">NSStringRromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">)];</span>
</span><span class='line'>  <span class="k">@throw</span><span class="p">[</span><span class="n">NSException</span> <span class="nl">exceptionWithName:</span><span class="n">NSInternalInconsistencyException</span> <span class="nl">reason:</span><span class="n">reason</span> <span class="nl">userInfo:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.而处理一般的异常OC通常使用NSError，该类包含以下信息：<br/>
1）Error domain(String):表明错误发生的域，一般是自定义的全局变量，例如：<em>NSURLErrorDomain</em>。
2）Error code(Integer):表明特定域的错误码，参考HTTP的状态码。<br/>
3）Userinfo(Dictionary):额外的信息，包括本地化描述信息和导致该错误的原因。<br/>
4.NSError的一些使用场景：<br/>
1）被用于Delegate中，例如：-(void)connection:(NSURLConnection <em>)connection didFailWithError:(NSError </em>)error。<br/>
2）用于返回型参数，参照Item19，类似：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//-(BOOL)doSomething:(NSError**)error</span>
</span><span class='line'><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="kt">BOOL</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">object</span> <span class="nl">doSomething:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">//There was an error</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
5.上述方法传入的是NSError<em><em>类型，开启ARC时该类型会转化为NSError</em> __autoreleasing</em>类型，该对象会在方法执行后自动释放，这么做，是因为doSomething:不能确定调用者会不会对NSError释放，大部分方法return的对象也是一样会添加autorelease（除了new，alloc，copy，mutableCopy等）。<br/>
6.doSomething的内部实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">doSomething:</span><span class="p">(</span><span class="n">NSError</span><span class="o">**</span><span class="p">)</span><span class="nv">error</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">//Do something that may cause an error</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="cm">/*there was an error*/</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">//有必要检查error，有可能传入nil值</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="c1">//Pass error through the out-parameter</span>
</span><span class='line'>          <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSError</span> <span class="nl">errorWithDomain:</span><span class="n">domain</span> <span class="nl">code:</span><span class="n">code</span> <span class="nl">userInfo:</span><span class="n">userInfo</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<!--more-->


<h2>Item22 Understand the NSCopying Protocol</h2>

<p>1.想要让自定义对象实现copy功能，必须遵循NSCopying协议，其中只有一个方法需要重写：-(id)copyWithZone:(NSZone*)zone。<br/>
2.一个重写copyWithZone:方法的例子，<em>friends是内部变量，所以使用了copy-></em>friends：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">copyWithZone:</span><span class="p">(</span><span class="n">NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nv">zone</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">EOCPerson</span> <span class="o">*</span><span class="n">copy</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">self</span> <span class="n">class</span><span class="p">]</span> <span class="nl">allocWithZone:</span><span class="n">zone</span><span class="p">]</span> <span class="nl">initWithFirstName:</span><span class="n">_firstName</span> <span class="nl">andLastName:</span><span class="n">_lastName</span><span class="p">];</span>
</span><span class='line'>  <span class="n">copy</span><span class="o">-&gt;</span><span class="n">_friends</span> <span class="o">=</span> <span class="p">[</span><span class="n">_friends</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">copy</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.关于这儿是否需要对_friends进行copy的讨论，作者认为如果原变量是可变的，是需要深拷贝的，而如果原变量是不可变的，则直接进行指针赋值即可，这样可以省一部分内存。<br/>
4.如果你的类有mutable和immutable两个类型，那么应该分别遵循NSMutableCopying和NSCopying协议，分别返回可变和不可变的copy。<br/>
5.采取这种方式的好处是可以提供一个可变与不可变类型的转换，而且采用copy，immutableCopy，mutableCopy三个方法的缺陷是我们很难判断将要复制的对象是不是可变的。<br/>
6.接下来讨论的是深拷贝和浅拷贝的问题，OC默认的Copy协议支持的都是浅拷贝，也就是指针拷贝，但是一些类的初始化方法提供了深拷贝，例如NSSet的：-(id)initWithSet:(NSArray*)array copyItems:(BOOL)copyItems。所以如果你需要进行深拷贝，必须自己定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">deepCopy</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">EOCPerson</span> <span class="o">*</span><span class="n">copy</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">self</span> <span class="n">class</span><span class="p">]</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFirstName:</span><span class="n">_firstName</span> <span class="nl">andLastName:</span><span class="n">_lastName</span><span class="p">];</span>
</span><span class='line'>  <span class="n">copy</span><span class="o">-&gt;</span><span class="n">_friends</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableSet</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSet:</span><span class="n">_friends</span> <span class="nl">copyItems:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">copy</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记2]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/07/22/effective-objective-cdu-shu-bi-ji-2/"/>
    <updated>2015-07-22T17:09:55+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/07/22/effective-objective-cdu-shu-bi-ji-2</id>
    <content type="html"><![CDATA[<p>继续上一篇，这篇的主题是Objects，Messaging，and the Runtime。</p>

<!--more-->


<h2>Item6 Understand Properties</h2>

<ol>
<li>在C++和Java中常使用@public和@private来声明实例变量，但在OC中由于对象是在编译期间定义的，所以按照这种定义方法，在新增变量后会导致访问偏移量出错，除非重新编译，但是这样就失去了动态语言的优势。</li>
<li>OC的解决方案是将实例变量作为可存储内存偏移量的类对象，这同时可以将实例变量定义到实现文件中，从而实现隐藏。Apple鼓励使用存取方法而不是直接访问实例变量，也是为了解决这一问题，@property就是为了方便提供getter和setter方法。</li>
<li>OC中的点方法类似C中访问结构体的成员，但其实是编译器转化为了对应的getter方法。</li>
</ol>


<h3>Property Attributes</h3>

<ol>
<li>主要说下有关内存管理的property属性，主要有assign，strong，weak，unsafe_unretained，copy。</li>
<li>assign：主要用于标量的property属性，简单的赋值操作，引用计数不变。</li>
<li>strong：声明的是持有关系，新值会被retain，旧值release，引用计数加1。</li>
<li>weak：声明的是非持有关系，与assign类似，如果指向的对象被释放，该值也会被释放。</li>
<li>unsafe_unretained：可以理解为针对对象的assign属性，但是所指向的对象被释放后，该值不会被释放，所以容易造成野指针，一般很少用到它。</li>
<li>copy：与strong类似，只不过所赋值的引用计数不变，旧值会被赋给一个所赋值copy的引用计数为1的对象，一般用于不可变对象，可能被赋可变对象的值时，这样可确保旧值改变时，不可变对象不发生变化。</li>
<li>get=&lt;>：可以自定义getter方法的名字，一般用于布尔型property，一般getter方法以is开头。</li>
<li>额外1：如果对一不可变对象复制，copy是指针复制（浅拷贝）和mutableCopy就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。</li>
<li>额外2：不要在init（包括自定义的初始化方法）和dealloc中使用setter和getter方法。</li>
<li>atomic用以确保线程安全，但是iOS平台的property基本都是nonatomic的，主要是因为性能问题，而且atomic也并非完全是线程安全的（例如一个线程频繁访问一个对象时，另一线程同时在写入，前一线程也会拿到不同的值），而在Mac OS X就不存在这个性能瓶颈了。</li>
</ol>


<!--more-->


<h2>Item7 Access Instance Variables Primarliy Directly When Accessing Them Internally</h2>

<ol>
<li>本章讨论的是如何在内部使用实例变量，有两种方式，一是使用生成的存取方法，二是直接使用实例变量。</li>
<li>优缺点如下：

<ol>
<li>直接访问对象，速度会快，绕开了OC的method dispatch，编译器会直接访问存储对象的内存。</li>
<li>直接访问对象会绕开与内存相关的setter方法，例如你设置的copy型的setter，只会按照retain来执行。</li>
<li>直接访问对象不会触发KVO。</li>
<li>使用存取方法会使调试变得简单，你可以在getter/setter添加断点。</li>
</ol>
</li>
<li>比较推荐的做法是，在存对象的时候使用setter方法，而在读取对象时直接读取，这样既享受了快速读取，也可以利用property控制保存对象。</li>
<li>但是这么做还是有一些需要注意的地方：

<ol>
<li>在初始化方法中，一定要使用直接赋值的方法，主要是因为怕子类复写了对象的setter方法，而导致异常，如果一个对象声明在了父类的内部，而子类不能直接访问它，你也不能直接访问读取该变量，这种情况只能通过setter赋值
2.如果实例变量使用了延时加载，那么读取一定要使用getter方法，不然这个对象永远都不会有值。</li>
</ol>
</li>
</ol>


<!--more-->


<h2>Item8 Understand Object Equality</h2>

<ol>
<li>比较两个对象，不使用==，那样只会比较指针的值，而一般使用<em>isEqual:</em>，如果对象有自己的专有比较方法，例如<em>isEqualToString:</em>，优先使用这些方法，速度会快些。</li>
<li><em>&ndash;(NSUIntegetr)hash;</em>是一个与比较对象息息相关的方法，hash相同的对象不一定相同，而相同的对象hash值一定相同。</li>
<li>所以自定义对象重写<em>isEqual:</em>方法，也一定要重写hash方法，共有三种方案：

<ol>
<li>返回一个常数，这个方案优点是使用单个对象时快，但是如果把大量对象放入同一集合，由于hash值相同，集合会挨个检查这些对象是否真的相同，从而导致向一个集合添加大量对象时就会很慢；</li>
<li>使用一个拼接的唯一字符串，然后进行hash，这个方案避免了上面的问题，但是出现了单个对象需要生成一个字符串，从而影响了速度的问题；</li>
<li>先取一系列变量的hash值，再将其异或，这个方案算是为了避免上述问题的折衷方案。</li>
</ol>
</li>
</ol>


<h3>Class-Specific Equality Methods</h3>

<ol>
<li>自定义类可以通过重写<em>isEqual:</em>方法，在方法里判断如果是同一类型，就调用上面的比较方法，如不是就调用父类的<em>isEqual:</em>方法，这样可以实现子类也可以与父类进行比较。</li>
</ol>


<h3>Deep versus Shallow Equality</h3>

<ol>
<li>有时你并不需要判断对象的所有信息是否相同，比如来自数据库的信息，可能只通过判断id就可以进行判断，所谓的浅比较就是这样。</li>
</ol>


<h3>Equality of Mutable Classes in Containers</h3>

<ol>
<li>这一部分主要讲的是，向集合添加可变对象，然后改变该对象，是有可能让集合出现重复对象的，这点值得关注。</li>
</ol>


<!--more-->


<h2>Item9 Use the Class Cluster Pattern to Hide Implementation Detail</h2>

<ol>
<li>类簇是OC中很重要的一个设计模式，例如UIButton的创建，类簇解决的问题是需要统一创建同一基本类型的不同对象，而同时避免暴露子类和父类内部复杂的switch语句。</li>
</ol>


<h3>Creating a Class Cluster</h3>

<ol>
<li>创建类簇的思路：一个基类，一些空方法，一个创建对象的工厂方法，继承的子类对空方法重写。这样的类簇有个缺点就是用户可能以为自己使用的类就是那个基类，而不知道其实是它的子类。</li>
</ol>


<h3>Class Clusters in Cocoa</h3>

<ol>
<li>由于很多Cocoa类都是使用了类簇模式，所以类似<em>[maybeAnArray class] == [NSArray class]</em>这样的校验类型的方法是不会返回正确值的，而要使用<em>[maybeAnArray isKindOfClass:[NSArray class]]</em>。</li>
<li>添加一个类簇的子类而不去改写其基类的工厂方法，对于NSArray是可以的，但是有三点要求：1、必须是该类簇基类的子类；2、该子类必须定义自己的存储空间，也就是说内部要有一个NSArray的对象来实现数据的存储；3、子类必须重写类簇文档中规定重写的方法。</li>
</ol>


<!--more-->


<h2>Item10 Use Associated Objects to Attach Custom Data to Existing Classes</h2>

<ol>
<li>有时为了为一个类绑定一些信息，而又不方便添加多余的property或者继承这个类，可以考虑使用<em>association</em>，类似字典型的键值读取，也可以设置内存管理策略，但是需要注意绑定的key必须是唯一的指针，而不只是值相同，所以一般使用全局的静态变量作为key。</li>
</ol>


<h3>An Example of Using Associated Objects</h3>

<ol>
<li>通过使用<em>Associated Objects</em>实现了UIAlertView的回调Block化，使得代码的可读性更好，也更方便。</li>
<li><em>Associated Objects</em>提供了一个将对象之间互相绑定的方法，但是并不推荐大范围使用该方法，因为会导致调试变的更难。</li>
</ol>


<!--more-->


<h2>Item11 Understand the Role of objec_msgSend</h2>

<ol>
<li>OC利用动态绑定成为了真正的动态语言，OC中传递消息最终被转化为函数<em>void objc_msgSend(id self, SEL cmd, &hellip;)</em>，例如：<em>id returnValue = [someObkect messageName:parameter];</em>转化后，<em>id returnValue = objc_msgSend(someObject, @sleector(messageName:), parameter);</em>。</li>
<li><em>objc_msgSend</em>执行的顺序是先在接受者实现的方法中找符合的方法来执行，如没有，向继承链上方逐级寻找符合的实现方法。</li>
<li><em>objc_msgSend</em>会为每个类缓存一张查找表，来加速这一过程，但即使如此，还是比在C中直接调用静态调用函数慢，但这常常不是应用的瓶颈，这样来换取程序的灵活性还是值得的。</li>
<li><em>objc_msgSend</em>是针对确定消息的处理，下面还有一些处理个别案例的方法。</li>
<li><em>objc_msgSend_stret</em>用于处理用户返回适用于CPU寄存器的结构体的消息（不太懂）。</li>
<li><em>objc_msgSend_fpret</em>用于处理返回浮点值的消息，一些结构需要在函数调用时对浮点数寄存器特殊处理，所以这是该方法存在的意义（不太懂）。</li>
<li><em>objc_msgSendSuper</em>直接把消息转发给父类执行，类的所有方法都是一个个类似<em>&lt;return_type> Class_selector(id self, SEL _CMD, &hellip;)</em>这样的原型，这些方法指针存在该类的一个查找表中等待调用，该原型与<em>objc_msgSend</em>是相同的，也就实现了<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html">尾部递归调用</a>的可能，这样会实现调用栈的空间复杂度保持O(1)，不会产生溢出。</li>
</ol>


<!--more-->


<h2>Item12 Understand Message Forwarding</h2>

<ol>
<li>转发路径是为了处理接受者无法处理消息的情况，分为两条路径：1、<em>dynamic method resolution</em>期望接收者自己在runtime添加处理方法；2、<em>full forwarding mechanism</em>到了这一步，runtime得知接收者是不可能对消息做出响应了，所以要求接收者自己处理该消息，又分为两步：(1)询问是否有其他对象可以接收消息，如果有则转发给该对象；(2)如果也没有替代的接收者，那么将使用<em>NSInvocation</em>来对消息进行封装，然后交给原接收者去处理。<a href="http://bugly.qq.com/blog/?p=64">这儿也做了详细解释</a>。</li>
</ol>


<h3>Dynamic Method Resolution</h3>

<ol>
<li><em>+(BOOL)resolveInstanceMethod:(SEL)selector</em>用于表明类有无实例方法可处理该消息，可以说是给予该类的第二次机会。</li>
<li>这类方法是存在的，例如CoreData的@dynamic的property的accessing方法，而<em>+(BOOL)resolveInstanceMethod:(SEL)selector</em>对其的处理是判断是否是@dynamic property，如果是，向该类添加预备好的getter，setter方法，已确保类可以响应该消息。</li>
</ol>


<h3>Replacement Receiver</h3>

<ol>
<li><em>&ndash;(id)forwardTargetForSelector:(SEL)selector</em>用于返回可以替代原接收者的对象（如果其存在的话），这其实提供了一些多继承的特性，即原类内部可以有其他对象来实现这一方法。但是无法对消息进行修改，只是转发，如需修改消息，则需要采取最后一步。</li>
</ol>


<h3>Full Forwarding Mechanism</h3>

<ol>
<li>&ndash;(void)forwardInvocation:(NSInvocation*)invocation用于转发接收到的NSInvocation消息，可以进行简单转发，但这和上述的方法没有区别，而更为常见的用途是修改消息，如增加参数或者改变方法等。</li>
<li>重写该方法时需要调用父类的相同方法来处理改invocation，这样会最终调用NSObject的<em>doesNotRecognizeSelector</em>，最终抛出异常，但如果你不希望程序崩溃，就不要去调用父类的方法。</li>
</ol>


<h3>The Full Picture</h3>

<ol>
<li>具体图表见<a href="http://bugly.qq.com/blog/?p=64">这儿</a>。</li>
<li>解决的代价是越来越高的，所以最好在第一阶段解决这一问题。</li>
</ol>


<h3>Full Example of Dynamic Method Resolution</h3>

<ol>
<li>举例说明，将一个model中的所有对象都存在一个dictionary中，而这些对象申明为@dynamic，在<em>+(BOOL)resolveInstanceMethod:(SEL)selector</em>中根据selector的信息对相应的对象动态添加setter，getter方法，大幅减少代码量，但缺点是想特殊处理某个对象，就变得比较麻烦了。</li>
</ol>


<!--more-->


<h2>Item13 Consider Method Swizzling to Debug Opaque Methods</h2>

<ol>
<li><em>Method Swizzling</em>主要用于不知道类的源码，且不用继承、重写，即可为原方法添加hook的手段（其实是在runtime中先交换，再执行一次原方法而已-_-）。</li>
<li>通过添加一个类的分类，在分类添加一个方法，在这个方法中进行递归调用，然后与目标方法进行交换，这时再执行原方法时，会依次执行这两个方法。<a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411">另外一篇文章也有说明</a>。</li>
</ol>


<!--more-->


<h2>Item14 Understand What a Class Object Is</h2>

<ol>
<li>Class本身也是一个结构体指针，叫objc_class，Class也有一个Class类型的isa指针，说明Class本身也是一个OC对象，他的类型叫做metaclass，Class有Class类型的super_class指针，用来指向他的父类Class。</li>
</ol>


<h3>Inspecting the Class Hierarchy</h3>

<ol>
<li><em>isMemberOfClass:</em>用于判断是否属于该类，<em>isKindOfClass:</em>用于判断是否属于该类或者该类的子类。原理还是利用上述的Class的isa和super_class指针。</li>
<li>内省（自我类型检查）是OC中的重要技术，应用也很广泛，除了上述方法，也可利用<em>[object class] == [EOCSomeClass class]</em>来判断，之所以这么写是合理的，是因为每个class的Class类型是一个单例对象，所以可以直接比较指针。</li>
<li>但是还是推荐使用默认的类型检测方法，因为这样可以利用消息转发技术，如果一个对象的所有方法都是代理对象执行的，那么调用class方法只会返回代理对象的类型，而调用<em>isKindOfClass:</em>方法，代理会把消息转给被代理的对象，会得到正确的类型。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记1]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/07/20/effective-objective-cdu-shu-bi-ji-1/"/>
    <updated>2015-07-20T14:47:04+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/07/20/effective-objective-cdu-shu-bi-ji-1</id>
    <content type="html"><![CDATA[<p>关于书不多做介绍了，很有名的一本书，是Mattt Thompson大神写的，他是AFNetworking的主要作者，同时维护了<a href="http://nshipster.com">NSHipster</a>，这本书之前看了一次，但是没那么细致，打算再看一次，同时做做笔记。</p>

<!--more-->


<h2>Item1 Familiarize Yourself with Objective-C&rsquo;s Roots</h2>

<ol>
<li>OC采用消息传递而非函数调用的基本结构，二者最大区别是消息传递中运行时才决定执行的代码，而函数调用中编译器会决定执行的代码。所以运行期承担了OC运作的大部分工作，所以每当运行期更新时你的应用都会从中受益，而不需等到重新编译（最后这段，不是太明白）。</li>
<li>学好C会让你更好理解OC，诸如内存模型和引用计数这些概念。所有OC对象的内存都是<a href="http://mobile.51cto.com/iphone-394484.htm">开辟在堆上的，不在栈上</a>，栈是编译器控制的，堆是程序员控制的，而这些对象的指针是存放在栈上的，所以当指针不存在，而程序员又没有释放堆上的对象，就导致了内存泄露。</li>
<li>OC是通过引用计数来模拟内存的开辟与释放。</li>
<li>有些变量是直接开辟在栈上的，如CGRect，他是一个结构体，不同于对象，他们的使用不会影响性能。</li>
</ol>


<!--more-->


<h2>Item2 Minimize Importing Headers in Headers</h2>

<ol>
<li>尽量避免在类的头文件直接#import其他class的头文件，能使用@class尽量使用，有俩个好处：1、避免引用头文件的连锁效应，增加编译时间；2、避免了互相#import头文件而出现的循环导入的特殊情况。</li>
<li>一些需要导入头文件到.h文件的请款：1、class所继承的父类；2、使用protocol类型。</li>
<li>遵从的protocol可以放在匿名分类中#import。</li>
</ol>


<!--more-->


<h2>Item3 Prefer Literal Syntax over the Equivalent Methods</h2>

<ol>
<li>尽量多去使用文字型语法，这样可减少代码量，增加可读性。</li>
<li>关于NSArray的文字型创建语法，如果其中一个对象为nil，则会立即抛出异常，而使用传统的<em>arrayWithObjects:</em>则会在加入nil对象时停下，并不会报错，这使得我们更难发现这一问题。</li>
<li>唯一一个不足是文字型语法只接受Foundation框架的对象，而不接受自定义对象。</li>
</ol>


<!--more-->


<h2>Item4 Prefer Typed Constants to Preprocessor #define</h2>

<ol>
<li>尽量多使用静态常量，而不是预编译常量。原因只要是预编译常量是代码整体进行替换，容易被重赋值，常量的范围不好控制。类似<em>static const NSTimeInterval kAnimationDuration = 0.3</em></li>
<li>而如果要使用全局常量（比如注册和接受通知的名称），采用以下方式</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//in the header file</span>
</span><span class='line'><span class="k">extern</span> <span class="n">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">EOCStringConstant</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//in the implementation file</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">EOCStringConstant</span> <span class="o">=</span> <span class="s">@&quot;VALUE&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//基本类型常量</span>
</span><span class='line'><span class="c1">//EOCAnimatedView.h</span>
</span><span class='line'><span class="k">extern</span> <span class="k">const</span> <span class="n">NSTimeInterval</span> <span class="n">EOCAnimatedViewAnimationDuration</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//EOCAnimatedView.m</span>
</span><span class='line'><span class="k">const</span> <span class="n">NSTimeInterval</span> <span class="n">EOCAnimatedViewAnimationDuration</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>Item5 Use Enumerations for States, Options, and Status Codes</h2>

<p>1.使用枚举类型主要是用于定义状态和选项，可读性好是它最大的优点，c++11后OC开始支持自定义枚举类型所用的数据类型。<br/>
2.用枚举做选项时，可用位移的方式实现多个选项合并使用，这种方式广泛用于UIKit。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">typedef</span> <span class="nf">NS_OPTIONS</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">,</span> <span class="n">EOCPermittedDirection</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">EOCPermittedDirectionUp</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span>
</span><span class='line'>  <span class="n">EOCPermittedDirectionDown</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>
</span><span class='line'>  <span class="n">EOCPermittedDirectionLeft</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span>
</span><span class='line'>  <span class="n">EOCPermittedDirectionRight</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">EOCPermittedDirection</span> <span class="n">permittedDirection</span> <span class="o">=</span> <span class="n">EOCPermittedDirectionUp</span> <span class="o">|</span> <span class="n">EOCPermittedDirectionDown</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">permittedDirection</span> <span class="o">&amp;</span> <span class="n">EOCPermittedDirectionUp</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">//EOCPermittedDirectionUp is set</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.OC定义了专门定义枚举的宏，NS_ENUM和NS_OPTIONS，他们对兼容新旧编译器做了自动判断，推荐使用，如想使用可合并的枚举，必须使用NS_OPTIONS来定义。<br/>
4. 最后一点，对枚举型值执行switch语句时，不要添加default处理。</p>

<!--more-->


<p></p>
]]></content>
  </entry>
  
</feed>
