<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 刘毅的技术博客]]></title>
  <link href="http://lucifer1988.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://lucifer1988.github.io/"/>
  <updated>2015-08-28T10:09:25+08:00</updated>
  <id>http://lucifer1988.github.io/</id>
  <author>
    <name><![CDATA[刘毅]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记5]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/08/28/effective-objective-cdu-shu-bi-ji-5/"/>
    <updated>2015-08-28T10:07:04+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/08/28/effective-objective-cdu-shu-bi-ji-5</id>
    <content type="html"><![CDATA[<p>第五篇</p>

<!--more-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记4]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/08/24/effective-objective-cdu-shu-bi-ji-4/"/>
    <updated>2015-08-24T14:58:20+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/08/24/effective-objective-cdu-shu-bi-ji-4</id>
    <content type="html"><![CDATA[<p>第四部分开始讨论OC的两大重要特性，Protocols和Categories。Protocols类似Java中的interfaces，弥补了OC没有多继承的缺点，常被用于实现OC委托模式，但还有很多其他方面的用途。Categories则是提供了不继承而向类添加拓展的方法，这要归功于OC动态语言特性，但同时了解它使用时的常见问题也非常重要。</p>

<!--more-->


<h2>Item23 Use Delegate and Data Source Protocols for Interobject Communication</h2>

<ol>
<li>Delegate是用于对象之间进行数据交互的设计模式，使用它的好处是可以让不同的业务逻辑解耦，实现代码模块化。而在OC中实现这一模式，主要依靠Protocols。</li>
<li>怎么使用Delegate不介绍了，注意点是：1）命名最好和你需要委托的类相关，例如UITableView,UITableViewDelegate；2）类的delegate property是weak属性，原因是接受委托的对象一般会持有需要委托的对象，如果delegate设置为strong，需要委托的对象也会持有接受委托的对象，这样就会出现retain cycle。</li>
<li>Delegate一般都定义为option，除非一些方法是一定要被委托者实现的，同时对于option的方法，委托者需要在调用之前使用<em>respondsToSelector:</em>来内省，确保被委托者实现了该方法。</li>
<li>Delegate中定义的方法一定要清楚，而且一定要包括被委托者自身作为其中一个参数，这样如果存在同类型多个实例对象时，委托者可以在同一个方法中区分这些实例变量。</li>
<li>Protocols还可以用于DataSource模式，与Delegate模式区别是，对于一个Class来说，Delegate的信息是流出Class的，而DataSource的信息是流入Class的，设计Protocols也可以参照这一原则。</li>
<li>对于option的方法要进行<em>respondsToSelector:</em>来检测，但是对于一些需要频繁调用的方法，采用这一方式非常影响性能，作者利用了C中的由多个1bit字段组成的结构体来标识被委托对象是否响应所有方法，这基于被委托对象一般不会动态改变对方法的响应：</li>
</ol>


<p>```objectivec
@interface EOCNetworkFetcher(){</p>

<pre><code>struc {
    unsigned int didReceiveData:1;
    unsigned int didFailWithError:1;
    unsigned int didUpdateProgressTo:1;
} _delegateFlags;
</code></pre>

<p>}
@end</p>

<p>@implementation EOCNetworkFetcher</p>

<p>&ndash;(void)setDelegate:(id<EOCNetworkFetcherDelegate>delegate) {</p>

<pre><code>_delegate = delegate;
_delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher: didReceiveData:)];
_delegateFlags.didFailWithError = [delegate respondsToSelector:@selector(networkFetcher: didFailWithError:)];
_delegateFlags.didUpdateProgressTo = [delegate respondsToSelector:@selector(networkFetcher: didUpdateProgressTo:)];
</code></pre>

<p>}</p>

<p>//调用委托时
/*
if(_delegateFlags.didUpdateProgressTo) {</p>

<pre><code>[_delegate networkFetcher:self didUpdateProgressTo:currentProgress];
</code></pre>

<p>}
*/
@end
```</p>

<!--more-->


<h2>Item24 Use Categories to Break Class Implementations into Manageable Segments</h2>

<ol>
<li>分类这一特性主要为了解决一个类在开发中无限膨胀的问题，将一个类的方法按照功能进行分类处理是常规做法。</li>
<li>第二种用途是为了对代码进行分割增加可读性，例如NSURLRequest想增加专门的HTTP请求，单纯继承不是一个很好的选择，原因是NSURLRequest封装了一组针对CFURLRequest的C方法，无法通过继承获得，而直接添加这些HTTP的方法则会导致一些代码理解错误，例如开发者使用FTP协议，去发现可以调用关于HTTP的方法，所以将HTTP部分的方法做成NSHTTPURLRequest的分类是最好的选择。</li>
<li>第三个用途是方便调试，原因是分类中的方法在日志里会显示为类似：<em>&ndash;[EOCPerson(Friendship) addFriend:]</em>，可以方便定位该方法。</li>
<li>另外，在做一个库时，把一些私有方法用名为Private的分类封装，这样这些方法不用暴露在外，而内部又可以随意调用，而且外部万一用到了，也可以在日志中看到private的标志，起到了文档的作用。</li>
</ol>


<!--more-->


<h2>Item25 Always Prefix Category Names on Third-Party Classes</h2>

<ol>
<li>为一个类添加分类后，运行时runtime会遍历category每个方法，顺便加入类的方法列表，如果这时category重写了类的某个方法，这将覆盖原有的方法，如果多个category都出现这个情况，那么最后被载入的那个分类的方法会被采用，这两种情况都将导致Bug，且难以定位。</li>
<li>解决这一问题的方法只能是添加namespace，规则参考Item15，最好就是公司+项目这样的方式，而且最好将分类的名字也加namespace，这样可以避免warning。</li>
<li>要记住添加到一个类的category中的方法，只要被添加，在所有类的示例都可以调用（这里还是需要导入这个category才可以），尤其在为Cocoa中的类添加分类时时刻注意添加命名空间，去刻意重写类中的方法是一个非常坏的习惯，它带来的问题可能比好处大得多。</li>
</ol>


<!--more-->


<h2>Item26 Avoid Properties in Categories</h2>

<ol>
<li>category默认是不支持添加property的（匿名分类除外），虽然这一做法可以在技术上实现，但是依然不推荐这么做。</li>
<li>category不支持property，主要是无法自动合成setter和getter方法，解决这一问题有两个方法：1）使用Item12的做法，用@dynamic声明，重写message-forwarding的方法，在runtime添加setter和getter方法；2）使用Item10，使用associated objects，自己在getter和setter进行关联。</li>
<li>上述两个方法均可行，但作者认为这两个方法都不完美，缺点有二：1）内存管理，你很容易忘记这个property的特殊性，而只去修改property的关键字，而忘记去修改setter方法；2）如果你想让自己的property对象在内部支持mutable，可以在内部声明一个，mutable拷贝，但是这又会出现一个进入源代码的混乱路径，所以在category中定义property的代价是很高的。</li>
<li>作者建议的方法是把所有的变量都放入原类中，而category只提供额外的方法。</li>
<li>但有时category中可以添加只读变量，而且也不涉及读写原类的变量，但是虽然不报错，还是推荐使用一个方法来完成，因为真的没必要这么做。</li>
</ol>


<!--more-->


<h2>Item27 Use the Class-Continuation Category to Hide Implementation Detail</h2>

<p>1.OC是没有真正的私有方法的，但我们还是不希望把不需要暴露的方法和变量暴露在外，所以匿名分类就是一种隐藏这些细节的手段。<br/>
2.你可以将实例变量声明在匿名变量或implementation中，可以完全不用暴露你要导入的头文件等一切信息，例如：</p>

<p>```objectivec
@interface EOCPerson(){</p>

<pre><code>NSString *_anInstanceVariable;
</code></pre>

<p>}
//Method declarations here
@end</p>

<p>@implemenation EOCPerson {</p>

<pre><code>int _anotherInstanceVariable;
</code></pre>

<p>}
//Method implemenations here
@end
```</p>

<p>3.一般OC代码中使用C++一般两种情况：一些游戏相关的后端代码需要用C++，使用的第三方库使用了C++，而你作为使用者除非特殊情况，一定要使用匿名分类来使用C++，这样其他类使用你的类时，不用再因为C++的原因，将.m文件命名为.mm，而使编译器将其编为Objective-C++。Cocoa的web browser framework和CoreAnimation使用了这一模式。<br/>
4.还有一种应用就是在外部声明readonly的property，然后在匿名分类中再将其声明为readwrite，这样可以实现外部只能通过方法设置值，而内部可以正常使用该变量，可能会出现外部在访问，内部同时在赋值同步的问题，将在Item41讨论。<br/>
5.接下来就是可以在匿名分类声明私有方法，虽然这不是必须的，而作者比较推荐先列好方法，理清思路，再开始实现，如果是比较大的项目，还是需要这么干的。<br/>
6.最后就是可以在匿名分类添加委托。</p>

<!--more-->


<h2>Item28 Use a Protocol to Provide Anonymous Objects</h2>

<ol>
<li>利用Protocol可以实现创建一些匿名对象，例如：id<EOCDelegate> delegate。</li>
<li>例子1：来自多个第三方类库的数据库管理对象对应不同数据库类型，现在需要提供一个统一的Manager，来返回这些不同的对象，依靠基类继承是不可能的，只能通过定义一组数据库通用的操作作为Protocol，然后分别继承这些类，而新类则遵从这一protocol，这样Manager只需返回id<Protocol>类型的对象即可，而使用者也只需要知道它们实现了这些方法也足够了。</li>
<li>例子2：已确定只有一个类型，但其是一个内部使用的数据类型，不需要将其所有细节暴露，只需要暴露其中一部分方法即可，那么将这些方法声明为Protocol，然后返回类型定义为id<Protocol>即可，其实就是实现了对对象的大部分封装。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记3]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/08/17/effective-objective-cdu-shu-bi-ji-3/"/>
    <updated>2015-08-17T14:15:03+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/08/17/effective-objective-cdu-shu-bi-ji-3</id>
    <content type="html"><![CDATA[<p>第二部分主要讲了一些OC底层的运作机制，这一部分开始，主要涉及实践部分，第三部分的主题是：Interface and API Design。</p>

<!--more-->


<h2>Item15 Use Prefix Names to Avoid Namespace Clashes</h2>

<ol>
<li>OC是没有内建的命名空间的，所以必须采取措施避免这一问题。</li>
<li>解决方案是自己在所有类都添加自定义的前缀，一般是项目名缩写，但推荐使用三个字母，因为两个字母被苹果使用，所以重名的概率大。</li>
<li>在.m文件中的纯C函数和全局变量也有可能出现重名，所以定义时需格外注意，也要加上前缀。</li>
<li>还有一种可能，你自己封装的类库A和应用使用了同一类库B，而应用也使用了你的类库A，这样的话，只能手动将你自己使用的类库B的所有加上类库A的前缀，虽然麻烦，但是如果是大工程的话，必须这么做。</li>
</ol>


<!--more-->


<h2>Item16 Have a Designated Initializer</h2>

<ol>
<li>一个类可能有很多初始化方法，但其中基本初始化方法只需有一个，其他初始化方法只是参数变化，这样保证数据在一个方法中赋值，便于维护。</li>
<li>为了避免用户使用原始的<em>init:</em>方法而出现错误，该类中应该重写<em>init:</em>方法，可以做一个默认的赋值，或者直接抛出异常。</li>
<li>继承一个拥有基本初始化方法的类，子类的初始化方法要调用父类的基本初始化方法，而且需要重写父类的基本初始化方法，与上一条的理由一致。</li>
<li>有时可能需要两个基本初始化方法，特例比如遵循NSCoding的类，要有一个-(id)initWithCoder:(NSCoder*)decoder的初始化方法，而该类的子类也必须重写initWithCoder:，同时调用父类initWithCoder:。</li>
</ol>


<h2>Item17 Implement the description Method</h2>

<p>1.重写对象的-(NSString*)description方法，可以获得更多的实用信息，默认的只是类名和指针地址，这也是NSObject协议的其中一项。<br/>
2.这是一种将NSDictionary特性结合起来的description写法。</p>

<p>```objectivec
&ndash;(NSString *)description {</p>

<pre><code>return [NSString stringWithFormat:@"&lt;%@:%p,%@&gt;",
[self class],
self,
@{@"title": _title,
@"latitude": @(_latitude),
@"longitude": @(_longitude)}
];
</code></pre>

<p>}
```</p>

<p>3.LLDB中的<em>po</em>命令会执行print-object函数，它返回的是NSObject协议的另一方法-(NSString *)debugDescription，而这一方法默认返回的是description的结果，如果需要隐藏部分信息，可以分别重写这两个方法，OC默认类型很多就是这么干的，例如NSArray。</p>

<!--more-->


<h2>Item18 Prefer Immutable Objects</h2>

<ol>
<li>设计类的时候，其中的property除非必须可变，都应设计为不可变只读类型，之前Item8也讨论过类似问题，一个可变集合加入两个可变数组，然后设法改变数组，可能会出现集合中有相同数组，而不会报错的问题。</li>
<li>解决这个问题的设计是在.h文件中设置property为readonly，而在.m文件中添加匿名分类，重新定义相同的property为readwrite，这样实现了对外只读，而内部可以进行修改。</li>
<li>如果需要对外提供修改变量的方法，也不建议直接把可变变量暴露，而是对外还是暴露只读变量，内部再定义一个可变的内部变量，外部的只读变量的getter方法返回内部可变变量的copy，而同时添加增删的外部方法来操作内部变量。</li>
</ol>


<!--more-->


<h2>Item19 Use Clear and Consistent Naming</h2>

<ol>
<li>OC命名方式是尽量详细，多使用一些介词，表明方法功能，同时使用驼峰命名法。</li>
</ol>


<h3>Method Naming</h3>

<ol>
<li>如果一个方法返回了一个新对象，那么方法一般以该对象的类型开头。</li>
<li>一个参数前需要加一个名词来描述他的类型。</li>
<li>一个方法描述对一个对象进行操作时，需要包含一个动词，然后每个参数前依旧需要名词描述。</li>
<li>避免使用缩写，而使用全称，例如：<em>str</em>和<em>string</em>。</li>
<li><em>Boolean</em>类型的property的getter方法用<em>is</em>前缀，返回<em>Boolean</em>的方法应该以<em>has</em>或<em>is</em>作为前缀。</li>
<li>保留<em>get</em>关键字，在方法并无返回值，但是通过传入的参数，进行值的返回时使用get，比如：-(void)getCharacters:(unichar *)buffer range:(NSRange)aRange。</li>
</ol>


<h3>Class and Protocol Naming</h3>

<ol>
<li>主要是注意你继承的类要以其类名结尾，但前缀不要，要加上自己的前缀，协议要以Delegate结尾。</li>
</ol>


<!--more-->


<h2>Item20 Prefix Private Method Names</h2>

<ol>
<li>用特殊前缀标记类的私有方法，会在调试时更加方便，Matt的方式是在方法前加<em>p_</em>前缀，例如：<em>&ndash;(void)p_privateMethod</em>，当然你最好定义自己的方式。</li>
<li>Apple的方式是在方法前加<em>_</em>来标识私有方法，但不推荐开发者这么做，因为如果你继承了Cocoa的类，很容易覆盖原来的私有方法。</li>
</ol>


<!--more-->


<h2>Item21 Understand the Objective-C Error Model</h2>

<p>1.抛出exception后，本来将要释放的对象将得不到释放，所以会造成内存泄露，所以抛异常时一定是非常严重的错误出现的场景。<br/>
2.场景一是基类的一些必须被子类重写的方法可以抛出异常已告知开发者去重写，因为OC没有基类的特殊概念。</p>

<p>```objectivec
&ndash;(void)mustOverrideMethod {</p>

<pre><code>NSString *reason = [NSString stringWithFormat:@"%@ must be overridden", NSStringRromSelector(_cmd)];
@throw[NSException exceptionWithName:NSInternalInconsistencyException reason:reason userInfo:nil];
</code></pre>

<p>}
```</p>

<p>3.而处理一般的异常OC通常使用NSError，该类包含以下信息：<br/>
1）Error domain(String):表明错误发生的域，一般是自定义的全局变量，例如：<em>NSURLErrorDomain</em>。
2）Error code(Integer):表明特定域的错误码，参考HTTP的状态码。<br/>
3）Userinfo(Dictionary):额外的信息，包括本地化描述信息和导致该错误的原因。<br/>
4.NSError的一些使用场景：<br/>
1）被用于Delegate中，例如：-(void)connection:(NSURLConnection <em>)connection didFailWithError:(NSError </em>)error。<br/>
2）用于返回型参数，参照Item19，类似：<br/>
```objectivec
//&ndash;(BOOL)doSomething:(NSError<em>*)error
NSError </em>error = nil;
BOOL ret = [object doSomething:&amp;error];
if(error) {</p>

<pre><code>//There was an error
</code></pre>

<p>}
```<br/>
5.上述方法传入的是NSError<em><em>类型，开启ARC时该类型会转化为NSError</em> __autoreleasing</em>类型，该对象会在方法执行后自动释放，这么做，是因为doSomething:不能确定调用者会不会对NSError释放，大部分方法return的对象也是一样会添加autorelease（除了new，alloc，copy，mutableCopy等）。<br/>
6.doSomething的内部实现：</p>

<p>```objectivec
&ndash;(BOOL)doSomething:(NSError**)error {</p>

<pre><code>//Do something that may cause an error
if(/*there was an error*/) {
    //有必要检查error，有可能传入nil值
    if(error) {
        //Pass error through the out-parameter
        *error = [NSError errorWithDomain:domain code:code userInfo:userInfo];
    }
    return NO;
} else {
    return YES;
}
</code></pre>

<p>}
```</p>

<!--more-->


<h2>Item22 Understand the NSCopying Protocol</h2>

<p>1.想要让自定义对象实现copy功能，必须遵循NSCopying协议，其中只有一个方法需要重写：-(id)copyWithZone:(NSZone*)zone。<br/>
2.一个重写copyWithZone:方法的例子，<em>friends是内部变量，所以使用了copy-></em>friends：</p>

<p>```objectivec
&ndash;(id)copyWithZone:(NSZone *)zone {</p>

<pre><code>EOCPerson *copy = [[[self class] allocWithZone:zone] initWithFirstName:_firstName andLastName:_lastName];
copy-&gt;_friends = [_friends mutableCopy];
return copy;
</code></pre>

<p>}
```</p>

<p>3.关于这儿是否需要对_friends进行copy的讨论，作者认为如果原变量是可变的，是需要深拷贝的，而如果原变量是不可变的，则直接进行指针赋值即可，这样可以省一部分内存。<br/>
4.如果你的类有mutable和immutable两个类型，那么应该分别遵循NSMutableCopying和NSCopying协议，分别返回可变和不可变的copy。<br/>
5.采取这种方式的好处是可以提供一个可变与不可变类型的转换，而且采用copy，immutableCopy，mutableCopy三个方法的缺陷是我们很难判断将要复制的对象是不是可变的。<br/>
6.接下来讨论的是深拷贝和浅拷贝的问题，OC默认的Copy协议支持的都是浅拷贝，也就是指针拷贝，但是一些类的初始化方法提供了深拷贝，例如NSSet的：-(id)initWithSet:(NSArray*)array copyItems:(BOOL)copyItems。所以如果你需要进行深拷贝，必须自己定义：</p>

<p>```objectivec
&ndash;(id)deepCopy {</p>

<pre><code>EOCPerson *copy = [[[self class] alloc] initWithFirstName:_firstName andLastName:_lastName];
copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:YES];
return copy;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记2]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/07/22/effective-objective-cdu-shu-bi-ji-2/"/>
    <updated>2015-07-22T17:09:55+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/07/22/effective-objective-cdu-shu-bi-ji-2</id>
    <content type="html"><![CDATA[<p>继续上一篇，这篇的主题是Objects，Messaging，and the Runtime。</p>

<!--more-->


<h2>Item6 Understand Properties</h2>

<ol>
<li>在C++和Java中常使用@public和@private来声明实例变量，但在OC中由于对象是在编译期间定义的，所以按照这种定义方法，在新增变量后会导致访问偏移量出错，除非重新编译，但是这样就失去了动态语言的优势。</li>
<li>OC的解决方案是将实例变量作为可存储内存偏移量的类对象，这同时可以将实例变量定义到实现文件中，从而实现隐藏。Apple鼓励使用存取方法而不是直接访问实例变量，也是为了解决这一问题，@property就是为了方便提供getter和setter方法。</li>
<li>OC中的点方法类似C中访问结构体的成员，但其实是编译器转化为了对应的getter方法。</li>
</ol>


<h3>Property Attributes</h3>

<ol>
<li>主要说下有关内存管理的property属性，主要有assign，strong，weak，unsafe_unretained，copy。</li>
<li>assign：主要用于标量的property属性，简单的赋值操作，引用计数不变。</li>
<li>strong：声明的是持有关系，新值会被retain，旧值release，引用计数加1。</li>
<li>weak：声明的是非持有关系，与assign类似，如果指向的对象被释放，该值也会被释放。</li>
<li>unsafe_unretained：可以理解为针对对象的assign属性，但是所指向的对象被释放后，该值不会被释放，所以容易造成野指针，一般很少用到它。</li>
<li>copy：与strong类似，只不过所赋值的引用计数不变，旧值会被赋给一个所赋值copy的引用计数为1的对象，一般用于不可变对象，可能被赋可变对象的值时，这样可确保旧值改变时，不可变对象不发生变化。</li>
<li>get=&lt;>：可以自定义getter方法的名字，一般用于布尔型property，一般getter方法以is开头。</li>
<li>额外1：如果对一不可变对象复制，copy是指针复制（浅拷贝）和mutableCopy就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。</li>
<li>额外2：不要在init（包括自定义的初始化方法）和dealloc中使用setter和getter方法。</li>
<li>atomic用以确保线程安全，但是iOS平台的property基本都是nonatomic的，主要是因为性能问题，而且atomic也并非完全是线程安全的（例如一个线程频繁访问一个对象时，另一线程同时在写入，前一线程也会拿到不同的值），而在Mac OS X就不存在这个性能瓶颈了。</li>
</ol>


<!--more-->


<h2>Item7 Access Instance Variables Primarliy Directly When Accessing Them Internally</h2>

<ol>
<li>本章讨论的是如何在内部使用实例变量，有两种方式，一是使用生成的存取方法，二是直接使用实例变量。</li>
<li>优缺点如下：

<ol>
<li>直接访问对象，速度会快，绕开了OC的method dispatch，编译器会直接访问存储对象的内存。</li>
<li>直接访问对象会绕开与内存相关的setter方法，例如你设置的copy型的setter，只会按照retain来执行。</li>
<li>直接访问对象不会触发KVO。</li>
<li>使用存取方法会使调试变得简单，你可以在getter/setter添加断点。</li>
</ol>
</li>
<li>比较推荐的做法是，在存对象的时候使用setter方法，而在读取对象时直接读取，这样既享受了快速读取，也可以利用property控制保存对象。</li>
<li>但是这么做还是有一些需要注意的地方：

<ol>
<li>在初始化方法中，一定要使用直接赋值的方法，主要是因为怕子类复写了对象的setter方法，而导致异常，如果一个对象声明在了父类的内部，而子类不能直接访问它，你也不能直接访问读取该变量，这种情况只能通过setter赋值
2.如果实例变量使用了延时加载，那么读取一定要使用getter方法，不然这个对象永远都不会有值。</li>
</ol>
</li>
</ol>


<!--more-->


<h2>Item8 Understand Object Equality</h2>

<ol>
<li>比较两个对象，不使用==，那样只会比较指针的值，而一般使用<em>isEqual:</em>，如果对象有自己的专有比较方法，例如<em>isEqualToString:</em>，优先使用这些方法，速度会快些。</li>
<li><em>&ndash;(NSUIntegetr)hash;</em>是一个与比较对象息息相关的方法，hash相同的对象不一定相同，而相同的对象hash值一定相同。</li>
<li>所以自定义对象重写<em>isEqual:</em>方法，也一定要重写hash方法，共有三种方案：

<ol>
<li>返回一个常数，这个方案优点是使用单个对象时快，但是如果把大量对象放入同一集合，由于hash值相同，集合会挨个检查这些对象是否真的相同，从而导致向一个集合添加大量对象时就会很慢；</li>
<li>使用一个拼接的唯一字符串，然后进行hash，这个方案避免了上面的问题，但是出现了单个对象需要生成一个字符串，从而影响了速度的问题；</li>
<li>先取一系列变量的hash值，再将其异或，这个方案算是为了避免上述问题的折衷方案。</li>
</ol>
</li>
</ol>


<h3>Class-Specific Equality Methods</h3>

<ol>
<li>自定义类可以通过重写<em>isEqual:</em>方法，在方法里判断如果是同一类型，就调用上面的比较方法，如不是就调用父类的<em>isEqual:</em>方法，这样可以实现子类也可以与父类进行比较。</li>
</ol>


<h3>Deep versus Shallow Equality</h3>

<ol>
<li>有时你并不需要判断对象的所有信息是否相同，比如来自数据库的信息，可能只通过判断id就可以进行判断，所谓的浅比较就是这样。</li>
</ol>


<h3>Equality of Mutable Classes in Containers</h3>

<ol>
<li>这一部分主要讲的是，向集合添加可变对象，然后改变该对象，是有可能让集合出现重复对象的，这点值得关注。</li>
</ol>


<!--more-->


<h2>Item9 Use the Class Cluster Pattern to Hide Implementation Detail</h2>

<ol>
<li>类簇是OC中很重要的一个设计模式，例如UIButton的创建，类簇解决的问题是需要统一创建同一基本类型的不同对象，而同时避免暴露子类和父类内部复杂的switch语句。</li>
</ol>


<h3>Creating a Class Cluster</h3>

<ol>
<li>创建类簇的思路：一个基类，一些空方法，一个创建对象的工厂方法，继承的子类对空方法重写。这样的类簇有个缺点就是用户可能以为自己使用的类就是那个基类，而不知道其实是它的子类。</li>
</ol>


<h3>Class Clusters in Cocoa</h3>

<ol>
<li>由于很多Cocoa类都是使用了类簇模式，所以类似<em>[maybeAnArray class] == [NSArray class]</em>这样的校验类型的方法是不会返回正确值的，而要使用<em>[maybeAnArray isKindOfClass:[NSArray class]]</em>。</li>
<li>添加一个类簇的子类而不去改写其基类的工厂方法，对于NSArray是可以的，但是有三点要求：1、必须是该类簇基类的子类；2、该子类必须定义自己的存储空间，也就是说内部要有一个NSArray的对象来实现数据的存储；3、子类必须重写类簇文档中规定重写的方法。</li>
</ol>


<!--more-->


<h2>Item10 Use Associated Objects to Attach Custom Data to Existing Classes</h2>

<ol>
<li>有时为了为一个类绑定一些信息，而又不方便添加多余的property或者继承这个类，可以考虑使用<em>association</em>，类似字典型的键值读取，也可以设置内存管理策略，但是需要注意绑定的key必须是唯一的指针，而不只是值相同，所以一般使用全局的静态变量作为key。</li>
</ol>


<h3>An Example of Using Associated Objects</h3>

<ol>
<li>通过使用<em>Associated Objects</em>实现了UIAlertView的回调Block化，使得代码的可读性更好，也更方便。</li>
<li><em>Associated Objects</em>提供了一个将对象之间互相绑定的方法，但是并不推荐大范围使用该方法，因为会导致调试变的更难。</li>
</ol>


<!--more-->


<h2>Item11 Understand the Role of objec_msgSend</h2>

<ol>
<li>OC利用动态绑定成为了真正的动态语言，OC中传递消息最终被转化为函数<em>void objc_msgSend(id self, SEL cmd, &hellip;)</em>，例如：<em>id returnValue = [someObkect messageName:parameter];</em>转化后，<em>id returnValue = objc_msgSend(someObject, @sleector(messageName:), parameter);</em>。</li>
<li><em>objc_msgSend</em>执行的顺序是先在接受者实现的方法中找符合的方法来执行，如没有，向继承链上方逐级寻找符合的实现方法。</li>
<li><em>objc_msgSend</em>会为每个类缓存一张查找表，来加速这一过程，但即使如此，还是比在C中直接调用静态调用函数慢，但这常常不是应用的瓶颈，这样来换取程序的灵活性还是值得的。</li>
<li><em>objc_msgSend</em>是针对确定消息的处理，下面还有一些处理个别案例的方法。</li>
<li><em>objc_msgSend_stret</em>用于处理用户返回适用于CPU寄存器的结构体的消息（不太懂）。</li>
<li><em>objc_msgSend_fpret</em>用于处理返回浮点值的消息，一些结构需要在函数调用时对浮点数寄存器特殊处理，所以这是该方法存在的意义（不太懂）。</li>
<li><em>objc_msgSendSuper</em>直接把消息转发给父类执行，类的所有方法都是一个个类似<em>&lt;return_type> Class_selector(id self, SEL _CMD, &hellip;)</em>这样的原型，这些方法指针存在该类的一个查找表中等待调用，该原型与<em>objc_msgSend</em>是相同的，也就实现了<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html">尾部递归调用</a>的可能，这样会实现调用栈的空间复杂度保持O(1)，不会产生溢出。</li>
</ol>


<!--more-->


<h2>Item12 Understand Message Forwarding</h2>

<ol>
<li>转发路径是为了处理接受者无法处理消息的情况，分为两条路径：1、<em>dynamic method resolution</em>期望接收者自己在runtime添加处理方法；2、<em>full forwarding mechanism</em>到了这一步，runtime得知接收者是不可能对消息做出响应了，所以要求接收者自己处理该消息，又分为两步：(1)询问是否有其他对象可以接收消息，如果有则转发给该对象；(2)如果也没有替代的接收者，那么将使用<em>NSInvocation</em>来对消息进行封装，然后交给原接收者去处理。<a href="http://bugly.qq.com/blog/?p=64">这儿也做了详细解释</a>。</li>
</ol>


<h3>Dynamic Method Resolution</h3>

<ol>
<li><em>+(BOOL)resolveInstanceMethod:(SEL)selector</em>用于表明类有无实例方法可处理该消息，可以说是给予该类的第二次机会。</li>
<li>这类方法是存在的，例如CoreData的@dynamic的property的accessing方法，而<em>+(BOOL)resolveInstanceMethod:(SEL)selector</em>对其的处理是判断是否是@dynamic property，如果是，向该类添加预备好的getter，setter方法，已确保类可以响应该消息。</li>
</ol>


<h3>Replacement Receiver</h3>

<ol>
<li><em>&ndash;(id)forwardTargetForSelector:(SEL)selector</em>用于返回可以替代原接收者的对象（如果其存在的话），这其实提供了一些多继承的特性，即原类内部可以有其他对象来实现这一方法。但是无法对消息进行修改，只是转发，如需修改消息，则需要采取最后一步。</li>
</ol>


<h3>Full Forwarding Mechanism</h3>

<ol>
<li>&ndash;(void)forwardInvocation:(NSInvocation*)invocation用于转发接收到的NSInvocation消息，可以进行简单转发，但这和上述的方法没有区别，而更为常见的用途是修改消息，如增加参数或者改变方法等。</li>
<li>重写该方法时需要调用父类的相同方法来处理改invocation，这样会最终调用NSObject的<em>doesNotRecognizeSelector</em>，最终抛出异常，但如果你不希望程序崩溃，就不要去调用父类的方法。</li>
</ol>


<h3>The Full Picture</h3>

<ol>
<li>具体图表见<a href="http://bugly.qq.com/blog/?p=64">这儿</a>。</li>
<li>解决的代价是越来越高的，所以最好在第一阶段解决这一问题。</li>
</ol>


<h3>Full Example of Dynamic Method Resolution</h3>

<ol>
<li>举例说明，将一个model中的所有对象都存在一个dictionary中，而这些对象申明为@dynamic，在<em>+(BOOL)resolveInstanceMethod:(SEL)selector</em>中根据selector的信息对相应的对象动态添加setter，getter方法，大幅减少代码量，但缺点是想特殊处理某个对象，就变得比较麻烦了。</li>
</ol>


<!--more-->


<h2>Item13 Consider Method Swizzling to Debug Opaque Methods</h2>

<ol>
<li><em>Method Swizzling</em>主要用于不知道类的源码，且不用继承、重写，即可为原方法添加hook的手段（其实是在runtime中先交换，再执行一次原方法而已-_-）。</li>
<li>通过添加一个类的分类，在分类添加一个方法，在这个方法中进行递归调用，然后与目标方法进行交换，这时再执行原方法时，会依次执行这两个方法。<a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411">另外一篇文章也有说明</a>。</li>
</ol>


<!--more-->


<h2>Item14 Understand What a Class Object Is</h2>

<ol>
<li>Class本身也是一个结构体指针，叫objc_class，Class也有一个Class类型的isa指针，说明Class本身也是一个OC对象，他的类型叫做metaclass，Class有Class类型的super_class指针，用来指向他的父类Class。</li>
</ol>


<h3>Inspecting the Class Hierarchy</h3>

<ol>
<li><em>isMemberOfClass:</em>用于判断是否属于该类，<em>isKindOfClass:</em>用于判断是否属于该类或者该类的子类。原理还是利用上述的Class的isa和super_class指针。</li>
<li>内省（自我类型检查）是OC中的重要技术，应用也很广泛，除了上述方法，也可利用<em>[object class] == [EOCSomeClass class]</em>来判断，之所以这么写是合理的，是因为每个class的Class类型是一个单例对象，所以可以直接比较指针。</li>
<li>但是还是推荐使用默认的类型检测方法，因为这样可以利用消息转发技术，如果一个对象的所有方法都是代理对象执行的，那么调用class方法只会返回代理对象的类型，而调用<em>isKindOfClass:</em>方法，代理会把消息转给被代理的对象，会得到正确的类型。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记1]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/07/20/effective-objective-cdu-shu-bi-ji-1/"/>
    <updated>2015-07-20T14:47:04+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/07/20/effective-objective-cdu-shu-bi-ji-1</id>
    <content type="html"><![CDATA[<p>关于书不多做介绍了，很有名的一本书，是Mattt Thompson大神写的，他是AFNetworking的主要作者，同时维护了<a href="http://nshipster.com">NSHipster</a>，这本书之前看了一次，但是没那么细致，打算再看一次，同时做做笔记。</p>

<!--more-->


<h2>Item1 Familiarize Yourself with Objective-C&rsquo;s Roots</h2>

<ol>
<li>OC采用消息传递而非函数调用的基本结构，二者最大区别是消息传递中运行时才决定执行的代码，而函数调用中编译器会决定执行的代码。所以运行期承担了OC运作的大部分工作，所以每当运行期更新时你的应用都会从中受益，而不需等到重新编译（最后这段，不是太明白）。</li>
<li>学好C会让你更好理解OC，诸如内存模型和引用计数这些概念。所有OC对象的内存都是<a href="http://mobile.51cto.com/iphone-394484.htm">开辟在堆上的，不在栈上</a>，栈是编译器控制的，堆是程序员控制的，而这些对象的指针是存放在栈上的，所以当指针不存在，而程序员又没有释放堆上的对象，就导致了内存泄露。</li>
<li>OC是通过引用计数来模拟内存的开辟与释放。</li>
<li>有些变量是直接开辟在栈上的，如CGRect，他是一个结构体，不同于对象，他们的使用不会影响性能。</li>
</ol>


<!--more-->


<h2>Item2 Minimize Importing Headers in Headers</h2>

<ol>
<li>尽量避免在类的头文件直接#import其他class的头文件，能使用@class尽量使用，有俩个好处：1、避免引用头文件的连锁效应，增加编译时间；2、避免了互相#import头文件而出现的循环导入的特殊情况。</li>
<li>一些需要导入头文件到.h文件的请款：1、class所继承的父类；2、使用protocol类型。</li>
<li>遵从的protocol可以放在匿名分类中#import。</li>
</ol>


<!--more-->


<h2>Item3 Prefer Literal Syntax over the Equivalent Methods</h2>

<ol>
<li>尽量多去使用文字型语法，这样可减少代码量，增加可读性。</li>
<li>关于NSArray的文字型创建语法，如果其中一个对象为nil，则会立即抛出异常，而使用传统的<em>arrayWithObjects:</em>则会在加入nil对象时停下，并不会报错，这使得我们更难发现这一问题。</li>
<li>唯一一个不足是文字型语法只接受Foundation框架的对象，而不接受自定义对象。</li>
</ol>


<!--more-->


<h2>Item4 Prefer Typed Constants to Preprocessor #define</h2>

<ol>
<li>尽量多使用静态常量，而不是预编译常量。原因只要是预编译常量是代码整体进行替换，容易被重赋值，常量的范围不好控制。类似<em>static const NSTimeInterval kAnimationDuration = 0.3</em></li>
<li>而如果要使用全局常量（比如注册和接受通知的名称），采用以下方式</li>
</ol>


<p>```objectivec
//in the header file
extern NSString *const EOCStringConstant;</p>

<p>//in the implementation file
NSString *const EOCStringConstant = @&ldquo;VALUE&rdquo;;</p>

<p>//基本类型常量
//EOCAnimatedView.h
extern const NSTimeInterval EOCAnimatedViewAnimationDuration;</p>

<p>//EOCAnimatedView.m
const NSTimeInterval EOCAnimatedViewAnimationDuration = 0.3;</p>

<p>```</p>

<!--more-->


<h2>Item5 Use Enumerations for States, Options, and Status Codes</h2>

<p>1.使用枚举类型主要是用于定义状态和选项，可读性好是它最大的优点，c++11后OC开始支持自定义枚举类型所用的数据类型。<br/>
2.用枚举做选项时，可用位移的方式实现多个选项合并使用，这种方式广泛用于UIKit。</p>

<p>```objectivec
typedef NS_OPTIONS(NSUInteger, EOCPermittedDirection) {
  EOCPermittedDirectionUp = 1&lt;&lt;0,
  EOCPermittedDirectionDown = 1&lt;&lt;1,
  EOCPermittedDirectionLeft = 1&lt;&lt;2,
  EOCPermittedDirectionRight = 1&lt;&lt;3,
}</p>

<p>EOCPermittedDirection permittedDirection = EOCPermittedDirectionUp | EOCPermittedDirectionDown;
if(permittedDirection &amp; EOCPermittedDirectionUp) {
  //EOCPermittedDirectionUp is set
}
```</p>

<p>3.OC定义了专门定义枚举的宏，NS_ENUM和NS_OPTIONS，他们对兼容新旧编译器做了自动判断，推荐使用，如想使用可合并的枚举，必须使用NS_OPTIONS来定义。<br/>
4. 最后一点，对枚举型值执行switch语句时，不要添加default处理。</p>

<!--more-->


<p></p>
]]></content>
  </entry>
  
</feed>
