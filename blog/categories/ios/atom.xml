<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 刘毅的技术博客]]></title>
  <link href="http://lucifer1988.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://lucifer1988.github.io/"/>
  <updated>2015-08-24T11:50:10+08:00</updated>
  <id>http://lucifer1988.github.io/</id>
  <author>
    <name><![CDATA[刘毅]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记3]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/08/17/effective-objective-cdu-shu-bi-ji-3/"/>
    <updated>2015-08-17T14:15:03+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/08/17/effective-objective-cdu-shu-bi-ji-3</id>
    <content type="html"><![CDATA[<p>第二部分主要讲了一些OC底层的运作机制，这一部分开始，主要涉及实践部分，第三部分的主题是：Interface and API Design。</p>

<!--more-->


<h2>Item15 Use Prefix Names to Avoid Namespace Clashes</h2>

<ol>
<li>OC是没有内建的命名空间的，所以必须采取措施避免这一问题。</li>
<li>解决方案是自己在所有类都添加自定义的前缀，一般是项目名缩写，但推荐使用三个字母，因为两个字母被苹果使用，所以重名的概率大。</li>
<li>在.m文件中的纯C函数和全局变量也有可能出现重名，所以定义时需格外注意，也要加上前缀。</li>
<li>还有一种可能，你自己封装的类库A和应用使用了同一类库B，而应用也使用了你的类库A，这样的话，只能手动将你自己使用的类库B的所有加上类库A的前缀，虽然麻烦，但是如果是大工程的话，必须这么做。</li>
</ol>


<!--more-->


<h2>Item16 Have a Designated Initializer</h2>

<ol>
<li>一个类可能有很多初始化方法，但其中基本初始化方法只需有一个，其他初始化方法只是参数变化，这样保证数据在一个方法中赋值，便于维护。</li>
<li>为了避免用户使用原始的<em>init:</em>方法而出现错误，该类中应该重写<em>init:</em>方法，可以做一个默认的赋值，或者直接抛出异常。</li>
<li>继承一个拥有基本初始化方法的类，子类的初始化方法要调用父类的基本初始化方法，而且需要重写父类的基本初始化方法，与上一条的理由一致。</li>
<li>有时可能需要两个基本初始化方法，特例比如遵循NSCoding的类，要有一个-(id)initWithCoder:(NSCoder*)decoder的初始化方法，而该类的子类也必须重写initWithCoder:，同时调用父类initWithCoder:。</li>
</ol>


<h2>Item17 Implement the description Method</h2>

<p>1.重写对象的-(NSString*)description方法，可以获得更多的实用信息，默认的只是类名和指针地址，这也是NSObject协议的其中一项。<br/>
2.这是一种将NSDictionary特性结合起来的description写法。</p>

<p>```objectivec
&ndash;(NSString *)description {</p>

<pre><code>return [NSString stringWithFormat:@"&lt;%@:%p,%@&gt;",
[self class],
self,
@{@"title": _title,
@"latitude": @(_latitude),
@"longitude": @(_longitude)}
];
</code></pre>

<p>}
```</p>

<p>3.LLDB中的<em>po</em>命令会执行print-object函数，它返回的是NSObject协议的另一方法-(NSString *)debugDescription，而这一方法默认返回的是description的结果，如果需要隐藏部分信息，可以分别重写这两个方法，OC默认类型很多就是这么干的，例如NSArray。</p>

<!--more-->


<h2>Item18 Prefer Immutable Objects</h2>

<ol>
<li>设计类的时候，其中的property除非必须可变，都应设计为不可变只读类型，之前Item8也讨论过类似问题，一个可变集合加入两个可变数组，然后设法改变数组，可能会出现集合中有相同数组，而不会报错的问题。</li>
<li>解决这个问题的设计是在.h文件中设置property为readonly，而在.m文件中添加匿名分类，重新定义相同的property为readwrite，这样实现了对外只读，而内部可以进行修改。</li>
<li>如果需要对外提供修改变量的方法，也不建议直接把可变变量暴露，而是对外还是暴露只读变量，内部再定义一个可变的内部变量，外部的只读变量的getter方法返回内部可变变量的copy，而同时添加增删的外部方法来操作内部变量。</li>
</ol>


<!--more-->


<h2>Item19 Use Clear and Consistent Naming</h2>

<ol>
<li>OC命名方式是尽量详细，多使用一些介词，表明方法功能，同时使用驼峰命名法。</li>
</ol>


<h3>Method Naming</h3>

<ol>
<li>如果一个方法返回了一个新对象，那么方法一般以该对象的类型开头。</li>
<li>一个参数前需要加一个名词来描述他的类型。</li>
<li>一个方法描述对一个对象进行操作时，需要包含一个动词，然后每个参数前依旧需要名词描述。</li>
<li>避免使用缩写，而使用全称，例如：<em>str</em>和<em>string</em>。</li>
<li><em>Boolean</em>类型的property的getter方法用<em>is</em>前缀，返回<em>Boolean</em>的方法应该以<em>has</em>或<em>is</em>作为前缀。</li>
<li>保留<em>get</em>关键字，在方法并无返回值，但是通过传入的参数，进行值的返回时使用get，比如：-(void)getCharacters:(unichar *)buffer range:(NSRange)aRange。</li>
</ol>


<h3>Class and Protocol Naming</h3>

<ol>
<li>主要是注意你继承的类要以其类名结尾，但前缀不要，要加上自己的前缀，协议要以Delegate结尾。</li>
</ol>


<!--more-->


<h2>Item20 Prefix Private Method Names</h2>

<ol>
<li>用特殊前缀标记类的私有方法，会在调试时更加方便，Matt的方式是在方法前加<em>p_</em>前缀，例如：<em>&ndash;(void)p_privateMethod</em>，当然你最好定义自己的方式。</li>
<li>Apple的方式是在方法前加<em>_</em>来标识私有方法，但不推荐开发者这么做，因为如果你继承了Cocoa的类，很容易覆盖原来的私有方法。</li>
</ol>


<!--more-->


<h2>Item21 Understand the Objective-C Error Model</h2>

<p>1.抛出exception后，本来将要释放的对象将得不到释放，所以会造成内存泄露，所以抛异常时一定是非常严重的错误出现的场景。<br/>
2.场景一是基类的一些必须被子类重写的方法可以抛出异常已告知开发者去重写，因为OC没有基类的特殊概念。</p>

<p>```objectivec
&ndash;(void)mustOverrideMethod {</p>

<pre><code>NSString *reason = [NSString stringWithFormat:@"%@ must be overridden", NSStringRromSelector(_cmd)];
@throw[NSException exceptionWithName:NSInternalInconsistencyException reason:reason userInfo:nil];
</code></pre>

<p>}
```</p>

<p>3.而处理一般的异常OC通常使用NSError，该类包含以下信息：<br/>
1）Error domain(String):表明错误发生的域，一般是自定义的全局变量，例如：<em>NSURLErrorDomain</em>。
2）Error code(Integer):表明特定域的错误码，参考HTTP的状态码。<br/>
3）Userinfo(Dictionary):额外的信息，包括本地化描述信息和导致该错误的原因。<br/>
4.NSError的一些使用场景：<br/>
1）被用于Delegate中，例如：-(void)connection:(NSURLConnection <em>)connection didFailWithError:(NSError </em>)error。<br/>
2）用于返回型参数，参照Item19，类似：<br/>
```objectivec
//&ndash;(BOOL)doSomething:(NSError<em>*)error
NSError </em>error = nil;
BOOL ret = [object doSomething:&amp;error];
if(error) {</p>

<pre><code>//There was an error
</code></pre>

<p>}
```<br/>
5.上述方法传入的是NSError<em><em>类型，开启ARC时该类型会转化为NSError</em> __autoreleasing</em>类型，该对象会在方法执行后自动释放，这么做，是因为doSomething:不能确定调用者会不会对NSError释放，大部分方法return的对象也是一样会添加autorelease（除了new，alloc，copy，mutableCopy等）。<br/>
6.doSomething的内部实现：</p>

<p>```objectivec
&ndash;(BOOL)doSomething:(NSError**)error {</p>

<pre><code>//Do something that may cause an error
if(/*there was an error*/) {
    //有必要检查error，有可能传入nil值
    if(error) {
        //Pass error through the out-parameter
        *error = [NSError errorWithDomain:domain code:code userInfo:userInfo];
    }
    return NO;
} else {
    return YES;
}
</code></pre>

<p>}
```</p>

<!--more-->


<h2>Item22 Understand the NSCopying Protocol</h2>

<p>1.想要让自定义对象实现copy功能，必须遵循NSCopying协议，其中只有一个方法需要重写：-(id)copyWithZone:(NSZone*)zone。<br/>
2.一个重写copyWithZone:方法的例子，<em>friends是内部变量，所以使用了copy-></em>friends：</p>

<p>```objectivec
&ndash;(id)copyWithZone:(NSZone *)zone {</p>

<pre><code>EOCPerson *copy = [[[self class] allocWithZone:zone] initWithFirstName:_firstName andLastName:_lastName];
copy-&gt;_friends = [_friends mutableCopy];
return copy;
</code></pre>

<p>}
```</p>

<p>3.关于这儿是否需要对_friends进行copy的讨论，作者认为如果原变量是可变的，是需要深拷贝的，而如果原变量是不可变的，则直接进行指针赋值即可，这样可以省一部分内存。<br/>
4.如果你的类有mutable和immutable两个类型，那么应该分别遵循NSMutableCopying和NSCopying协议，分别返回可变和不可变的copy。<br/>
5.采取这种方式的好处是可以提供一个可变与不可变类型的转换，而且采用copy，immutableCopy，mutableCopy三个方法的缺陷是我们很难判断将要复制的对象是不是可变的。<br/>
6.接下来讨论的是深拷贝和浅拷贝的问题，OC默认的Copy协议支持的都是浅拷贝，也就是指针拷贝，但是一些类的初始化方法提供了深拷贝，例如NSSet的：-(id)initWithSet:(NSArray*)array copyItems:(BOOL)copyItems。所以如果你需要进行深拷贝，必须自己定义：</p>

<p>```objectivec
&ndash;(id)deepCopy {</p>

<pre><code>EOCPerson *copy = [[[self class] alloc] initWithFirstName:_firstName andLastName:_lastName];
copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:YES];
return copy;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记2]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/07/22/effective-objective-cdu-shu-bi-ji-2/"/>
    <updated>2015-07-22T17:09:55+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/07/22/effective-objective-cdu-shu-bi-ji-2</id>
    <content type="html"><![CDATA[<p>继续上一篇，这篇的主题是Objects，Messaging，and the Runtime。</p>

<!--more-->


<h2>Item6 Understand Properties</h2>

<ol>
<li>在C++和Java中常使用@public和@private来声明实例变量，但在OC中由于对象是在编译期间定义的，所以按照这种定义方法，在新增变量后会导致访问偏移量出错，除非重新编译，但是这样就失去了动态语言的优势。</li>
<li>OC的解决方案是将实例变量作为可存储内存偏移量的类对象，这同时可以将实例变量定义到实现文件中，从而实现隐藏。Apple鼓励使用存取方法而不是直接访问实例变量，也是为了解决这一问题，@property就是为了方便提供getter和setter方法。</li>
<li>OC中的点方法类似C中访问结构体的成员，但其实是编译器转化为了对应的getter方法。</li>
</ol>


<h3>Property Attributes</h3>

<ol>
<li>主要说下有关内存管理的property属性，主要有assign，strong，weak，unsafe_unretained，copy。</li>
<li>assign：主要用于标量的property属性，简单的赋值操作，引用计数不变。</li>
<li>strong：声明的是持有关系，新值会被retain，旧值release，引用计数加1。</li>
<li>weak：声明的是非持有关系，与assign类似，如果指向的对象被释放，该值也会被释放。</li>
<li>unsafe_unretained：可以理解为针对对象的assign属性，但是所指向的对象被释放后，该值不会被释放，所以容易造成野指针，一般很少用到它。</li>
<li>copy：与strong类似，只不过所赋值的引用计数不变，旧值会被赋给一个所赋值copy的引用计数为1的对象，一般用于不可变对象，可能被赋可变对象的值时，这样可确保旧值改变时，不可变对象不发生变化。</li>
<li>get=&lt;>：可以自定义getter方法的名字，一般用于布尔型property，一般getter方法以is开头。</li>
<li>额外1：如果对一不可变对象复制，copy是指针复制（浅拷贝）和mutableCopy就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。</li>
<li>额外2：不要在init（包括自定义的初始化方法）和dealloc中使用setter和getter方法。</li>
<li>atomic用以确保线程安全，但是iOS平台的property基本都是nonatomic的，主要是因为性能问题，而且atomic也并非完全是线程安全的（例如一个线程频繁访问一个对象时，另一线程同时在写入，前一线程也会拿到不同的值），而在Mac OS X就不存在这个性能瓶颈了。</li>
</ol>


<!--more-->


<h2>Item7 Access Instance Variables Primarliy Directly When Accessing Them Internally</h2>

<ol>
<li>本章讨论的是如何在内部使用实例变量，有两种方式，一是使用生成的存取方法，二是直接使用实例变量。</li>
<li>优缺点如下：

<ol>
<li>直接访问对象，速度会快，绕开了OC的method dispatch，编译器会直接访问存储对象的内存。</li>
<li>直接访问对象会绕开与内存相关的setter方法，例如你设置的copy型的setter，只会按照retain来执行。</li>
<li>直接访问对象不会触发KVO。</li>
<li>使用存取方法会使调试变得简单，你可以在getter/setter添加断点。</li>
</ol>
</li>
<li>比较推荐的做法是，在存对象的时候使用setter方法，而在读取对象时直接读取，这样既享受了快速读取，也可以利用property控制保存对象。</li>
<li>但是这么做还是有一些需要注意的地方：

<ol>
<li>在初始化方法中，一定要使用直接赋值的方法，主要是因为怕子类复写了对象的setter方法，而导致异常，如果一个对象声明在了父类的内部，而子类不能直接访问它，你也不能直接访问读取该变量，这种情况只能通过setter赋值
2.如果实例变量使用了延时加载，那么读取一定要使用getter方法，不然这个对象永远都不会有值。</li>
</ol>
</li>
</ol>


<!--more-->


<h2>Item8 Understand Object Equality</h2>

<ol>
<li>比较两个对象，不使用==，那样只会比较指针的值，而一般使用<em>isEqual:</em>，如果对象有自己的专有比较方法，例如<em>isEqualToString:</em>，优先使用这些方法，速度会快些。</li>
<li><em>&ndash;(NSUIntegetr)hash;</em>是一个与比较对象息息相关的方法，hash相同的对象不一定相同，而相同的对象hash值一定相同。</li>
<li>所以自定义对象重写<em>isEqual:</em>方法，也一定要重写hash方法，共有三种方案：

<ol>
<li>返回一个常数，这个方案优点是使用单个对象时快，但是如果把大量对象放入同一集合，由于hash值相同，集合会挨个检查这些对象是否真的相同，从而导致向一个集合添加大量对象时就会很慢；</li>
<li>使用一个拼接的唯一字符串，然后进行hash，这个方案避免了上面的问题，但是出现了单个对象需要生成一个字符串，从而影响了速度的问题；</li>
<li>先取一系列变量的hash值，再将其异或，这个方案算是为了避免上述问题的折衷方案。</li>
</ol>
</li>
</ol>


<h3>Class-Specific Equality Methods</h3>

<ol>
<li>自定义类可以通过重写<em>isEqual:</em>方法，在方法里判断如果是同一类型，就调用上面的比较方法，如不是就调用父类的<em>isEqual:</em>方法，这样可以实现子类也可以与父类进行比较。</li>
</ol>


<h3>Deep versus Shallow Equality</h3>

<ol>
<li>有时你并不需要判断对象的所有信息是否相同，比如来自数据库的信息，可能只通过判断id就可以进行判断，所谓的浅比较就是这样。</li>
</ol>


<h3>Equality of Mutable Classes in Containers</h3>

<ol>
<li>这一部分主要讲的是，向集合添加可变对象，然后改变该对象，是有可能让集合出现重复对象的，这点值得关注。</li>
</ol>


<!--more-->


<h2>Item9 Use the Class Cluster Pattern to Hide Implementation Detail</h2>

<ol>
<li>类簇是OC中很重要的一个设计模式，例如UIButton的创建，类簇解决的问题是需要统一创建同一基本类型的不同对象，而同时避免暴露子类和父类内部复杂的switch语句。</li>
</ol>


<h3>Creating a Class Cluster</h3>

<ol>
<li>创建类簇的思路：一个基类，一些空方法，一个创建对象的工厂方法，继承的子类对空方法重写。这样的类簇有个缺点就是用户可能以为自己使用的类就是那个基类，而不知道其实是它的子类。</li>
</ol>


<h3>Class Clusters in Cocoa</h3>

<ol>
<li>由于很多Cocoa类都是使用了类簇模式，所以类似<em>[maybeAnArray class] == [NSArray class]</em>这样的校验类型的方法是不会返回正确值的，而要使用<em>[maybeAnArray isKindOfClass:[NSArray class]]</em>。</li>
<li>添加一个类簇的子类而不去改写其基类的工厂方法，对于NSArray是可以的，但是有三点要求：1、必须是该类簇基类的子类；2、该子类必须定义自己的存储空间，也就是说内部要有一个NSArray的对象来实现数据的存储；3、子类必须重写类簇文档中规定重写的方法。</li>
</ol>


<!--more-->


<h2>Item10 Use Associated Objects to Attach Custom Data to Existing Classes</h2>

<ol>
<li>有时为了为一个类绑定一些信息，而又不方便添加多余的property或者继承这个类，可以考虑使用<em>association</em>，类似字典型的键值读取，也可以设置内存管理策略，但是需要注意绑定的key必须是唯一的指针，而不只是值相同，所以一般使用全局的静态变量作为key。</li>
</ol>


<h3>An Example of Using Associated Objects</h3>

<ol>
<li>通过使用<em>Associated Objects</em>实现了UIAlertView的回调Block化，使得代码的可读性更好，也更方便。</li>
<li><em>Associated Objects</em>提供了一个将对象之间互相绑定的方法，但是并不推荐大范围使用该方法，因为会导致调试变的更难。</li>
</ol>


<!--more-->


<h2>Item11 Understand the Role of objec_msgSend</h2>

<ol>
<li>OC利用动态绑定成为了真正的动态语言，OC中传递消息最终被转化为函数<em>void objc_msgSend(id self, SEL cmd, &hellip;)</em>，例如：<em>id returnValue = [someObkect messageName:parameter];</em>转化后，<em>id returnValue = objc_msgSend(someObject, @sleector(messageName:), parameter);</em>。</li>
<li><em>objc_msgSend</em>执行的顺序是先在接受者实现的方法中找符合的方法来执行，如没有，向继承链上方逐级寻找符合的实现方法。</li>
<li><em>objc_msgSend</em>会为每个类缓存一张查找表，来加速这一过程，但即使如此，还是比在C中直接调用静态调用函数慢，但这常常不是应用的瓶颈，这样来换取程序的灵活性还是值得的。</li>
<li><em>objc_msgSend</em>是针对确定消息的处理，下面还有一些处理个别案例的方法。</li>
<li><em>objc_msgSend_stret</em>用于处理用户返回适用于CPU寄存器的结构体的消息（不太懂）。</li>
<li><em>objc_msgSend_fpret</em>用于处理返回浮点值的消息，一些结构需要在函数调用时对浮点数寄存器特殊处理，所以这是该方法存在的意义（不太懂）。</li>
<li><em>objc_msgSendSuper</em>直接把消息转发给父类执行，类的所有方法都是一个个类似<em>&lt;return_type> Class_selector(id self, SEL _CMD, &hellip;)</em>这样的原型，这些方法指针存在该类的一个查找表中等待调用，该原型与<em>objc_msgSend</em>是相同的，也就实现了<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html">尾部递归调用</a>的可能，这样会实现调用栈的空间复杂度保持O(1)，不会产生溢出。</li>
</ol>


<!--more-->


<h2>Item12 Understand Message Forwarding</h2>

<ol>
<li>转发路径是为了处理接受者无法处理消息的情况，分为两条路径：1、<em>dynamic method resolution</em>期望接收者自己在runtime添加处理方法；2、<em>full forwarding mechanism</em>到了这一步，runtime得知接收者是不可能对消息做出响应了，所以要求接收者自己处理该消息，又分为两步：(1)询问是否有其他对象可以接收消息，如果有则转发给该对象；(2)如果也没有替代的接收者，那么将使用<em>NSInvocation</em>来对消息进行封装，然后交给原接收者去处理。<a href="http://bugly.qq.com/blog/?p=64">这儿也做了详细解释</a>。</li>
</ol>


<h3>Dynamic Method Resolution</h3>

<ol>
<li><em>+(BOOL)resolveInstanceMethod:(SEL)selector</em>用于表明类有无实例方法可处理该消息，可以说是给予该类的第二次机会。</li>
<li>这类方法是存在的，例如CoreData的@dynamic的property的accessing方法，而<em>+(BOOL)resolveInstanceMethod:(SEL)selector</em>对其的处理是判断是否是@dynamic property，如果是，向该类添加预备好的getter，setter方法，已确保类可以响应该消息。</li>
</ol>


<h3>Replacement Receiver</h3>

<ol>
<li><em>&ndash;(id)forwardTargetForSelector:(SEL)selector</em>用于返回可以替代原接收者的对象（如果其存在的话），这其实提供了一些多继承的特性，即原类内部可以有其他对象来实现这一方法。但是无法对消息进行修改，只是转发，如需修改消息，则需要采取最后一步。</li>
</ol>


<h3>Full Forwarding Mechanism</h3>

<ol>
<li>&ndash;(void)forwardInvocation:(NSInvocation*)invocation用于转发接收到的NSInvocation消息，可以进行简单转发，但这和上述的方法没有区别，而更为常见的用途是修改消息，如增加参数或者改变方法等。</li>
<li>重写该方法时需要调用父类的相同方法来处理改invocation，这样会最终调用NSObject的<em>doesNotRecognizeSelector</em>，最终抛出异常，但如果你不希望程序崩溃，就不要去调用父类的方法。</li>
</ol>


<h3>The Full Picture</h3>

<ol>
<li>具体图表见<a href="http://bugly.qq.com/blog/?p=64">这儿</a>。</li>
<li>解决的代价是越来越高的，所以最好在第一阶段解决这一问题。</li>
</ol>


<h3>Full Example of Dynamic Method Resolution</h3>

<ol>
<li>举例说明，将一个model中的所有对象都存在一个dictionary中，而这些对象申明为@dynamic，在<em>+(BOOL)resolveInstanceMethod:(SEL)selector</em>中根据selector的信息对相应的对象动态添加setter，getter方法，大幅减少代码量，但缺点是想特殊处理某个对象，就变得比较麻烦了。</li>
</ol>


<!--more-->


<h2>Item13 Consider Method Swizzling to Debug Opaque Methods</h2>

<ol>
<li><em>Method Swizzling</em>主要用于不知道类的源码，且不用继承、重写，即可为原方法添加hook的手段（其实是在runtime中先交换，再执行一次原方法而已-_-）。</li>
<li>通过添加一个类的分类，在分类添加一个方法，在这个方法中进行递归调用，然后与目标方法进行交换，这时再执行原方法时，会依次执行这两个方法。<a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411">另外一篇文章也有说明</a>。</li>
</ol>


<!--more-->


<h2>Item14 Understand What a Class Object Is</h2>

<ol>
<li>Class本身也是一个结构体指针，叫objc_class，Class也有一个Class类型的isa指针，说明Class本身也是一个OC对象，他的类型叫做metaclass，Class有Class类型的super_class指针，用来指向他的父类Class。</li>
</ol>


<h3>Inspecting the Class Hierarchy</h3>

<ol>
<li><em>isMemberOfClass:</em>用于判断是否属于该类，<em>isKindOfClass:</em>用于判断是否属于该类或者该类的子类。原理还是利用上述的Class的isa和super_class指针。</li>
<li>内省（自我类型检查）是OC中的重要技术，应用也很广泛，除了上述方法，也可利用<em>[object class] == [EOCSomeClass class]</em>来判断，之所以这么写是合理的，是因为每个class的Class类型是一个单例对象，所以可以直接比较指针。</li>
<li>但是还是推荐使用默认的类型检测方法，因为这样可以利用消息转发技术，如果一个对象的所有方法都是代理对象执行的，那么调用class方法只会返回代理对象的类型，而调用<em>isKindOfClass:</em>方法，代理会把消息转给被代理的对象，会得到正确的类型。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记1]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/07/20/effective-objective-cdu-shu-bi-ji-1/"/>
    <updated>2015-07-20T14:47:04+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/07/20/effective-objective-cdu-shu-bi-ji-1</id>
    <content type="html"><![CDATA[<p>关于书不多做介绍了，很有名的一本书，是Mattt Thompson大神写的，他是AFNetworking的主要作者，同时维护了<a href="http://nshipster.com">NSHipster</a>，这本书之前看了一次，但是没那么细致，打算再看一次，同时做做笔记。</p>

<!--more-->


<h2>Item1 Familiarize Yourself with Objective-C&rsquo;s Roots</h2>

<ol>
<li>OC采用消息传递而非函数调用的基本结构，二者最大区别是消息传递中运行时才决定执行的代码，而函数调用中编译器会决定执行的代码。所以运行期承担了OC运作的大部分工作，所以每当运行期更新时你的应用都会从中受益，而不需等到重新编译（最后这段，不是太明白）。</li>
<li>学好C会让你更好理解OC，诸如内存模型和引用计数这些概念。所有OC对象的内存都是<a href="http://mobile.51cto.com/iphone-394484.htm">开辟在堆上的，不在栈上</a>，栈是编译器控制的，堆是程序员控制的，而这些对象的指针是存放在栈上的，所以当指针不存在，而程序员又没有释放堆上的对象，就导致了内存泄露。</li>
<li>OC是通过引用计数来模拟内存的开辟与释放。</li>
<li>有些变量是直接开辟在栈上的，如CGRect，他是一个结构体，不同于对象，他们的使用不会影响性能。</li>
</ol>


<!--more-->


<h2>Item2 Minimize Importing Headers in Headers</h2>

<ol>
<li>尽量避免在类的头文件直接#import其他class的头文件，能使用@class尽量使用，有俩个好处：1、避免引用头文件的连锁效应，增加编译时间；2、避免了互相#import头文件而出现的循环导入的特殊情况。</li>
<li>一些需要导入头文件到.h文件的请款：1、class所继承的父类；2、使用protocol类型。</li>
<li>遵从的protocol可以放在匿名分类中#import。</li>
</ol>


<!--more-->


<h2>Item3 Prefer Literal Syntax over the Equivalent Methods</h2>

<ol>
<li>尽量多去使用文字型语法，这样可减少代码量，增加可读性。</li>
<li>关于NSArray的文字型创建语法，如果其中一个对象为nil，则会立即抛出异常，而使用传统的<em>arrayWithObjects:</em>则会在加入nil对象时停下，并不会报错，这使得我们更难发现这一问题。</li>
<li>唯一一个不足是文字型语法只接受Foundation框架的对象，而不接受自定义对象。</li>
</ol>


<!--more-->


<h2>Item4 Prefer Typed Constants to Preprocessor #define</h2>

<ol>
<li>尽量多使用静态常量，而不是预编译常量。原因只要是预编译常量是代码整体进行替换，容易被重赋值，常量的范围不好控制。类似<em>static const NSTimeInterval kAnimationDuration = 0.3</em></li>
<li>而如果要使用全局常量（比如注册和接受通知的名称），采用以下方式</li>
</ol>


<p>```objectivec
//in the header file
extern NSString *const EOCStringConstant;</p>

<p>//in the implementation file
NSString *const EOCStringConstant = @&ldquo;VALUE&rdquo;;</p>

<p>//基本类型常量
//EOCAnimatedView.h
extern const NSTimeInterval EOCAnimatedViewAnimationDuration;</p>

<p>//EOCAnimatedView.m
const NSTimeInterval EOCAnimatedViewAnimationDuration = 0.3;</p>

<p>```</p>

<!--more-->


<h2>Item5 Use Enumerations for States, Options, and Status Codes</h2>

<p>1.使用枚举类型主要是用于定义状态和选项，可读性好是它最大的优点，c++11后OC开始支持自定义枚举类型所用的数据类型。<br/>
2.用枚举做选项时，可用位移的方式实现多个选项合并使用，这种方式广泛用于UIKit。</p>

<p>```objectivec
typedef NS_OPTIONS(NSUInteger, EOCPermittedDirection) {
  EOCPermittedDirectionUp = 1&lt;&lt;0,
  EOCPermittedDirectionDown = 1&lt;&lt;1,
  EOCPermittedDirectionLeft = 1&lt;&lt;2,
  EOCPermittedDirectionRight = 1&lt;&lt;3,
}</p>

<p>EOCPermittedDirection permittedDirection = EOCPermittedDirectionUp | EOCPermittedDirectionDown;
if(permittedDirection &amp; EOCPermittedDirectionUp) {
  //EOCPermittedDirectionUp is set
}
```</p>

<p>3.OC定义了专门定义枚举的宏，NS_ENUM和NS_OPTIONS，他们对兼容新旧编译器做了自动判断，推荐使用，如想使用可合并的枚举，必须使用NS_OPTIONS来定义。<br/>
4. 最后一点，对枚举型值执行switch语句时，不要添加default处理。</p>

<!--more-->


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[raywenderlich.com代码风格规范]]></title>
    <link href="http://lucifer1988.github.io/blog/2014/04/09/raywenderlich-dot-comdai-ma-feng-ge-gui-fan/"/>
    <updated>2014-04-09T14:36:55+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2014/04/09/raywenderlich-dot-comdai-ma-feng-ge-gui-fan</id>
    <content type="html"><![CDATA[<p><img src="http://lucifer1988.github.io/images/rayWenderlich_icon.png"></p>

<p><a href="http://www.raywenderlich.com">raywenderlich.com</a>对于搞iOS开发的人来说不会陌生（如果你经常关注一些技术博客的话），它原本只是Ray Wenderlich的个人博客，但通过不断聚集优秀的开发者参与到其站点的技术博客撰写，包括了应用开发和游戏开发的各个方面，同时将这些技术博客整理成书，作为开发教程出售（貌似最近还出视频教程了，又想法圈钱了···），这样raywenderlich.com渐渐发展成了一个iOS开发社区，其优质的文章和对文章本地化的重视，使得其影响力逐渐向全球扩展。本文是对其最近公布的自家的Objective-C代码风格规范的一些整理，原文地址在<a href="https://github.com/raywenderlich/objective-c-style-guide">这里</a>。</p>

<!--more-->


<h2>目录</h2>

<ul>
<li><a href="#%E8%AF%AD%E8%A8%80">语言</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84">代码结构</a></li>
<li><a href="#%E7%A9%BA%E6%A0%BC">空格</a></li>
<li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li>
<li><a href="#%E5%91%BD%E5%90%8D">命名</a></li>
<li><a href="#%E4%B8%8B%E5%88%92%E7%BA%BF">下划线</a></li>
<li><a href="#%E6%96%B9%E6%B3%95">方法</a></li>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E5%B1%9E%E6%80%A7">属性</a></li>
<li><a href="#%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F">点表达式</a></li>
<li><a href="#%E6%96%87%E5%AD%97%E9%87%8F">文字量</a></li>
<li><a href="#%E5%B8%B8%E9%87%8F">常量</a></li>
<li><a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B">枚举类型</a></li>
<li><a href="#%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5">分支语句</a></li>
<li><a href="#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7">私有属性</a></li>
<li><a href="#%E5%B8%83%E5%B0%94%E5%9E%8B">布尔型</a></li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">条件语句</a></li>
<li><a href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6">三元运算符</a></li>
<li><a href="#Init%E6%96%B9%E6%B3%95">Init方法</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E7%B1%BB%E6%96%B9%E6%B3%95">构造类方法</a></li>
<li><a href="#CGRect%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">CGRect相关函数</a></li>
<li><a href="#%E6%84%89%E5%BF%AB%E8%B7%AF%E5%BE%84">愉快路径</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</a></li>
<li><a href="#%E5%8D%95%E4%BE%8B">单例</a></li>
<li><a href="#%E6%8D%A2%E8%A1%8C">换行</a></li>
<li><a href="#%E7%AC%91%E8%84%B8">笑脸（你没看错，这也有规范）</a></li>
<li><a href="#Xcode%E5%B7%A5%E7%A8%8B">Xcode工程</a></li>
</ul>


<h2><a name="语言"></a>语言</h2>

<p>推荐使用美英，主要体现在命名时使用美英单词。</p>

<p><strong>推荐：</strong></p>

<p><code>objc
UIColor *myColor = [UIColor whiteColor];
</code></p>

<p><strong>不推荐：</strong></p>

<p><code>objc
UIColor *myColour = [UIColor whiteColor];
</code></p>

<h2><a name="代码结构"></a>代码结构</h2>

<p>统一使用<code>#pragma mark -</code>组织代码结构。</p>

<p>```objc</p>

<h1>pragma mark &ndash; Lifecycle</h1>

<ul>
<li>(instancetype)init {}</li>
<li>(void)dealloc {}</li>
<li>(void)viewDidLoad {}</li>
<li>(void)viewWillAppear:(BOOL)animated {}</li>
<li>(void)didReceiveMemoryWarning {}</li>
</ul>


<h1>pragma mark &ndash; Custom Accessors</h1>

<ul>
<li>(void)setCustomProperty:(id)value {}</li>
<li>(id)customProperty {}</li>
</ul>


<h1>pragma mark &ndash; IBActions</h1>

<ul>
<li>(IBAction)submitData:(id)sender {}</li>
</ul>


<h1>pragma mark &ndash; Public</h1>

<ul>
<li>(void)publicMethod {}</li>
</ul>


<h1>pragma mark &ndash; Private</h1>

<ul>
<li>(void)privateMethod {}</li>
</ul>


<h1>pragma mark &ndash; Protocol conformance</h1>

<h1>pragma mark &ndash; UITextFieldDelegate</h1>

<h1>pragma mark &ndash; UITableViewDataSource</h1>

<h1>pragma mark &ndash; UITableViewDelegate</h1>

<h1>pragma mark &ndash; NSCopying</h1>

<ul>
<li>(id)copyWithZone:(NSZone *)zone {}</li>
</ul>


<h1>pragma mark &ndash; NSObject</h1>

<ul>
<li>(NSString *)description {}
```</li>
</ul>


<h2><a name="空格"></a>空格</h2>

<ul>
<li>使用2个空格缩进（理由是可以在保持打印空白的基础上，尽量减少换行的可能性），不要使用tab缩进，可以在Xcode的preference下进行修改（默认是4个空格）；</li>
<li>方法中的<code>{}</code>和在<code>if</code>/<code>else</code>/<code>switch</code>/<code>while</code>等语法中出现的<code>{}</code>在本行开始，而结束于新一行。</li>
</ul>


<p><strong>推荐：</strong></p>

<p><code>objc
if (user.isHappy) {
  //Do something
} else {
  //Do something else
}
</code></p>

<p><strong>不推荐：</strong></p>

<p>```objc
if (user.isHappy)
{</p>

<pre><code>//Do something
</code></pre>

<p>}
else {</p>

<pre><code>//Do something else
</code></pre>

<p>}
```</p>

<ul>
<li>方法之间应该有且只有一空行来保持代码结构清晰，方法中的空白行用来划分功能，但是经常你可能需要将它们重构为新的方法；</li>
<li>推荐使用自动提示的语法结构，不过<code>@sythesize</code>和<code>@dyamic</code>可以声明在新行；</li>
<li><code>冒号对齐</code>这样的方法调用结构要避免，假如方法中出现3个以上的冒号，这样的调用结构会使代码可读性很差。千万别在含有block的方法中去对齐冒号，这样Xcode的缩进会使其非法。</li>
</ul>


<p><strong>推荐：</strong></p>

<p><code>objc
// blocks are easily readable
[UIView animateWithDuration:1.0 animations:^{
  // something
} completion:^(BOOL finished) {
  // something
}];
</code></p>

<p><strong>不推荐：</strong></p>

<p>```objc
// colon-aligning makes the block indentation hard to read
[UIView animateWithDuration:1.0</p>

<pre><code>             animations:^{
                 // something
             }
             completion:^(BOOL finished) {
                 // something
             }];
</code></pre>

<p>```</p>

<h2><a name="注释"></a>注释</h2>

<p>注释主要用来解释这段代码为什么存在于此，注意所有注释需要及时更新或删除。</p>

<p>大段的注释要避免，有必要可以加到单独的文档，注释需要一些简短的说明。PS：不包括那些为生成文档而做的注释（一些工具可以通过代码中的注释生成文档）。</p>

<h2><a name="命名"></a>命名</h2>

<p>Apple的命名习惯是尽可能详细，尤其是和内存管理相关的。</p>

<p>长的，描述性的方法和变量名命名是被推荐的。</p>

<p><strong>推荐：</strong></p>

<p><code>objc
UIButton *settingsButton;
</code></p>

<p><strong>不推荐：</strong></p>

<p><code>objc
UIButton *setBut;
</code></p>

<p>类名和常量名必须要有三个字母的命名前缀（主要为了避免和Apple大多数两个前缀的命名冲突，比如UIButton，CAAnimation，CGRect等），不过Core Data的实体命名可以省略这些前缀。比如raywenderlich.com的命名前缀为RTW。</p>

<p>常量需要驼峰型命名，所有单词首字母大写，且使用相关类名作为前缀。</p>

<p><strong>推荐：</strong></p>

<p><code>objc
static NSTimeInterval const RWTTutorialViewControllerNavigationFadeAnimationDuration = 0.3;
</code></p>

<p><strong>不推荐：</strong></p>

<p><code>objc
static NSTimeInterval const fadetime = 1.7;
</code></p>

<p>property使用驼峰形命名，保证开头单词小写，且使用Apple的自动合成规则，除了特殊情况，不要手动声明<code>@synthesize</code>。</p>

<p><strong>推荐：</strong></p>

<p><code>objc
@property (strong, nonatomic) NSString *descriptiveVariableName;
</code></p>

<p><strong>不推荐：</strong></p>

<p><code>objc
id varnm;
</code></p>

<h2><a name="下划线"></a>下划线</h2>

<p>当使用property时，实例变量的读写要使用<code>self.</code>，这样的话所有的property可以清楚地区分出来。</p>

<p>一个例外：在初始化方法中，需要的实例变量要直接使用<code>_variableName</code>型，为了避免调用getter/setter方法可能出现的循环引用。</p>

<p>临时变量不能使用下划线。</p>

<h2><a name="方法"></a>方法</h2>

<p>在方法声明时，方法类型（-/+）后要有一个空格。方法段之间也要有一个空格。在每个变量前要加一个描述性的词语用来描述这个变量。</p>

<p>不要在用于描述的词语中加入“and”，具体例子见下：</p>

<p><strong>推荐：</strong></p>

<p><code>objc
- (void)setExampleText:(NSString *)text image:(UIImage *)image;
- (void)sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;
- (id)viewWithTag:(NSInteger)tag;
- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;
</code></p>

<p><strong>不推荐：</strong></p>

<p><code>objc
-(void)setT:(NSString *)text i:(UIImage *)image;
- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;
- (id)taggedView:(NSInteger)tag;
- (instancetype)initWithWidth:(CGFloat)width andHeight:(CGFloat)height;
- (instancetype)initWith:(int)width and:(int)height;  // Never do this.
</code></p>

<h2><a name="变量"></a>变量</h2>

<p>变量命名尽量使用描述性的词语。单个字母的命名除了在<code>for()</code>循环中，其他地方都是不允许的。</p>

<p>星号声明了指向变量的指针，例如：<code>NSString *text</code>，不是<code>NSString* text</code>或<code>NSString * text</code>，除了在声明常量的时候（例如：<code>NSString *const text</code>）。</p>

<p>如果可能的话，使用<a href="#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7">私有属性</a>，而不是实例变量，尽管使用实例变量也是对的，不过这样的协定可以保持代码的一致性。</p>

<p>只有在初始化方法（如<code>init</code>，<code>initWithCoder:</code>等），<code>dealloc</code>和setter/getter方法中使用下划线加变量名的读写方法，更多关于这一情况的说明见<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW6">Apple相关文档</a></p>

<p><strong>推荐：</strong></p>

<p>```objc
@interface RWTTutorial : NSObject</p>

<p>@property (strong, nonatomic) NSString *tutorialName;</p>

<p>@end
```</p>

<p><strong>不推荐：</strong></p>

<p><code>objc
@interface RWTTutorial : NSObject {
  NSString *tutorialName;
}
</code></p>

<h2><a name="属性"></a>属性</h2>

<p>属性需要清楚地列出，属性的property类型顺序应该是先内存相关，再原子性相关，这与从IB中自动关联的属性的顺序是一致的。</p>

<p><strong>推荐：</strong></p>

<p><code>objc
@property (weak, nonatomic) IBOutlet UIView *containerView;
@property (strong, nonatomic) NSString *tutorialName;
</code></p>

<p><strong>不推荐：</strong></p>

<p><code>objc
@property (nonatomic, weak) IBOutlet UIView *containerView;
@property (nonatomic) NSString *tutorialName;
</code></p>

<p>带有不可变性质的属性（比如：NSString）推荐使用<code>copy</code>而不是<code>strong</code>，理由是其他人可能传入一个其对应的可变实例（比如：NSMutableString），而你可能不会注意到。</p>

<p><strong>推荐：</strong></p>

<p><code>objc
@property (copy, nonatomic) NSString *tutorialName;
</code></p>

<p><strong>不推荐：</strong></p>

<p><code>objc
@property (strong, nonatomic) NSString *tutorialName;
</code></p>

<h2><a name="点表达式"></a>点表达式</h2>

<p>读写property时应一直使用点表达式，这使代码变得简洁，而<code>[]</code>表达式用于其他所有的实例中。</p>

<p><strong>推荐：</strong></p>

<p><code>objc
NSInteger arrayCount = [self.array count];
view.backgroundColor = [UIColor orangeColor];
[UIApplication sharedApplication].delegate;
</code></p>

<p><strong>不推荐：</strong></p>

<p><code>objc
NSInteger arrayCount = self.array.count;
[view setBackgroundColor:[UIColor orangeColor]];
UIApplication.sharedApplication.delegate;
</code></p>

<h2><a name="文字量"></a>文字量</h2>

<p><code>NSString</code>，<code>NSDictionary</code>，<code>NSArry</code>，<code>NSNumber</code>如果可能的话，尽量使用它们的不可变实例。<code>NSArray</code>和<code>NSDictionary</code>不能存在<code>nil</code>值，否则会引起崩溃。</p>

<p><strong>推荐：</strong></p>

<p><code>objc
NSArray *names = @[@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul"];
NSDictionary *productManagers = @{@"iPhone": @"Kate", @"iPad": @"Kamal", @"Mobile Web": @"Bill"};
NSNumber *shouldUseLiterals = @YES;
NSNumber *buildingStreetNumber = @10018;
</code></p>

<p><strong>不推荐：</strong></p>

<p><code>objc
NSArray *names = [NSArray arrayWithObjects:@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul", nil];
NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @"Kate", @"iPhone", @"Kamal", @"iPad", @"Bill", @"Mobile Web", nil];
NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];
NSNumber *buildingStreetNumber = [NSNumber numberWithInteger:10018];
</code></p>

<h2><a name="常量"></a>常量</h2>

<p>常量推荐内联的字符串或数字，推荐定义为<code>static</code>变量，除非要作为宏，不然不要使用<code>#define</code>。</p>

<p><strong>推荐：</strong></p>

<p>```objc
static NSString * const RWTAboutViewControllerCompanyName = @&ldquo;RayWenderlich.com&rdquo;;</p>

<p>static CGFloat const RWTImageThumbnailHeight = 50.0;
```</p>

<p><strong>不推荐：</strong></p>

<p>```objc</p>

<h1>define CompanyName @&ldquo;RayWenderlich.com&rdquo;</h1>

<h1>define thumbnailHeight 2</h1>

<p>```</p>

<h2><a name="枚举类型"></a>枚举类型</h2>

<p>当使用枚举型时，推荐使用新的固定基础类型定义，理由是有更强的类型检查和代码完成功能。SDK现在包含了一个宏来确保和推广使用固定基础类型：<code>NS_ENUM()</code>。</p>

<p><strong>例如：</strong></p>

<p><code>objc
typedef NS_ENUM(NSInteger, RWTLeftMenuTopItemType) {
  RWTLeftMenuTopItemMain,
  RWTLeftMenuTopItemShows,
  RWTLeftMenuTopItemSchedule
};
</code></p>

<p>也可以做明确的赋值</p>

<p><code>objc
typedef NS_ENUM(NSInteger, RWTGlobalConstants) {
  RWTPinSizeMin = 1,
  RWTPinSizeMax = 5,
  RWTPinCountMin = 100,
  RWTPinCountMax = 500,
};
</code></p>

<p>旧式的k型常量定义只被用于书写CoreFoundation的C代码中。</p>

<p><strong>不推荐：</strong></p>

<p><code>objc
enum GlobalConstants {
  kMaxPinSize = 5,
  kMaxPinCount = 500,
};
</code></p>

<h2><a name="分支语句"></a>分支语句</h2>

<p>花括号对于分支语句并不是必须的，除非编译器强制使用。
当一个分支包含多于一条语句，花括号需要添加。</p>

<p>```objc
switch (condition) {
  case 1:</p>

<pre><code>// ...
break;
</code></pre>

<p>  case 2: {</p>

<pre><code>// ...
// Multi-line example using braces
break;
</code></pre>

<p>  }
  case 3:</p>

<pre><code>// ...
break;
</code></pre>

<p>  default:</p>

<pre><code>// ...
break;
</code></pre>

<p>}
```</p>

<p>有时会出现一段代码被多个分支使用，这时就相当于“穿过”。一个“穿过”就是移除这一分支的‘break’语句，使代码继续执行下一分支。“穿过”这种情况需要在代码中进行注释。</p>

<p>```objc
switch (condition) {
  case 1:</p>

<pre><code>// ** fall-through! **
</code></pre>

<p>  case 2:</p>

<pre><code>// code executed for values 1 and 2
break;
</code></pre>

<p>  default:</p>

<pre><code>// ...
break;
</code></pre>

<p>}
```</p>

<p>当在<code>switch</code>语句中使用枚举类型，<code>default</code>是不需要的：</p>

<p>```objc
RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;
switch (menuType) {
  case RWTLeftMenuTopItemMain:</p>

<pre><code>// ...
break;
</code></pre>

<p>  case RWTLeftMenuTopItemShows:</p>

<pre><code>// ...
break;
</code></pre>

<p>  case RWTLeftMenuTopItemSchedule:</p>

<pre><code>// ...
break;
</code></pre>

<p>}
```</p>

<h2><a name="私有属性"></a>私有属性</h2>

<p>私有属性应该定义到<code>.m</code>文件中的类扩展（匿名分类）中，命名的分类（如<code>RWTPrivate</code>，<code>private</code>）是不允许使用的，除非是在做另一个类的拓展。匿名分类可以暴露和共享于与<code>+Private.h</code>文件的命名惯例测试中。</p>

<p><strong>例如：</strong></p>

<p>```objc
@interface RWTDetailViewController ()</p>

<p>@property (strong, nonatomic) GADBannerView <em>googleAdView;
@property (strong, nonatomic) ADBannerView </em>iAdView;
@property (strong, nonatomic) UIWebView *adXWebView;</p>

<p>@end
```</p>

<h2><a name="布尔型"></a>布尔型</h2>

<p>Objective-C使用<code>YES</code>和<code>NO</code>。因此<code>true</code>和<code>false</code>只用于CoreFoundation，C和C++中。由于<code>nil</code>意味着<code>NO</code>，拿<code>nil</code>来做比较条件是不允许的，永远不要直接拿<code>YES</code>来比较，因为<code>YES</code>被定义为1，而一个布尔型可以支持到8比特。</p>

<p>这是为了文件间更多的一致性和更好的可读性。</p>

<p><strong>推荐：</strong></p>

<p><code>objc
if (someObject) {}
if (![anotherObject boolValue]) {}
</code></p>

<p><strong>不推荐：</strong></p>

<p><code>objc
if (someObject == nil) {}
if ([anotherObject boolValue] == NO) {}
if (isAwesome == YES) {} // Never do this.
if (isAwesome == true) {} // Never do this.
</code></p>

<p>如果布尔型被命名为一个形容词，属性名可以省略<code>is</code>，但是getter方法要保持这一命名。</p>

<p><code>objc
@property (assign, getter=isEditable) BOOL editable;
</code></p>

<p>这一部分来自<a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-BAJGIIJE">Cocoa Naming Guidelines</a>。</p>

<h2><a name="条件语句"></a>条件语句</h2>

<p>条件语句主体任何时候都要使用花括号，即使是只有一条语句也需要。这是为了避免错误。这些错误包括添加下一条语句，以为这条语句位于if主体中。另一个更危险的缺点是，if主体内的语句被注释掉，这时下一条语句无意中成为了if语句中的一部分。除此之外，这样的风格与其他条件语句格式保持了一致，便于查找。</p>

<p><strong>推荐：</strong></p>

<p><code>objc
if (!error) {
  return success;
}
</code></p>

<p><strong>不推荐：</strong></p>

<p><code>objc
if (!error)
  return success;
</code></p>

<p>或</p>

<p><code>objc
if (!error) return success;
</code></p>

<h2><a name="三元运算符"></a>三元运算符</h2>

<p>三元运算符<code>?:</code>，只有在可以提高可读性和简洁性时才可使。单一的判断条件一般可以使用，当执行多个判断条件时推荐使用<code>if</code>语句提高可读性，或者将条件重构为实例变量。总的来说，使用三元运算符的最好时机是决定如何给一个变量赋值的时候。</p>

<p>非布尔类型变量需要比较时，要添加<code>()</code>提高可读性。如果是布尔类型，则不需要。</p>

<p><strong>推荐：</strong></p>

<p>```objc
NSInteger value = 5;
result = (value != 0) ? x : y;</p>

<p>BOOL isHorizontal = YES;
result = isHorizontal ? x : y;
```</p>

<p><strong>不推荐：</strong></p>

<p><code>objc
result = a &gt; b ? x = c &gt; d ? c : d : y;
</code></p>

<h2><a name="Init方法"></a>Init方法</h2>

<p>Init方法遵守Apple生成的代码模板，<code>instancetype</code>应取代<code>id</code>作为返回值。</p>

<p>```objc
&ndash; (instancetype)init {
  self = [super init];
  if (self) {</p>

<pre><code>// ...
</code></pre>

<p>  }
  return self;
}
```</p>

<p>关于<code>instancetype</code>参照<a href="#class-constructor-methods">Class Constructor Methods</a>。</p>

<h2><a name="构造类方法"></a>构造类方法</h2>

<p>当类构造方法使用时，同样需要注意返回值使用<code>instancetype</code>，而不是<code>id</code>，这样可确保编译器得知正确的结果类型。</p>

<p><code>objc
@interface Airplane
+ (instancetype)airplaneWithType:(RWTAirplaneType)type;
@end
</code></p>

<p>更多关于<code>instancetype</code>在<a href="http://nshipster.com/instancetype/">NSHipster.com</a>。</p>

<h2><a name="CGRect相关函数"></a>CGRect相关函数</h2>

<p>当读取一个<code>CGRect</code>的<code>x</code>、<code>y</code>、<code>width</code>、<code>height</code>时，要使用<code>CGGeometry</code>相关的函数，而不是直接读取结构体。参照Apple的相关文档：</p>

<blockquote><p>All functions described in this reference that take CGRect data structures as inputs implicitly standardize those rectangles before calculating their results. For this reason, your applications should avoid directly reading and writing the data stored in the CGRect data structure. Instead, use the functions described here to manipulate rectangles and to retrieve their characteristics.</p></blockquote>

<p><strong>推荐：</strong></p>

<p>```objc
CGRect frame = self.view.frame;</p>

<p>CGFloat x = CGRectGetMinX(frame);
CGFloat y = CGRectGetMinY(frame);
CGFloat width = CGRectGetWidth(frame);
CGFloat height = CGRectGetHeight(frame);
CGRect frame = CGRectMake(0.0, 0.0, width, height);
```</p>

<p><strong>不推荐：</strong></p>

<p>```objc
CGRect frame = self.view.frame;</p>

<p>CGFloat x = frame.origin.x;
CGFloat y = frame.origin.y;
CGFloat width = frame.size.width;
CGFloat height = frame.size.height;
CGRect frame = (CGRect){ .origin = CGPointZero, .size = frame.size };
```</p>

<h2><a name="愉快路径"></a>愉快路径</h2>

<p>进行条件编程时，左边缘的代码应该是愉快路径。也就是说，不要嵌套<code>if</code>语句。多个<code>return</code>是允许的。</p>

<p><strong>推荐：</strong></p>

<p>```objc
&ndash; (void)someMethod {
  if (![someOther boolValue]) {</p>

<pre><code>return;
</code></pre>

<p>  }</p>

<p>  //Do something important
}
```</p>

<p><strong>不推荐：</strong></p>

<p>```objc
&ndash; (void)someMethod {
  if ([someOther boolValue]) {</p>

<pre><code>//Do something important
</code></pre>

<p>  }
}
```</p>

<h2><a name="异常处理"></a>异常处理</h2>

<p>当方法通过引用的方式返回一个错误参数，使用返回值进行判断，而不是那个错误参数。</p>

<p><strong>推荐：</strong></p>

<p><code>objc
NSError *error;
if (![self trySomethingWithError:&amp;error]) {
  // Handle Error
}
</code></p>

<p><strong>不推荐：</strong></p>

<p><code>objc
NSError *error;
[self trySomethingWithError:&amp;error];
if (error) {
  // Handle Error
}
</code></p>

<p>一些Apple的API在成功的情况下向错误参数写入一些垃圾值，所以通过错误参数来判断会带来不良的影响。</p>

<h2><a name="单例"></a>单例</h2>

<p>单例对象生成共享实例时要注意线程安全。</p>

<p>```objc
+ (instancetype)sharedInstance {
  static id sharedInstance = nil;</p>

<p>  static dispatch_once_t onceToken;
  dispatch_once(&amp;onceToken, ^{</p>

<pre><code>sharedInstance = [[self alloc] init];
</code></pre>

<p>  });</p>

<p>  return sharedInstance;
}
```</p>

<p>这将避免一些<a href="http://cocoasamurai.blogspot.com/2011/04/singletons-your-doing-them-wrong.html">多线程下的应用崩溃</a>。</p>

<h2><a name="换行"></a>换行</h2>

<p>换行是一个重要的部分，本代码风格规则着重打印和在线的可读性。</p>

<p>例如：</p>

<p><code>objc
self.productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers];
</code></p>

<p>长代码的话，可以进行换行，在第二行开头遵照“空白”一节的规定，需要空两个空格。</p>

<p><code>objc
self.productsRequest = [[SKProductsRequest alloc]
  initWithProductIdentifiers:productIdentifiers];
</code></p>

<h2><a name="笑脸"></a>笑脸</h2>

<p>笑脸是raywenderlich.com站点代码风格的显著特征。使用正确的笑脸表现编程时巨大的喜悦和激动是很重要的。使用方括号笑脸，是因为它是使用ASCII能获得的最大的笑脸···。使用以圆括号结尾的笑脸会出现一个半心形，所以不被推荐···。</p>

<p><strong>推荐：</strong></p>

<p><code>objc
:]
</code></p>

<p><strong>不推荐：</strong></p>

<p><code>objc
:)
</code></p>

<h2><a name="Xcode工程"></a>Xcode工程</h2>

<p>物理文件结构和Xcode工程文件结构要保持一致。Xcode项目中的新建分组都要对应文件系统中的文件夹。代码不但要按类型，也要按特征来分组，保证结构更清晰。</p>

<p>可能的话，尽量打开"Treat Warnings as Errors"选项，如果你想忽略一个类型的警告，请查看<a href="http://clang.llvm.org/docs/UsersManual.html#controlling-diagnostics-via-pragmas">这里</a>。</p>

<h2>其他Objective-C的代码风格规范</h2>

<ul>
<li><a href="https://github.com/RobotsAndPencils/objective-c-style-guide">Robots &amp; Pencils</a></li>
<li><a href="https://github.com/NYTimes/objective-c-style-guide">New York Times</a></li>
<li><a href="http://google-styleguide.googlecode.com/svn/trunk/objcguide.xml">Google</a></li>
<li><a href="https://github.com/github/objective-c-conventions">GitHub</a></li>
<li><a href="https://trac.adium.im/wiki/CodingStyle">Adium</a></li>
<li><a href="https://gist.github.com/soffes/812796">Sam Soffes</a></li>
<li><a href="http://cocoadevcentral.com/articles/000082.php">CocoaDevCentral</a></li>
<li><a href="http://lukeredpath.co.uk/blog/my-objective-c-style-guide.html">Luke Redpath</a></li>
<li><a href="http://www.cimgf.com/zds-code-style-guide/">Marcus Zarra</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[调试利器-PonyDebugger]]></title>
    <link href="http://lucifer1988.github.io/blog/2014/03/03/diao-shi-li-qi-ponydebugger/"/>
    <updated>2014-03-03T15:12:01+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2014/03/03/diao-shi-li-qi-ponydebugger</id>
    <content type="html"><![CDATA[<p><img src="http://lucifer1988.github.io/images/ponyDebugger_icon.png"></p>

<p>PonyDebugger是git上一个利用Chrome开发者工具来进行iOS客户端远程调试的工具包，与其他远类型程调试工具相比，它有着非常IMBA且又非常实用的功能：网络活动监控、查看CoreData对象、视图层级查看等，下面让我们看看如何驾驭这只神奇的小马驹吧！</p>

<!--more-->


<h2>功能</h2>

<p>PonyDebugger提供了四个特色的功能，包括：监控网络、CoreData对象查看、视图分层查看和远程日志打印。</p>

<h3>监控网络</h3>

<p>所有通过NSURLConnection进行的网络访问，都会被监测到，也就是说那些基于NSURLConnection的第三方网络组件，如AFNetworking，都可以被监测到，而且看以方便的查看到：访问类型、接口名、错误类型，返回类型、网络延时等信息，非常强大！</p>

<p><img src="http://lucifer1988.github.io/images/ponyDebugger_Network.png"></p>

<h3>CoreData对象查看</h3>

<p>这个功能就不必多说了，你可能见过很多方便的sqlite工具，比如FireFox的SQLite Manager插件，但是这样直接查看CoreData对象的不多见吧？</p>

<p><img src="http://lucifer1988.github.io/images/ponyDebugger_CoreData.png"></p>

<h3>视图分层查看</h3>

<p>这个功能对于前端开发者来说是最重要不过了，PonyDebugger将你应用的视图关系以xml的形式分层展示出来，选择相应xml，会在客户端进行对应视图的高亮响应，xml的属性信息可以在客户端进行配置，而且竟然支持直接修改xml属性值，而客户端UI会实时做出改变！</p>

<p><img src="http://lucifer1988.github.io/images/ponyDebugger_ViewHierarchy.png"></p>

<h3>远程日志打印</h3>

<p>这个可能你觉得没什么亮点，上次介绍的NSLogger可是专门做这件事的，不过PonyDebugger的这一功能也不会让你失望，它的语句类型不多，主要分为<code>PDLog()</code>和<code>PDLogObjects()</code>，<code>PDLog()</code>负责打印字符串信息，<code>PDLogObjects()</code>负责打印对象和数组。不过正如下图所示，<code>PDLogObjects()</code>打印出的对象也是分层展示的，比如查看一个数组中自定义modal对象的一个属性的值这样的事情就非常轻松，而且不用你再回Xcode中加断点，这是不很爽啊！</p>

<p><img src="http://lucifer1988.github.io/images/ponyDebugger_Console.png"></p>

<h2>配置</h2>

<p>配置工作包括配置服务器端和客户端。</p>

<h3>配置服务器端</h3>

<ul>
<li>安装Xcode&rsquo;s Command Line Tools，在之前的版本中可直接在Xcode中安装，如果你的环境更新到10.9和Xcode5之后，不妨参考<a href="http://ourcoders.com/thread/show/1208/">这里</a>进行安装，这是之前10.9更新CocoaPods时发现的一个问题。</li>
<li>在终端执行以下命令，进行安装</li>
</ul>


<p><code>
curl -sk https://cloud.github.com/downloads/square/PonyDebugger/bootstrap-ponyd.py | \
  python - --ponyd-symlink=/usr/local/bin/ponyd ~/Library/PonyDebugger
</code>
注：如果在安装过程中报出如下错误：</p>

<p>```
···
  Running setup.py (path:/Users/user/Library/PonyDebugger/build/tornado/setup.py) egg_info for package tornado</p>

<pre><code>warning: no previously-included files matching '_auto2to3*' found anywhere in distribution
</code></pre>

<p>Downloading/unpacking pybonjour (from ponydebugger)
  Could not find any downloads that satisfy the requirement pybonjour (from ponydebugger)
  Some externally hosted files were ignored (use &mdash;allow-external pybonjour to allow).
Cleaning up&hellip;
<code>
可以参考[这里](https://github.com/square/PonyDebugger/issues/100)的解决方法，在我安装的过程中也遇到了这个问题，按照提示是</code>pip<code>安装时没有配置</code>&mdash;allow-external pybonjour &mdash;allow-unverified pybonjour```。</p>

<ul>
<li>成功安装后，在终端输入<code>ponyd serve --listen-interface=127.0.0.1</code>，打开监听。</li>
<li>最后打开浏览器，输入地址<code>http://localhost:9000</code>，如果访问到如下结果，说明安装成功。</li>
</ul>


<p><img src="http://lucifer1988.github.io/images/ponyDebugger_install.png"></p>

<h3>配置客户端</h3>

<p>由于现在PonyDebugger支持CocoaPods安装了，可以直接在你的podfile中加入：</p>

<p><code>
pod 'PonyDebugger'
</code>
然后，安装一下就可以了。</p>

<p><code>
pod install
</code>
不了解CocoaPods的童鞋可以参考下唐巧大哥的<a href="http://blog.devtang.com/blog/2012/12/02/use-cocoapod-to-manage-ios-lib-dependency/">这篇介绍</a>，希望手动加入PonyDebugger的童鞋可以参考<a href="https://github.com/square/PonyDebugger">官方文档</a>中Manual Installation一项。</p>

<h2>使用</h2>

<p>相比起搭建环境，PonyDebugger的使用非常简单。你需要在你应用的<code>AppDelegate.m</code>的<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {}</code>方法中加入以下代码：</p>

<p>```</p>

<pre><code>PDDebugger *debugger = [PDDebugger defaultInstance];
//设置网络监控
[debugger enableNetworkTrafficDebugging];
[debugger forwardAllNetworkTraffic];
//通过TCP连接至服务端
[debugger connectToURL:[NSURL URLWithString:@"ws://localhost:9000/device"]];
// 也可通过bonjour自动连接
//[debugger autoConnect];
// 或连接至指定bonjour服务
//[debugger autoConnectToBonjourServiceNamed:@"MY PONY"];
//设置CoreData监控
[debugger enableCoreDataDebugging];
[debugger addManagedObjectContext:self.managedObjectContext withName:@"TIME Test MOC"];
//设置视图分层监控
[debugger enableViewHierarchyDebugging];
[debugger setDisplayedViewAttributeKeyPaths:@[@"frame", @"hidden", @"alpha", @"opaque", @"accessibilityLabel", @"text"]];
//设置远程日志打印
[debugger enableRemoteLogging];
</code></pre>

<p>```</p>

<h2>小结</h2>

<p>本文可以作为<code>PonyDebugger</code>一个入门级的文档。相比上一次介绍的<code>NSLogger</code>来说，<code>PonyDebugger</code>的展示方式和查看方式更加直观和方便，作为通用的调试工具非常不错，而<code>NSLogger</code>拥有强大的日志记录功能，但想要发挥<code>NSLogger</code>的作用，对程序员的经验和能力就有了一定的要求，所以两种工具各有千秋，大家各取所需就好。</p>
]]></content>
  </entry>
  
</feed>
