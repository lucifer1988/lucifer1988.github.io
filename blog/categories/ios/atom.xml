<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 刘毅的技术博客]]></title>
  <link href="http://lucifer1988.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://lucifer1988.github.io/"/>
  <updated>2015-11-09T09:54:13+08:00</updated>
  <id>http://lucifer1988.github.io/</id>
  <author>
    <name><![CDATA[刘毅]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS开发备忘录1]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/05/ioskai-fa-bei-wang-lu-1/"/>
    <updated>2015-11-05T13:41:03+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/05/ioskai-fa-bei-wang-lu-1</id>
    <content type="html"><![CDATA[<p>总结一些iOS开发必备的知识点，结构可能会比较杂，可以当做备忘录使用，不断更新中。</p>

<!--more-->


<h2>1.library和framework的比较</h2>

<p>library也就是我们常用的.a文件，而framework就是.framework文件，当然还有.dylib这样的文件。</p>

<h3>静态库和动态库的区别</h3>

<ul>
<li>静态库：链接时完整地拷贝至可执行文件夹中，被多次使用时会有多份冗余拷贝。</li>
<li>动态库：链接时不复制，程序运行是由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。</li>
</ul>


<h3>iOS库的形式</h3>

<ul>
<li>静态库：.a和.framework</li>
<li>动态库：.dylib和.framework</li>
<li>系统提供的.framework是动态的，而自己开发的.framework是静态的</li>
</ul>


<h3>.a和.framework区别</h3>

<ul>
<li>.a就是一个纯二进制的文件，而.framework还会包含头文件和资源文件</li>
<li>.a一般是要配合.h头文件使用的，.framework是可以直接使用的</li>
<li>实际上.framework = .a + .h + sourceFile</li>
</ul>


<h3>需要注意的问题</h3>

<ul>
<li>注意理解：无论是.a静态库还.framework静态库，我们需要的都是二进制文件+.h+其它资源文件的形式，不同的是，.a本身就是二进制文件，需要我们自己配上.h和其它文件才能使用，而.framework本身已经包含了.h和其它文件，可以直接使用。</li>
<li>图片资源的处理：两种静态库，一般都是把图片文件单独的放在一个.bundle文件中，一般.bundle的名字和.a或.framework的名字相同。.bundle文件很好弄，新建一个文件夹，把它改名为.bundle就可以了，右键，显示包内容可以向其中添加图片资源。</li>
<li>category是我们实际开发项目中经常用到的，把category打成静态库是没有问题的，但是在用这个静态库的工程中，调用category中的方法时会有找不到该方法的运行时错误（selector not recognized），解决办法是：在使用静态库的工程中配置other linker flags的值为-ObjC。</li>
<li>如果一个静态库很复杂，需要暴露的.h比较多的话，就可以在静态库的内部创建一个.h文件（一般这个.h文件的名字和静态库的名字相同），然后把所有需要暴露出来的.h文件都集中放在这个.h文件中，而那些原本需要暴露的.h都不需要再暴露了，只需要把.h暴露出来就可以了。</li>
<li>创建.a文件的一篇<a href="http://www.raywenderlich.com/41377/creating-a-static-library-in-ios-tutorial">博客</a>，创建.framework的一篇<a href="http://www.raywenderlich.com/65964/create-a-framework-for-ios">博客</a>。</li>
</ul>


<!--more-->


<h2>2.事件响应链The Responder Chain</h2>

<h3>事件的传递顺序</h3>

<p>当用户触发的一个事件发生，UIKit会创建一个包含要处理的事件信息的事件对象。然后她会将事件对象放入active app’s（应用程序对象，每个程序对应唯一一个）事件队列。对于触摸事件，事件对象就是UIEvent对象封装的一系列触摸集合。对于动作事件，这个事件对象依赖于使用的framework和你关心哪种动作事件。</p>

<h3>事件类型</h3>

<p>事件通过特殊的路径传递直到被传递到一个可以处理该事件的对象。首先，单例的UIApplication对象从顶层的队列中获取事件，然后分发。典型的，它将事件发送到App的key window对象，window则为了处理该事件而发送它到初始化对象（initial object），这个初始化对像依靠事件类型。</p>

<ul>
<li>触摸事件（Touch events）。对于触摸事件，window对象首先会尝试将事件传递给事件发生的view。这个view就是所谓的hit-test view。寻找hit-test view的方法叫hit-testing，具体描述见<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW4">Apple文档</a>。</li>
<li>动作事件和远程控制事件（Motion and remote control events）。在这些事件中，window对象发送事件到第一个响应器。第一个响应器的具体描述见<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW1">Apple文档</a>。</li>
</ul>


<p>事件传递路径的最终目的时找出能处理和响应该事件的对象。因此，UIKit给适合处理该事件的对象发送事件。对于触摸事件，这个对象就是hit-test view，对于其他事件，这个对象就是第一个响应器（first responder）。</p>

<h3>触摸事件的响应链</h3>

<p>iOS使用hit-testing寻找触摸的view。 Hit-Testing通过检查触摸点是否在关联的view边界内，如果在，则递归地（recursively）检查该view的所有子view。在层级上处于lowest（就是用户直接接触view）且边界范围包含触摸点的view成为hit-test view。确定hit-test view后，它传递触摸事件给该view。</p>

<p>举例说明，假设用户触摸了图中的view E。iOS通过如下顺序查找hit-test view。</p>

<p><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png" alt="image" /></p>

<ol>
<li>触摸点在view A中，所以要检查子view B和C。</li>
<li>触摸点不在view B中，但在C中，所以检查C的子view D和E。</li>
<li>触摸点不在D中，但在E中。</li>
</ol>


<p><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/hitTest:withEvent:">hitTest:withEvent:</a>方法通过传递进来CGPoint和UIEvent返回hit test view。该方法调用<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/pointInside:withEvent:">pointInside:withEvent:</a>方法，如果传入hitTest:withEvent:的point在view的边界范围内，则pointInside:withEvent:返回YES。然后，这个方法会在view的所有子view中递归的调用hitTest:withEvent:。</p>

<p>如果传入hitTest:withEvent:的point不在view的边界范围内，则pointInside:withEvent:返回NO。这个point会被忽略，hitTest:withEvent:返回nil。如果一个子view返回NO，则它所在的view的层级上的分支的子view都会被忽略。</p>

<p>Hit-test view是处理触摸事件的第一选择，如果hit-test view不能处理事件，该事件将从事件响应链中寻找响应器，直到系统找到一个处理事件的对象。</p>

<h3>响应器链</h3>

<p>一些类型的事件的传递依赖响应器链。响应器链（responder chain）是一系列相关的响应器对象。它开始于第一个响应器终止于应用对象（application object）。如果第一个responder不处理事件，则会根据responder chain将event传递给下一个responder。</p>

<p>Responder object，即可以响应和处理事件的对象。UIResponder类是所有responder对象的基类，它定义了动态的接口，不仅处理事件也包括处理响应行为。包括UIApplication，UIViewController，和UIView类都是responder，这意味着所有view和大部分关键的controller对象都是responder。但是Core Animation layers不是responders。</p>

<p>First responder被设计来第一个接收事件。典型的，first responder是一个view object。之所以成为第一个responder由于两个原因：</p>

<ol>
<li>覆盖canBecomeFirstResponder方法，返回YES。</li>
<li>接收becomeFirstResponder消息。如果必须，一个object能发送给自身这个消息。</li>
</ol>


<h3>响应器链的传输路径</h3>

<p>如果初始化对象（initial object）—— 即hit-test view或者first responder —— 不处理事件，UIKit会将事件传递给responder chain的下一个responder。每个responder决定它是传递事件还是通过nextResponder方法传递给它的下一个responder。这个操作继续直到一个responder处理event或者没有responder了。</p>

<p>Responder chain 序列在iOS确定一个事件并将它传递给initial object（通常是view）时开始。所以initial view有处理事件的第一个机会。下图描述了两个不同的事件传递路径（因为不同的app 设置）。一个App的事件传递路径由app特殊的构成决定，但事件传递路径会遵守相同的规则。</p>

<p><img src="http://lucifer1988.github.io/images/responser_chain.jpeg"></p>

<h3>手动指定当前view不响应事件</h3>

<p>```objectivec
&ndash;(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event {</p>

<pre><code>for (UIView *view in self.subviews) {
    if (!view.hidden &amp;&amp; view.userInteractionEnabled &amp;&amp; [view pointInside:[self convertPoint:point toView:view] withEvent:event])
        return YES;
}
return NO;
</code></pre>

<p>}
```</p>

<h3>总结</h3>

<p>事件的传递和响应分两个链：</p>

<ul>
<li>传递链：由系统向离用户最近的view传递。UIKit –> active app’s event queue –> window –> root view –>……–>lowest view</li>
<li>响应链：由离用户最近的view向系统传递。initial view –> super view –> …..–> view controller –> window –> Application</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回答Sunny的55道iOS面试题2]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/30/hui-da-sunnyde-55dao-iosmian-shi-ti-2/"/>
    <updated>2015-10-30T14:36:08+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/30/hui-da-sunnyde-55dao-iosmian-shi-ti-2</id>
    <content type="html"><![CDATA[<p>百度知道的<a href="http://weibo.com/u/1364395395">微博@我就叫Sunny怎么了</a>出了55道iOS的面试题，很多题目是很有深度，这次会将剩下的题目完成解答。</p>

<!--more-->


<h3>25. <code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？</h3>

<p><strong>我的解答：</strong></p>

<p><code>_objc_msgForward</code>用于消息的转发，直接调用会直接进入消息转发阶段。</p>

<p><strong>大神解答：</strong></p>

<blockquote><p><code>_objc_msgForward</code>是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p></blockquote>

<p>我们可以这样创建一个<code>_objc_msgForward</code>对象：</p>

<pre><code>IMP msgForwardIMP = _objc_msgForward;
</code></pre>

<p>在<a href="http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1/">上篇</a>中的《objc中向一个对象发送消息<code>[obj foo]</code>和<code>objc_msgSend()</code>函数之间有什么关系？》曾提到<code>objc_msgSend</code>在“消息传递”中的作用。在“消息传递”过程中，<code>objc_msgSend</code>的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用<code>_objc_msgForward</code>函数指针代替 IMP 。最后，执行这个 IMP 。</p>

<p>Objective-C运行时是开源的，所以我们可以看到它的实现。打开<a href="http://www.opensource.apple.com/tarballs/objc4/"> <strong><em>Apple Open Source 里Mac代码里的obj包</em></strong> </a>下载一个最新版本，找到 <code>objc-runtime-new.mm</code>，进入之后搜索<code>_objc_msgForward</code>。</p>

<p><img src="http://i.imgur.com/rGBfaoL.png" alt="enter image description here" /></p>

<p>里面有对<code>_objc_msgForward</code>的功能解释：</p>

<p><img src="http://i.imgur.com/vcThcdA.png" alt="enter image description here" /></p>

<p><code>objectivec
/***********************************************************************
* lookUpImpOrForward.
* The standard IMP lookup.
* initialize==NO tries to avoid +initialize (but sometimes fails)
* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)
* Most callers should use initialize==YES and cache==YES.
* inst is an instance of cls or a subclass thereof, or nil if none is known.
*   If cls is an un-initialized metaclass then a non-nil inst is faster.
* May return _objc_msgForward_impcache. IMPs destined for external use
*   must be converted to _objc_msgForward or _objc_msgForward_stret.
*   If you don't want forwarding at all, use lookUpImpOrNil() instead.
**********************************************************************/
</code></p>

<p>对 <code>objc-runtime-new.mm</code>文件里与<code>_objc_msgForward</code>有关的三个函数使用伪代码展示下：</p>

<p>```objectivec
//  objc-runtime-new.mm 文件里与 _objc_msgForward 有关的三个函数使用伪代码展示
//  Created by <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
//  Copyright &copy;  微博@iOS程序犭袁(<a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>). All rights reserved.
//  同时，这也是 obj_msgSend 的实现过程</p>

<p>id objc_msgSend(id self, SEL op, &hellip;) {</p>

<pre><code>if (!self) return nil;
IMP imp = class_getMethodImplementation(self-&gt;isa, SEL op);
imp(self, op, ...); //调用这个函数，伪代码...
</code></pre>

<p>}</p>

<p>//查找IMP
IMP class_getMethodImplementation(Class cls, SEL sel) {</p>

<pre><code>if (!cls || !sel) return nil;
IMP imp = lookUpImpOrNil(cls, sel);
if (!imp) return _objc_msgForward; //_objc_msgForward 用于消息转发
return imp;
</code></pre>

<p>}</p>

<p>IMP lookUpImpOrNil(Class cls, SEL sel) {</p>

<pre><code>if (!cls-&gt;initialize()) {
    _class_initialize(cls);
}

Class curClass = cls;
IMP imp = nil;
do { //先查缓存,缓存没有时重建,仍旧没有则向父类查询
    if (!curClass) break;
    if (!curClass-&gt;cache) fill_cache(cls, curClass);
    imp = cache_getImp(curClass, sel);
    if (imp) break;
} while (curClass = curClass-&gt;superclass);

return imp;
</code></pre>

<p>}
<code>``
虽然Apple没有公开</code>_objc_msgForward`的实现源码，但是我们还是能得出结论：</p>

<blockquote><p><code>_objc_msgForward</code>是一个函数指针（和 IMP 的类型一样），是用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p>

<p>在<a href="http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1/">上篇</a>中的《objc中向一个对象发送消息<code>[obj foo]</code>和<code>objc_msgSend()</code>函数之间有什么关系？》曾提到<code>objc_msgSend</code>在“消息传递”中的作用。在“消息传递”过程中，<code>objc_msgSend</code>的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用<code>_objc_msgForward</code>函数指针代替 IMP 。最后，执行这个 IMP 。</p></blockquote>

<p>为了展示消息转发的具体动作，这里尝试向一个对象发送一条错误的消息，并查看一下<code>_objc_msgForward</code>是如何进行转发的。</p>

<p>首先开启调试模式、打印出所有运行时发送的消息：
可以在代码里执行下面的方法：</p>

<p><code>objectivec
(void)instrumentObjcMessageSends(YES);
</code></p>

<p>或者断点暂停程序运行，并在 gdb 中输入下面的命令：</p>

<p><code>objectivec
call (void)instrumentObjcMessageSends(YES)
</code></p>

<p>以第二种为例，操作如下所示：</p>

<p><img src="http://i.imgur.com/uEwTCC4.png" alt="enter image description here" /></p>

<p>之后，运行时发送的所有消息都会打印到<code>/tmp/msgSend-xxxx</code>文件里了。</p>

<p>终端中输入命令前往：</p>

<p><code>objectivec
open /private/tmp
</code></p>

<p><img src="http://i.imgur.com/Fh5hhCw.png" alt="enter image description here" /></p>

<p>可能看到有多条，找到最新生成的，双击打开</p>

<p>在模拟器上执行执行以下语句（这一套调试方案仅适用于模拟器，真机不可用，关于该调试方案的拓展链接：<a href="http://stackoverflow.com/a/10750398/3395008"> <strong><em>Can the messages sent to an object in Objective-C be monitored or printed out?</em></strong> </a>），向一个对象发送一条错误的消息：</p>

<p>```objectivec
//
//  main.m
//  CYLObjcMsgForwardTest
//
//  Created by <a href="http://weibo.com/luohanchenyilong/.">http://weibo.com/luohanchenyilong/.</a>
//  Copyright &copy; 2015年 微博@iOS程序犭袁. All rights reserved.
//</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<h1>import &ldquo;AppDelegate.h&rdquo;</h1>

<h1>import &ldquo;CYLTest.h&rdquo;</h1>

<p>int main(int argc, char * argv[]) {</p>

<pre><code>@autoreleasepool {
    CYLTest *test = [[CYLTest alloc] init];
    [test performSelector:(@selector(iOS程序犭袁))];
    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
}
</code></pre>

<p>}</p>

<p>```</p>

<p><img src="http://i.imgur.com/UjbmVvB.png" alt="enter image description here" /></p>

<p>你可以在<code>/tmp/msgSend-xxxx</code>（我这一次是<code>/tmp/msgSend-9805</code>）文件里，看到打印出来：</p>

<p><img src="http://i.imgur.com/AAERz1T.png" alt="enter image description here" /></p>

<p><code>objectivec
+ CYLTest NSObject initialize
+ CYLTest NSObject alloc
- CYLTest NSObject init
- CYLTest NSObject performSelector:
+ CYLTest NSObject resolveInstanceMethod:
+ CYLTest NSObject resolveInstanceMethod:
- CYLTest NSObject forwardingTargetForSelector:
- CYLTest NSObject forwardingTargetForSelector:
- CYLTest NSObject methodSignatureForSelector:
- CYLTest NSObject methodSignatureForSelector:
- CYLTest NSObject class
- CYLTest NSObject doesNotRecognizeSelector:
- CYLTest NSObject doesNotRecognizeSelector:
- CYLTest NSObject class
</code></p>

<p>结合<a href="https://developer.apple.com/library/prerelease/watchos/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/#//apple_ref/doc/uid/20000050-SW11">《NSObject官方文档》</a>，排除掉 NSObject 做的事，剩下的就是<code>_objc_msgForward</code>消息转发做的几件事：</p>

<ol>
<li><p>调用<code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始<code>objc_msgSend</code>流程。这一次对象会响应这个选择器，一般是因为它已经调用过<code>class_addMethod</code>。如果仍没实现，继续下面的动作。</p></li>
<li><p>调用<code>forwardingTargetForSelector:</code>方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。</p></li>
<li><p>调用<code>methodSignatureForSelector:</code>方法，尝试获得一个方法签名。如果获取不到，则直接调用<code>doesNotRecognizeSelector</code>抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给<code>forwardInvocation:</code>。</p></li>
<li><p>调用<code>forwardInvocation:</code>方法，将第3步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。</p></li>
<li><p>调用<code>doesNotRecognizeSelector:</code> ，默认的实现是抛出异常。如果第3步没能获得一个方法签名，执行该步骤。</p></li>
</ol>


<p>上面前4个方法均是模板方法，开发者可以override，由 runtime 来调用。最常见的实现消息转发：就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的</p>

<p>也就是说<code>_objc_msgForward</code>在进行消息转发的过程中会涉及以下这几个方法：</p>

<ol>
<li><p><code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。</p></li>
<li><p><code>forwardingTargetForSelector:</code>方法</p></li>
<li><p><code>methodSignatureForSelector:</code>方法</p></li>
<li><p><code>forwardInvocation:</code>方法</p></li>
<li><p><code>doesNotRecognizeSelector:</code> 方法</p></li>
</ol>


<p>为了能更清晰地理解这些方法的作用，git仓库里也给出了一个Demo，名称叫“ <code>_objc_msgForward_demo</code> ”,可运行起来看看。</p>

<p>下面回答下第二个问题“直接<code>_objc_msgForward</code>调用它将会发生什么？”</p>

<p>直接调用<code>_objc_msgForward</code>是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。</p>

<p>就好像跑酷，干得好，叫“耍酷”，干不好就叫“作死”。</p>

<p>正如前文所说：</p>

<blockquote><p><code>_objc_msgForward</code>是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p></blockquote>

<p>如何调用<code>_objc_msgForward</code>？<br/>
<code>_objc_msgForward</code>隶属 C 语言，有三个参数 ：</p>

<table>
<thead>
<tr>
<th>序号</th>
<th> <code>_objc_msgForward</code>参数</th>
<th> 类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td> 1. </td>
<td> 所属对象 </td>
<td> id类型</td>
</tr>
<tr>
<td> 2. </td>
<td>方法名 </td>
<td> SEL类型 </td>
</tr>
<tr>
<td> 3. </td>
<td>可变参数 </td>
<td>可变参数类型</td>
</tr>
</tbody>
</table>


<p>首先了解下如何调用 IMP 类型的方法，IMP类型是如下格式：</p>

<p>为了直观，我们可以通过如下方式定义一个 IMP类型 ：</p>

<p><code>objectivec
typedef void (*voidIMP)(id, SEL, ...)
</code>
一旦调用<code>_objc_msgForward</code>，将跳过查找 IMP 的过程，直接触发“消息转发”，</p>

<p>如果调用了<code>_objc_msgForward</code>，即使这个对象确实已经实现了这个方法，你也会告诉<code>objc_msgSend</code>：</p>

<blockquote><p>“我没有在这个对象里找到这个方法的实现”</p></blockquote>

<p>想象下<code>objc_msgSend</code>会怎么做？通常情况下，下面这张图就是你正常走<code>objc_msgSend</code>过程，和直接调用<code>_objc_msgForward</code>的前后差别：</p>

<p><img src="http://ww1.sinaimg.cn/bmiddle/6628711bgw1eecx3jef23g206404tkbi.gif" alt="enter image description here" /></p>

<p>有哪些场景需要直接调用<code>_objc_msgForward</code>？最常见的场景是：你想获取某方法所对应的<code>NSInvocation</code>对象。举例说明：</p>

<p><a href="https://github.com/bang590/JSPatch">JSPatch （Github 链接）</a>就是直接调用<code>_objc_msgForward</code>来实现其核心功能的：</p>

<blockquote><p> JSPatch 以小巧的体积做到了让JS调用/替换任意OC方法，让iOS APP具备热更新的能力。</p></blockquote>

<p>作者的博文<a href="http://blog.cnbang.net/tech/2808/">《JSPatch实现原理详解》</a>详细记录了实现原理，有兴趣可以看下。</p>

<h3>26. runtime如何实现weak变量的自动置nil？</h3>

<p><strong>我的解答：</strong></p>

<p>原理不清楚。</p>

<p><strong>大神解答：</strong></p>

<blockquote><p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p></blockquote>

<p>在<a href="http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1/">上篇</a>中的《runtime 如何实现 weak 属性》有论述。（注：在<a href="http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1/">上篇</a>的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到<code>__weak</code>引用的解除时间。）</p>

<p>我们可以设计一个函数（伪代码）来表示上述机制：</p>

<p><code>objc_storeWeak(&amp;a, b)</code>函数：</p>

<p><code>objc_storeWeak</code>函数把第二个参数&mdash;赋值对象（b）的内存地址作为键值key，将第一个参数&mdash;weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，</p>

<p>你可以把<code>objc_storeWeak(&amp;a, b)</code>理解为：<code>objc_storeWeak(value, key)</code>，并且当key变nil，将value置nil。</p>

<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>

<p>而如果a是由assign修饰的，则：
在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。</p>

<p>下面我们将基于<code>objc_storeWeak(&amp;a, b)</code>函数，使用伪代码模拟“runtime如何实现weak属性”：</p>

<p>```objectivec
// 使用伪代码模拟：runtime如何实现weak属性
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a></p>

<p> id obj1;
 objc_initWeak(&amp;obj1, obj);
/<em>obj引用计数变为0，变量作用域结束</em>/
 objc_destroyWeak(&amp;obj1);
```</p>

<p>下面对用到的两个方法<code>objc_initWeak</code>和<code>objc_destroyWeak</code>做下解释：</p>

<p>总体说来，作用是：
通过<code>objc_initWeak</code>函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过<code>objc_destoryWeak</code>函数释放该变量（obj1）。</p>

<p>下面分别介绍下方法的内部实现：</p>

<p><code>objc_initWeak</code>函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用<code>objc_storeWeak</code>函数。</p>

<p><code>objectivec
obj1 = 0；
obj_storeWeak(&amp;obj1, obj);
</code></p>

<p>也就是说：</p>

<blockquote><p> weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）</p></blockquote>

<p>然后<code>obj_destroyWeak</code>函数将0（nil）作为参数，调用<code>objc_storeWeak</code>函数。</p>

<p><code>objc_storeWeak(&amp;obj1, 0);</code></p>

<p>前面的源代码与下列源代码相同。</p>

<p>```objectivec
// 使用伪代码模拟：runtime如何实现weak属性
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a></p>

<p>id obj1;
obj1 = 0;
objc_storeWeak(&amp;obj1, obj);
/<em> &hellip; obj的引用计数变为0，被置nil &hellip; </em>/
objc_storeWeak(&amp;obj1, 0);
```</p>

<p><code>objc_storeWeak</code>函数把第二个参数&mdash;赋值对象（obj）的内存地址作为键值，将第一个参数&mdash;weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除。</p>

<h3>27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3>

<p><strong>我的解答：</strong></p>

<p>不能向编译后得到的类添加实例变量，可以向运行时创建的类添加实例变量，OC是动态语言，可以在运行时向类添加实例变量和方法，原理不知道。</p>

<p><strong>大神解答：</strong></p>

<ul>
<li>不能向编译后得到的类中增加实例变量；</li>
<li>能向运行时创建的类中添加实例变量；</li>
</ul>


<p>解释下：</p>

<ul>
<li><p>因为编译后的类已经注册在 runtime 中，类结构体中的 <code>objc_ivar_list</code> 实例变量的链表 和 <code>instance_size</code> 实例变量的内存大小已经确定，同时runtime 会调用 <code>class_setIvarLayout</code> 或 <code>class_setWeakIvarLayout</code> 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；</p></li>
<li><p>运行时创建的类是可以添加实例变量，调用 <code>class_addIvar</code> 函数。但是得在调用 <code>objc_allocateClassPair</code> 之后，<code>objc_registerClassPair</code> 之前，原因同上。</p></li>
</ul>


<h3>28. runloop和线程有什么关系？</h3>

<p><strong>我的解答：</strong></p>

<p>额，看大神的。</p>

<p><strong>大神解答：</strong></p>

<p>总的说来，Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分， Cocoa 和 CoreFundation 都提供了 run loop 对象方便配置和管理线程的 run loop （以下都以 Cocoa 为例）。每个线程，包括程序的主线程（ main thread ）都有与之相应的 run loop 对象。</p>

<p> runloop 和线程的关系：</p>

<ol>
<li>主线程的run loop默认是启动的。</li>
</ol>


<p> iOS的应用程序里面，程序启动后会有一个如下的main()函数</p>

<p>```objectivec
int main(int argc, char * argv[]) {</p>

<pre><code>@autoreleasepool {
    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
}
</code></pre>

<p>}
```</p>

<p> 重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p>

<ol>
<li><p>对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。</p></li>
<li><p>在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。</p></li>
</ol>


<p><code>objectivec
NSRunLoop *runloop = [NSRunLoop currentRunLoop];
</code></p>

<p>参考链接：<a href="http://blog.csdn.net/wzzvictory/article/details/9237973">《Objective-C之run loop详解》</a>。</p>

<h3>29. runloop的mode作用是什么？</h3>

<p><strong>我的解答：</strong></p>

<p>额，继续看大神的。</p>

<p><strong>大神解答：</strong></p>

<p>model 主要是用来指定事件在运行循环中的优先级的，分为：</p>

<ul>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态</li>
<li>UITrackingRunLoopMode：ScrollView滑动时</li>
<li>UIInitializationRunLoopMode：启动时</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合</li>
</ul>


<p>苹果公开提供的 Mode 有两个：</p>

<ol>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）</li>
</ol>


<h3>30. 以+ scheduledTimerWithTimeInterval&hellip;的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3>

<p><strong>我的解答：</strong></p>

<p>应该和上面的Runloop的mode优先级有关，具体原因不明。</p>

<p><strong>大神解答：</strong></p>

<p>RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunLoopMode模式下处理的事件会影响scrllView的滑动。</p>

<p>如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候,
ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。</p>

<p>同时因为mode还是可定制的，所以：</p>

<p> Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决。代码如下：</p>

<p>```objectivec
//
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a> (微博@iOS程序犭袁)
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a></p>

<p>//将timer添加到NSDefaultRunLoopMode中
NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0</p>

<pre><code> target:self
 selector:@selector(timerTick:)
 userInfo:nil
 repeats:YES];
</code></pre>

<p>//然后再添加到NSRunLoopCommonModes里
NSTimer *timer = [NSTimer timerWithTimeInterval:1.0</p>

<pre><code> target:self
 selector:@selector(timerTick:)
 userInfo:nil
 repeats:YES];
</code></pre>

<p>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
```</p>

<h3>31. 猜想runloop内部是如何实现的？</h3>

<p><strong>我的解答：</strong></p>

<p>额，继续看大神的。</p>

<p><strong>大神解答：</strong></p>

<blockquote><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑
是这样的：</p></blockquote>

<pre><code>function loop() {
    initialize();
    do {
        var message = get_next_message();
        process_message(message);
    } while (message != quit);
}
</code></pre>

<p>或使用伪代码来展示下:</p>

<pre><code>// 
// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)
// https://github.com/ChenYilong
int main(int argc, char * argv[]) {
 //程序一直运行状态
 while (AppIsRunning) {
      //睡眠状态，等待唤醒事件
      id whoWakesMe = SleepForWakingUp();
      //得到唤醒事件
      id event = GetEvent(whoWakesMe);
      //开始处理事件
      HandleEvent(event);
 }
 return 0;
}
</code></pre>

<p>参考链接：</p>

<ol>
<li><a href="http://blog.ibireme.com/2015/05/18/runloop/#base">《深入理解RunLoop》</a></li>
<li>摘自博文<a href="https://github.com/ming1016/study/wiki/CFRunLoop"><strong><em>CFRunLoop</em></strong></a>，原作者是<a href="http://weibo.com/u/1364395395">微博@我就叫Sunny怎么了</a></li>
</ol>


<h3>32. objc使用什么机制管理对象内存？</h3>

<p><strong>我的解答：</strong></p>

<p>通过retain count，即引用计数，来管理对象内存，当retain count大于0时对象内存就不会释放，而retain count为0时对象会自动释放内存，通过retain、release来增加/减少retain count。</p>

<p><strong>大神解答：</strong></p>

<p>通过 retainCount 的机制来决定对象是否需要释放。
每次 runloop 的时候，都会检查对象的 retainCount，如果retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。</p>

<h3>33. ARC通过什么方式帮助开发者管理内存？</h3>

<p><strong>我的解答：</strong></p>

<p>ARC引入了新的关键字strong、weak来描述对象的持有关系，更加简化了对象对内存的占有关系，而在实现时还是使用retain count机制，只是编译器会自动添加内存相关的代码，而且很多地方作了特殊的优化，比如：对象创建方法和普通方法返回对象时，会添加不同的内存关键字，所以ARC还是强烈推荐的。</p>

<p><strong>大神解答：</strong></p>

<p> <p><del>编译时根据代码上下文，插入 retain/release
</del></p>
ARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单。应该是编译期和运行期两部分共同帮助开发者管理内存。</p>

<p>在编译期，ARC用的是更底层的C接口实现的retain/release/autorelease，这样做性能更好，也是为什么不能在ARC环境下手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化（即忽略掉不必要的操作）；ARC也包含运行期组件，这个地方做的优化比较复杂，但也不能被忽略。【TODO:后续更新会详细描述下】</p>

<h3>34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h3>

<p><strong>我的解答：</strong></p>

<p>该对象加入最近创建的的autoreleasepool中，而该autoreleasepool会在当前runloop循环结束时，执行drain操作，而此时其内的对象都会被执行一次release操作。</p>

<p><strong>大神解答：</strong></p>

<p>分两种情况：手动干预释放时机、系统自动去释放。</p>

<ol>
<li>手动干预释放时机&mdash;指定autoreleasepool
就是所谓的：当前作用域大括号结束时释放。</li>
<li>系统自动去释放&mdash;不手动指定autoreleasepool</li>
</ol>


<p>  Autorelease对象出了作用域之后，会被添加到最近一次创建的自动释放池中，并会在当前的 runloop 迭代结束时释放。</p>

<p>释放的时机总结起来，可以用下图来表示：</p>

<p><img src="http://i61.tinypic.com/28kodwp.jpg" alt="autoreleasepool与 runloop 的关系图" /></p>

<p>下面对这张图进行详细的解释：</p>

<p>从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</p>

<p>我们都是知道：
<strong>所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。</strong></p>

<p>但是如果每次都放进应用程序的 <code>main.m</code> 中的 autoreleasepool 中，迟早有被撑满的一刻。这个过程中必定有一个释放的动作。何时？</p>

<p>在一次完整的运行循环结束之前，会被销毁。</p>

<p>那什么时间会创建自动释放池？运行循环检测到事件并启动后，就会创建自动释放池。</p>

<p>子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。</p>

<p>自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如： 自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。</p>

<p>但对于 blockOperation 和 invocationOperation 这种默认的Operation ，系统已经帮我们封装好了，不需要手动创建自动释放池。</p>

<p>@autoreleasepool 当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release 消息，释放自动释放池中的所有对象。</p>

<p> 如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。</p>

<p>参考链接：<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">《黑幕背后的Autorelease》</a></p>

<h3>35. BAD_ACCESS在什么情况下出现？</h3>

<p><strong>我的解答：</strong></p>

<p>当所访问的对象指针指向的内存已经释放，但指针没有置nil，成为野指针，会报BAD_ACCESS错误。</p>

<p><strong>大神解答：</strong></p>

<p>访问了野指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。</p>

<h3>36. 苹果是如何实现autoreleasepool的？</h3>

<p><strong>我的解答：</strong></p>

<p>autoreleasepool在内存中是以栈的形式储存的，在顶端的的pool会最先经行drain操作。</p>

<p><strong>大神解答：</strong></p>

<p>autoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成.</p>

<ol>
<li><code>objc_autoreleasepoolPush</code></li>
<li><code>objc_autoreleasepoolPop</code></li>
<li><code>objc_autorelease</code></li>
</ol>


<p>看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。</p>

<p>举例说明：我们都知道用类方法创建的对象都是 Autorelease 的，那么一旦 Person 出了作用域，当在 Person 的 dealloc 方法中打上断点，我们就可以看到这样的调用堆栈信息：</p>

<p> <img src="http://i60.tinypic.com/15mfj11.jpg" alt="enter image description here" /></p>

<h3>37. 使用block时什么情况会发生引用循环，如何解决？</h3>

<p><strong>我的解答：</strong></p>

<p>当block本身作为类的强引用，而在block内部又对self的属性进行的使用，因为block会默认retain包含的对象，所以此时block会与self相互引用，而导致循环引用，解决方法一般是声明__weak属性的self替代，而在block内部使用weak替代，这样block就不会对self有强引用，从而解除这一循环。</p>

<p><strong>大神解答：</strong></p>

<p>一个对象中强引用了block，在block中又使用了该对象，就会发射循环引用。
解决方法是将该对象使用<strong>weak或者</strong>block修饰符修饰之后再在block中使用。</p>

<ol>
<li>id weak weakSelf = self;
或者 weak __typeof(&amp;*self)weakSelf = self该方法可以设置宏</li>
<li>id __block weakSelf = self;</li>
</ol>


<h3>38. 在block内如何修改block外部变量？</h3>

<p><strong>我的解答：</strong></p>

<p>使用__block关键字来修饰需要改变的对象，该对象可在block内修改。</p>

<p><strong>大神解答：</strong></p>

<p>默认情况下，在block中访问的外部变量是复制过去的，即：<strong>写操作不对原变量生效</strong>。但是你可以加上<code>__block</code>来让其写操作生效，示例代码如下:</p>

<pre><code>__block int a = 0;
void  (^foo)(void) = ^{ 
    a = 1; 
}
f00(); 
//这里，a的值被修改为1
</code></pre>

<p>参考链接：<a href="http://weibo.com/tangqiaoboy">微博@唐巧_boy</a>的著作《iOS开发进阶》中的第11.2.3章节</p>

<h3>39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h3>

<p><strong>我的解答：</strong></p>

<p>不需要，因为这些block并不被当前类型实例持有，即使在内部使用了self的实例变量，也不会造成引用循环。</p>

<p><strong>大神解答：</strong></p>

<p>系统的某些block api中，UIView的block版本写动画时不需要考虑，但也有一些api 需要考虑：</p>

<p>所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block 强引用 self ）没有问题，比如这些：</p>

<p><code>objectivec
[UIView animateWithDuration:duration animations:^{ [self.superview layoutIfNeeded]; }];
</code></p>

<p><code>objectivec
[[NSOperationQueue mainQueue] addOperationWithBlock:^{ self.someProperty = xyz; }];
</code></p>

<p>```objectivec
[[NSNotificationCenter defaultCenter] addObserverForName:@&ldquo;someNotification&rdquo;</p>

<pre><code>                                              object:nil 
                       queue:[NSOperationQueue mainQueue]
                                          usingBlock:^(NSNotification * notification) {
                                                self.someProperty = xyz; }]; 
</code></pre>

<p>```</p>

<p>这些情况不需要考虑“引用循环”。</p>

<p>但如果你使用一些参数中可能含有 ivar 的系统 api ，如 GCD 、NSNotificationCenter就要小心一点：比如GCD 内部如果引用了 self，而且 GCD 的其他参数是 ivar，则要考虑到循环引用：</p>

<p><code>objectivec
__weak __typeof__(self) weakSelf = self;
dispatch_group_async(_operationsGroup, _operationsQueue, ^
{
__typeof__(self) strongSelf = weakSelf;
[strongSelf doSomething];
[strongSelf doSomethingElse];
} );
</code>
类似的：</p>

<p>```objectivec
  <strong>weak </strong>typeof<em>_(self) weakSelf = self;
  </em>observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&ldquo;testKey&rdquo;</p>

<pre><code>                                                            object:nil
                                                             queue:nil
                                                        usingBlock:^(NSNotification *note) {
  __typeof__(self) strongSelf = weakSelf;
  [strongSelf dismissModalViewControllerAnimated:YES];
</code></pre>

<p>  }];
```
self &mdash;> _observer &mdash;> block &mdash;> self 显然这也是一个循环引用。</p>

<h3>40. GCD的队列（<code>dispatch_queue_t</code>）分哪两种类型？</h3>

<p><strong>我的解答：</strong></p>

<p>执行的时候分同步和异步。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>串行队列Serial Dispatch Queue</li>
<li>并行队列Concurrent Dispatch Queue</li>
</ol>


<h3>41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h3>

<p><strong>我的解答：</strong></p>

<p>使用dispatch group技术，将多个dispatch queue加入同一group中，然后在group任务结束时，统一执行合成任务。</p>

<p><strong>大神解答：</strong></p>

<p>使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。</p>

<p>```objectivec
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, queue, ^{ /<em>加载图片1 </em>/ });
dispatch_group_async(group, queue, ^{ /<em>加载图片2 </em>/ });
dispatch_group_async(group, queue, ^{ /<em>加载图片3 </em>/ });
dispatch_group_notify(group, dispatch_get_main_queue(), ^{</p>

<pre><code>    // 合并图片
</code></pre>

<p>});
```</p>

<h3>42. <code>dispatch_barrier_async</code>的作用是什么？</h3>

<p><strong>我的解答：</strong></p>

<p>是用来阻塞当前queue内的并发线程，然后执行阻塞的任务，任务执行完后，继续并发操作。</p>

<p><strong>大神解答：</strong></p>

<p> 在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。
 <code>dispatch_barrier_async</code> 函数会等待追加到Concurrent Dispatch Queue并行队列中的操作全部执行完之后，然后再执行 <code>dispatch_barrier_async</code> 函数追加的处理，等 <code>dispatch_barrier_async</code> 追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。</p>

<p>打个比方：比如你们公司周末跟团旅游，高速休息站上，司机说：大家都去上厕所，速战速决，上完厕所就上高速。超大的公共厕所，大家同时去，程序猿很快就结束了，但程序媛就可能会慢一些，即使你第一个回来，司机也不会出发，司机要等待所有人都回来后，才能出发。 <code>dispatch_barrier_async</code> 函数追加的内容就如同 “上完厕所就上高速”这个动作。</p>

<p>（注意：使用 <code>dispatch_barrier_async</code> ，该函数只能搭配自定义并行队列 <code>dispatch_queue_t</code> 使用。不能使用： <code>dispatch_get_global_queue</code> ，否则 <code>dispatch_barrier_async</code> 的作用会和 <code>dispatch_async</code> 的作用一模一样。 ）</p>

<h3>43. 苹果为什么要废弃<code>dispatch_get_current_queue</code>？</h3>

<p><strong>我的解答：</strong></p>

<p>因为<code>dispatch_get_current_queue</code>并不能保证获取到的queue就是代码逻辑上正在运行的queue，尤其在dispatch互相嵌套时，按照<code>dispatch_get_current_queue</code>来判断，容易造成死锁。</p>

<p><strong>大神解答：</strong></p>

<p><code>dispatch_get_current_queue</code>容易造成死锁</p>

<h3>44. 以下代码运行结果如何？</h3>

<pre><code>- (void)viewDidLoad
{
    [super viewDidLoad];
    NSLog(@"1");
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@"2");
    });
    NSLog(@"3");
}
</code></pre>

<p><strong>我的解答：</strong></p>

<p>输出1，造成死锁。</p>

<p><strong>大神解答：</strong></p>

<p>只输出：1 。发生主线程锁死。</p>

<h3>45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h3>

<p><strong>我的解答：</strong></p>

<p>observer是监听者，keyPath是要监听的字段，option可以定义值以何种情况下改变触发监听，context不常用，实现的回调是：</p>

<p><code>objectivec
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;
</code></p>

<p><strong>大神解答：</strong></p>

<p><code>objectivec
// 添加键值观察
/*
1 观察者，负责处理监听事件的对象
2 观察的属性
3 观察的选项
4 上下文
*/
[self.person addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@"Person Name"];
</code>
observer中需要实现一下方法：</p>

<p><code>objectivec
// 所有的 kvo 监听到事件，都会调用此方法
/*
 1. 观察的属性
 2. 观察的对象
 3. change 属性变化字典（新／旧）
 4. 上下文，与监听的时候传递的一致
 */
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;
</code></p>

<h3>46. 如何手动触发一个value的KVO</h3>

<p><strong>我的解答：</strong></p>

<p>改变所监听属性的值即可触发。</p>

<p><strong>大神解答：</strong></p>

<p>所谓的“手动触发”是区别于“自动触发”：</p>

<p>自动触发是指类似这种场景：在注册 KVO 之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。</p>

<p>想知道如何手动触发，必须知道自动触发 KVO 的原理：</p>

<p>键值观察通知依赖于 NSObject 的两个方法:  <code>willChangeValueForKey:</code> 和 <code>didChangevlueForKey:</code> 。在一个被观察属性发生改变之前，  <code>willChangeValueForKey:</code> 一定会被调用，这就
会记录旧的值。而当改变发生后，  <code>didChangeValueForKey:</code> 会被调用，继而 <code>observeValueForKey:ofObject:change:context:</code> 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了。</p>

<p>那么“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。</p>

<p>具体做法如下：</p>

<p>如果这个  <code>value</code> 是  表示时间的 <code>self.now</code> ，那么代码如下：最后两行代码缺一不可。</p>

<p>```objectivec
//  .m文件
//  Created by <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
//  微博@iOS程序犭袁(<a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>).
//  手动触发 value 的KVO，最后两行代码缺一不可。</p>

<p>//@property (nonatomic, strong) NSDate *now;
&ndash; (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad];
[self willChangeValueForKey:@"now"]; // “手动触发self.now的KVO”，必写。
[self didChangeValueForKey:@"now"]; // “手动触发self.now的KVO”，必写。
</code></pre>

<p>}
```</p>

<p>但是平时我们一般不会这么干，我们都是等系统去“自动触发”。“自动触发”的实现原理：</p>

<blockquote><p>比如调用 <code>setNow:</code> 时，系统还会以某种方式在中间插入 <code>wilChangeValueForKey:</code> 、 <code>didChangeValueForKey:</code>  和 <code>observeValueForKeyPath:ofObject:change:context:</code> 的调用。</p></blockquote>

<p>大家可能以为这是因为 <code>setNow:</code> 是合成方法，有时候我们也能看到人们这么写代码:</p>

<p>```objectivec
&ndash; (void)setNow:(NSDate *)aDate {</p>

<pre><code>[self willChangeValueForKey:@"now"]; // 没有必要
_now = aDate;
[self didChangeValueForKey:@"now"];// 没有必要
</code></pre>

<p>}
<code>``
这是完全没有必要的代码，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用</code>willChangeValueForKey:<code> ，之后总是调用</code>didChangeValueForkey:` 。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。下文《apple用什么方式实现对一个对象的KVO？》会有详述。</p>

<p>参考链接： <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOCompliance.html#//apple_ref/doc/uid/20002178-SW3">Manual Change Notification&mdash;-Apple 官方文档</a></p>

<h3>47. 若一个类有实例变量 <code>NSString *_foo</code> ，调用setValue:forKey:时，可以以foo还是 <code>_foo</code> 作为key？</h3>

<p><strong>我的解答：</strong></p>

<p>都行。</p>

<p><strong>大神解答：</strong></p>

<p>都可以。</p>

<h3>48. KVC的keyPath中的集合运算符如何使用？</h3>

<p><strong>我的解答：</strong></p>

<p>没用过。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>必须用在集合对象上或普通对象的集合属性上</li>
<li>简单集合运算符有@avg， @count ， @max ， @min ，@sum，</li>
<li>格式 @&ldquo;@sum.age"或 @"集合属性.@max.age&rdquo;</li>
</ol>


<h3>49. KVC和KVO的keyPath一定是属性么？</h3>

<p><strong>我的解答：</strong></p>

<p>不清楚有其他类型。</p>

<p><strong>大神解答：</strong></p>

<p>KVO支持实例变量</p>

<h3>50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</h3>

<p><strong>我的解答：</strong></p>

<p>额，不知道。</p>

<p><strong>大神解答：</strong></p>

<p>不常用，大神也没解释，请参考：<a href="http://tech.glowing.com/cn/implement-kvo/">《如何自己动手实现 KVO》</a></p>

<h3>51. apple用什么方式实现对一个对象的KVO？</h3>

<p><strong>我的解答：</strong></p>

<p>额，不清楚。</p>

<p><strong>大神解答：</strong></p>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html">Apple 的文档</a>对 KVO 实现的描述：</p>

<blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling&hellip; When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class &hellip;</p></blockquote>

<p>从<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html">Apple 的文档</a>可以看出：Apple 并不希望过多暴露 KVO 的实现细节。不过，要是借助 runtime 提供的方法去深入挖掘，所有被掩盖的细节都会原形毕露：</p>

<blockquote><p>当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象：值的更改。最后通过 <code>isa 混写（isa-swizzling）</code> 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。我画了一张示意图，如下所示：</p></blockquote>

<p><img src="http://i62.tinypic.com/sy57ur.jpg" alt="enter image description here" /></p>

<p> KVO 确实有点黑魔法：</p>

<blockquote><p>Apple 使用了 <code>isa 混写（isa-swizzling）</code>来实现 KVO 。</p></blockquote>

<p>下面做下详细解释：</p>

<p>键值观察通知依赖于 NSObject 的两个方法:  <code>willChangeValueForKey:</code> 和 <code>didChangevlueForKey:</code> 。在一个被观察属性发生改变之前，  <code>willChangeValueForKey:</code> 一定会被调用，这就会记录旧的值。而当改变发生后，  <code>didChangeValueForKey:</code> 会被调用，继而 <code>observeValueForKey:ofObject:change:context:</code> 也会被调用。可以手动实现这些调用，但很少有人这么做。一般我们只在希望能控制回调的调用时机时才会这么做。大部分情况下，改变通知会自动调用。</p>

<p> 比如调用 <code>setNow:</code> 时，系统还会以某种方式在中间插入 <code>wilChangeValueForKey:</code> 、 <code>didChangeValueForKey:</code>  和 <code>observeValueForKeyPath:ofObject:change:context:</code> 的调用。大家可能以为这是因为 <code>setNow:</code> 是合成方法，有时候我们也能看到人们这么写代码:</p>

<p>```objectivec
&ndash; (void)setNow:(NSDate *)aDate {</p>

<pre><code>[self willChangeValueForKey:@"now"]; // 没有必要
_now = aDate;
[self didChangeValueForKey:@"now"];// 没有必要
</code></pre>

<p>}
<code>``
这是完全没有必要的代码，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用</code>willChangeValueForKey:<code> ，之后总是调用</code>didChangeValueForkey:<code>。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。第一次对一个对象调用</code>addObserver:forKeyPath:options:context:` 时，框架会创建这个类的新的 KVO 子类，并将被观察对象转换为新子类的对象。在这个 KVO 特殊子类中， Cocoa 创建观察属性的 setter ，大致工作原理如下:</p>

<p>```objectivec
&ndash; (void)setNow:(NSDate *)aDate {</p>

<pre><code>[self willChangeValueForKey:@"now"];
[super setValue:aDate forKey:@"now"];
[self didChangeValueForKey:@"now"];
</code></pre>

<p>}
```
这种继承和方法注入是在运行时而不是编译时实现的。这就是正确命名如此重要的原因。只有在使用KVC命名约定时，KVO才能做到这一点。</p>

<p>KVO 在实现中通过 <code>isa 混写（isa-swizzling）</code> 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。这在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html">Apple 的文档</a>可以得到印证：</p>

<blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling&hellip; When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class &hellip;</p></blockquote>

<p>然而 KVO 在实现中使用了 <code>isa 混写（ isa-swizzling）</code> ，这个的确不是很容易发现：Apple 还重写、覆盖了 <code>-class</code> 方法并返回原来的类。 企图欺骗我们：这个类没有变，就是原本那个类。。。</p>

<p>但是，假设“被监听的对象”的类对象是 <code>MYClass</code> ，有时候我们能看到对 <code>NSKVONotifying_MYClass</code> 的引用而不是对  <code>MYClass</code>  的引用。借此我们得以知道 Apple 使用了 <code>isa 混写（isa-swizzling）</code>。具体探究过程可参考<a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html"> 这篇博文 </a>。</p>

<h3>52. IBOutlet连出来的视图属性为什么可以被设置成weak?</h3>

<p><strong>我的解答：</strong></p>

<p>忘了。如果做成strong，需要手动去释放这些控件。</p>

<p><strong>大神解答：</strong></p>

<p>参考链接：<a href="http://stackoverflow.com/questions/7678469/should-iboutlets-be-strong-or-weak-under-arc"> <strong><em>Should IBOutlets be strong or weak under ARC?</em></strong> </a></p>

<p>文章告诉我们：</p>

<blockquote><p>因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了。</p></blockquote>

<p>不过这个回答漏了个重要知识，使用storyboard（xib不行）创建的vc，会有一个叫_topLevelObjectsToKeepAliveFromStoryboard的私有数组强引用所有top level的对象，所以这时即便outlet声明成weak也没关系</p>

<h3>53. IB中User Defined Runtime Attributes如何使用？</h3>

<p><strong>我的解答：</strong></p>

<p>可以对控件添加额外的属性。</p>

<p><strong>大神解答：</strong></p>

<p>它能够通过KVC的方式配置一些你在interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller</p>

<h3>54. 如何调试BAD_ACCESS错误</h3>

<p><strong>我的解答：</strong></p>

<p>通过开启NSZombies，可以在对象释放后创建其对应的Zombie对象，并记录对其发送的消息，然后打印给开发者，从而告知开发者造成内存泄露的对象类型和方法。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>重写object的respondsToSelector方法，现实出现EXEC_BAD_ACCESS前访问的最后一个object</li>
<li><p>通过 Zombie
<img src="http://i.stack.imgur.com/ZAdi0.png" alt="enter image description here" /></p></li>
<li><p>设置全局断点快速定位问题代码所在行</p></li>
<li>Xcode 7 已经集成了BAD_ACCESS捕获功能：<strong>Address Sanitizer</strong>。
用法如下：在配置中勾选✅Enable Address Sanitizer
<img src="https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Art/xc7-asan_2x.png" alt="enter image description here" /></li>
</ol>


<h3>55. lldb（gdb）常用的调试命令？</h3>

<p><strong>我的解答：</strong></p>

<p>用过po命令打印出当前对象的值。</p>

<p><strong>大神解答：</strong></p>

<ul>
<li>breakpoint 设置断点定位到某一个函数</li>
<li>n 断点指针下一步</li>
<li>po打印对象</li>
</ul>


<p>更多 lldb（gdb） 调试命令可查看</p>

<ol>
<li><a href="http://lldb.llvm.org/lldb-gdb.html"> <strong><em>The LLDB Debugger</em></strong> </a>；</li>
<li>苹果官方文档：<a href="https://developer.apple.com/library/ios/technotes/tn2239/_index.html"> <strong><em>iOS Debugging Magic</em></strong> </a>。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回答Sunny的55道iOS面试题1]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1/"/>
    <updated>2015-10-28T15:32:57+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1</id>
    <content type="html"><![CDATA[<p>百度知道的<a href="http://weibo.com/u/1364395395">微博@我就叫Sunny怎么了</a>出了55道iOS的面试题，很多题目是很有深度，现在自己尝试解一下这些题，并付上大神给出的答案。</p>

<!--more-->


<h3>1. 风格纠错题</h3>

<p><img src="http://i.imgur.com/O7Zev94.png" alt="enter image description here" /></p>

<p><strong>我的解答：</strong></p>

<p>```objectivec
typedef NS_ENUM(NSInteger, CCUserSex) {</p>

<pre><code>CCUserSexMan = 0,
CCUserSexWoman
</code></pre>

<p>}
@interface CCUser : NSObject
@property(nonatomic, copy)NSString <em>name;
@property(nonatomic, assign)NSUInteger age;
@property(nonatomic, assign)CCUserSex sex;
+(instancetype)userWithName:(NSString </em>)name age:(NSUInteger)age;
&ndash;(instancetype)initWithName:(NSString *)name age:(NSUInteger)age;</p>

<p>&ndash;(void)login;
```</p>

<p><strong>大神解答：</strong></p>

<p>```objectivec
// .h文件
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
// 修改完的代码，这是第一种修改方法，后面会给出第二种修改方法</p>

<p>typedef NS_ENUM(NSInteger, CYLSex) {</p>

<pre><code>CYLSexMan,
CYLSexWoman
</code></pre>

<p>};</p>

<p>@interface CYLUser : NSObject<NSCopying></p>

<p>@property (nonatomic, readonly, copy) NSString *name;
@property (nonatomic, readonly, assign) NSUInteger age;
@property (nonatomic, readonly, assign) CYLSex sex;</p>

<ul>
<li>(instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</li>
<li>(instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</li>
</ul>


<p>@end
```</p>

<p> 详解：</p>

<p> 1.enum建议使用NS_ENUM和NS_OPTIONS来定义，这是Apple推荐的枚举定义宏，主要是可以通过它来指定type的类型。<br/>
 2.数值型变量尽量使用Foundation的数据类型，而不要使用c的类型，主要是为了适配不同处理器而考虑的。<br/>
 3.大的工程必须在类前加前缀作为命名空间。<br/>
 4.命名习惯，通常情况下，即使有类似 withA:withB: 的命名需求，也通常是使用withA:andB: 这种命名，用来表示方法执行了两个相对独立的操作（从设计上来说，这时候也可以拆分成两个独立的方法），它不应该用作阐明有多个参数，比如下面的：</p>

<p><code>objectivec
 //错误，不要使用"and"来连接参数
- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;
//错误，不要使用"and"来阐明有多个参数
- (instancetype)initWithName:(CGFloat)name andAge:(CGFloat)age;
//正确，使用"and"来表示两个相对独立的操作
- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;
</code></p>

<p> 5.一些有可变类型的类型，如NSString、NSArray、NSDictionary，经常使用copy来命名property，为了避免将可变类型赋给当前对象，然后在外部改变数值，而对当前类型产生影响。<br/>
 6.OC有designated和secondary初始化方法的概念。 designated初始化方法是提供所有的参数，secondary初始化方法是一个或多个，并且提供一个或者更多的默认参数来调用designated初始化方法的初始化方法。子类在继承父类时，可以添加新的secondary初始化方法，但必须在内部调用父类的designated初始化方法，而且也必须重写父类暴露的secondary初始化方法。</p>

<h3>2. 什么情况使用 weak 关键字，相比 assign 有什么不同？</h3>

<p> <strong>我的解答：</strong><br/>
weak关键字一般用于xib导出的IBOutlet类型控件的变量声明，和delegate的声明，主要用于避免循环引用。相比assign，weak也是不会改变对象的retain count，但是weak只能用于object的property声明，而assign一般用于数值型变量的property声明。</p>

<p> <strong>大神解答：</strong></p>

<ol>
<li>在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性</li>
<li>自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。</li>
</ol>


<p>不同点：</p>

<ol>
<li><p><code>weak</code> 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，
然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。
而 <code>assign</code> 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或
NSlnteger 等)的简单赋值操作。</p></li>
<li><p>assigin 可以用非 OC 对象,而 weak 必须用于 OC 对象</p></li>
</ol>


<h3>3. 怎么用 copy 关键字？</h3>

<p><strong>我的解答：</strong></p>

<ol>
<li>copy一般用于property时是用于NSString、NSArray、NSDictionary这些有可变类型，原因为了避免将可变类型赋给当前对象，然后在外部改变数值，而对当前类型产生影响。</li>
<li>然后也经常适用于block类型的property赋值，原因是block声明时是被存放在栈中，如果不使用copy对其操作，将其拷贝到堆上，那么该block会在其声明的作用域失效时被释放。</li>
</ol>


<p><strong>大神解答：</strong></p>

<ol>
<li>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</li>
<li>block 也经常使用 copy 关键字，具体原因见<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12">官方文档：<strong><em>Objects Use Properties to Keep Track of Blocks</em></strong></a>：</li>
</ol>


<p>  block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。</p>

<p><img src="http://i.imgur.com/VlVKl8L.png" alt="enter image description here" /></p>

<p>下面做下解释：
 copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。
当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>

<blockquote><p>用 <code>@property</code> 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p></blockquote>

<h3>4. 这个写法会出什么问题： <code>@property (copy) NSMutableArray *array;</code></h3>

<p><strong>我的解答：</strong></p>

<p>对NSMutableArray执行copy操作，会返回NSArray类型的对象，那么给array赋值一个NSMutabeArray后，再对其经行修改操作，会出现错误。</p>

<p><strong>大神解答：</strong></p>

<p>两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；2、使用了 atomic 属性会严重影响性能 ；</p>

<p>比如下面的代码就会发生崩溃</p>

<p>```objectivec
// .h文件
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
// 下面的代码就会发生崩溃</p>

<p>@property (nonatomic, copy) NSMutableArray *mutableArray;
```</p>

<p>```objectivec
// .m文件
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
// 下面的代码就会发生崩溃</p>

<p>NSMutableArray *array = [NSMutableArray arrayWithObjects:@1,@2,nil];
self.mutableArray = array;
[self.mutableArray removeObjectAtIndex:0];
```</p>

<p>接下来就会崩溃：</p>

<p><code>objectivec
 -[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460
</code></p>

<p>第2条原因，如下：</p>

<blockquote><p>该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销。</p></blockquote>

<p>在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic))。</p>

<p>在iOS开发中，你会发现，几乎所有属性都声明为 nonatomic。</p>

<p>一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。</p>

<p>因此，开发iOS程序时一般都会使用 nonatomic 属性。但是在开发 Mac OS X 程序时，使用
 atomic 属性通常都不会有性能瓶颈。</p>

<h3>5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</h3>

<p><strong>我的解答：</strong></p>

<p>1.要让自己的类实现NSCopying协议的方法，也就是<strong>&ndash; (id)copyWithZone:(NSZone *)zone;</strong>方法。<br/>
2.重写copy的setter：</p>

<p>```objectivec
&ndash;(void)setCopyProperty:(id)copyProperty{</p>

<pre><code>_copyProperty = [copyProperty copy];
</code></pre>

<p>}
```</p>

<p><strong>大神解答：</strong></p>

<blockquote><p>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 <code>NSCopying</code> 与 <code>NSMutableCopying</code> 协议。</p></blockquote>

<p>具体步骤：</p>

<ol>
<li>需声明该类遵从 NSCopying 协议</li>
<li>实现 NSCopying 协议。该协议只有一个方法:</li>
</ol>


<p><code>objectivec
- (id)copyWithZone:(NSZone *)zone;
</code>
注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。</p>

<p>以第一题的代码为例：</p>

<p>```objectivec</p>

<pre><code>// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 修改完的代码

typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

@interface CYLUser : NSObject&lt;NSCopying&gt;

@property (nonatomic, readonly, copy) NSString *name;
@property (nonatomic, readonly, assign) NSUInteger age;
@property (nonatomic, readonly, assign) CYLSex sex;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;

@end
</code></pre>

<p>```</p>

<p>然后实现协议中规定的方法：</p>

<p>```objectivec
&ndash; (id)copyWithZone:(NSZone *)zone {</p>

<pre><code>CYLUser *copy = [[[self class] allocWithZone:zone] 
                 initWithName:_name
                              age:_age
                              sex:_sex];
return copy;
</code></pre>

<p>}
```
但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如 CYLUser 中含有一个数组，与其他 CYLUser 对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码:</p>

<p>```objectivec
// .h文件
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
// 以第一题《风格纠错题》里的代码为例</p>

<p>typedef NS_ENUM(NSInteger, CYLSex) {</p>

<pre><code>CYLSexMan,
CYLSexWoman
</code></pre>

<p>};</p>

<p>@interface CYLUser : NSObject<NSCopying></p>

<p>@property (nonatomic, readonly, copy) NSString *name;
@property (nonatomic, readonly, assign) NSUInteger age;
@property (nonatomic, readonly, assign) CYLSex sex;</p>

<ul>
<li>(instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</li>
<li>(instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</li>
<li>(void)addFriend:(CYLUser *)user;</li>
<li>(void)removeFriend:(CYLUser *)user;</li>
</ul>


<p>@end
```</p>

<p>// .m文件</p>

<p>```objectivec
// .m文件
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
//</p>

<p>@implementation CYLUser {</p>

<pre><code>NSMutableSet *_friends;
</code></pre>

<p>}</p>

<ul>
<li><p>(void)setName:(NSString *)name {
  _name = [name copy];
}</p></li>
<li><p>(instancetype)initWithName:(NSString *)name
                       age:(NSUInteger)age
                       sex:(CYLSex)sex {
  if(self = [super init]) {
      <em>name = [name copy];
      </em>age = age;
      <em>sex = sex;
      </em>friends = [[NSMutableSet alloc] init];
  }
  return self;
}</p></li>
<li><p>(void)addFriend:(CYLUser *)user {
  [_friends addObject:user];
}</p></li>
<li><p>(void)removeFriend:(CYLUser *)user {
  [_friends removeObject:person];
}</p></li>
<li><p>(id)copyWithZone:(NSZone <em>)zone {
  CYLUser </em>copy = [[[self class] allocWithZone:zone]
                   initWithName:<em>name
                   age:</em>age
                   sex:<em>sex];
  copy-></em>friends = [_friends mutableCopy];
  return copy;
}</p></li>
<li><p>(id)deepCopy {
  CYLUser *copy = [[[self class] allocWithZone:zone]
                   initWithName:<em>name
                   age:</em>age
                   sex:<em>sex];
  copy-></em>friends = [[NSMutableSet alloc] initWithSet:_friends
                                           copyItems:YES];
  return copy;
}</p></li>
</ul>


<p>@end</p>

<p>```</p>

<p>以上做法能满足基本的需求，但是也有缺陷：</p>

<blockquote><p>如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。</p></blockquote>

<p>【注：深浅拷贝的概念，在下文中有介绍，详见下文的：<strong><em>用@property声明的 NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？</em></strong>】</p>

<p>在例子中，存放朋友对象的 set 是用 “copyWithZone:” 方法来拷贝的，这种浅拷贝方式不会逐个复制 set 中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法:</p>

<p>```objectivec
&ndash; (id)deepCopy {</p>

<pre><code>CYLUser *copy = [[[self class] allocWithZone:zone]
                 initWithName:_name
                 age:_age
                 sex:_sex];
copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends
                                         copyItems:YES];
return copy;
</code></pre>

<p>}</p>

<p>```</p>

<p>至于<strong><em>如何重写带 copy 关键字的 setter</em></strong>这个问题，</p>

<p>如果抛开本例来回答的话，如下：</p>

<p>```objectivec
&ndash; (void)setName:(NSString *)name {</p>

<pre><code>//[_name release];
_name = [name copy];
</code></pre>

<p>}
```</p>

<p>不过也有争议，有人说“苹果如果像下面这样干，是不是效率会高一些？”</p>

<p>```objectivec
&ndash; (void)setName:(NSString *)name {</p>

<pre><code>if (_name != name) {
    //[_name release];//MRC
    _name = [name copy];
}
</code></pre>

<p>}
```</p>

<p>这样真得高效吗？不见得！这种写法“看上去很美、很合理”，但在实际开发中，它更像下图里的做法：</p>

<p><img src="http://i.imgur.com/UwV9oSn.jpeg" alt="enter image description here" /></p>

<p>克强总理这样评价你的代码风格：</p>

<p><img src="http://i.imgur.com/N77Lkic.png" alt="enter image description here" /></p>

<p>我和总理的意见基本一致：</p>

<blockquote><p>老百姓 copy 一下，咋就这么难？</p></blockquote>

<p>你可能会说：</p>

<p>之所以在这里做<code>if判断</code> 这个操作：是因为一个 if 可能避免一个耗时的copy，还是很划算的。
(在刚刚讲的：《如何让自己的类用 copy 修饰符？》里的那种复杂的copy，我们可以称之为 “耗时的copy”，但是对 NSString 的 copy 还称不上。)</p>

<p>但是你有没有考虑过代价：</p>

<blockquote><p>你每次调用 <code>setX:</code> 都会做 if 判断，这会让 <code>setX:</code> 变慢，如果你在 <code>setX:</code>写了一串复杂的 <code>if+elseif+elseif+...</code> 判断，将会更慢。</p></blockquote>

<p>要回答“哪个效率会高一些？”这个问题，不能脱离实际开发，就算 copy 操作十分耗时，if 判断也不见得一定会更快，除非你把一个“ @property他当前的值 ”赋给了他自己，代码看起来就像：</p>

<p><code>objectivec
[a setX:x1];
[a setX:x1];    //你确定你要这么干？与其在setter中判断，为什么不把代码写好？
</code></p>

<p>或者</p>

<p><code>objectivec
[a setX:[a x]];   //队友咆哮道：你在干嘛？！！
</code></p>

<blockquote><p>不要在 setter 里进行像 <code>if(_obj != newObj)</code> 这样的判断。（该观点参考链接：<a href="http://vgable.com/blog/tag/autorelease/"> <strong><em>How To Write Cocoa Object Setters： Principle 3: Only Optimize After You Measure</em></strong> </a>
）</p></blockquote>

<p>什么情况会在 copy setter 里做 if 判断？
例如，车速可能就有最高速的限制，车速也不可能出现负值，如果车子的最高速为300，则 setter 的方法就要改写成这样：</p>

<p>```objectivec
&ndash;(void)setSpeed:(int)_speed{</p>

<pre><code>if(_speed &lt; 0) speed = 0;
if(_speed &gt; 300) speed = 300;
_speed = speed;
</code></pre>

<p>}
```</p>

<p>回到这个题目，如果单单就上文的代码而言，我们不需要也不能重写 name 的 setter ：由于是 name 是只读属性，所以编译器不会为其创建对应的“设置方法”，用初始化方法设置好属性值之后，就不能再改变了。（ 在本例中，之所以还要声明属性的“内存管理语义”&mdash;copy，是因为：如果不写 copy，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而低效）。</p>

<p>那如何确保 name 被 copy？在初始化方法(initializer)中做：</p>

<p>```objectivec</p>

<pre><code>- (instancetype)initWithName:(NSString *)name 
                             age:(NSUInteger)age 
                             sex:(CYLSex)sex {
     if(self = [super init]) {
        _name = [name copy];
        _age = age;
        _sex = sex;
        _friends = [[NSMutableSet alloc] init];
     }
     return self;
}
</code></pre>

<p>```</p>

<h3>6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h3>

<p><strong>我的解答：</strong></p>

<ol>
<li>@property本质就是自动为变量创建对应的setter，getter的快捷语法。</li>
<li>额，不会。</li>
</ol>


<p><strong>大神解答：</strong></p>

<p><strong>@property 的本质是什么？</strong></p>

<blockquote><p>@property = ivar + getter + setter;</p></blockquote>

<p>下面解释下：</p>

<blockquote><p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p></blockquote>

<p>“属性” (property)作为 objectivec 的一项特性，主要的作用就在于封装对象中的数据。 objectivec 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 <code>objectivec 2.0</code> 的一部分。
而在正规的 objectivec 编码风格中，存取方法有着严格的命名规范。
正因为有了这种严格的命名规范，所以 objectivec 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p>

<blockquote><p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。
所以你也可以这么说：</p>

<p>@property = getter + setter;</p></blockquote>

<p>例如下面这个类：</p>

<p><code>objectivec
@interface Person : NSObject
@property NSString *firstName;
@property NSString *lastName;
@end
</code></p>

<p>上述代码写出来的类与下面这种写法等效：</p>

<p><code>objectivec
@interface Person : NSObject
- (NSString *)firstName;
- (void)setFirstName:(NSString *)firstName;
- (NSString *)lastName;
- (void)setLastName:(NSString *)lastName;
@end
</code></p>

<p><strong>ivar、getter、setter 是如何生成并添加到这个类中的?</strong></p>

<blockquote><p>“自动合成”( autosynthesis)</p></blockquote>

<p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译
器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为
 <code>_firstName</code> 与 <code>_lastName</code>。也可以在类的实现代码里通过
 <code>@synthesize</code> 语法来指定实例变量的名字.</p>

<p><code>objectivec
@implementation Person
@synthesize firstName = _myFirstName;
@synthesize lastName = _myLastName;
@end
</code></p>

<p>我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西</p>

<ol>
<li><code>OBJC_IVAR_$类名$属性名称</code> ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。</li>
<li>setter 与 getter 方法对应的实现函数</li>
<li><code>ivar_list</code> ：成员变量列表</li>
<li><code>method_list</code> ：方法列表</li>
<li><code>prop_list</code> ：属性列表</li>
</ol>


<p>也就是说我们每次在增加一个属性,系统都会在 <code>ivar_list</code> 中添加一个成员变量的描述,在 <code>method_list</code> 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</p>

<h3>7. @protocol 和 category 中如何使用 @property</h3>

<p><strong>我的解答：</strong></p>

<p>理论上说@protocol和category是不能使用@property，主要是声明property后，不能自动合成setter、getter方法，所以无法使用变量，不过确实存在需要时，可以使用associated objects技术为其绑定对象，作为实例变量的代替。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性</li>
<li><p>category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：</p></li>
<li><p> <code>objc_setAssociatedObject</code></p></li>
<li> <code>objc_getAssociatedObject</code></li>
</ol>


<h3>8. runtime 如何实现 weak 属性</h3>

<p><strong>我的解答：</strong></p>

<p>额，不会。</p>

<p><strong>大神解答：</strong></p>

<p>要实现 weak 属性，首先要搞清楚 weak 属性的特点：</p>

<blockquote><p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p></blockquote>

<p>那么 runtime 如何实现 weak 变量的自动置nil？</p>

<blockquote><p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p></blockquote>

<h3>9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</h3>

<p><strong>我的解答：</strong></p>

<p>有atomic、nonatomic、retain、assign、copy、strong（ARC）、weak（ARC）、readonly、readwrite，另外有指定setter和getter方法的关键字setter=setXXX、getter=xxx，最后一个在BOOL型对象时常用getter=isXXX来替代getter方法。</p>

<p><strong>大神解答：</strong></p>

<p>属性可以拥有的特质分为四类:</p>

<ol>
<li><p>原子性&mdash;&ndash; <code>nonatomic</code> 特质</p>

<p>在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。</p></li>
<li><p>读/写权限&mdash;&ndash;<code>readwrite(读写)</code>、<code>readonly (只读)</code></p></li>
<li>内存管理语义&mdash;&ndash;<code>assign</code>、<code>strong</code>、 <code>weak</code>、<code>unsafe_unretained</code>、<code>copy</code></li>
<li>方法名&mdash;&ndash;<code>getter=&lt;name&gt;</code> 、<code>setter=&lt;name&gt;</code></li>
</ol>


<p>  <code>getter=&lt;name&gt;</code>的样式：</p>

<p>```objectivec</p>

<pre><code>    @property (nonatomic, getter=isOn) BOOL on;
</code></pre>

<p><code>``
 &lt;p&gt;&lt;del&gt;（</code>setter=<name>`这种不常用，也不推荐使用。故不在这里给出写法。）
</del></p></p>

<p> <code>setter=&lt;name&gt;</code>一般用在特殊的情境下，比如：</p>

<p>在数据反序列化、转模型的过程中，服务器返回的字段如果以 <code>init</code> 开头，所以你需要定义一个 <code>init</code> 开头的属性，但默认生成的 <code>setter</code> 与 <code>getter</code> 方法也会以 <code>init</code> 开头，而编译器会把所有以 <code>init</code> 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。</p>

<p>这时你就可以使用下面的方式来避免编译器报错：</p>

<p>```objectivec
@property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:)NSString *initBy;</p>

<p>```</p>

<p>另外也可以用关键字进行特殊说明，来避免编译器报错：</p>

<p><code>objectivec
@property(nonatomic, readwrite, copy, null_resettable) NSString *initBy;
- (NSString *)initBy __attribute__((objc_method_family(none)));
</code></p>

<ol>
<li>不常用的：<code>nonnull</code>,<code>null_resettable</code>,<code>nullable</code></li>
</ol>


<h3>10. weak属性需要在dealloc中置nil么？</h3>

<p><strong>我的解答：</strong></p>

<p>不需要，weak属性的变量，在其所指向内存释放后，会自动指向nil，成为空指针。</p>

<p><strong>大神解答：</strong></p>

<p>不需要。</p>

<blockquote><p>在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理</p></blockquote>

<p>即便是编译器不帮我们做这些，weak也不需要在 dealloc 中置nil：</p>

<p>正如上文的：<strong><em>runtime 如何实现 weak 属性</em></strong> 中提到的：</p>

<p>我们模拟下 weak 的 setter 方法，应该如下：</p>

<p>```objectivec
&ndash; (void)setObject:(NSObject *)object
{</p>

<pre><code>objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);
[object cyl_runAtDealloc:^{
    _object = nil;
}];
</code></pre>

<p>}
```</p>

<p>也即:</p>

<blockquote><p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p></blockquote>

<h3>11. @synthesize和@dynamic分别有什么作用？</h3>

<p><strong>我的解答：</strong></p>

<p>@synthesize用于合成声明的property的实例变量和其setter、getter方法，并可以在其后面声明对应的内部变量，目前已不需要手写@synthesize操作，系统会对property执行autosynthesize操作。而@dynamic声明的变量，是告诉系统该变量没有显式的setter、getter方法，但是会在运行时为其添加setter/getter方法，常用于CoreData变量的声明，不是很常用。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是<code>@syntheszie var = _var;</code></li>
<li>@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。</li>
<li>@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 <code>instance.var = someVar</code>，由于缺 setter 方法会导致程序崩溃；或者当运行到 <code>someVar = var</code> 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</li>
</ol>


<h3>12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h3>

<p><strong>我的解答：</strong></p>

<p>默认添加的关键字有atomic，readwrite，assign。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>对应基本数据类型默认关键字是<br/>
atomic,readwrite,assign</li>
<li>对于普通的 objectivec 对象<br/>
atomic,readwrite,strong</li>
</ol>


<p>参考链接：</p>

<ol>
<li><p><a href="http://stackoverflow.com/a/15541801/3395008"> <strong><em>objectivec ARC: strong vs retain and weak vs assign</em></strong> </a></p></li>
<li><p><a href="http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html"> <strong><em>Variable property attributes or Modifiers in iOS</em></strong> </a></p></li>
</ol>


<h3>13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h3>

<p><strong>我的解答：</strong></p>

<p>上面答过。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.</li>
<li>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.</li>
</ol>


<p> copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。
当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>

<p>举例说明：</p>

<p>定义一个以 strong 修饰的 array：</p>

<p><code>objectivec
@property (nonatomic ,readwrite, strong) NSArray *array;
</code></p>

<p>然后进行下面的操作：</p>

<p>```objectivec</p>

<pre><code>NSMutableArray *mutableArray = [[NSMutableArray alloc] init];
NSArray *array = @[ @1, @2, @3, @4 ];
self.array = mutableArray;
[mutableArray removeAllObjects];;
NSLog(@"%@",self.array);

[mutableArray addObjectsFromArray:array];
self.array = [mutableArray copy];
[mutableArray removeAllObjects];;
NSLog(@"%@",self.array);
</code></pre>

<p>```</p>

<p>打印结果如下所示：</p>

<p>```objectivec
2015-09-27 19:10:32.523 CYLArrayCopyDmo[10681:713670] (
)
2015-09-27 19:10:32.524 CYLArrayCopyDmo[10681:713670] (</p>

<pre><code>1,
2,
3,
4
</code></pre>

<p>)
```</p>

<p>（详见仓库内附录的 Demo。）</p>

<p>为了理解这种做法，首先要知道，两种情况：</p>

<ol>
<li>对非集合类对象的 copy 与 mutableCopy 操作；</li>
<li>对集合类对象的 copy 与 mutableCopy 操作。</li>
</ol>


<h4>1. 对非集合类对象的copy操作：</h4>

<p>在非集合类对象中：对 immutable 对象进行 copy 操作，是指针复制，mutableCopy 操作时内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：</p>

<ul>
<li>[immutableObject copy] // 浅复制</li>
<li>[immutableObject mutableCopy] //深复制</li>
<li>[mutableObject copy] //深复制</li>
<li>[mutableObject mutableCopy] //深复制</li>
</ul>


<p>比如以下代码：</p>

<p><code>objectivec
NSMutableString *string = [NSMutableString stringWithString:@"origin"];//copy
NSString *stringCopy = [string copy];
</code></p>

<p>查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：</p>

<p><code>objectivec
[string appendString:@"origion!"]
</code></p>

<p>stringCopy 的值也不会因此改变，但是如果不使用 copy，stringCopy 的值就会被改变。
  集合类对象以此类推。
所以，</p>

<blockquote><p>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p></blockquote>

<h4>2、集合类对象的copy与mutableCopy</h4>

<p>集合类对象是指 NSArray、NSDictionary、NSSet &hellip; 之类的对象。下面先看集合类immutable对象使用 copy 和 mutableCopy 的一个例子：</p>

<p><code>objectivec
NSArray *array = @[@[@"a", @"b"], @[@"c", @"d"]];
NSArray *copyArray = [array copy];
NSMutableArray *mCopyArray = [array mutableCopy];
</code></p>

<p>查看内容，可以看到 copyArray 和 array 的地址是一样的，而 mCopyArray 和 array 的地址是不同的。说明 copy 操作进行了指针拷贝，mutableCopy 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 array 这个对象，array 集合内部的元素仍然是指针拷贝。这和上面的非集合 immutable 对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看 mutable 对象拷贝的例子：</p>

<p><code>objectivec
NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@"a"],@"b",@"c",nil];
NSArray *copyArray = [array copy];
NSMutableArray *mCopyArray = [array mutableCopy];
</code></p>

<p>查看内存，如我们所料，copyArray、mCopyArray和 array 的内存地址都不一样，说明 copyArray、mCopyArray 都对 array 进行了内容拷贝。同样，我们可以得出结论：</p>

<p>在集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：</p>

<p><code>objectivec
[immutableObject copy] // 浅复制
[immutableObject mutableCopy] //单层深复制
[mutableObject copy] //单层深复制
[mutableObject mutableCopy] //单层深复制
</code></p>

<p>这个代码结论和非集合类的非常相似。</p>

<p>参考链接：<a href="https://www.zybuluo.com/MicroCai/note/50592">iOS 集合的深复制与浅复制</a></p>

<h3>14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为<code>_foo</code>的实例变量，那么还会自动合成新变量么？</h3>

<p><strong>我的解答：</strong></p>

<p>额，规则不知道，感觉不会合成新变量。</p>

<p><strong>大神解答：</strong></p>

<p>在回答之前先说明下一个概念：</p>

<blockquote><p>实例变量 = 成员变量 ＝ ivar</p></blockquote>

<p>这些说法，笔者下文中，可能都会用到，指的是一个东西。</p>

<p>正如
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW6">Apple官方文档 <strong><em>You Can Customize Synthesized Instance Variable Names</em></strong></a> 所说：
<img src="http://i.imgur.com/D6d0zGJ.png" alt="enter image description here" /></p>

<p>如果使用了属性的话，那么编译器就会自动编写访问属性所需的方法，此过程叫做“自动合成”( auto synthesis)。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法” (synthesized method)的源代码。除了生成方法代码之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。</p>

<p><code>objectivec
@interface CYLPerson : NSObject
@property NSString *firstName;
@property NSString *lastName;
@end
</code></p>

<p>在上例中，会生成两个实例变量，其名称分别为
 <code>_firstName</code> 与 <code>_lastName</code>。也可以在类的实现代码里通过 <code>@synthesize</code> 语法来指定实例变量的名字:</p>

<p><code>objectivec
@implementation CYLPerson
@synthesize firstName = _myFirstName;
@synthesize lastName = _myLastName;
@end
</code></p>

<p>上述语法会将生成的实例变量命名为 <code>_myFirstName</code> 与 <code>_myLastName</code> ，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>

<p>总结下 @synthesize 合成实例变量的规则，有以下几点：</p>

<ol>
<li><p>如果指定了成员变量的名称,会生成一个指定的名称的成员变量,</p></li>
<li><p>如果这个成员已经存在了就不再生成了.</p></li>
<li>如果是 <code>@synthesize foo;</code> 还会生成一个名称为foo的成员变量，也就是说：</li>
</ol>


<blockquote><p>如果没有指定成员变量的名称会自动生成一个属性同名的成员变量,</p></blockquote>

<ol>
<li>如果是 <code>@synthesize foo = _foo;</code> 就不会生成成员变量了.</li>
</ol>


<p>假如 property 名为 foo，存在一个名为 <code>_foo</code> 的实例变量，那么还会自动合成新变量么？
不会。如下图：</p>

<p><img src="http://i.imgur.com/t28ge4W.png" alt="enter image description here" /></p>

<h3>15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h3>

<p><strong>我的解答：</strong></p>

<p>额，为了指定内部变量的名称会用到，其他呢？为啥就和@synthesize干上了？</p>

<p><strong>大神解答：</strong></p>

<p>回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？</p>

<ol>
<li>同时重写了 setter 和 getter 时</li>
<li>重写了只读属性的 getter 时</li>
<li>使用了 @dynamic 时</li>
<li>在 @protocol 中定义的所有属性</li>
<li>在 category 中定义的所有属性</li>
<li>重载的属性</li>
</ol>


<p>当你在子类中重载了父类中的属性，你必须 使用 <code>@synthesize</code> 来手动合成ivar。</p>

<p>除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理 @property 的所有内容时，你就会尝试通过实现 @property 的所有“存取方法”（the accessor methods）或者使用 <code>@dynamic</code> 来达到这个目的，这时编译器就会认为你打算手动管理 @property，于是编译器就禁用了 autosynthesis（自动合成）。</p>

<p>因为有了 autosynthesis（自动合成），大部分开发者已经习惯不去手动定义ivar，而是依赖于 autosynthesis（自动合成），但是一旦你需要使用ivar，而 autosynthesis（自动合成）又失效了，如果不去手动定义ivar，那么你就得借助 <code>@synthesize</code> 来手动合成 ivar。</p>

<p>其实，<code>@synthesize</code> 语法还有一个应用场景，但是不太建议大家使用：</p>

<p>可以在类的实现代码里通过 <code>@synthesize</code> 语法来指定实例变量的名字:</p>

<p><code>objectivec
@implementation CYLPerson
@synthesize firstName = _myFirstName;
@synthesize lastName = _myLastName;
@end
</code></p>

<p>上述语法会将生成的实例变量命名为 <code>_myFirstName</code> 与 <code>_myLastName</code>，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>

<p>举例说明：应用场景：</p>

<p>```objectivec</p>

<p>//
// .m文件
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a> (微博@iOS程序犭袁)
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
// 打开第14行和第17行中任意一行，就可编译成功</p>

<p>@import Foundation;</p>

<p>@interface CYLObject : NSObject
@property (nonatomic, copy) NSString *title;
@end</p>

<p>@implementation CYLObject {</p>

<pre><code>//    NSString *_title;
</code></pre>

<p>}</p>

<p>//@synthesize title = _title;</p>

<ul>
<li><p>(instancetype)init
{
  self = [super init];
  if (self) {
      _title = @&ldquo;微博@iOS程序犭袁&rdquo;;
  }
  return self;
}</p></li>
<li><p>(NSString *)title {
  return _title;
}</p></li>
<li><p>(void)setTitle:(NSString *)title {
  _title = [title copy];
}</p></li>
</ul>


<p>@end
```</p>

<p>结果编译器报错：
<img src="http://i.imgur.com/fAEGHIo.png" alt="enter image description here" /></p>

<p>当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择：</p>

<ol>
<li>要么如第14行：手动创建 ivar</li>
<li>要么如第17行：使用<code>@synthesize foo = _foo;</code> ，关联 @property 与 ivar。</li>
</ol>


<p>更多信息，请戳- 》<a href="http://stackoverflow.com/a/19821816/3395008"> <strong><em>When should I use @synthesize explicitly?</em></strong> </a></p>

<h3>16. objc中向一个nil对象发送消息将会发生什么？</h3>

<p><strong>我的解答：</strong></p>

<p>返回nil。</p>

<p><strong>大神解答：</strong></p>

<p>在 objectivec 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:</p>

<ol>
<li>如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如：</li>
</ol>


<p><code>objectivec
Person * motherInlaw = [[aPerson spouse] mother];
</code></p>

<p> 如果 spouse 对象为 nil，那么发送给 nil 的消息 mother 也将返回 nil。
 2. 如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量，发送给 nil 的消息将返回0。
 2. 如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。
 2. 如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。</p>

<p>具体原因如下：</p>

<blockquote><p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p></blockquote>

<p>那么，为了方便理解这个内容，还是贴一个objc的源代码：</p>

<p>```objectivec
// runtime.h（类在runtime中的定义）
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a></p>

<p>struct objc_class {
  Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object
  #if !<strong>OBJC2</strong>
  Class super_class OBJC2_UNAVAILABLE; // 父类
  const char <em>name OBJC2_UNAVAILABLE; // 类名
  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0
  long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识
  long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小
  struct objc_ivar_list </em>ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表
  struct objc_method_list <em><em>methodLists OBJC2_UNAVAILABLE; // 方法定义的链表
  struct objc_cache </em>cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。
  struct objc_protocol_list </em>protocols OBJC2_UNAVAILABLE; // 协议链表
  #endif
  } OBJC2_UNAVAILABLE;
```</p>

<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。
那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</p>

<h3>17. objc中向一个对象发送消息[obj foo]和<code>objc_msgSend()</code>函数之间有什么关系？</h3>

<p><strong>我的解答：</strong></p>

<p>编译期间[obj foo]会被编译为C代码，也就是objc_msgSend()方法，消息的接收者和消息名都会作为参数传到该方法中。</p>

<p><strong>大神解答：</strong></p>

<p>具体原因同上题：该方法编译之后就是<code>objc_msgSend()</code>函数调用.</p>

<p>我们用 clang 分析下，clang 提供一个命令，可以将objectivec的源码改写成C++语言，借此可以研究下[obj foo]和<code>objc_msgSend()</code>函数之间有什么关系。</p>

<p>以下面的代码为例，由于 clang 后的代码达到了10万多行，为了便于区分，添加了一个叫 iOSinit 方法，</p>

<p>```objectivec
//
//  main.m
//  <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
//  <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
//  Copyright &copy; 2015年 微博@iOS程序犭袁. All rights reserved.
//</p>

<h1>import &ldquo;CYLTest.h&rdquo;</h1>

<p>int main(int argc, char * argv[]) {</p>

<pre><code>@autoreleasepool {
    CYLTest *test = [[CYLTest alloc] init];
    [test performSelector:(@selector(iOSinit))];
    return 0;
}
</code></pre>

<p>}
```</p>

<p>在终端中输入</p>

<p><code>objectivec
clang -rewrite-objc main.m
</code>
就可以生成一个<code>main.cpp</code>的文件，在最低端（10万4千行左右）</p>

<p><img src="http://i.imgur.com/eAH5YWn.png" alt="enter image description here" /></p>

<p>我们可以看到大概是这样的：</p>

<p><code>objectivec
((void ()(id, SEL))(void )objc_msgSend)((id)obj, sel_registerName("foo"));
</code></p>

<p>也就是说：</p>

<blockquote><p> [obj foo];在objc动态编译时，会被转意为：<code>objc_msgSend(obj, @selector(foo));</code>。</p></blockquote>

<h3>18. 什么时候会报unrecognized selector的异常？</h3>

<p><strong>我的解答：</strong></p>

<p>当向对象发送消息时，对象无法响应该消息，且在系统的转发后也无法响应时，最后会报错unrecognized selector。</p>

<p><strong>大神解答：</strong></p>

<p>简单来说：</p>

<blockquote><p>当调用该对象上某个方法,而该对象上没有实现这个方法的时候，
可以通过“消息转发”进行解决。</p></blockquote>

<p>简单的流程如下，在上一题中也提到过：</p>

<blockquote><p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p></blockquote>

<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：</p>

<ol>
<li>Method resolution</li>
</ol>


<p> objc运行时会调用<code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。</p>

<ol>
<li>Fast forwarding</li>
</ol>


<p> 如果目标对象实现了<code>-forwardingTargetForSelector:</code>，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。
只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。
这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。
 3. Normal forwarding</p>

<p> 这一步是Runtime最后一次给你挽救的机会。首先它会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果<code>-methodSignatureForSelector:</code>返回nil，Runtime则会发出<code>-doesNotRecognizeSelector:</code>消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送<code>-forwardInvocation:</code>消息给目标对象。</p>

<p>为了能更清晰地理解这些方法的作用，git仓库里也给出了一个Demo，名称叫“ <code>_objc_msgForward_demo</code> ”,可运行起来看看。</p>

<h3>19. 一个objc对象如何进行内存布局？（考虑有父类的情况）</h3>

<p><strong>我的解答：</strong></p>

<p>额，不好描述。</p>

<p><strong>大神解答：</strong></p>

<ul>
<li>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.</li>
<li><p>每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的</p></li>
<li><p> 对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）</p></li>
<li> 成员变量的列表,</li>
<li> 属性列表,</li>
</ul>


<p> 它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。</p>

<p>每个 objectivec 对象都有相同的结构，如下图所示：</p>

<p> <img src="http://i.imgur.com/7mJlUj1.png" alt="enter image description here" /></p>

<p>翻译过来就是</p>

<table>
<thead>
<tr>
<th></th>
<th>  objectivec 对象的结构图 </th>
<th> </th>
</tr>
</thead>
<tbody>
<tr>
<td> ISA指针 </td>
<td></td>
<td></td>
</tr>
<tr>
<td> 根类的实例变量 </td>
<td></td>
<td></td>
</tr>
<tr>
<td> 倒数第二层父类的实例变量 </td>
<td></td>
<td></td>
</tr>
<tr>
<td> &hellip; </td>
<td></td>
<td></td>
</tr>
<tr>
<td> 父类的实例变量 </td>
<td></td>
<td></td>
</tr>
<tr>
<td> 类的实例变量 </td>
<td> </td>
<td></td>
</tr>
</tbody>
</table>


<ul>
<li><p>根对象就是NSobject，它的superclass指针指向nil</p></li>
<li><p>类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。</p></li>
</ul>


<p>如图:
<img src="http://i.imgur.com/w6tzFxz.png" alt="enter image description here" /></p>

<h3>20. 一个objc对象的isa的指针指向什么？有什么作用？</h3>

<p><strong>我的解答：</strong></p>

<p>isa指针指向objc所属的类型的结构体，用于找到该类的方法列表。</p>

<p><strong>大神解答：</strong></p>

<p>指向他的类对象,从而可以找到对象上的方法。</p>

<h3>21. 下面的代码输出什么？</h3>

<p>```objectivec</p>

<pre><code>@implementation Son : Father
- (id)init
{
    self = [super init];
    if (self) {
        NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@", NSStringFromClass([super class]));
    }
    return self;
}
@end
</code></pre>

<p>```</p>

<p><strong>我的解答：</strong></p>

<p>son，son</p>

<p><strong>大神解答：</strong></p>

<p>都输出 Son</p>

<pre><code>NSStringFromClass([self class]) = Son
NSStringFromClass([super class]) = Son
</code></pre>

<p>这个题目主要是考察关于 objectivec 中对 self 和 super 的理解。</p>

<p>我们都知道：self 是类的隐藏参数，指向当前调用方法的这个类的实例。那 super 呢？</p>

<p>很多人会想当然的认为“ super 和 self 类似，应该是指向父类的指针吧！”。这是很普遍的一个误区。其实 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者！他们两个的不同点在于：super 会告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。</p>

<p>上面的例子不管调用<code>[self class]</code>还是<code>[super class]</code>，接受消息的对象都是当前 <code>Son ＊xxx</code> 这个对象。</p>

<p>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。</p>

<p>这也就是为什么说“不推荐在 init 方法中使用点语法”，如果想访问实例变量 iVar 应该使用下划线（ <code>_iVar</code> ），而非点语法（ <code>self.iVar</code> ）。</p>

<p>点语法（ <code>self.iVar</code> ）的坏处就是子类有可能覆写 setter 。假设 Person 有一个子类叫 ChenPerson，这个子类专门表示那些姓“陈”的人。该子类可能会覆写 lastName 属性所对应的设置方法：</p>

<p>```objectivec
//
//  ChenPerson.m
//<br/>
//
//  Created by <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a> on 15/8/30.
//  Copyright &copy; 2015年 <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a> 微博@iOS程序犭袁. All rights reserved.
//</p>

<h1>import &ldquo;ChenPerson.h&rdquo;</h1>

<p>@implementation ChenPerson</p>

<p>@synthesize lastName = _lastName;</p>

<ul>
<li><p>(instancetype)init
{
  self = [super init];
  if (self) {
      NSLog(@&ldquo;🔴类名与方法名：%s（在第%d行），描述：%@&rdquo;, <strong>PRETTY_FUNCTION</strong>, <strong>LINE</strong>, NSStringFromClass([self class]));
      NSLog(@&ldquo;🔴类名与方法名：%s（在第%d行），描述：%@&rdquo;, <strong>PRETTY_FUNCTION</strong>, <strong>LINE</strong>, NSStringFromClass([super class]));
  }
  return self;
}</p></li>
<li><p>(void)setLastName:(NSString*)lastName
{
  //设置方法一：如果setter采用是这种方式，就可能引起崩溃
//    if (![lastName isEqualToString:@&ldquo;陈&rdquo;])
//    {
//        [NSException raise:NSInvalidArgumentException format:@&ldquo;姓不是陈&rdquo;];
//    }
//    _lastName = lastName;</p>

<p>  //设置方法二：如果setter采用是这种方式，就不会引起崩溃
  _lastName = @&ldquo;陈&rdquo;;
  NSLog(@&ldquo;🔴类名与方法名：%s（在第%d行），描述：%@&rdquo;, <strong>PRETTY_FUNCTION</strong>, <strong>LINE</strong>, @&ldquo;会调用这个方法,想一下为什么？&rdquo;);</p></li>
</ul>


<p>}</p>

<p>@end
```</p>

<p>在基类 Person 的默认初始化方法中，可能会将姓氏设为空字符串。此时若使用点语法（ <code>self.lastName</code> ）也即 setter 设置方法，那么调用将会是子类的设置方法，如果在刚刚的 setter 代码中采用设置方法一，那么就会抛出异常，</p>

<p>为了方便采用打印的方式展示，究竟发生了什么，我们使用设置方法二。</p>

<p>如果基类的代码是这样的：</p>

<p>```objectivec
//
//  Person.m
//  nil对象调用点语法
//
//  Created by <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a> on 15/8/29.
//  Copyright &copy; 2015年 <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a> 微博@iOS程序犭袁. All rights reserved.
//</p>

<h1>import &ldquo;Person.h&rdquo;</h1>

<p>@implementation Person</p>

<ul>
<li><p>(instancetype)init
{
  self = [super init];
  if (self) {
      self.lastName = @&ldquo;&rdquo;;
      //NSLog(@&ldquo;🔴类名与方法名：%s（在第%d行），描述：%@&rdquo;, <strong>PRETTY_FUNCTION</strong>, <strong>LINE</strong>, NSStringFromClass([self class]));
      //NSLog(@&ldquo;🔴类名与方法名：%s（在第%d行），描述：%@&rdquo;, <strong>PRETTY_FUNCTION</strong>, <strong>LINE</strong>, self.lastName);
  }
  return self;
}</p></li>
<li><p>(void)setLastName:(NSString*)lastName
{
  NSLog(@&ldquo;🔴类名与方法名：%s（在第%d行），描述：%@&rdquo;, <strong>PRETTY_FUNCTION</strong>, <strong>LINE</strong>, @&ldquo;根本不会调用这个方法&rdquo;);
  _lastName = @&ldquo;炎黄&rdquo;;
}</p></li>
</ul>


<p>@end
```</p>

<p>那么打印结果将会是这样的：</p>

<p><code>objectivec
 🔴类名与方法名：-[ChenPerson setLastName:]（在第36行），描述：会调用这个方法,想一下为什么？
 🔴类名与方法名：-[ChenPerson init]（在第19行），描述：ChenPerson
 🔴类名与方法名：-[ChenPerson init]（在第20行），描述：ChenPerson
</code></p>

<p>我在仓库里也给出了一个相应的 Demo（名字叫：Demo_21题_下面的代码输出什么）。有兴趣可以跑起来看一下，主要看下他是怎么打印的，思考下为什么这么打印。</p>

<p>接下来让我们利用 runtime 的相关知识来验证一下 super 关键字的本质，使用clang重写命令:</p>

<p>```objectivec</p>

<pre><code>$ clang -rewrite-objc test.m
</code></pre>

<p>```</p>

<p>将这道题目中给出的代码被转化为:</p>

<p>```objectivec</p>

<pre><code>NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName("class"))));

NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){ (id)self, (id)class_getSuperclass(objc_getClass("Son")) }, sel_registerName("class"))));
</code></pre>

<p>```</p>

<p>从上面的代码中，我们可以发现在调用 [self class] 时，会转化成 <code>objc_msgSend</code>函数。看下函数定义：</p>

<p>```objectivec</p>

<pre><code>id objc_msgSend(id self, SEL op, ...)
</code></pre>

<p>```
我们把 self 做为第一个参数传递进去。</p>

<p>而在调用 [super class]时，会转化成 <code>objc_msgSendSuper</code>函数。看下函数定义:</p>

<p>```objectivec</p>

<pre><code>id objc_msgSendSuper(struct objc_super *super, SEL op, ...)
</code></pre>

<p>```</p>

<p>第一个参数是 <code>objc_super</code> 这样一个结构体，其定义如下:</p>

<p>```objectivec
struct objc_super {</p>

<pre><code>   __unsafe_unretained id receiver;
   __unsafe_unretained Class super_class;
</code></pre>

<p>};
```</p>

<p>结构体有两个成员，第一个成员是 receiver, 类似于上面的 <code>objc_msgSend</code>函数第一个参数self 。第二个成员是记录当前类的父类是什么。</p>

<p>所以，当调用 ［self class] 时，实际先调用的是 <code>objc_msgSend</code>函数，第一个参数是 Son当前的这个实例，然后在 Son 这个类里面去找 &ndash; (Class)class这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 &ndash; (Class)class的实现就是返回self的类别，故上述输出结果为 Son。</p>

<p>objc Runtime开源代码对- (Class)class方法的实现:</p>

<p>```objectivec
&ndash; (Class)class {</p>

<pre><code>return object_getClass(self);
</code></pre>

<p>}
```</p>

<p>而当调用 <code>[super class]</code>时，会转换成<code>objc_msgSendSuper函数</code>。第一步先构造 <code>objc_super</code> 结构体，结构体第一个成员就是 <code>self</code> 。
第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code> , 实际该函数输出结果为 Father。</p>

<p>第二步是去 Father这个类里去找 <code>- (Class)class</code>，没有，然后去NSObject类去找，找到了。最后内部是使用 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>去调用，</p>

<p>此时已经和<code>[self class]</code>调用相同了，故上述输出结果仍然返回 Son。</p>

<p>参考链接：<a href="http://weibo.com/junbbcom">微博@Chun_iOS</a>的博文<a href="http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1">刨根问底objectivec Runtime（1）－ Self &amp; Super</a>%5Bnil%5D-self-and-super/)</p>

<h3>22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h3>

<p><strong>我的解答：</strong></p>

<p>从类型的结构体中找到对应的实例方法列表中按照selector的名称去查找对应的方法，而类方法列表存储在类型的类型，即meta class当中。</p>

<p><strong>大神解答：</strong></p>

<p>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</p>

<h3>23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h3>

<p><strong>我的解答：</strong></p>

<p>不需要，原因不清楚。</p>

<p><strong>大神解答：</strong></p>

<ul>
<li>在ARC下不需要。</li>
<li><p><del> 在MRC中,对于使用retain或copy策略的需要 。</del></p>在MRC下也不需要</li>
</ul>


<blockquote><p>无论在MRC下还是ARC下均不需要。</p></blockquote>

<p><a href="https://web.archive.org/web/20120818164935/http://developer.apple.com/library/ios/#/web/20120820002100/http://developer.apple.com/library/ios/documentation/cocoa/conceptual/objectivec/Chapters/ocAssociativeReferences.html"> <strong><em>2011年版本的Apple API 官方文档 &ndash; Associative References</em></strong>  </a> 一节中有一个MRC环境下的例子：</p>

<p>```objectivec
// 在MRC下，使用runtime Associate方法关联的对象，不需要在主对象dealloc的时候释放
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a> (微博@iOS程序犭袁)
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
// 摘自2011年版本的Apple API 官方文档 &ndash; Associative References</p>

<p>static char overviewKey;</p>

<p>NSArray *array =</p>

<pre><code>[[NSArray alloc] initWithObjects:@"One", @"Two", @"Three", nil];
</code></pre>

<p>// For the purposes of illustration, use initWithFormat: to ensure
// the string can be deallocated
NSString *overview =</p>

<pre><code>[[NSString alloc] initWithFormat:@"%@", @"First three numbers"];
</code></pre>

<p>objc_setAssociatedObject (</p>

<pre><code>array,
&amp;overviewKey,
overview,
OBJC_ASSOCIATION_RETAIN
</code></pre>

<p>);</p>

<p>[overview release];
// (1) overview valid
[array release];
// (2) overview invalid
```
文档指出</p>

<blockquote><p>At point 1, the string <code>overview</code> is still valid because the <code>OBJC_ASSOCIATION_RETAIN</code> policy specifies that the array retains the associated object. When the array is deallocated, however (at point 2), <code>overview</code> is released and so in this case also deallocated.</p></blockquote>

<p>我们可以看到，在<code>[array release];</code>之后，overview就会被release释放掉了。</p>

<p>既然会被销毁，那么具体在什么时间点？</p>

<blockquote><p>根据<a href="https://developer.apple.com/videos/wwdc/2011/#322-video"> <strong><em>WWDC 2011, Session 322 (第36分22秒)</em></strong> </a>中发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的 object_dispose() 方法中释放。</p></blockquote>

<p>对象的内存销毁时间表，分四个步骤：</p>

<pre><code>// 对象的内存销毁时间表
// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)
// https://github.com/ChenYilong
// 根据 WWDC 2011, Session 322 (36分22秒)中发布的内存销毁时间表 

 1. 调用 -release ：引用计数变为零
     * 对象正在被销毁，生命周期即将结束.
     * 不能再有新的 __weak 弱引用， 否则将指向 nil.
     * 调用 [self dealloc] 
 2. 父类 调用 -dealloc
     * 继承关系中最底层的父类 在调用 -dealloc
     * 如果是 MRC 代码 则会手动释放实例变量们（iVars）
     * 继承关系中每一层的父类 都在调用 -dealloc
 3. NSObject 调 -dealloc
     * 只做一件事：调用 objectivec runtime 中的 object_dispose() 方法
 4. 调用 object_dispose()
     * 为 C++ 的实例变量们（iVars）调用 destructors 
     * 为 ARC 状态下的 实例变量们（iVars） 调用 -release 
     * 解除所有使用 runtime Associate方法关联的对象
     * 解除所有 __weak 引用
     * 调用 free()
</code></pre>

<p>对象的内存销毁时间表：<a href="http://stackoverflow.com/a/10843510/3395008">参考链接</a>。</p>

<h3>24. objc中的类方法和实例方法有什么本质区别和联系？</h3>

<p><strong>我的解答：</strong></p>

<ol>
<li>类方法是类型调用的，而实例方法是类的实例来调用的。</li>
<li>类方法中不能使用实例方法和实例变量，而实例方法中可以使用类方法。</li>
</ol>


<p><strong>大神解答：</strong></p>

<p>类方法：</p>

<ol>
<li>类方法是属于类对象的</li>
<li>类方法只能通过类对象调用</li>
<li>类方法中的self是类对象</li>
<li>类方法可以调用其他的类方法</li>
<li>类方法中不能访问成员变量</li>
<li>类方法中不定直接调用对象方法</li>
</ol>


<p>实例方法：</p>

<ol>
<li>实例方法是属于实例对象的</li>
<li>实例方法只能通过实例对象调用</li>
<li>实例方法中的self是实例对象</li>
<li>实例方法中可以访问成员变量</li>
<li>实例方法中直接调用实例方法</li>
<li>实例方法中也可以调用类方法(通过类名)</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native初探1]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/20/react-nativechu-tan-1/"/>
    <updated>2015-10-20T17:29:08+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/20/react-nativechu-tan-1</id>
    <content type="html"><![CDATA[<p>React Native是Facebook最近推出的一个框架，让开发者通过JavaScript来完成iOS或Android的Native App，类似的方案好像几年前就出现过，比如PhoneGap，但经过市场检验，其App的用户体验，尤其是UI方面，始终较Native App相距甚远，那么这次Facebook带来的解决方案又有什么不同呢？</p>

<!--more-->


<h2>React Native特点</h2>

<ol>
<li>使用React Native后，你的App的逻辑部分是用JavaScript完成的，而UI则是完全native的，所以也不用担心H5带来的体验下降。</li>
<li>React Native还为用户界面构建带来了一种全新的函数式构建方案，App的UI会用与app的状态有关的函数来呈现。</li>
<li>React Native的核心思路是将响应式编程引入移动开发，这并不像之前PhoneGap倡导的<em>write-once,run-anywhere</em>，而是<em>learn-once,write-anywhere</em>。</li>
<li>Swift中Apple倡导使用函数式编程来完成算法和业务逻辑，但是构建UI仍然是基于UIKit，并没有实现函数式实现，而React则引入了UI层的函数式编程。</li>
</ol>


<h2>React Native环境搭建</h2>

<p>React Native的源码开源在<a href="https://github.com/facebook/react-native">GitHub</a>上，不过如果只是开发使用，则推荐使用commend line interface（CLI）来创建项目。<br/>
1.React Native使用Node.js，JavaScript的runtime，来创建JS代码。这里推荐使用Homebrew来安装Node.js。</p>

<p><code>ruby
brew install node
</code></p>

<p>2.然后安装watchman，一个Facebook开发的文件监听器，React Native通过它来监视代码的改动并适时编译，类似在Xcode中保存一次文件，便会执行一次build。</p>

<p><code>ruby
brew install watchman
</code></p>

<p>3.然后利用安装好的Node.js带的Node Package Manager来安装React Native CLI工具。</p>

<p><code>ruby
npm install -g react-native-cli
</code></p>

<p>4.这样环境就搭建完毕了，然后在目标文件夹，利用React Native的CLI创建新的项目。</p>

<p><code>ruby
react-native init YourAppFolderName
</code></p>

<h2>Hello Recact Native</h2>

<p>1.下面来创建一个“Hello World”的小程序，首先打开<strong>index.ios.js</strong>文件，删除测试代码，先添加以下代码，这段代码是开启了Strict Mode，主要为了提高JS的错误处理和禁用一些JS的语言特性。</p>

<p><code>javascript
'use strict'
</code></p>

<p>2.然后继续添加，这其实是导入了react-native模块，并将其赋值给了React，类似于#import或include。</p>

<p><code>javascript
var React = require("react-native")
</code></p>

<p>3.再添加一个样式，React Native使用了CSS来定义UI的样式，这和web开发是一致的。</p>

<p>```javascript
 var styles = React.StyleSheet.create({</p>

<pre><code>text:{
    color:'black',
    backgroundColor:'white',
    fontSize:30,
    margin:80
}
</code></pre>

<p> })
```</p>

<p>4.创建一个JS的类，Class是在ES6中引入的，但web开发为了兼容旧版浏览器，一般不会使用类，React Native是基于JavaScriptCore，可以放心使用JS的新特性，而不用担心浏览器兼容的问题。PropertyFinderApp扩展了React.Component，它是React UI的基本构建块，包含了不可变的Properties、可变的状态变量和用于渲染的方法，这里由于程序简单，只有一个渲染方法。</p>

<p>```javascript
class PropertyFinderApp extends React.Component{</p>

<pre><code>render(){
    return React.createElement(React.Text, {style:styles.text}, "Hello World!");
}
</code></pre>

<p>}
```</p>

<p>5.React.Component不是UIKit类，可以说是UIKit类的替代品，框架来负责将React components来转换为Native UI。最后再添加程序的入口，这里需要提供root component，也就是我们上面定义的PropertyFinderApp。</p>

<p><code>javascript
React.AppRegistry.registerComponent("RANTest", function(){return PropertyFinderApp});
</code></p>

<p>6.然后运行程序，你会发现JS代码已经转化为Native元素，完全没有网页元素出现。</p>

<h2>React Native运作原理</h2>

<p>1.先来看一下OC的程序加载后做了什么，一个类为RCTRootView的对象被创建，它负责加载JS程序和渲染视图，它通过*<a href="http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true*%E6%9D%A5%E5%8A%A0%E8%BD%BDJS%E3%80%82">http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true*%E6%9D%A5%E5%8A%A0%E8%BD%BDJS%E3%80%82</a></p>

<p>```objectivec
&ndash; (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{
  NSURL <em>jsCodeLocation;
  jsCodeLocation = [NSURL URLWithString:@&ldquo;<a href="http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true">http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true</a>&rdquo;];
  RCTRootView </em>rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</p>

<pre><code>                                                  moduleName:@"RANTest"
                                           initialProperties:nil
                                               launchOptions:launchOptions];
</code></pre>

<p>  self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
  UIViewController *rootViewController = [[UIViewController alloc] init];
  rootViewController.view = rootView;
  self.window.rootViewController = rootViewController;
  [self.window makeKeyAndVisible];
  return YES;
}
```</p>

<p>2.当你运行程序时，会打开一个终端窗口，就是为了开启一个packager和server来处理上述请求，在浏览器打开这一URL，也可以看到JS代码。<br/>
3.当app启动时，这些代码被载入，并被JavaScriptCore framework执行，将各个component载入，然后构建Native UIKit视图。</p>

<h2>Hello World JSX</h2>

<p>1.为了增加可读性和提高可维护性，可以使用HTML样式的JSX，也就是JavaScript syntax extension。</p>

<p><code>javascript
return &lt;React.Text style={styles.text}&gt;Hello World(Again)&lt;/React.Text&gt;;
</code></p>

<h2>A Search React Native App1</h2>

<h3>Adding Navigation</h3>

<p>1.这一节构建一个OC的NavgationController，将之前的PropertyFinderApp类改为HelloWorld，然后新定义一个PropertyFinderApp类，initialRoute定为HelloWorld，routing技术是web开发中定义导航结构，即哪个页面（或route）对应哪个URL。</p>

<p>```javascript
class PropertyFinderApp extends React.Component {
  render() {</p>

<pre><code>return (
  &lt;React.NavigatorIOS
    style={styles.container}
    initialRoute={ {
      title: 'Property Finder',
      component: HelloWorld,
    } }/&gt;
);
</code></pre>

<p>  }
}
```</p>

<p>2.然后添加container样式，这样，一个简单的导航控制器就完成了。</p>

<p>```javascript
var styles = React.StyleSheet.create({</p>

<pre><code>text:{
    color:'black',
    backgroundColor:'white',
    fontSize:30,
    margin:80
},
container:{
    flex:1
}
</code></pre>

<p>})
```</p>

<h3>Building the Search Page</h3>

<p>1.这一节介绍如何添加自定义一个Search页面，并在其他文件中进行引用。首先新建一个SearchPage.js文件，并在文件中添加代码。</p>

<p>```javascript
&lsquo;use strict&rsquo;
var React = require(&lsquo;react-native&rsquo;);
var {</p>

<pre><code>StyleSheet,
Text,
TextInput,
View,
TouchableHighlight,
ActivityIndicatorIOS,
Image,
Component
</code></pre>

<p>} = React;
```</p>

<p>2.这里使用了destructuring assignment，可以通过一行代码将多个对象属性一次性输出并将他们赋值给多个变量，这样你可以在之后的代码去掉React前缀，例如直接引用StyleSheet而不是React.StyleShet，这一技术在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">修改数组</a>时也经常用到，有点类似Swift的元组取值模式。</p>

<p><code>javascript
var foo = ["one", "two", "three"];
// without destructuring
var one   = foo[0];
var two   = foo[1];
var three = foo[2];
// with destructuring
var [one, two, three] = foo;
</code></p>

<p>3.然后创建CSS样式，并创建SearchPage component，语法依然使用了JSX的结构。</p>

<p>```javascript
var styles = StyleSheet.creat({</p>

<pre><code>description:{
    marginBottom:20,
    fontSize:18.
    textAlign:'center'.
    color:'#656565'
},
container:{
    padding:30,
    marginTop:65,
    alignItems:'center'
}
</code></pre>

<p>});
```</p>

<p>```javascript
class SearchPage extends Component {</p>

<pre><code>render() {
    return(
     &lt;View style={styles.container}&gt;
      &lt;Text style={styles.description}&gt;
       Search for houses to buy!
      &lt;/Text&gt;
      &lt;Text style={styles.description}&gt;
       Search by place-name, postcode or search near your location.
      &lt;/Text&gt;
     &lt;/View&gt;
    );
}
</code></pre>

<p>}
```</p>

<p>4.最后在文件结尾将SearchPage作为输出，并在index.ios.js中导入SearchPage，然后将之前render方法中的PropertyFinderApp类中的initialRoute更新。</p>

<p><code>javascript
module.exports = SearchPage;
</code></p>

<p><code>javascript
var SearchPage = require('./SearchPage');
</code></p>

<p><code>javascript
initialRoute={ {
  title: 'Property Finder',
  component: SearchPage,
} }
</code></p>

<h3>Styling with Flexbox</h3>

<p>1.flexbox是CSS最近加入的新特性，用于页面的布局（类似Autolayout），React Native使用了<a href="http://https://github.com/facebook/css-layout">css-layout</a>库，该库是Facebook自己开发的一个使用了flexbox标准的JS库，而这一标准对于C(iOS)和Java(Android)都是可接受的，这里有一篇专门讲解<a href="http://blog.scottlogic.com/2015/02/02/svg-layout-flexbox.html">flexbox layout to SVG</a>的文章，也是该作者写的。<br/>
2.在这个app中，container默认是列方向布局，也就是垂直方向布局（这与Android的布局方式是相同的），同时container也可以决定他的子视图的布局方向。</p>

<p>```javascript
<View style={styles.flowRight}>
  &lt;TextInput</p>

<pre><code>style={styles.searchInput}
placeholder='Search via name or postcode'/&gt;
</code></pre>

<p>  &lt;TouchableHighlight style={styles.button}</p>

<pre><code>  underlayColor='#99d9f4'&gt;
&lt;Text style={styles.buttonText}&gt;Go&lt;/Text&gt;
</code></pre>

<p>  </TouchableHighlight>
</View>
&lt;TouchableHighlight style={styles.button}</p>

<pre><code>underlayColor='#99d9f4'&gt;
</code></pre>

<p>  <Text style={styles.buttonText}>Location</Text>
</TouchableHighlight>
```</p>

<p>3.添加新的样式，记得在每个样式后要添加逗号分开，flex值是为了划分同一container下子视图的占位比，如这里的Go button和input view的flex分别为1和4，那么就按照1:4来划分，另外，这里的button是使用了TouchableHighlight。</p>

<p><code>javascript
flowRight: {
  flexDirection: 'row',
  alignItems: 'center',
  alignSelf: 'stretch'
},
buttonText: {
  fontSize: 18,
  color: 'white',
  alignSelf: 'center'
},
button: {
  height: 36,
  flex: 1,
  flexDirection: 'row',
  backgroundColor: '#48BBEC',
  borderColor: '#48BBEC',
  borderWidth: 1,
  borderRadius: 8,
  marginBottom: 10,
  alignSelf: 'stretch',
  justifyContent: 'center'
},
searchInput: {
  height: 36,
  padding: 4,
  marginRight: 5,
  flex: 4,
  fontSize: 18,
  borderWidth: 1,
  borderColor: '#48BBEC',
  borderRadius: 8,
  color: '#48BBEC'
}
</code></p>

<p>4.然后添加一张图片，图片资源依然要添加到Xcode的Images.xcassets，使用require(&lsquo;image!house&rsquo;)来加载图片，</p>

<p><code>javascript
&lt;Image source={require('image!house')} style={styles.image}/&gt;
</code></p>

<p><code>javascript
image: {
  width: 217,
  height: 138
}
</code></p>

<h2>A Search React Native App2</h2>

<h3>Adding Component State</h3>

<p>1.这一节，让我们来处理TextInput的输入，首先，我们来初始化SearchPage Component，下列代码添加到render()之前，这里有了新变量state以及searchString，并对TextInput赋该值。</p>

<p>```javascript
constructor(props) {
  super(props);
  this.state = {</p>

<pre><code>searchString: 'london'
</code></pre>

<p>  };
}
```</p>

<p><code>javascript
&lt;TextInput
  style={styles.searchInput}
  value={this.state.searchString}
  placeholder='Search via name or postcode'/&gt;
</code></p>

<p>2.然后在SearchPage Class添加一个方法，作为TextInput的回调，并将其与TextInput绑定，这一过程在OC中是以delegate的形式实现的，需要说明下的是这里的this是指向所在component的实例的指针。</p>

<p><code>javascript
onSearchTextChanged(event) {
  console.log('onSearchTextChanged');
  this.setState({ searchString: event.nativeEvent.text });
  console.log(this.state.searchString);
}
</code></p>

<p><code>javascript
&lt;TextInput
  style={styles.searchInput}
  value={this.state.searchString}
  onChange={this.onSearchTextChanged.bind(this)}
  placeholder='Search via name or postcode'/&gt;
</code></p>

<p>3.通过实验TextInput我们发现，每次TextIput的状态发生改变，整个component就会重新render一次，这一机制将渲染逻辑和与UI有关的状态改变彻底分开。在大部分UI框架中，一般都是开发者根据app状态改变来手动刷新UI（比如OC或Swift），或者使用隐式链接来绑定app的状态和UI刷新完成自动刷新（比如ReactiveCocoa），但是在React Native中，你不用再去手动处理这些逻辑，整个UI就是app状态的一个函数表示！这就是响应式编程的核心理念。<br/>
4.不过你可能会担心效率问题，频繁刷新整个UI当然是不明智的，React在每次刷新时，它会从render方法获取整个视图树，然后与现在的UIKit视图进行比较，比较的结果就是一个简单的更新表，React按照这个表去更新当前视图，所以只有需要更新的UI才会去更新。<br/>
5.这一理念的应用，将虚拟DOM和一致性引入了App开发，也是React的独特之处。</p>

<h3>Initiating a Search</h3>

<p>1.这一节为Search页面添加搜索功能，首先在state中加入isLoading变量，再在render中添加spinner变量告知用户搜索在进行，它依据isLoading变量来添加一个spinner或空视图，并将{spinner}加入return方法。</p>

<p><code>javascript
this.state = {
  searchString: 'london',
  isLoading: false
};
</code></p>

<p>```javascript
var spinner = this.state.isLoading ?
  ( &lt;ActivityIndicatorIOS</p>

<pre><code>  hidden='true'
  size='large'/&gt; ) :
</code></pre>

<p>  ( <View/>);
&hellip;
{spinner}
```</p>

<p>2.在Go Button绑定onPress事件回调，并添加回调方法，注意Javascript的类没有访问器，所以也没有私有方法，所以一般用<em>_</em>前缀来标识私有方法。</p>

<p><code>javascript
onPress={this.onSearchPressed.bind(this)}
</code></p>

<p><code>javascript
_executeQuery(query) {
  console.log(query);
  this.setState({ isLoading: true });
}
onSearchPressed() {
  var query = urlForQueryAndPage('place_name', this.state.searchString, 1);
  this._executeQuery(query);
}
</code></p>

<p>3.在SearchPage外单独定义urlForQueryAndPage()方法，这里做了URL的拼接，用到了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">JS的方法</a> 。</p>

<p>```javascript
function urlForQueryAndPage(key, value, pageNumber) {
  var data = {</p>

<pre><code>  country: 'uk',
  pretty: '1',
  encoding: 'json',
  listing_type: 'buy',
  action: 'search_listings',
  page: pageNumber
</code></pre>

<p>  };
  data[key] = value;</p>

<p>  var querystring = Object.keys(data)</p>

<pre><code>.map(key =&gt; key + '=' + encodeURIComponent(data[key]))
.join('&amp;');
</code></pre>

<p>  return &lsquo;<a href="http://api.nestoria.co.uk/api?">http://api.nestoria.co.uk/api?</a>&rsquo; + querystring;
};
```</p>

<p>4.=>是JS中对函数指针的缩写，可理解为OC中的block，这里先用map将其原字典的keys映射为新的数组，然后用&amp;相连，产生URL的参数String。</p>

<p><code>javascript
var a = [
  "Hydrogen",
  "Helium",
  "Lithium",
  "Beryl­lium"
];
var a2 = a.map(function(s){ return s.length });
var a3 = a.map( s =&gt; s.length );
</code></p>

<h3>Performing an API Request</h3>

<p>1.在state添加message变量，并在render添加Text，用以显示请求错误信息，并在_excuteQuery()中添加请求的代码。</p>

<p><code>javascript
this.state = {
  searchString: 'london',
  isLoading: false,
  message: ''
};
</code></p>

<p><code>javascript
&lt;Text style={styles.description}&gt;{this.state.message}&lt;/Text&gt;
</code></p>

<p>2.请求代码使用了fetch函数，这是<a href="https://fetch.spec.whatwg.org">Fetch API</a>中的函数，相比XMLHttpRequest，有很大提升，使用了promise规范。</p>

<p>```javascript
fetch(query)
  .then(response => response.json())
  .then(json => this._handleResponse(json.response))
  .catch(error =></p>

<pre><code> this.setState({
  isLoading: false,
  message: 'Something bad happened ' + error
</code></pre>

<p>   }));
```</p>

<p>3.success的回调处理，先对response code做了判断，然后打印出了listings的长度，可以看出JSON在JS开发中是直接使用的，而省去了转化为Model的步骤。</p>

<p>`&ldquo;javascript
_handleResponse(response) {
  this.setState({ isLoading: false , message: &rdquo; });
  if (response.application_response_code.substr(0, 1) === &lsquo;1&rsquo;) {</p>

<pre><code>console.log('Properties found: ' + response.listings.length);
</code></pre>

<p>  } else {</p>

<pre><code>this.setState({ message: 'Location not recognized; please try again.'});
</code></pre>

<p>  }
}
```</p>

<h3>Displaying the Results</h3>

<p>1.新建SearchResult.js，新建SearchResults component，代码中使用到了ListView，类似OC的UITableView，通过dataSource来提供数据源，renderRow来渲染每个cell。</p>

<p>```javascript
class SearchResults extends Component {</p>

<p>  constructor(props) {</p>

<pre><code>super(props);
var dataSource = new ListView.DataSource(
  {rowHasChanged: (r1, r2) =&gt; r1.guid !== r2.guid});
this.state = {
  dataSource: dataSource.cloneWithRows(this.props.listings)
};
</code></pre>

<p>  }</p>

<p>  renderRow(rowData, sectionID, rowID) {</p>

<pre><code>return (
  &lt;TouchableHighlight
      underlayColor='#dddddd'&gt;
    &lt;View&gt;
      &lt;Text&gt;{rowData.title}&lt;/Text&gt;
    &lt;/View&gt;
  &lt;/TouchableHighlight&gt;
);
</code></pre>

<p>  }</p>

<p>  render() {</p>

<pre><code>return (
  &lt;ListView
    dataSource={this.state.dataSource}
    renderRow={this.renderRow.bind(this)}/&gt;
);
</code></pre>

<p>  }
}
```</p>

<p>2.构建数据源时，提供了一个方法来比较row之间的id是否相同，ListView在更新时调用它，来确定数据源是否改变，本例中通过数据的guid来达到这个目的，然后在SearchPage的_handleResponse中添加导航方法。</p>

<p><code>javascript
this.props.navigator.push({
  title: 'Results',
  component: SearchResults,
  passProps: {listings: response.listings}
});
</code></p>

<h3>A Touch of Style</h3>

<p>1.添加样式，更新renderRow()方法，price为了去掉GBP后缀，做了字符串裁剪，同时这次的Image数据源为url，JS可直接赋值，而React Native会自动后台一步下载。</p>

<p>```javascript
var styles = StyleSheet.create({
  thumb: {</p>

<pre><code>width: 80,
height: 80,
marginRight: 10
</code></pre>

<p>  },
  textContainer: {</p>

<pre><code>flex: 1
</code></pre>

<p>  },
  separator: {</p>

<pre><code>height: 1,
backgroundColor: '#dddddd'
</code></pre>

<p>  },
  price: {</p>

<pre><code>fontSize: 25,
fontWeight: 'bold',
color: '#48BBEC'
</code></pre>

<p>  },
  title: {</p>

<pre><code>fontSize: 20,
color: '#656565'
</code></pre>

<p>  },
  rowContainer: {</p>

<pre><code>flexDirection: 'row',
padding: 10
</code></pre>

<p>  }
});
```</p>

<p>```javascript
renderRow(rowData, sectionID, rowID) {
  var price = rowData.price_formatted.split(&lsquo; &rsquo;)[0];</p>

<p>  return (</p>

<pre><code>&lt;TouchableHighlight onPress={() =&gt; this.rowPressed(rowData.guid)}
    underlayColor='#dddddd'&gt;
  &lt;View&gt;
    &lt;View style={styles.rowContainer}&gt;
      &lt;Image style={styles.thumb} source={ { uri: rowData.img_url } } /&gt;
      &lt;View  style={styles.textContainer}&gt;
        &lt;Text style={styles.price}&gt;£{price}&lt;/Text&gt;
        &lt;Text style={styles.title} 
              numberOfLines={1}&gt;{rowData.title}&lt;/Text&gt;
      &lt;/View&gt;
    &lt;/View&gt;
    &lt;View style={styles.separator}/&gt;
  &lt;/View&gt;
&lt;/TouchableHighlight&gt;
</code></pre>

<p>  );
}
```</p>

<p>2.然后添加点击cell的回调，可以看到数据源始终还是最原始的数据源，做了一步过滤操作（因为这里的cell没有index的概念，所以只能过滤，但是必须保证guid唯一才可以）。</p>

<p><code>javascript
rowPressed(propertyGuid) {
  var property = this.props.listings.filter(prop =&gt; prop.guid === propertyGuid)[0];
}
</code></p>

<h3>Property Details View</h3>

<p>1.添加详情页，PropertyView，首先对房屋的配置信息做了整理，然后就是常规的视图布局。</p>

<p>```javascript
class PropertyView extends Component {
  render() {</p>

<pre><code>var property = this.props.property;
var stats = property.bedroom_number + ' bed ' + property.property_type;
if (property.bathroom_number) {
  stats += ', ' + property.bathroom_number + ' ' + (property.bathroom_number &gt; 1 ? 'bathrooms' : 'bathroom');
}

var price = property.price_formatted.split(' ')[0];

return (
  &lt;View style={styles.container}&gt;
    &lt;Image style={styles.image} 
        source={ {uri: property.img_url} } /&gt;
    &lt;View style={styles.heading}&gt;
      &lt;Text style={styles.price}&gt;£{price}&lt;/Text&gt;
      &lt;Text style={styles.title}&gt;{property.title}&lt;/Text&gt;
      &lt;View style={styles.separator}/&gt;
    &lt;/View&gt;
    &lt;Text style={styles.description}&gt;{stats}&lt;/Text&gt;
    &lt;Text style={styles.description}&gt;{property.summary}&lt;/Text&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
}
```</p>

<p>2.最后从SearchResults，推入PropertyView。</p>

<p>```javascript
rowPressed(propertyGuid) {
  var property = this.props.listings.filter(prop => prop.guid === propertyGuid)[0];</p>

<p>  this.props.navigator.push({</p>

<pre><code>title: "Property",
component: PropertyView,
passProps: {property: property}
</code></pre>

<p>  });
}
```</p>

<h3>Geolocation Search</h3>

<p>1.增加自动定位并搜索周边房屋的功能，在SearchPage的Location按钮添加该功能，前提在Xcode的工程的Plist中添加NSLocationWhenInUseUsageDescription来添加请求允许定位的描述。</p>

<p><code>javascript
onPress={this.onLocationPressed.bind(this)}
</code></p>

<p>```javascript
onLocationPressed() {
  navigator.geolocation.getCurrentPosition(</p>

<pre><code>location =&gt; {
  var search = location.coords.latitude + ',' + location.coords.longitude;
  this.setState({ searchString: search });
  var query = urlForQueryAndPage('centre_point', search, 1);
  this._executeQuery(query);
},
error =&gt; {
  this.setState({
    message: 'There was a problem with obtaining your location: ' + error
  });
});
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Functions and Closures]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/20/swift-by-tutorials-functions-and-closures/"/>
    <updated>2015-10-20T17:28:15+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/20/swift-by-tutorials-functions-and-closures</id>
    <content type="html"><![CDATA[<p>函数是现代编程的一个重要部分，它将执行一个特定任务的逻辑打包到一个单元，可以复用，也可以提供给其他开发者作为黑盒接入使用。Swift支持全局的函数和类以及结构体的方法，还支持闭包，可以当做对象来传递。在这一章，会深入介绍Swift的函数，包括语法、类型及参数，还有Swift的命名习惯如何受OC的影响。最后，还有巧妙和灵活的闭包，这也是Swift作为一个函数式语言的重要原因。</p>

<!--more-->


<h2>Functions</h2>

<h3>Your first functon</h3>

<p>1.定义一个全局函数，Swift的函数全部是全局的，而方法是被定义在类或结构体中的，这与其他绝大多数语言室相同的。</p>

<p>```objectivec
func square(number: Double) &ndash;> Double {</p>

<pre><code>return number * number
</code></pre>

<p>}
```</p>

<h3>Functions are first-class</h3>

<p>1.函数在Swift中是一级对象，也就意味着它可以赋值，可以作为函数参数，也可以作为函数结果返回，这也是第七章要讲的函数式编程的基础。<br/>
2.从前面几章得知，Swift是非常强调类型的安全性，那么函数的类型是什么呢？</p>

<p><code>objectivec
let operation = square
</code></p>

<p><code>objectivec
let operation:(Double) -&gt; Double = square
</code></p>

<p>3.面对一些函数类型中嵌套过于复杂，可以考虑使用typealias来梳理代码。</p>

<p><code>objectivec
func doMath(operation:(Double) -&gt; Double) -&gt; Double {...}
</code></p>

<p><code>objectivec
typealias OperationType = (Double) -&gt; Double
func doMath(operation:OperationType) -&gt; Double {...}
</code></p>

<h3>Function syntax</h3>

<p>1.除了一些常见的参数和返回结果这些必须条件，Swift函数无返回值时，<strong>Void</strong>并不是一个关键字，而是一个类型。</p>

<p>```objectivec
func logDouble(number: Double) &ndash;> Void {</p>

<pre><code>print(String(format: "%.2f", number))
</code></pre>

<p>}
```</p>

<p><code>objectivec
typealias Void = ()
</code></p>

<p>2.所以你可以将返回空的函数返回值写为<strong>()</strong>，其实也可以不写返回符号和类型，但是函数类型没变，还是<strong>(Double) &ndash;> ()</strong>。</p>

<p>```objectivec
func logDouble(number: Double) &ndash;> () {</p>

<pre><code>print(String(format: "%.2f", number))
</code></pre>

<p>}
```</p>

<p>```objectivec
func logDouble(number: Double) {</p>

<pre><code>print(String(format: "%.2f", number))
</code></pre>

<p>}
```</p>

<h3>Overloading and generics</h3>

<p>1.Swift是支持重载的，如下两个方法是可以共存的。</p>

<p>```objectivec
func checkAreEqual(value: Int, expected: Int, message: String) {</p>

<pre><code>if expected != value {
    print(message)
}
</code></pre>

<p>}
func checkAreEqual(value: String, expected: String, message: String) {</p>

<pre><code>if expected != value {
    print(message)
}
</code></pre>

<p>}
```</p>

<p>2.这里复习下重载（overload）和重写（override）的区别，overload是指在同一类中同样方法名，但参数与返回结果可以不同；而重写是指子类覆盖父类的方法，方法名、参数、返回都相同，实现不同，重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。<br/>
3.但是其实更好的解决方案是泛型，上一章也介绍过。</p>

<p>```objectivec
func checkAreEqual&lt;T: Equatable> (value: T, expected: T, message: String) {</p>

<pre><code>if value != expected {
    print(message)
}
</code></pre>

<p>}
```</p>

<p>4.经测试会出现这一现象，这一现象出现的原因是checkAreEqual会对前两个参数类型进行检查，一是其类型必须遵循Equatable协议，二是两个参数类型必须相同，第一个出现error就是因为类型不同造成的，而后者成功是因为45并没有指明类型，所以Swift通过"cat"推测出T应该是String类型，所以45也被推测为String类型，所以通过。</p>

<p><code>objectivec
//error
checkAreEqual(Int(45), expected: "cat", message: "is not cat")
//success
checkAreEqual(45, expected: "cat", message: "is not cat")
</code></p>

<h3>In-out variables</h3>

<p>1.开发中有些情况是需要我们改变参数值的，比如下面的square方法</p>

<p>```objectivec
func square(number: Double) {</p>

<pre><code>number = number*number
</code></pre>

<p>}
```</p>

<p>2.但是这么写会直接报错，因为Swift中传入方法的参数类型默认都是let常量，是不可改变的，所以我们先将number改为var类型。</p>

<p>```objectivec
func square(var number: Double) {</p>

<pre><code>number = number*number
</code></pre>

<p>}
```</p>

<p>3.这次编译通过了，但是结果测试不对，仍输出原值，其实这里Swift与其他主流语言（OC、Java、C#、JS）一样，虽然表面上允许参数值修改，但是其实修改的是参数的本地copy，并不影响原值。<br/>
4.但是Swift还是支持直接修改原参数的，通过添加inout关键字，就可以将参数的指针地址直接传入，从而修改参数，如下：</p>

<p>```objectivec
func square(inout number: Double) {</p>

<pre><code>number = number*number
</code></pre>

<p>}
var a = 5.0
square(&amp;a)
print(a)
```</p>

<p>5.但是作者还是推荐谨慎使用，尤其在调用者对该技术不了解时，可能会造成困惑。</p>

<h3>Classes and structures as function parameters</h3>

<p>1.这一节讨论下类和结构体作为函数参数时的区别，首先看下Class作为参数的情况。</p>

<p>```objectivec
class Person {</p>

<pre><code>var age = 34, name = "Colin"
func growOlder() {
    self.age++
}
</code></pre>

<p>}
func celebrateBirthday(person: Person) {</p>

<pre><code>print("Happy Birthday \(person.name)")
person.growOlder()
</code></pre>

<p>}
let person = Person()
celebrateBirthday(person)
print(person.age)
```</p>

<p>2.结果person成功完成了age的增加，因为函数参数person和声明的实例person都是常量，并引用了相同的实例，当函数将class作为参数类型时，swift会将该类的实例的指针传入函数。<br/>
3.再看下结构体的实现，显然结构体和上一节的基本数据类型是一样的，仍需要声明参数为inout，而且在修改自身变量时需要在方法前加mutating关键字。</p>

<p>```objectivec
struct Person {</p>

<pre><code>var age = 34, name = "Colin"
mutating func growOlder() {
    self.age++
}
</code></pre>

<p>}
func celebrateBirthday(inout person: Person) {</p>

<pre><code>print("Happy Birthday \(person.name)")
person.growOlder()
</code></pre>

<p>}
var person = Person()
celebrateBirthday(&amp;person)
print(person.age)
```</p>

<p>4.另外由于array和dictionary都是struct，所以需要在函数中，他们作为参数并允许被修改时，也需要inout关键字。</p>

<h3>Variadics</h3>

<p>1.这一节来讨论有变长参数的函数类型，下面就是一个用例：</p>

<p>```objectivec
func longestWord(words: String&hellip;) &ndash;> String? {</p>

<pre><code>var currentLongest: String?
for word in words {
    if currentLongest != nil {
        if word.characters.count &gt; currentLongest!.characters.count {
            currentLongest = word
        }
    } else {
        currentLongest = word
    }
}
return currentLongest
</code></pre>

<p>}
let long = longestWord(&ldquo;chick&rdquo;, &ldquo;fish&rdquo;, &ldquo;cat&rdquo;, &ldquo;elephant&rdquo;)
print(long)
```</p>

<p>2.words相当于一个常量数组，在函数中可以直接使用for-in来遍历其成员，可变长参数可能并不常用，但是在特定场景下还是一种比较优雅的实现方式。<br/>
3.这里补充一点，计算String长度的函数已经从<strong>countElements(word)【Swift1.0】</strong> &ndash;> <strong>count(word)【Swift1.2】</strong> &ndash;> <strong>word.characters.count【Swift2.0】</strong>，经历了这一变化。<br/>
4.如果结合第七章要讲的函数式编程，其实该方法可以用reduce函数来实现，如下：</p>

<p>```objectivec
func longestWord(words: String&hellip;) &ndash;> String? {</p>

<pre><code>return words.reduce(String?()) {
(longest, word) in
longest == nil || word.characters.count &gt; longest!.characters.count
    ? word : longest
}
</code></pre>

<p>}
```</p>

<h3>External parameter names</h3>

<p>1.有时一些参数的作用表示的不是很明确，Swift不像OC，习惯在每个参数前写一段方法名，比如上述的比较字符串输入验证，光从调用来看无法得知那个是需要的名称。</p>

<p><code>objectivec
checkAreEqual("cat", "dog", "Incorrect input")
</code>
2.为了解决这一问题，Swift允许开发者添加供外部使用的参数名，可以和内部的参数名共存，内部外部各自使用不同的参数名：</p>

<p>```objectivec
func checkAreEqual(value val: String, expected exp: String, message msg: String) {</p>

<pre><code>if exp != val {
    print(msg)
}
</code></pre>

<p>}
checkAreEqual(value: &ldquo;cat&rdquo;, expected: &ldquo;dog&rdquo;, message: &ldquo;Incorrect input&rdquo;)
```</p>

<p>3.但是需要注意的是，即使是使用了另外一套参数名，调用的顺序还是要和原来一致，像下面的调用是不会成功的。</p>

<p><code>objectivec
checkAreEqual(expected: "dog", value: "cat", message: "Incorrect input")
</code></p>

<p>4.如果你的内外部参数名一致，而且也确实需要外部参数名，可以在参数名前加#来使内外部参数名相同。</p>

<p>```objectivec
func checkAreEqual(#value: String, #expected: String, #message: String) {   if expected != value {</p>

<pre><code>    println(message)
} 
</code></pre>

<p>}checkAreEqual(value: &ldquo;dog&rdquo;, expected: &ldquo;cat&rdquo;, message:&ldquo;Incorrect input&rdquo;)
```</p>

<p>2.当然这是一些场景下的问题，很多方法其实从函数名即可推断出参数的意义，而有些方法则是必须加参数名的，这一决定由具体情况来决定，<strong>大部分需要添加的属于有多个相同类型的参数</strong>。</p>

<p><code>objectivec
//purpose is clear
dateFromString("2014-03-14")
//not clear, which is row? which is colume?
convertCellAt(42, 13)
//to be clear
convertCellAt(column: 42, row: 13)
</code></p>

<h2>Methods</h2>

<p>与函数相对的是方法，方法是与类、结构体、枚举关联的函数，本章会对各类方法进行讨论。</p>

<h3>Instance methods</h3>

<p>1.下面是一个名叫cell的类，其中包含单个参数和多个参数的方法。</p>

<p>```objectivec
class Cell: CustomStringConvertible {</p>

<pre><code>private(set) var row = 0
private(set) var column = 0
func move(x: Int = 0, y: Int = 0) {
    row += y
    column += x
}
func moveByX(x: Int) {
    column += x
}
func moveByY(y: Int) {
    row += y
}
var description: String {
    get {
        return "Cell [row=\(row), col=\(column)]"
    }
}
</code></pre>

<p>}
```</p>

<p>2.调用单个参数方法与函数没有区别，而调用多参数时需要在第二个参数后加上外部变量名，这与函数是不同的。其原因是函数默认是不添加外部参数名的，而方法除了第一个参数，后面的参数都是默认添加外部参数名，且与内部参数名一致，这一点也是从OC的命名风格继承而来。</p>

<p><code>objectivec
let cell = Cell()
cell.moveByX(4)
cell.move(4, y: 7)
</code></p>

<p>3.你可以通过在参数前加<strong> _ </strong>来禁止这一默认添加外部参数名的行为，如下：</p>

<p>```objectivec
func move(x: Int, _ y: Int) {</p>

<pre><code>row += y    column += x 
</code></pre>

<p>}
cell.move(4, 7)
```</p>

<p>4.还有一个酷的特性是可以为参数赋默认值，这样调用时可以只输入单个参数，如下：</p>

<p>```objectivec
func move(x: Int = 0, y: Int = 0) {</p>

<pre><code>row += y
column += x
</code></pre>

<p>}
cell.move(4, y: 7)
cell.move(2)
cell.move(y: 3)
```</p>

<h3>Methods are first-class,too</h3>

<p>1.与function类似，Method也是第一类对象，同样可以作为参数、返回结果、或则赋值给其他变量。</p>

<p><code>objectivec
var cell = Cell()var instanceFunc = cell.moveByY
instanceFunc(34)
</code></p>

<p>2.除此之外，还有一个函数式编程的特性，直接通过类获取方法，在调用时需要绑定一个类的实例，这被称为柯里化函数，会在第七章的函数式编程介绍。</p>

<p><code>objectivec
var cell = Cell()var moveFunc = Cell.moveByY
moveFunc(cell)(34)
</code></p>

<h2>Closures</h2>

<p>闭包如同函数和方法一样，是一组代码，可以被调用或传递，但是闭包是匿名的，而且它会将它范围内的值进行持有，这是它的特性。</p>

<h3>Closure expressions as anonymous function</h3>

<ol>
<li></li>
</ol>

]]></content>
  </entry>
  
</feed>
