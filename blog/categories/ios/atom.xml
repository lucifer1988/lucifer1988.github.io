<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 刘毅的技术博客]]></title>
  <link href="http://lucifer1988.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://lucifer1988.github.io/"/>
  <updated>2016-02-22T14:34:46+08:00</updated>
  <id>http://lucifer1988.github.io/</id>
  <author>
    <name><![CDATA[刘毅]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swifter读书笔记1]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/27/swifterdu-shu-bi-ji-1/"/>
    <updated>2015-11-27T14:24:30+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/27/swifterdu-shu-bi-ji-1</id>
    <content type="html"><![CDATA[<p>继续Swift的进阶学习，这一阶段使用的是<a href="http://weibo.com/onevcat">王巍（onevcat）</a>的Swifter一书，书中记录了100个Swift开发的Tips，本章包含了Tip1~Tip20。</p>

<!--more-->


<h2>1.柯里化（Currying）</h2>

<p>Currying我们在之前的Swift by Tutorials中也学习过，是一种可以使函数分布调用的方式，也可以充当产生新方法的工厂方法，例如：</p>

<p>```objectivec
func greaterThan(comparor: Int)(Input: Int) &ndash;> Bool {</p>

<pre><code>return Input &gt; comparor
</code></pre>

<p>}</p>

<p>let greaterThan10 = greaterThan(10)</p>

<p>greaterThan10(Input: 12)
greaterThan10(Input: 1)
```</p>

<p>作者举了一个实践的例子，我们之前也讲过Swift中的Selector只能通过String类型来赋值，从实用角度讲，是很好的与OC的Target/Action做了桥接，但是任然无法保证调用的安全性，用例就是借助Currying对selector调用做了改造，<a href="http://oleb.net/blog/2014/07/swift-instance-methods-curried-functions/?utm_campaign=iOS_Dev_Weekly_Issue_157&amp;utm_medium=email&amp;utm_source=iOS%2BDev%2BWeekly">这篇博客</a>做了详细说明。</p>

<p>首先通过以下的例子，我们可以得知，一个类的方法也是可以被获取的，这因为Swift中方法是第一类对象，例如最后depositor的调用，它的类型就是<strong>BankAccount &ndash;> (Double) &ndash;> ()</strong>，其实也是currying调用，利用这一特性，博主自己对selector的调用进行了改造。</p>

<p>```objectivec
class BankAccount {</p>

<pre><code>var balance = 0.0

func deposit(amount: Double) {
    balance += amount
}
</code></pre>

<p>}</p>

<p>let account = BankAccount()
account.deposit(100)
print(account.balance)</p>

<p>let depositor = BankAccount.deposit
depositor(account)(100)
print(account.balance)
```</p>

<p>这样改变了selector的调用方式，现在开发者需要传入target和一个(T) &ndash;> () &ndash;> ()类型的action，而不采用之前的字符串输入，这当然保证了该方法一定会被响应，因为如果，该类型没有这个方法，在编译期间就会报错，而不会是在runtime中。</p>

<p>```objectivec
protocol TargetAction {</p>

<pre><code>func performAction()
</code></pre>

<p>}</p>

<p>struct TargetActionWrapper&lt;T: AnyObject>: TargetAction {</p>

<pre><code>weak var target: T?
let action: (T) -&gt; () -&gt; ()

func performAction() -&gt; () {
    if let t = target {
        action(t)()
    }
}
</code></pre>

<p>}</p>

<p>enum ControlEvent {</p>

<pre><code>case TouchUpInside
case ValueChanged
//...
</code></pre>

<p>}</p>

<p>class Control {</p>

<pre><code>var actions = [ControlEvent: TargetAction]()

func setTarget&lt;T: AnyObject&gt;(target: T, action: (T) -&gt; () -&gt; (), controlEvent: ControlEvent) {
    actions[controlEvent] = TargetActionWrapper(target: target, action: action)
}

func removeTargetForCotrolEvent(controlEvent: ControlEvent) {
    actions[controlEvent] = nil
}

func performActionForControlEvent(controlEvent: ControlEvent) {
    actions[controlEvent]?.performAction()
}
</code></pre>

<p>}
```</p>

<p>```objectivec
class MyViewController {</p>

<pre><code>let button = Control()

func viewDidLoad() {
    button.setTarget(self, action: MyViewController.onButtonTap, controlEvent: .TouchUpInside)
}

func onButtonTap() {
    println("Button was tapped")
}
</code></pre>

<p>}
```</p>

<h2>2.Struct Mutable的方法</h2>

<p>这个问题，之前的<a href="http://lucifer1988.github.io/blog/2015/10/15/swift-by-tutorials-generics/">Swift by Tutorials</a>也提到过，结构体的实例方法是不能修改自己声明的变量的，因为Struct是数值型的，默认是不可变的，所以如果某个方法需要修改结构体的变量，就需要添加<strong>mutating</strong>关键字，使得编译器可以对结构体进行copy-on-write操作。</p>

<p>```objectivec
struct User {</p>

<pre><code>var age: Int
var weight: Int
var height: Int
mutating func gainWeight(newWeight: Int) {
    weight += newWeight
}
</code></pre>

<p>}
```</p>

<h2>3.将protocol的方法声明为mutating</h2>

<p>这个问题是承接上一个问题的，Swift中的protocol是可以被class、struct、enum实现的，所以如果protocol中一些方法正好会修改到自身变量，但没有加<strong>mutating</strong>关键字的话，struct和enum实现该方法时就无法编过，所以一定要在设计protocol时考虑这个问题。另外，我补充一点，如果这个protocol只是给class实现的，那么可以不加mutating，同时也可以使用<strong>protocol ClassOnlyProtocol: class</strong>这样的写法，告诉使用者，该协议只能实现于class。</p>

<p>```objectivec
import UIKit</p>

<p>protocol Vehicle {</p>

<pre><code>var numberOfWheels: Int {get}
var color: UIColor {get set}

mutating func changeColor()
</code></pre>

<p>}</p>

<p>struct MyCar: Vehicle {</p>

<pre><code>let numberOfWheels = 4
var color = UIColor.blueColor()

mutating func changeColor() {
    color = UIColor.redColor()
}
</code></pre>

<p>}
```</p>

<h2>4.Sequence</h2>

<p>在Swift中，只要实现了SequenceType，就可以使用for&hellip;in快速遍历，而需要先实现一个GeneratorType来控制遍历的顺序。</p>

<p>```objectivec
class ReverseGenerator: GeneratorType {</p>

<pre><code>typealias Element = Int

var counter: Element
init&lt;T&gt;(array: [T]) {
    self.counter = array.count - 1
}

init(start: Int) {
    self.counter = start
}

func next() -&gt; Element? {
    return self.counter &lt; 0 ? nil : counter--
}
</code></pre>

<p>}</p>

<p>struct ReverseSequence<T>: SequenceType {</p>

<pre><code>var array: [T]

init (array: [T]) {
    self.array = array
}

typealias Generator = ReverseGenerator

func generate() -&gt; Generator {
    return ReverseGenerator(array: array)
}
</code></pre>

<p>}</p>

<p>let arr = [0, 1, 2, 3, 4]</p>

<p>for i in ReverseSequence(array: arr) {</p>

<pre><code>print("Index \(i) is \(arr[i])")
</code></pre>

<p>}
```</p>

<p>for&hellip;in如何利用这两个协议，作者给出了一个解释。</p>

<p>```objectivec
var g = array.generate()
while let obj = g.next() {</p>

<pre><code>print(obj)
</code></pre>

<p>}
```</p>

<p>而且你也可以免费使用map，filter，reduce这些函数，因为SequenceType的几个extension实现了他们。关于这几个函数的使用，我们在Swift by Tutorials做了很多介绍。</p>

<h2>5.多元组(Tuple)</h2>

<p>Tuple我们之前也介绍过，主要用于简单场景的复合数据类型，作者举了一个CGRect的方法在OC和Swift中的实践。</p>

<p>CGRect有个函数<strong>CGRectDivide()</strong>，用来切割矩形区域，由于会返回两个新的CGRect，而OC又没有返回多个结果的机制，只能先声明两个CGRect，然后将指针传入函数，等待函数对其赋值。</p>

<p><code>objectivec
//CGRectDivide(CGRect rect, CGRect *slice, CGRect *remainder, CGFloat amount, CGRectEdge edge)
CGRect rect = CGRectMake(0, 0, 100, 100);
CGRect small;
CGRect large;
CGRectDivide(rect, &amp;small, &amp;large, 20, CGRectMinXEdge);
</code></p>

<p>而在Swift中由于有了元组，可以优雅的进行实现，同时，由于Swift中结构体可以添加方法，所以将原来的函数直接作为了CGRect的一个方法，使得实现更加简洁。</p>

<p><code>objectivec
//func rectsByDividing(atDistance: CGFloat, fromEdge: CGRectEdge) -&gt; (slice: CGRect, remainder: CGRect)
let rect = CGRectMake(0, 0, 100, 100)
let (small, large) = rect.rectsByDividing(20, fromEdge: .MinXEdge)
</code></p>

<h2>6.@autoclosure和??</h2>

<p>@autoclosure是简化代码的一个关键字，之前说过方法是Swift中的第一类对象，所以会在Swift中出现大量的匿名方法，即闭包closure作为参数，如下例。</p>

<p>```objectivec
func logIfTrue(@autoclosure predicate:() &ndash;> Bool) {</p>

<pre><code>if predicate() {
    print("True")
}
</code></pre>

<p>}
logIfTrue({return 2>1})
```</p>

<p>当然按照之前介绍的简化策略，上面的调用可以简化为：</p>

<p><code>objectivec
logIfTrue{2&gt;1}
</code></p>

<p>然而我们可以在方法定义时加上@autoclosure，这样调用时，Swift会自动将输入的参数转化为closure，但需要注意的是使用@autoclosure关键字时，闭包的参数只能是()，如果包含参数时，不能使用该关键字。</p>

<p>```objectivec
func logIfTrue(@autoclosure predicate:() &ndash;> Bool) {</p>

<pre><code>if predicate() {
    print("True")
}
</code></pre>

<p>}
logIfTrue(2>1)
```</p>

<p>??可以用来对Optional类型进行空值判断，并赋默认值，用法如下：</p>

<p><code>objectivec
var level: Int?
var startLevel = 1
var currentLevel = level ?? startLevel
</code></p>

<p>??的具体实现如下，两个版本的区别是默认值是否是optional类型，但是需要注意的是输入的第二个参数被封装成了一个闭包的类型，作者猜测了??方法的具体实现。</p>

<p><code>objectivec
@warn_unused_result
public func ??&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T?) rethrows -&gt; T?
@warn_unused_result
public func ??&lt;T&gt;(optional: T?, @autoclosure defaultValue: () throws -&gt; T) rethrows -&gt; T
</code></p>

<p>```objectivec
func ??<T>(optional: T?, @autoclosure defaultValue: () &ndash;> T) &ndash;> T {</p>

<pre><code>switch optional {
    case .Some(let value):
        return value
    case .None:
        return defaultValue()
}
</code></pre>

<p>}
```</p>

<p>这里没有直接用T类型作为默认值的参数，而是封转了一个方法，这是一种优化手段。这样，系统在开始判断optional是否有值之前就不需要开辟默认值的内存，只有在optional为nil时，才去准备默认值。但是在开发者调用??方法时又不需要输入一个闭包参数，而仍是一个数值，这就是巧妙的利用了@autoclosure关键字。</p>

<p>作者留出了关于Swift的||和&amp;&amp;的实现，其实他们的情况也和??一样，需要分布判断，下面是我给出的答案。</p>

<p>```objectivec
func ||<T : BooleanType, U : BooleanType>(lhs: T, @autoclosure rhs: () &ndash;> U) &ndash;> Bool {</p>

<pre><code>switch lhs.boolValue {
case true:
    return true
case false:
    return rhs().boolValue
}
</code></pre>

<p>}
```</p>

<p>```objectivec
func &amp;&amp;<T : BooleanType, U : BooleanType>(lhs: T, @autoclosure rhs: () &ndash;> U) &ndash;> Bool {</p>

<pre><code>switch lhs.boolValue {
case false:
    return false
case true:
    return rhs().boolValue
}
</code></pre>

<p>}
```</p>

<h2>7.Optional Chaining</h2>

<p>Optional Chaining在之前也介绍过，可以摆脱Swift中不必要的有值判断，但使用时也需注意其返回值和执行方法的不确定性。</p>

<p>```objectivec
class Toy {</p>

<pre><code>let name: String
init(name: String) {
    self.name = name
}
</code></pre>

<p>}</p>

<p>class Pet {</p>

<pre><code>var toy: Toy?
</code></pre>

<p>}</p>

<p>class Child {</p>

<pre><code>var pet: Pet?
</code></pre>

<p>}</p>

<p>let xiaoming = Child()
let toyName = xiaoming.pet?.toy?.name
```
如上，虽然name定义为toy的String类型，非Optional，但由于Optional Chaining的使用，是可能提前返回nil的，所以最终toyName的类型，还是String？。</p>

<p>实际开发中，一般还是用Optional Binding+Optional Chaining的方式来取值。</p>

<p>```objectivec
if let toyname = xiaoming.pet?.toy?.name {</p>

<pre><code>print(toyname)
</code></pre>

<p>}
```</p>

<p>如果，我们给Toy再加一个扩展：</p>

<p>```objectivec
extension Toy {</p>

<pre><code>func play() {
    //...
}
</code></pre>

<p>}
```</p>

<p>如果我们想将play()封装成一个以Child为参数的closure，那么就要注意closure的返回类型了。以下列出了错误和正确的写法。</p>

<p><code>objectivec
//wrong
//let playClosure = {(child: Child) -&gt; () in child.pet?.toy?.play()}
//right
let playClosure = {(child: Child) -&gt; ()? in child.pet?.toy?.play()}
</code></p>

<p>由于toy之前的值的不确定性，所以play()不一定可以正常执行，所以应该是()?类型，或者Void?类型，最后列出我们实际使用的场景，依然使用Optional Binding。</p>

<p>```objectivec
if let result: () = playClosure(xiaoming) {</p>

<pre><code>//...
</code></pre>

<p>}
```</p>

<h2>8.操作符</h2>

<p>Swift与OC的一大区别是支持操作符的重载，比如我们需要定义以下结构体的相加运算，我们可以重载加号操作符。</p>

<p>```objectivec
struct Vector2D {</p>

<pre><code>var x = 0.0
var y = 0.0
</code></pre>

<p>}</p>

<p>func +(left: Vector2D, right: Vector2D) &ndash;> Vector2D {</p>

<pre><code>return Vector2D(x: left.x+right.x, y: left.y+right.y)
</code></pre>

<p>}</p>

<p>let v1 = Vector2D(x: 2.0, y: 3.0)
let v2 = Vector2D(x: 1.0, y: 4.0)
let v3 = v1+v2
print(v3)
```</p>

<p>类似的，我们也可以重载减号（-），负号（-）这样的运算符。</p>

<p>但是如果我们要定义一个全新的运算符，比如点积运算，单纯重载是无效的，因为该方法并不存在于Swift之中，需要我们先声明，如下：</p>

<p>```objectivec
infix operator +* {</p>

<pre><code>associativity none
precedence 160
</code></pre>

<p>}
```</p>

<p>infix表示这是一个中位操作符，即前后都是输入，其他修饰子还包括prefix（一个输入，并操作符作用于输入之前，类似++i，!i）和postfix（一个输入，并操作符作用于输入之后，类似i++，i&mdash;）。</p>

<p>associativity定义的事结合律，就是计算顺序，比如常见的加法和减法就是left，我们这里定义的点积的结果是Double，不会再和其他点积结合，所以就是none。</p>

<p>precedence是运算的优先级，越高的优先级优先进行运算，Swift中乘除法是150，加减法是140，这里的点积是160，是优先于乘除法的。</p>

<p>之后就可以定义点积运算了。</p>

<p>```objectivec
func +* (left: Vector2D, right: Vector2D) &ndash;> Double {</p>

<pre><code>return left.x*right.x+left.y*right.y
</code></pre>

<p>}</p>

<p>let result = v1 +* v2
```</p>

<p>需要注意的是，重载的操作符都是函数，所以是全局的，也就是说多次重载会导致冲突，尤其是多个module同时重载时。所以应该尽量将其作为其他某个方法的简便写法，避免实现大量逻辑或提供独一无二的功能，因为这样即使出现冲突，使用者还可以通过方法名调用的方式来使用，总之，重载操作符的特性不要滥用，除非确实存在大量并全局的需求。</p>

<h2>9.func的参数修饰</h2>

<p>这一问题在之前也说过，一般我们声明Swift函数时都不会添加参数修饰符，如：</p>

<p>```objectivec
func incrementor(variable: Int) &ndash;> Int {</p>

<pre><code>return variable + 1
</code></pre>

<p>}
```</p>

<p>而很多人可能不会这么写，因为有++这样的运算符，一般都会这么写：</p>

<p>```objectivec
func incrementor(variable: Int) &ndash;> Int {</p>

<pre><code>return ++variable
</code></pre>

<p>}
```</p>

<p>然而直接报错，原因是Swift默认参数是let型的，所以++对自己会重新赋值，所以会报错，修改也很简单。修改参数为var就好。</p>

<p>```objectivec
func incrementor(var variable: Int) &ndash;> Int {</p>

<pre><code>return ++variable
</code></pre>

<p>}</p>

<p>var putIn = 3
let resultOut = incrementor(putIn)
print(resultOut)
print(putIn)
```</p>

<p>但在我们使用时会发现，返回值没错，但是作为输入的putIn并没有改变，这一原因是即使我们将参数声明为var，但Swift在使用之前还是会将其copy一份，然后对其copy修改，所以实际输入的变量并不会改变。</p>

<p>如果我们想对输入参数在方法内修改，就要使用inout关键字，这样我们就将参数的指针输入了方法，所以在调用时也需要传入参数的指针，其实这与OC中的block使用外部变量是一样的，默认就是值拷贝，无法修改原值，如需修改，在原值加_block关键字。</p>

<p>```objectivec
func incrementor(inout variable: Int) {</p>

<pre><code>++variable
</code></pre>

<p>}</p>

<p>var putIn = 3
incrementor(&amp;putIn)
print(putIn)
```</p>

<p>作者补充的一点是，参数修饰符是有传递限制性的，入股统一参数要跨层调用，需要保证同一参数的修饰统一，如下例：</p>

<p>```objectivec
func makeIncrementor(addNumber: Int) &ndash;> ((inout variable: Int) &ndash;> ()) {</p>

<pre><code>func incrementor(inout variable: Int) -&gt; () {
    variable + addNumber
}
return incrementor
</code></pre>

<p>}
```</p>

<h2>10.字面量转换</h2>

<p>字面量就是指特定的数字，字符串或布尔值这样可以直接表明类型，并直接赋值的值。如下：</p>

<p><code>objectivec
let aNumber = 3
let aString = "Hello"
let aBool = true
let anArray = [1, 2, 3]
let aDictionary = ["key1": "value1", "key2": "value2"]
</code></p>

<p>Swift提供了一组协议，用来将字面量转换为特定类型，对于实现了字面量转换接口的类型，在字面量赋值时，可以直接通过赋值的方式，将其转化为对应类型。这些协议有：</p>

<ul>
<li>ArrayLiteralConvertible</li>
<li>BooleanLiteralConvertible</li>
<li>DictionaryLiteralConvertible</li>
<li>FloatLiteralConvertible</li>
<li>NilLiteralConvertible</li>
<li>IntegerLiteralConvertible</li>
<li>StringLiteralConvertible</li>
</ul>


<p>下面举例BooleanLiteralConvertible的实现，BooleanLiteralConvertible的定义是：</p>

<p>```objectivec
protocol BooleanLiteralConvertible {</p>

<pre><code>typealias BooleanLiteralConvertible

init(booleanLiteral value: BooleanLiteralType)
</code></pre>

<p>}
```</p>

<p>BooleanLiteralConvertible在Swift中已有定义：</p>

<p><code>objectivec
typealias BooleanLiteralType = Bool
</code></p>

<p>那么我们自己实现字面量转换时，就需要实现init方法就好了，这样我们就可以直接使用true和false对MyBool类型赋值：</p>

<p>```objectivec
enum MyBool: Int {</p>

<pre><code>case myTrue, myFalse
</code></pre>

<p>}</p>

<p>extension MyBool: BooleanLiteralConvertible {</p>

<pre><code>init(booleanLiteral value: Self.BooleanLiteralType) {
    self = value ? myTrue : myFalse
}
</code></pre>

<p>}</p>

<p>let myTrue: MyBool = true
let myFalse: MyBool = false</p>

<p>myTrue.rawValue
myFalse.rawValue
```</p>

<p>BooleanLiteralConvertible是这些协议中最简单的了，如果是StringLiteralConvertible协议，还要实现另外两个方法，这两个方法我们一般开发中不会遇到，是对应的<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html">字符簇和字符</a>的字面量转换。</p>

<ul>
<li>ExtendedGraphemeClusterLiteralConvertible</li>
<li>UnicodeScalarLiteralConvertible</li>
</ul>


<p>继续举例比如，我们声明一个Person类，想通过String赋值，来生成Person对象，那么可以这样实现。</p>

<p>```objectivec
class Person: StringLiteralConvertible {</p>

<pre><code>let name: String
init(name value: String) {
    self.name = value
}

required init(stringLiteral value: String) {
    self.name = value
}

required init(extendedGraphemeClusterLiteral value: String) {
    self.name = value
}

required init(unicodeScalarLiteral value: String) {
    self.name = value
}
</code></pre>

<p>}
```</p>

<p>下面三个init方法都加上了<strong>required</strong>关键字，这是由初始化方法的完备性需求所决定的，该类的子类都需要保证能实现类似的字面量转换，以确保类型安全。</p>

<p>上面多次调用了self.name = value，其实是不必要的，我们可以在之后的每个init中调用最初的init方法，当然这需要在其他init方法前加<strong>convenience</strong>关键字。</p>

<p>```objectivec
class Person: StringLiteralConvertible {</p>

<pre><code>let name: String
init(name value: String) {
    self.name = value
}

required convenience init(stringLiteral value: String) {
    self.init(name: value)
}

required convenience init(extendedGraphemeClusterLiteral value: String) {
    self.init(name: value)
}

required convenience init(unicodeScalarLiteral value: String) {
    self.init(name: value)
}
</code></pre>

<p>}</p>

<p>let p: Person = &ldquo;xiaoming&rdquo;
print(p.name)
```</p>

<p>Person例子中，没有像MyBool一样，使用extension来扩展，因为在extension中，我们无法定义required的初始化方法，也就是说我们无法为非final的class添加字面量转换。</p>

<p>综上，字面量转换是一个强大的功能，使用得当对代码简洁度有很大提高，但是对于使用者来讲，如果没有详细的文档支持，会造成很多困惑，所以它的最佳实践还有待开发者们继续挖掘。</p>

<h2>11.下标</h2>

<p>Swift中的Array和Dictionary是支持下标读写的，这一点与新版OC是一致的。</p>

<p>```objectivec
var arr = [1, 2, 3]
arr[2]
arr[2] = 4</p>

<p>var dict = [&ldquo;cat&rdquo;:&ldquo;meow&rdquo;, &ldquo;goat&rdquo;:&ldquo;mie&rdquo;]
dict[&ldquo;cat&rdquo;]
dict[&ldquo;cat&rdquo;] = &ldquo;miao&rdquo;
```</p>

<p>而Swift比较先进的是，Swift是允许自定义下标的，比如作者给出的，使用subscript关键字为Array添加支持以[Int]为index来读取的extension。</p>

<p>```objectivec
extension Array {</p>

<pre><code>subscript(input: [Int]) -&gt; ArraySlice&lt;Element&gt; {
    get {
        var result = ArraySlice&lt;Element&gt;()
        for i in input {
            assert(i &lt; self.count, "index out of range")
            result.append(self[i])
        }
        return result
    }
    set {
        for (index, i) in input.enumerate() {
            assert(i &lt; self.count, "index out of range")
            self[i] = newValue[index]
        }
    }
}
</code></pre>

<p>}</p>

<p>var arr = [1, 2, 3, 4, 5]
arr[[0, 2, 3]]
arr[[0, 2, 3]] = [-1, -3, -4]
arr
```</p>

<h2>12.方法嵌套</h2>

<p>方法在Swift中成为了第一对象，可以作为参数，可以作为结果返回，而且可以在方法中定义子方法，这对内容过长的方法进行重构提供了新的思路。如果子方法只会被调用一次，那么它更适合被声明到父方法内部。</p>

<p>```objectivec
func appendQuery(var url: String, key: String, value: AnyObject) &ndash;> String {</p>

<pre><code>func appendQueryDictionary(var url: String, key: String, value: [String: AnyObject]) {
    //...
    return result
}

func appendQueryArray(var url: String, key: String, value: [AnyObject]) {
    //...
    return result
}

func appendQuerySingle(var url: String, key: String, value: AnyObject) {
    //...
    return result
}

if let dictionary = value as? [String: AnyObject] {
    return appendQueryDictionary(url, key: key, value: dictionary)
} else if let array = value as? [AnyObject] {
    return appendQueryArray(url, key: key, value: array)
} else {
    return appendQuerySingle(url, key: key, value: value)
}
</code></pre>

<p>}
```</p>

<p>还有在方法模板中（就是在Swift By Tutorials中提到的<a href="http://lucifer1988.github.io/blog/2015/11/23/swift-by-tutorials-functional-programming/">Partial application</a>），开发者一方面希望提供一个模板来让使用者定制方法，而同时不希望暴露太多的的实现细节。</p>

<p>```objectivec
func makeIncrementor(addNumber: Int) &ndash;> ((inout Int) &ndash;> Void {</p>

<pre><code>func incrementor(inout variable: Int) -&gt; Void {
    variable += addNumber;
}
return incrementor;
</code></pre>

<p>}
```</p>

<h2>13.命名空间</h2>

<p>OC是没有命名空间的，开发时只能通过自己添加前缀来区分，但是还是有可能出现类文件相同的情况，而另一种情况是，一些第三方库本身引用了其他第三方库，而开发者同时使用这两个库时，就会出现冲突。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Swift Quick Reference]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/26/swift-by-tutorials-swift-quick-reference/"/>
    <updated>2015-11-26T17:09:12+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/26/swift-by-tutorials-swift-quick-reference</id>
    <content type="html"><![CDATA[<p>这是Swift by Tutorials的最后一章，主要是提供一个Swift实践代码的快速查找手册，方便开发时快速查阅。</p>

<!--more-->


<h2>Language basics</h2>

<p>```objectivec
// variables can be updated
var variableNumber: Int = 1
variableNumber = variableNumber + 1</p>

<p>// constants cannot be updated
let constNumber: Int = 1
// constNumber = constNumber + 1 &lt;&ndash; error!</p>

<p>// inferred type
let inferredInt = 1</p>

<p>// Swift types
let int: Int = 20
let double: Double = 3.5
let float: Float = 4.5
let bool: Bool = false
let str: String = &ldquo;Hello Swift!&rdquo;</p>

<p>// explicit type conversion
let pi = 3.1415
let multiplier = 2
let twoPi = pi * Double(multiplier)
```</p>

<p>Tips:</p>

<ul>
<li>尽量将数值定义为常量let，不仅会使代码更健壮，也可以获得更多的编译器优化</li>
<li>Swift是强类型的语言，所以很多地方需要手动类型转换</li>
</ul>


<h2>Basic control structures</h2>

<p>```objectivec
for index in 1..&lt;3 {
  // loops with index taking values 1,2
}</p>

<p>for index in 1&hellip;3 {
  // loops with index taking values 1,2,3
}</p>

<p>//<a href="http://stackoverflow.com/questions/32197250/using-stride-in-swift-2-0">http://stackoverflow.com/questions/32197250/using-stride-in-swift-2-0</a>
for index in 10.stride(to: 20, by: 2) {
  // loops form 10 to 20 (inclusive) in steps of 2
}</p>

<p>var index = 0
while index &lt; 5 {
  // loops 5 times
  index++
}</p>

<p>index = 0
repeat {
  // loops 5 times
  index++
} while index &lt; 5</p>

<p>// if/else
let temperature = 45
if temperature > 60 {
  print(&ldquo;It&rsquo;s hot!&rdquo;)
} else if temperature > 40 {
  print(&ldquo;It&rsquo;s warm&rdquo;)
} else {
  print(&ldquo;It&rsquo;s chilly&rdquo;)
}
```</p>

<h2>Tuples</h2>

<p>```objectivec
let tuple = (1, 3, 5)   // inferred type (Int, Int, Int)
let tuple2 = (1, 5.0)   // inferred type (Int, Double)
let tuple3: (Double, Double) = (5, 6)</p>

<p>// indexing a tuple
print(tuple.0)
print(tuple.1)
print(tuple.2)</p>

<p>// a tuple with named elements
let product = (id: 24, name: &ldquo;Swift Book&rdquo;)
print(product.name)</p>

<p>// decomposing a tuple
let (x, y, z) = tuple
print(&ldquo;(x), (y), (z)&rdquo;) // &ldquo;1, 3, 5&rdquo;
```</p>

<p>Tips：</p>

<ul>
<li>Tuples在快速创建简易的复合类型时非常实用，而大多数情况struct是更好的选择，它有更强的类型安全和更好的功能性</li>
</ul>


<h2>Arrays</h2>

<p>```objectivec
import Foundation</p>

<p>// empty array creation
let empty1 = <a href="">String</a>
let empty2 = Array<String>()
let empty3: [String] = []</p>

<p>// a constant array with inferred type
let animals = [&ldquo;cat&rdquo;, &ldquo;dog&rdquo;, &ldquo;chicken&rdquo;]
// animals.append(&ldquo;cow&rdquo;)  &lt;&ndash; error!
// animals[2] = &ldquo;fish&rdquo;    &lt;&ndash; error!</p>

<p>// a variable array with explicit type
var mutableAnimals: [String] = [&ldquo;cat&rdquo;, &ldquo;dog&rdquo;, &ldquo;chicken&rdquo;]
mutableAnimals.append(&ldquo;cow&rdquo;)
mutableAnimals[2] = &ldquo;fish&rdquo;</p>

<p>// iteration
for animal in animals {
  print(animal)
}</p>

<p>// array API
animals[0]                      // &ldquo;cat&rdquo;
animals[1..&lt;3]                  // &ldquo;dog&rdquo;, &ldquo;chicken&rdquo;
animals.count                   // &ldquo;3&rdquo;
animals.contains(&ldquo;cat&rdquo;)        // true
mutableAnimals.removeAtIndex(0) // &ldquo;cat&rdquo;</p>

<p>// functional API
animals.map { $0.uppercaseString }   // &ldquo;CAT&rdquo;, &ldquo;DOG&rdquo;, &hellip;
animals.filter { $0.hasPrefix(&ldquo;c&rdquo;) } // &ldquo;cat&rdquo;, &ldquo;chicken&rdquo;
animals.sort { $0 &lt; $1 }           // &ldquo;cat&rdquo;, &ldquo;chicken&rdquo;, &hellip;</p>

<p>// bridged NSArray API
let nsArray = animals as NSArray
nsArray.objectAtIndex(2)        // &ldquo;chicken&rdquo;
```</p>

<p>Tips：</p>

<ul>
<li>Swift中的Array是数值类型</li>
</ul>


<h2>Dictionaries</h2>

<p>```objectivec
// empty dictionary creation
let empty1 = <a href="">Int:String</a>
let empty2 = Dictionary&lt;Int, String>()
let empty3: [Int:String] = [:]</p>

<p>// a constant dictionary with inferred type
let animals = [24 : &ldquo;cat&rdquo;, 36 : &ldquo;dog&rdquo;]
// animals[88] = &ldquo;fish&rdquo;   &lt;&ndash; error!</p>

<p>// a variable dictionary with explicit type
var mutableAnimals: [Int:String] = [24 : &ldquo;cat&rdquo;, 36 : &ldquo;dog&rdquo;]
mutableAnimals[55] = &ldquo;fish&rdquo;
mutableAnimals[24] = &ldquo;chicken&rdquo;</p>

<p>// dictionary API
animals[24]                 // &ldquo;cat&rdquo;
animals[1]                  // nil
animals.count               // &ldquo;2&rdquo;
mutableAnimals.removeValueForKey(24) // &ldquo;chicken&rdquo;</p>

<p>// dictionary values are returned as optionals
animals[24]!.hasPrefix(&ldquo;c&rdquo;) // true</p>

<p>// iteration
for (key, value) in animals {
  print(key)
  print(value)
}
```</p>

<p>Tips：</p>

<ul>
<li>Swift中的Dictionary是数值类型</li>
</ul>


<h2>Optionals</h2>

<p>```objectivec
// an optional variable
var maybeString: String?   // defaults to nil
maybeString = nil          // can be assigned a nil value
maybeString = &ldquo;fish&rdquo;       // can be assigned a value</p>

<p>// unwrapping an optional
if let unwrappedString = maybeString {
  // unwrappedString is a String rather than an optional String
  print(unwrappedString.hasPrefix(&ldquo;f&rdquo;)) // &ldquo;true&rdquo;
} else {
  print(&ldquo;maybeString is nil&rdquo;)
}</p>

<p>// forced unwrapping &ndash; will fail at runtime if the optional is nil
if maybeString!.hasPrefix(&ldquo;f&rdquo;) {
  print(&ldquo;maybeString starts with &lsquo;f&rsquo;&rdquo;)
}</p>

<p>// optional chaining, returning an optional with the
// result of hasPrefix, which is then unwrapped
if let hasPrefix = maybeString?.hasPrefix(&ldquo;f&rdquo;) {
  if hasPrefix {</p>

<pre><code>print("maybeString starts with 'f'")
</code></pre>

<p>  }
}</p>

<p>// null coalesce
var anOptional: Int?
var coalesced = anOptional ?? 3 // anOptional is nil, coalesced to 3
```</p>

<h2>Implicitly unwrapped optionals</h2>

<p>```objectivec
// an implicitely unwrapped optional variable
var maybeString: String!
maybeString = nil
maybeString = &ldquo;fish&rdquo;</p>

<p>// methods invoked directly, failing at runtime if the optional is nil
if maybeString.hasPrefix(&ldquo;f&rdquo;) {
  print(&ldquo;maybeString starts with &lsquo;f&rsquo;&rdquo;)
}else {
  print(&ldquo;maybeString does not start with an &lsquo;f&rsquo;&rdquo;)
}
```</p>

<p>Tips：</p>

<ul>
<li>隐式拆解的optional一般的使用场景是，类和结构体中初始化时不会给一个property赋值，而在稍后在使用前会进行赋值</li>
<li>虽然使用上不需要再去拆解，但是它仍是optional类型，所以依然需要注意它为nil时的调用</li>
</ul>


<h2>Switch</h2>

<p>```objectivec
let bit = Bit.Zero</p>

<p>// a simple switch statement on an enum
switch bit {
case .Zero:
  print(&ldquo;zero&rdquo;)
case .One:
  print(&ldquo;one&rdquo;)
}</p>

<p>// interval matching
let time = 45
switch time {
case 0..&lt;60:
  print(&ldquo;A few seconds ago&rdquo;)
case 60..&lt;(60 * 4):
  print(&ldquo;A few minutes ago&rdquo;)
default:                 // default required in order
  print(&ldquo;Ages ago!&rdquo;)   // to be exhaustive
}</p>

<p>// tuples and value bindings
let boardLocation = (2, 5)
switch boardLocation {
case (3, 4), (3, 3), (4, 3), (4, 4):
  print(&ldquo;central location&rdquo;)
case (let x, let y):
  print(&ldquo;((x), (y) is not in the center&rdquo;)
}
```</p>

<p>Tips：</p>

<ul>
<li>Swift中的switch需要覆盖所有的case</li>
</ul>


<h2>Enums</h2>

<p>```objectivec
// enum declaration
enum Direction {
  case North, South, East, West
}</p>

<p>// assignment
var direction = Direction.North
direction = .South   // enum type inferred</p>

<p>// switching on enums
switch direction {
case .North:
  print(&ldquo;Going North&rdquo;)
default:
  print(&ldquo;Going someplace else!&rdquo;)
}</p>

<p>// advanced enumerations &ndash; using generics
enum Result<T> {
  case Failure
  // enumeration member with associated value
  case Success(T)
}</p>

<p>// creating an instance &ndash; where the type T is an Int
var result = Result.Success(22)</p>

<p>// switching and extracting the associated value
switch result {
case .Failure:
  print(&ldquo;Operation failed&rdquo;)
case .Success(let value):
  print(&ldquo;Operation returned value (value)&rdquo;)
}
```</p>

<h2>Functions</h2>

<p>```objectivec
// a simple function
func voidFunc(message: String) {
  print(message);
}
voidFunc(&ldquo;Hello Swift!&rdquo;)</p>

<p>// a function that returns a value
func multiply(arg1: Double, arg2: Double) &ndash;> Double {
  return arg1 * arg2
}
let result = multiply(20.0, arg2: 35.2)</p>

<p>// external and default parameters names
func multiplyTwo(first first: Double, andSecond second: Double) &ndash;> Double {
  return first * second
}
let result2 = multiplyTwo(first: 20.0, andSecond: 35.2)</p>

<p>// inout parameters
func square(inout number: Double) {
  number *= number
}
var number = 4.0
square(&amp;number) // number = 16</p>

<p>// function types
let myFunc: (Double, Double) &ndash;> Double = multiplyTwo</p>

<p>// a generic function
func areEqual&lt;T: Equatable>(op1: T, op2: T) &ndash;> Bool {
  return op1 == op2
}
```</p>

<h2>Closures</h2>

<p>```objectivec
let animals = [&ldquo;fish&rdquo;, &ldquo;cat&rdquo; , &ldquo;chicken&rdquo;, &ldquo;dog&rdquo;]</p>

<p>animals.sort({
  (one: String, two: String) &ndash;> Bool in
  return one > two
})</p>

<p>animals.sort({
  (one, two) &ndash;> Bool in // inferred argument types
  return one > two
})</p>

<p>animals.sort({
  (one, two) in        // inferred return type
  return one > two
})</p>

<p>animals.sort({
  // no brackets around parameters
  one, two in return one > two
})</p>

<p>animals.sort({
  // no return keyword
  one, two in one > two
})</p>

<p>// shorthand arguments
animals.sort({ $0 > $1 })</p>

<p>// trailing closure
animals.sort() { $0 > $1 }
animals.sort { $0 > $1 }
animals.sort(>)
```</p>

<h2>Classes and protocols</h2>

<p>```objectivec
public class BaseClass {
  private let id: Int            // private constant property</p>

<p>  init(id: Int) {</p>

<pre><code>self.id = id
</code></pre>

<p>  }</p>

<pre><code>class func numberOfLegs() -&gt;Int {
return 4;
}
</code></pre>

<p>}</p>

<p>protocol NamedType {
  var name: String { get }       // a property with a getter
}</p>

<p>public class Animal: BaseClass, NamedType {</p>

<p>  private(set) var name: String  // variable with public getter</p>

<pre><code>                             // and private setter
</code></pre>

<p>  var size: Double = 45.0        // implicit internal property
  public let fullName: String    // public constant property</p>

<p>  init (id: Int, name: String, fullName: String) {</p>

<pre><code>// all properties initialized before base init invoked
self.name = name;
self.fullName = fullName;

// super initialiser invoked
super.init(id: id)

// methods on self can now be called
</code></pre>

<p>  }
}</p>

<p>// creating an instance
var animal = Animal(id: 24, name: &ldquo;cat&rdquo;, fullName: &ldquo;Felis catus&rdquo;)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Swift and Cocoa]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/25/swift-by-tutorials-swift-and-cocoa/"/>
    <updated>2015-11-25T11:20:10+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/25/swift-by-tutorials-swift-and-cocoa</id>
    <content type="html"><![CDATA[<p>Swift是一门新推出的语言，但是核心框架还是Cocoa，这与OC是一致的，Cocoa的Foundation和UIKit框架对于开发应用仍是最重要的。这一章将创建一个应用，主要介绍Swift一Cocoa直接的交互，同时了解Cocoa的设计模式如何在Swift中体现出来。</p>

<!--more-->


<h2>Getting started</h2>

<p>作者提供了一个starter project，添加了一个viewcontroller和之前介绍的JSON.swift（帮助解析JSON的工具类），另外还有facebook的SDK，所以接下来会介绍如何在Swift中混用OC代码。</p>

<h2>Bridging Swift and Objectivec-C</h2>

<p>通过<strong>bridging</strong>技术，可以让我们在Swift和OC间相互调用。</p>

<h3>Swift bridging header</h3>

<p>新建一个OC的.h文件，如：CafeHunter-ObjCBridging.h，然后在<strong>Build Settings</strong>中找到<strong>Objective-C Bridging Header</strong>，填写该头文件的路径，如：CafeHunter/CafeHunter-ObjCBridging.h，然后可以在该头文件中添加所需的OC头文件，如下，这样就可以在Swift中使用OC的类和方法了。</p>

<p>```objectivec</p>

<h1>import &lt;FacebookSDK/FacebookSDK.h></h1>

<p>```</p>

<p><code>objectivec
FBSettings.setDefaultAppID("INSERT_YOUR_FB_APP_ID")
</code></p>

<h3>Objective-C compatibility header</h3>

<p>那么如何在OC中使用Swift代码呢？还记得刚才在<strong>Build Settings</strong>中找到的<strong>Objective-C Bridging Header</strong>上面的<strong>Install Objective-C Compatibility Header</strong>吗？该项就是控制Swift向OC转换的开关，默认是打开的。</p>

<p>在report navigation的Build，中可以找到<strong> Copy CafeHunter-Swift.h</strong>的信息，可以双击打开该文件，你会发现你用Swift中创建的继承于OC的类和方法都在这里有对应的OC代码，而且实际上还有用@objec标记的代码，也有对应的转化。需要注意的两点是：</p>

<ol>
<li>Swift中的私有方法是没有转化的，因为理论上外部不可能使用私有方法，但私有方法仍会注册在runtime中。</li>
<li>转化的代码每个类之前会有一行类似<strong>SWIFT_CLASS(&ldquo;_TtC10CafeHunter11AppDelegate&rdquo;)</strong>的代码，实际上是Swift的压缩命名，为每个类添加了命名空间，也是该类在runtime中实际的名字，即使不同库中有相同名类，编译器也会通过该类名，准确找到对应的类。</li>
</ol>


<h2>Adding the UI</h2>

<p>添加一个FaceBook的登录View和MKMapView到Storybiard，然后关联到代码，如下。</p>

<p><code>objectivec
@IBOutlet weak var mapView: MKMapView!
@IBOutlet weak var loginView: FBLoginView!
</code></p>

<p>有几点说明：</p>

<ol>
<li>outlet的类型是optional的，而且是隐式拆解的，这是因为如果不这么设置，编译器会发现这些变量没有在初始化中赋值，从而报错，所以这是为了避免编译器报错的手段，但我们知道它会在IB中初始化，所以采用了隐式拆解。使用outlet时不用再去拆解，但同时需要注意在view加载之前调用它们会导致崩溃，这点需要谨记。</li>
<li>outlet被加了weak关键字，这和OC中是一致的，是因为viewController的view对outlet是有强引用的，所以不必再添加额外的强引用。</li>
</ol>


<h3>Showing the user&rsquo;s location</h3>

<p>在Swift中长把协议的实现放在单独的extension中，这样可以将代码分组，但依然可以访问原类的变量和方法。</p>

<p>```objectivec
extension ViewController: MKMapViewDelegate {</p>

<p>  func mapView(mapView: MKMapView, didFailToLocateUserWithError error: NSError) {</p>

<pre><code>print(error)
let alert = UIAlertController(title: "Error", message: "Failed to obtain location!", preferredStyle: .Alert)
alert.addAction(UIAlertAction(title: "OK", style: .Default, handler: nil))
self.presentViewController(alert, animated: true, completion: nil)
</code></pre>

<p>  }</p>

<p>  func mapView(mapView: MKMapView, didUpdateUserLocation userLocation: MKUserLocation) {</p>

<pre><code>let newLocation = userLocation.location!
let distance = self.lastLoction?.distanceFromLocation(newLocation)
if distance == nil || distance &gt; searchDistance {
  self.lastLoction = newLocation
  self.centerMapOnLocation(newLocation)
  self.fetchCafesAroundLocation(newLocation)
}
</code></pre>

<p>  }
}
```</p>

<p>本节其他部分都是一些业务逻辑方面的内容，数不赘述。</p>

<h2>Fetching data</h2>

<p>前面的开发进行到了最后一步，就是将用户位置附近的咖啡馆找出来，并在地图上展示，这依赖于一个FaceBook的接口访问，同时本地需要定义咖啡馆的模型。</p>

<h3>Building the data model</h3>

<p>先定义Cafe的model，首先你会想到Cafe在这里是一个纯数据类型，你可能会使用struct，因为Swift中struct也是model的选择之一。</p>

<p>但同时，你希望Cafe可以直接被显示到地图上，那么它就必须遵循MKAnnotation协议，这时，编译器便会报错，因为MKAnnotation是OC的协议，Cafe遵循该协议，必须可以被转化为OC代码，但struct在OC中只是一个C的数据类型，无法转化，所以这里必须声明Cafe为class，且必须继承自NSObject，因为MKAnnotation也遵循NSObject协议。最后，别忘了在init()结尾，添加<strong>super.init()</strong>，这样才能调到NSObject的初始化方法。</p>

<p>```objectivec
import Foundation
import MapKit</p>

<p>class Cafe: NSObject {
  let fbid: String
  let name: String
  let location: CLLocationCoordinate2D
  let street: String
  let city: String
  let zip: String</p>

<p>  init(fbid: String, name: String, location: CLLocationCoordinate2D, street: String, city: String, zip: String) {    self.fbid = fbid</p>

<pre><code>self.name = name
self.location = location
self.street = street
self.city = city
self.zip = zip
super.init()  }
</code></pre>

<p>}</p>

<p>extension Cafe: MKAnnotation {
  var title: String? {</p>

<pre><code>return name
</code></pre>

<p>  }
  var coordinate: CLLocationCoordinate2D {</p>

<pre><code>  return location
</code></pre>

<p>  }
}
```</p>

<h3>Fetching from Facebook</h3>

<p>下面将从Facebook的接口获取数据。</p>

<p>```objectivec
var urlString = &ldquo;<a href="https://graph.facebook.com/v2.0/search/">https://graph.facebook.com/v2.0/search/</a>&rdquo;
urlString += &ldquo;?access_token=&rdquo;
urlString += &ldquo;(FBSession.activeSession().accessTokenData.accessToken)&rdquo;
urlString += &ldquo;&amp;type=place&rdquo;
urlString += &ldquo;&amp;q=cafe&rdquo;
urlString += &ldquo;&amp;center=(location.coordinate.latitude),&rdquo;
urlString += &ldquo;(location.coordinate.longitude)&rdquo;
urlString += &ldquo;&amp;distance=(Int(searchDistance))&rdquo;</p>

<p>let url = NSURL(string: urlString)!
print(&ldquo;Request URL: (url)&rdquo;)</p>

<p>let request = NSURLRequest(URL: url)
NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.mainQueue()) { (response: NSURLResponse?, data: NSData?, error: NSError?) &ndash;> Void in</p>

<pre><code>if error != nil {
  let alert = UIAlertController(title: "Oops!", message: "An error occured", preferredStyle: .Alert)
  alert.addAction(UIAlertAction( title: "OK", style: .Default, handler: nil))
  self.presentViewController(alert, animated: true, completion: nil)
  return
}

let jsonObject: AnyObject! = try? NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions(rawValue: 0))

if let jsonObject = jsonObject as? [String:AnyObject] {
    if let data = JSONValue.fromObject(jsonObject)?["data"]?.array {
        var cafes: [Cafe] = []
        for cafeJSON in data {
        if let cafeJSON = cafeJSON.object {
            if let cafe = Cafe.fromJSON(cafeJSON) {
                cafes.append(cafe)
            }
        }
    }

    self.mapView.removeAnnotations(self.cafes)
    self.cafes = cafes
    self.mapView.addAnnotations(cafes)
    }
}
</code></pre>

<p>}
```</p>

<ol>
<li>首先拼接要访问的URL，采用了String拼接，而不是stringWithFormat:，这样代码比较清晰</li>
<li>然后将string转化为NSURL，虽然NSURL的参数需要NSString，但是使用String也没问题，这是因为Swift对它们进行了无缝的桥接。</li>
<li>使用了NSURLConnection的异步请求，使用closure处理回调。</li>
<li>JSON的反序列化，目前Swift2.0采用了try/catch这样的写法，而弃用了之前OC的传入NSError**参数的做法，代码更简洁。</li>
<li>NSJSONSerialization的JSONObjectWithData()方法实际返回的是NSDictionary，但是我们使用时是转化成[NSObject:AnyObject]，这也是Swift的隐式转换，还有NSArray和[AnyObject]。</li>
<li>具体的JSON对象的解析，使用了JSON.swift库，关于这个库的原理在之前讲过，主要是利用enum的新特性，为每一种JSON元素类型提供了type。</li>
</ol>


<h3>Parsing the JSON data</h3>

<p>让我们在Cafe类中添加一个直接从JSON初始化的方法，在取JSON每一个元素时，一定要注意使用optional类型，这样可以保证不会因为某个值不存在而崩溃。</p>

<p>```objectivec
class func fromJSON(json: [String:JSONValue]) &ndash;> Cafe? {
   let fbid = json[&ldquo;id&rdquo;]?.string
   let name = json[&ldquo;name&rdquo;]?.string
   let latitude = json[&ldquo;location&rdquo;]?[&ldquo;latitude&rdquo;]?.double
   let longitude = json[&ldquo;location&rdquo;]?[&ldquo;longitude&rdquo;]?.double</p>

<p>   if fbid != nil &amp;&amp; name != nil &amp;&amp; latitude != nil &amp;&amp; longitude != nil {</p>

<pre><code>   var street: String
   if let maybeStreet = json["location"]?["street"]?.string {
       street = maybeStreet
   } else {
       street = ""
   }

   var city: String
   if let maybeCity = json["location"]?["city"]?.string {
       city = maybeCity
   } else {
       city = ""
   }

   var zip: String
   if let maybeZip = json["location"]?["zip"]?.string {
       zip = maybeZip
   } else {
       zip = ""
   }

   let location = CLLocationCoordinate2D(latitude: latitude!, longitude: longitude!)
   return Cafe(fbid: fbid!, name: name!, location: location, street: street, city: city, zip: zip)
</code></pre>

<p>   }
   return nil
}
```</p>

<p>从OC的角度考虑，我们可能会问，为什么不写一个secondary初始化方法？这是由于Swift决定的，某个类初始化方法是不能返回nil值的，如果可以，那么所有的Swift类型都是optional类型了，那么区分optional就没有意义，所以我们一定要注意，像构建这类可能返回nil的初始化方法，最好采用该类型的工厂方法来实现。</p>

<h2>Selectors</h2>

<p>这一小节想给app加一个刷新按钮，引出OC中的target/selector模式在Swift中如何使用的问题。</p>

<p>OC中的方法调用是动态分发的，即方法的调用者（target）和方法名（SEL）都是可以在runtime动态分发的，而且你可以在runtime中修改这些值，而编译器不会在意该方法有没有实现。而在Swift中，所有的方法调用在编译期间就会决定，不再采用动态分发。那么如何解决Swift中调用原OC中需要target/SEL的方法，就需要得到解决。</p>

<p>Swift给出的方案是使用一个结构体Selector，Selector遵循了StringLiteralConvertible协议，其内部使用时可以直接从String转换，而使用者只需传入一个String即可。</p>

<p><code>objectivec
self.navigationItem.leftBarButtonItem = UIBarButtonItem(barButtonSystemItem: .Refresh, target: self, action: "refresh:")
</code></p>

<p><code>objectivec
public convenience init(barButtonSystemItem systemItem: UIBarButtonSystemItem, target: AnyObject?, action: Selector)
</code></p>

<p>你可以尝试不去实现refresh:方法，而编译器也不会报错，而在执行时才会报错，这就是因为它的真正实现还是使用了OC的动态分发，只是做了Swift的桥接。</p>

<h2>Protocols and delegates</h2>

<p>接下来会为每个cafe创建一个detail view，并定义一个protocol，使用委托模式，并确保可以桥接到OC。</p>

<h3>Creating the detail view</h3>

<p>创建对应的viewController，并在storyboard上定义好xib。</p>

<p>这里声明了一个Cafe变量作为数据源，如下，与以往不同的是，添加了didSet()方法，该方法会在cafe被赋值之后会调用，类似OC中的KVO，你可以为实现变量的didSet和willSet，分别在赋值前和复制后调用。</p>

<p>```objectivec
var cafe: Cafe? {
  didSet {</p>

<pre><code>self.setupWithCafe()
</code></pre>

<p>  }
}
```</p>

<p>在Cafe类添加一个pictureURL变量，是一个computed property，提供了返回值。</p>

<p><code>objectivec
var pictureURL: NSURL {
return NSURL(string: "http://graph.facebook.com/place/picture?id=\(self.fbid)&amp;type=large")!
}
</code></p>

<p>接下来是setupWithCafe()方法，由于该方法放在了cafe的didSet中调用了，而且存在很多outlet存在，需要判断这些outlet是否加载完成，所以先进行了self.isViewLoaded()判断。</p>

<p>```objectivec
private func setupWithCafe() {
  if !self.isViewLoaded() {</p>

<pre><code>return
</code></pre>

<p>  }</p>

<p>  if let cafe = self.cafe {</p>

<pre><code>self.title = cafe.name

self.nameLabel.text = cafe.name
self.streetLabel.text = cafe.street
self.cityLabel.text = cafe.city
self.zipLabel.text = cafe.zip

let request = NSURLRequest(URL: cafe.pictureURL)
NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.mainQueue()) {
  (response: NSURLResponse?, data: NSData?, error: NSError?) -&gt; Void in
  let image = UIImage(data: data!)
  self.imageView.image = image
}
</code></pre>

<p>  }
}
```</p>

<h3>Wiring up the detail view</h3>

<p>在ViewController中，通过实现mapView(mapView: MKMapView!, viewForAnnotation annotation: MKAnnotation!) &ndash;> MKAnnotationView!和mapView(mapView: MKMapView!, annotationView view: MKAnnotationView!, calloutAccessoryControlTapped control: UIControl!)两个MKMapViewDelegate的方法，完成了通过点击大头针，弹出详情按钮，再进入详情页的功能。</p>

<p>这里还想将ViewController作为CafeViewController的委托，在CafeViewController点击返回时调用。</p>

<p><code>objectivec
@objc protocol CafeViewControllerDelegate {
  optional func cafeViewControllerDidFinish(viewController: CafeViewController)
}
</code></p>

<p>这里在声明protocol前加了<strong>@objc</strong>关键字是因为该protocol有optional方法，因为这样可以使Swift添加多个runtime检测，来检测protocol的一致性和是否实现了optional类型的方法。同时这也限制了，protocol的实现者必须是class类型，因为runtime对@obj的检测需要对象为class。而你也可以通过在protocol后加限制来实现。</p>

<p><code>objectivec
@objc protocol CafeViewControllerDelegate: class {
  optional func cafeViewControllerDidFinish(viewController: CafeViewController)
}
</code></p>

<p>然后在CafeViewController添加delegate变量，与OC一样，使用weak属性，需要注意的是声明为optional类型，因为不是一定有委托对象的。</p>

<p><code>objectivec
weak var delegate: CafeViewControllerDelegate?
</code></p>

<p>然后是delegate的调用，这里使用了optional chain，delegate的存在与cafeViewControllerDidFinish()方法的实现与否都是不确定的。</p>

<p>```objectivec
@IBAction private func back(sender: AnyObject) {</p>

<pre><code>self.delegate?.cafeViewControllerDidFinish?(self)}
</code></pre>

<p>```</p>

<p>最后，是在ViewController中的delegate实现。</p>

<p>```objectivec
extension ViewController: CafeViewControllerDelegate {
  func cafeViewControllerDidFinish(viewController: CafeViewController) {</p>

<pre><code>self.dismissViewControllerAnimated(true, completion: nil)
</code></pre>

<p>  }
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Functional Programming]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/23/swift-by-tutorials-functional-programming/"/>
    <updated>2015-11-23T14:09:04+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/23/swift-by-tutorials-functional-programming</id>
    <content type="html"><![CDATA[<p>前几篇分别介绍了泛型、类、枚举、范围运算符这些Swift的语言新特性，当然有一部分是对已有技术的改进，但这已经表明Swift是比OC更具表现力和更简洁的语言。而Swift不仅仅是提供了更好的语法，在Swift中，函数式编程会成为编程中可行的并且非常重要的编程工具。函数式编程，简而言之，就是一种通过数学式的函数概括计算的编程范式，不可变且具表现力，同时使用最少的变量和状态值。函数式编程对于测试是非常友好的。随着多核设备的普及，并行和并发处理显得非常重要，而函数式编程就是可以很好处理并行和并发处理的，这也是它日趋重要的原因之一。</p>

<!--more-->


<h2>Simple array filtering</h2>

<p>这个简单的例子要求我们在1到10之间找到所有的偶数的数字，看起来是一个简单的工作，但是是介绍函数式编程的一大步。</p>

<h3>Filtering the old way</h3>

<p>```objectivec
var evens = <a href="">Int</a>
for i in 1&hellip;10 {</p>

<pre><code>if i % 2 == 0 {
evens.append(i)
}
</code></pre>

<p>}
print(evens)
```</p>

<p>这是一个很简单的小程序，而且运行也没问题，但是最核心的逻辑，检测一个数是否偶数，被隐藏在了for循环中。另外，添加数字到数组的逻辑在判断条件中，如果你想要打印每个偶数，那么除了复制粘贴，没法儿复用这部分代码。</p>

<h3>Functional filtering</h3>

<p>让我们来看看函数式的解决方案，其中filter是核心，通过传递isEven给filter，直接返回了我们需要的新数组。</p>

<p>```objectivec
func isEven(number: Int) &ndash;> Bool {</p>

<pre><code>return number%2 == 0
</code></pre>

<p>}
evens = Array(1&hellip;10).filter(isEven)
print(evens)
```</p>

<p>通过上一章我们知道函数只是有名字的闭包，按照之前的介绍，利用type inference我们可以对该方案进一步简化。</p>

<p><code>objectivec
evens = Array(1...10).filter { number in number % 2 == 0 }
println(evens)
</code></p>

<p>或者最简化的使用参数简化符号。</p>

<p><code>objectivec
evens = Array(1...10).filter{ $0%2 == 0 }
print(evens)
</code></p>

<p>对于简化符号的使用，作者表示，对于比较简单的逻辑（如上例）推荐使用简化符号，而对于复杂的逻辑，则不推荐使用，因为即使减少了代码量，但牺牲了可读性，还是不太划算。</p>

<p>上面的函数式编程较上一节的方案，更为简洁，而同时它也反映了，函数式编程三个共同的特点。</p>

<ol>
<li>Higher-order functons：你需要将这些函数当做参数传入其他函数，该例中isEven即是Higher-order functons。</li>
<li>First-class function：这也是我们多次强调的一点，函数作为第一类对象，可以作为参数或者返回结果，这也是函数式编程的基础，Swift全面支持这一点。</li>
<li>Closures：闭包，可以使代码更简洁，相当于匿名函数。</li>
</ol>


<p>你可能觉得OC的block也具有类似的特点，但Swift较之更胜一筹，主要是因为它拥有很多内建的函数式语法，比如该例中的filter就是。</p>

<h3>The magic behind filter</h3>

<p>通过自定义一个myFilter方法，让我们来看一下filter的背后实现。</p>

<p>```objectivec
func myFilter<T>(source: [T], predicate:(T) &ndash;> Bool) &ndash;> [T] {</p>

<pre><code>var result = [T]()
for i in source {
    if predicate(i) {
        result.append(i)
    }
}
return result
</code></pre>

<p>}
```</p>

<p>从上面发现，实际上的实现和我们在第一节的逻辑是相同的，只不过通过泛型和函数作为参数完成了filter这一过程的抽象，这也是函数式编程的本质。</p>

<p>原文还提出一个将myFilter()作为Array的一个方法，而不是函数，其实只需要添加一个Array的扩展，将泛型改为Array自身的元素就行，下面给出自己的解答。</p>

<p>```objectivec
extension Array {</p>

<pre><code>func myFilter&lt;T&gt;(predicate:(T) -&gt; Bool) -&gt; [T] {
    var result = [T]()
    for i in self {
        if predicate(i as! T) {
            result.append(i as! T)
        }
    }
    return result
}
</code></pre>

<p>}
evens = Array(1&hellip;10).myFilter{$0%2 == 0}
```</p>

<h2>Reducing</h2>

<p>这一节将介绍Swift中内建的，比较复杂的reduce函数，进一步了解函数式编程。</p>

<h3>Manual reduction</h3>

<p>reduce的效果是输入一个数组，但最终得到一个结果，例子是要求我们找出1到10的所有偶数，并计算出他们的和，先看下常规控制流的实现。</p>

<p>```objectivec
var evens = <a href="">Int</a>
for i in 1&hellip;10 {</p>

<pre><code>if i % 2 == 0 {
    evens.append(i)
}
</code></pre>

<p>}
var evenSum = 0
for i in evens {</p>

<pre><code>evenSum += i
</code></pre>

<p>}
print(evenSum)
```</p>

<h3>Functional reduce</h3>

<p>下面是reduce的函数式实现，这里采用的是全简写符号。</p>

<p><code>objectivec
let evenSum = Array(1...10).filter{$0%2 == 0}.reduce(0){$0+$1}
print(evenSum)
</code></p>

<p>reduce的函数原型如下，有两个参数，initial和combine，initial为U类型，最终的返回值也是U类型，而combine的参数是U和T类型，返回值也是U类型，每次执行完后，返回值都会成为combine新的参数，所以实现了上述的累加效果。</p>

<p><code>objectivec
func reduce&lt;U&gt;(initial: U, combine: (U, T) -&gt; U) -&gt; U
</code></p>

<p>这里还有一个寻找数组中最大值的例子。</p>

<p><code>objectivec
let maxNumber = Array(1...10).reduce(0){total, number in max(total, number)}
print(maxNumber)
</code></p>

<p>我们发现，输入值T和最终返回值U可以是不同的类型，所以可以有更多的应用，比如下面的字符串输出。</p>

<p><code>objectivec
let numbers = Array(1...10).reduce("numbers:"){$0+"\($1)"}
print(numbers)
</code></p>

<p>这里又有一个附加问题，要求输入一个[&ldquo;3&rdquo;, &ldquo;1&rdquo;, &ldquo;4&rdquo;, &ldquo;1&rdquo;]数组，而输出Int值3141，我的思路是先拼接字符串，然后转为Int。</p>

<p><code>objectivec
let digits = Int(["3", "1", "4", "1"].reduce(""){$0+$1})
print(digits)
</code></p>

<h3>The magic behind reduce</h3>

<p>下面我们自己为Array添加一个自定义的reduce方法，实现方法与我们在之前的实现是一致的，还是做了一步抽象。</p>

<p>```objectivec
extension Array {</p>

<pre><code>func myReduce&lt;T, U&gt;(seed:U, combiner:(U, T) -&gt; U) -&gt; U {
    var result = seed;
    for i in self {
        result = combiner(result, i as! T)
    }
    return result
}
</code></pre>

<p>}
```</p>

<h2>Building an index</h2>

<p>接下来，我们将实践一次函数式编程，题目是将下面的String数组，按照首字母进行分组。</p>

<p><code>objectivec
let words = ["Cat", "Chicken", "fish", "Dog", "Mouse", "Guinea Pig", "monkey"]
</code></p>

<p>首先现有一个大致的思路，建立一个元组，包含首字母和其对应的String数组，最后通过一个函数返回一个该元组的数组，然后就完成了任务。</p>

<p>```objectivec
typealias Entry = (Character, [String])</p>

<p>func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>return [Entry]()
</code></pre>

<p>}
```</p>

<h3>Building an index imperatively</h3>

<p>下面是常规控制流实现，使用了两个for循环，一个用于记录所有的首字母key，第二个用于将原数组添加到对应的元组中。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {
  var result = <a href="">Entry</a>
  var letters = <a href="">Character</a>
  for word in words {</p>

<pre><code>let firstLetter = Character(word.substringToIndex(
  advance(word.startIndex, 1)).uppercaseString)
if !contains(letters, firstLetter) {
  letters.append(firstLetter)
}
</code></pre>

<p>  }
  for letter in letters {</p>

<pre><code>var wordsForLetter = [String]()
for word in words {
  let firstLetter = Character(word.substringToIndex(
    advance(word.startIndex, 1)).uppercaseString)
  if firstLetter == letter {
    wordsForLetter.append(word)
  }
}
result.append((letter, wordsForLetter))
</code></pre>

<p>  }
  return result
}
```</p>

<h3>Building an index the functional way</h3>

<p>下面是该问题的函数式解决方案，首先我们利用Array的map函数，得到words对应的首字母数组。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>let letters = words.map { word -&gt; Character in
Character(word.substringToIndex(word.startIndex.advancedBy(1)).uppercaseString)
}
return [Entry]()
</code></pre>

<p>}
```</p>

<p>map与前面的filter，reduce一样都是Array的内建函数，它的作用是输出一个与原数组对应的相关数组。而且数组元素可以与原数组不同，这里通过map得到了words对应的首字母数组，但是不足的是重复字母并没有过滤。我们可以像之前一样自定义一个过滤相同字母的函数。</p>

<p>```objectivec
func distinct&lt;T: Equatable> (source: [T]) &ndash;> [T] {</p>

<pre><code>var unique = [T]()
for item in source {
    if !unique.contains(item) {
        unique.append(item)
    }
}
return unique
</code></pre>

<p>}
```</p>

<p>利用这一函数，过滤重复字母。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>let letters = words.map { word -&gt; Character in 
Character(word.substringToIndex(word.startIndex.advancedBy(1)).uppercaseString)
}
let distinctLetters = distinct(letters)
print(distinctLetters)
return [Entry]()
</code></pre>

<p>}
```</p>

<p>最后，我们利用map和filter的嵌套使用，完成最终的结果数组。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>let letters = words.map { word -&gt; Character in 
Character(word.substringToIndex(word.startIndex.advancedBy(1)).uppercaseString)
}
let distinctLetters = distinct(letters)

return distinctLetters.map { letter -&gt; Entry in
    return (letter, words.filter { word -&gt; Bool in 
    Character(word.substringToIndex(word.startIndex.advancedBy(1)).uppercaseString) == letter
        })
}
</code></pre>

<p>}
```</p>

<p>在完成基础上我们可以进一步重构，我们在buildIndex()函数中声明了一个新的函数firstLetter()，该函数的作用范围只在外围函数中，这得益于Swift中function作为第一类对象，所以可以被视作本地变量，也有作用范围。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>func firstLetter(str: String) -&gt; Character {
    return Character(str.substringToIndex(str.startIndex.advancedBy(1)).uppercaseString)
}

let letters = words.map { word -&gt; Character in
    return firstLetter(word)
}
let distinctLetters = distinct(letters)
print(distinctLetters)

return distinctLetters.map { letter -&gt; Entry in
    return (letter, words.filter { word -&gt; Bool in
        firstLetter(word) == letter
        })
}
</code></pre>

<p>}
```</p>

<p>然而，这还不是最简形式，追求最简形式，可以将所有函数连续调用，这是没问题的，以下是最终结果。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>func firstLetter(str: String) -&gt; Character {
    return Character(str.substringToIndex(str.startIndex.advancedBy(1)).uppercaseString)
}

return distinct(words.map(firstLetter))
    .map {
      letter -&gt; Entry in
      return (letter, words.filter {
        word -&gt; Bool in
        firstLetter(word) == letter
      })
    }
</code></pre>

<p>}
```</p>

<p>通过比较，你会发现，在常规做法中，你会声明很多临时变量，而在函数式编程中，你会使用对应的常量替代，这就意味着是不可变的，而不可变的类型更容易测试和协助并发，函数式编程与不可变类型是一体的，而且会导致你的代码更简洁，错误更少。</p>

<p>这节的挑战任务是需要输出的结果按字母排序，我们可以添加之前介绍过的最简的sort()方法，在distinct()之后进行调用。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>func firstLetter(str: String) -&gt; Character {
    return Character(str.substringToIndex(str.startIndex.advancedBy(1)).uppercaseString)
}

return distinct(words.map(firstLetter)).sort(&lt;)
    .map {
      letter -&gt; Entry in
      return (letter, words.filter {
        word -&gt; Bool in
        firstLetter(word) == letter
      })
    }
</code></pre>

<p>}
```</p>

<h2>Partial application and currying</h2>

<p>前面几节围绕Array的三个方法，map，reduce，filter来介绍函数式编程。这一节将进一步介绍函数式编程的Partial application和currying。这里有一篇<a href="http://segmentfault.com/a/1190000000765247">博客</a>也进行了简单的介绍。</p>

<h3>Partial application</h3>

<p>为了说明Partial application，先提出一个问题，切割字符串为数组，我们的常用解决方案就是就是直接调用NSString的componentsSeparatedByString()方法。</p>

<p><code>objectivec
import Foundation
let data = "5,7;3,4;55,6"
print(data.componentsSeparatedByString(";"))
print(data.componentsSeparatedByString(","))
</code></p>

<p>这么调用也没问题，但是如果有场景需要我们多次用分号，或者逗号切割字符串，这样处理会出现许多重复代码，那么partical application就是这类问题的解决方案。</p>

<p>```objectivec
func creatSplitter(separator: String) &ndash;> (String &ndash;> [String]) {</p>

<pre><code>func split(source: String) -&gt; [String] {
    return source.componentsSeparatedByString(separator)
}
return split
</code></pre>

<p>}</p>

<p>let commaSplitter = creatSplitter(&ldquo;,&rdquo;)
print(commaSplitter(data))</p>

<p>let semiColonSplitter = creatSplitter(&ldquo;;&rdquo;)
print(semiColonSplitter(data))
```</p>

<p>我们创建了一个产生分割字符串方法的工厂方法，输入分隔符号，返回一个该符号的分割方法，也就是我们先实现了函数的一部分，将函数从二元降为了一元，最主要的是，我们可以反复使用这一得到的方法，可能在该例中优点体现不太明显，但是如果逻辑更复杂，参数更多后，partical application带来的效率提高就非常可观了。</p>

<h3>A mild curry</h3>

<p>使用curry也可以实现上例中的结果，如下，但是调用和工厂方法的写法都会改变。</p>

<p>```objectivec
func createSplitter(separator: String)(source: String) &ndash;> [String] {</p>

<pre><code>return source.componentsSeparatedByString(separator)
</code></pre>

<p>}</p>

<p>let commaSplitter = createSplitter(&ldquo;,&rdquo;)
print(commaSplitter(source: data))</p>

<p>let semiColonSplitter = createSplitter(&ldquo;;&rdquo;)
print(semiColonSplitter(source: data))
```</p>

<p>curry实现了相同的目的，但是它创建的方法包含了两组“分开的”参数，而当你输入第一个参数时，会返回一个函数，你可以继续输入第二个参数（第二个参数需要使用外部参数名，与一般函数一致）。</p>

<h3>A hotter curry</h3>

<p>让我们进一步了解curry，将下面的三元函数进行curry化。</p>

<p>```objectivec
func addNumbers(one:Int, two:Int, three:Int) &ndash;> Int {</p>

<pre><code>return one + two + three
</code></pre>

<p>}
let sum = addNumbers(2, two: 5, three: 4)
print(sum)
```</p>

<p>```objectivec
func curryAddNumbers(one:Int)(two:Int)(three:Int) &ndash;> Int {</p>

<pre><code>return one+two+three
</code></pre>

<p>}
```</p>

<p>接着让我们分部对curry函数进行调用，每一步都会返回一个函数，最后一步返回最终结果。</p>

<p><code>objectivec
let stepOne = curryAddNumbers(2)
let stepTwo = stepOne(two: 5)
let result = stepTwo(three: 4)
</code></p>

<p>也可以像一般函数一样，一次性直接调用。</p>

<p><code>objectivec
let result2 = curryAddNumbers(2)(two: 5)(three: 4)
</code></p>

<p>当然，也可以在每一步添加多个参数。</p>

<p>```objectivec
func curryAddNumbers2(one:Int, two: Int)(three: Int) &ndash;> Int {</p>

<pre><code>return one+two+three
</code></pre>

<p>}
let result3 = curryAddNumbers2(2, two: 5)(three: 4)
```</p>

<h3>Practical curring</h3>

<p>上面两例主要为了说明curry的使用，这里看下它在实际开发中的用法。</p>

<p><code>objectivec
let text = "Swift"let paddedText = text.stringByPaddingToLength(10, withString: ".", startingAtIndex: 0)print(paddedText)
</code></p>

<p>这是一个调用了NSString的填充字符串的方法（额外注意一点startingAtIndex:是指明要填充的字符串从哪位开始填充，所以不能超过withString:参数的长度）。我们在他基础之上要封装一个四元的curry函数。</p>

<p>```objectivec
func curriedPadding(startingAtIndex: Int, withString: String)
  (source: String, length: Int) &ndash;> String {</p>

<pre><code>return source.stringByPaddingToLength(length,
  withString: withString, startingAtIndex: startingAtIndex);
</code></pre>

<p>}
```</p>

<p>然后在它基础上创建一个只用点填充字符串的方法。</p>

<p><code>objectivec
let dotPadding = curriedPadding(0, withString: ".")
let dotPadded = dotPadding(source: "Curry!", length: 10)
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Enums and Switch Statements]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/20/swift-by-tutorials-enums-and-switch-statements/"/>
    <updated>2015-11-20T10:11:34+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/20/swift-by-tutorials-enums-and-switch-statements</id>
    <content type="html"><![CDATA[<p>enum枚举类型是很多编程语言的基本特性，一般是用来存储一组表示不同type的值，比如UILabel使用的NSTextAlignment，会有.Center，.Left多个type。而在Swift中，enum除了原始的用法，它的用法更像class或struct，enum可以拥有自己的方法，甚至是构造方法，然后通过配合Switch，可以实现更灵活的代码流控制，所以才会专门拿出来讲解，足见enum+switch在Swift的重要性。</p>

<!--more-->


<h2>Basic enumerations</h2>

<p>先看一个Swift中定义的简单enum，如下：</p>

<p>```objectivec
enum Shape {</p>

<pre><code>case Rectangle
case Square
case Triangle
case Circle
</code></pre>

<p>}
```</p>

<p>而使用时，可以按照下面两种方式赋值，如果事先定义了类型，那么可以不用在后面写类型，这还是Swift type inference的表现。</p>

<p><code>objectivec
var aShape = Shape.Triangle
var bShape: Shape = .Triangle
</code></p>

<p>而在之后的再次赋值中，都不用再指定类型。</p>

<p><code>objectivec
aShape = .Square
</code></p>

<h3>Raw values</h3>

<p>在OC中，我们一般使用NS_ENUM()来定义枚举，并可以指定值的类型，也可以单独指定某个type的值。而在Swift中，也可以做到，而且更简单。</p>

<p>```objectivec
enum Shape: Int {</p>

<pre><code>case Rectangle
case Square
case Triangle
case Circle
</code></pre>

<p>}
```</p>

<p>使用上述代码就指定了enum的原始值类型为Int，同时该enum获得了一个property，<strong>rawValue</strong>，用于读取当前枚举值的raw value，和一个新的初始化方法，<strong>init(rawValue:)</strong>，用raw value来初始化enum。</p>

<p><code>objectivec
var triangle = Shape.Triangle
triangle.rawValue
var square = Shape(rawValue: 1)
</code></p>

<p>有一点需要注意，就是通过<strong>init(rawValue:)</strong>生成的enum值，是Optional类型的，因为可能会出现输入的raw value没有对应的enum，如下，会返回nil。</p>

<p><code>objectivec
var notAShape = Shape(rawValue: 100)
</code></p>

<p>enum可以直接给某个type赋值，然后其他未赋值的type会自动加1。</p>

<p>```objectivec
enum Shape: Int {</p>

<pre><code>case Rectangle = 10
case Square
case Triangle
case Circle
</code></pre>

<p>}
```</p>

<p>此外，enum可以使用其他类型的raw value，比如Double，Float，String，但是需要为所有type指定对应的raw value，因为除了Int，其他类型的enum是不会对没赋值的enum自动加1的。</p>

<p>```objectivec
enum Shape: String {</p>

<pre><code>case Rectangle = "Rectangle"
case Square = "Square"
case Triangle = "Triangle"
case Circle = "Circle"
</code></pre>

<p>}
```</p>

<h2>Switch statements</h2>

<p>switch与enum的配合在很多语言都是常见的用法，Swift中一样可以，而且有很多实用的改进。</p>

<p>```objectivec
enum Shape {</p>

<pre><code>case Rectangle
case Square
case Triangle
case Circle
</code></pre>

<p>}</p>

<p>var aShape = Shape.Rectangle</p>

<p>switch(aShape) {
case .Rectangle:</p>

<pre><code>print("a rectangle")
</code></pre>

<p>case .Square:</p>

<pre><code>print("a square")
</code></pre>

<p>default:</p>

<pre><code>print("other shape")
</code></pre>

<p>}
```</p>

<p>之前在控制流的章节我们介绍过Swift中的switch，它是需要所有case全部覆盖的，如果你实现了全部case的覆盖，则不用添加default，反之，一定要添加defaut处理。而且，你不需要在每个case后添加break，系统会自动为你添加。</p>

<p>```objectivec
switch(aShape) {
case .Rectangle, .Square:</p>

<pre><code>print("a quadrilateral")
</code></pre>

<p>case .Circle:</p>

<pre><code>print("a circle")
</code></pre>

<p>default:</p>

<pre><code>break
</code></pre>

<p>}
```</p>

<p>一个case处理多个值也很简单，只需要逗号隔开多个值即可，并不需要其他语言中，用不加break的多行处理。</p>

<h2>Associated values</h2>

<p>Associated values是Swift与其他语言的enum类型最大的不同之处，你可以向每个type添加一个类似元组类型的附加值，来作为二级判断条件，下面是有附带值的enum声明，可以为参数添加参数名。</p>

<p>```objectivec
enum Shape {</p>

<pre><code>case Rectangle(width: Float, height: Float)
case Square(side: Float)
case Triangle(base: Float, height: Float)
case Circle(radius: Float)
</code></pre>

<p>}
```</p>

<p>使用时，可以像类或结构体初始化一样赋值，但记住不能像两者一样用<strong>.</strong>来访问。</p>

<p><code>objectivec
var rectangle = Shape.Rectangle(width: 5, height: 10)
</code></p>

<p>你可以使用这些associated values的场景只能是在switch语句中，同时你还可以使用where关键字，为case添加二级条件。</p>

<p>```objectivec
switch (rectangle) {
case .Rectangle(let width, let height) where width &lt;= 10:</p>

<pre><code>print("Narrow rectangle:\(width)*\(height)")
</code></pre>

<p>case .Rectangle(let width, let height):</p>

<pre><code>print("Wide rectangle:\(width)*\(height)")
</code></pre>

<p>default:</p>

<pre><code>print("other shape")
</code></pre>

<p>}
```</p>

<p>需要注意的是，判断条件越来越复杂，便会出现符合多个case的情况，但像前面所说，系统会自动在case后添加break，所以也只会执行最先符合的case，这需要注意。</p>

<h2>Eunms as types</h2>

<p>Swift中的enum还有另外一个重要特性，就是可以添加方法，配合associated value，可以封转一些方便的方法，比如为上面的Shape添加一个计算面积的方法。</p>

<p>```objectivec
func area() &ndash;> Float {</p>

<pre><code>switch(self) {
case .Rectangle(let width, let height):
    return width * height
case .Square(let side):
    return side * side
case .Triangle(let base, let height):
    return 0.5 * base * height
case .Circle(let radius):
    return Float(M_PI) * powf(radius, 2)
}
</code></pre>

<p>}
```</p>

<p>然后申明一个Shape的变量，就可以直接调用该方法计算面积了。</p>

<p><code>objectivec
var circle = Shape.Circle(radius: 5)
circle.area()
</code></p>

<p>除此之外，可以添加新的构建方法，这是Shape实例的构造方法，所以切记一定要给self赋值，否则self没有值是无法返回对象的。</p>

<p>```objectivec
init(_ rect: CGRect) {</p>

<pre><code>let width = Float(CGRectGetWidth(rect))
let height = Float(CGRectGetHeight(rect))
if width == height {
    self = Square(side: width)
} else {
    self = Rectangle(width: width, height: height)
}
</code></pre>

<p>}
```</p>

<p><code>objectivec
var shape = Shape(CGRectMake(0, 0, 5, 10))
</code></p>

<p>所以如下这个构建方法是不合法的，因为会存在无法给self赋值的情况。</p>

<p>```objectivec
init(_ string: String) {</p>

<pre><code>switch(string) {
case "rectangle":
    self = Rectangle(width: 5, height: 10)
case "square":
    self = Square(side: 5)
case "triangle":
    self = Triangle(base: 5, height: 10)
case "circle":
    self = Circle(radius: 5)
default:
    break
}
</code></pre>

<p>}
```</p>

<p>但是想通过这种思路来初始化Shape，也可以实现，就是构建一个static的工厂方法，这样就不存在一定要有值的限制了，可以返回Optional类型。</p>

<p>```objectivec
static func fromString(string: String) &ndash;> Shape? {
switch(string) {</p>

<pre><code>case "rectangle":
    return Rectangle(width: 5, height: 10)
case "square":
    return Square(side: 5)
case "triangle":
    return Triangle(base: 5, height: 10)
case "circle":
    return Circle(radius: 5)
default:
    return nil
}
</code></pre>

<p>}
```</p>

<p>对应的，使用时也要用if来拆包。</p>

<p>```objectivec
if let anotherShape = Shape.fromString(&ldquo;rectangle&rdquo;) {</p>

<pre><code>anotherShape.area()
</code></pre>

<p>}
```</p>

<h3>Optionals are enums</h3>

<p>Swift的Optional类型是enum类型，下面是部分实现：</p>

<p><code>objectivec
enum Optional&lt;T&gt; : NilLiteralConvertible {
  case None  case Some(T)  init()  init(_ some: T)  static func convertFromNilLiteral() -&gt; T?
}
</code></p>

<p>这里使用了泛型，并将该类型作为Some的associated value，可以使Optional持有任何类型的值。</p>

<p>同时enum可以实现协议，NilLiteralConvertible协议使你可以用nil来替代optional，编译器自动会将赋值nil时去调用<strong>convertFromNilLiteral</strong>，最终转化为.None。正是因为实现了这个协议，才可以对optional类型赋nil值，不然会报错。</p>

<h2>JSON parsing using enums</h2>

<p>本节用解析JSON这一常见用例，来实践enum在Swift中的使用。</p>

<h3>Parsing JSON the hard way</h3>

<p>这是常规的解析方法，看起来确实比较繁琐（但相比OC是还是简单多了）。</p>

<p>```objectivec
let json = &ldquo;{\"success\&rdquo;:true,\&ldquo;data\&rdquo;:{\&ldquo;numbers\&rdquo;:[1,2,3,4,5],\&ldquo;animal\&rdquo;:\&ldquo;dog\&rdquo;}}"</p>

<p>if let jsonData = (json as NSString).dataUsingEncoding(NSUTF8StringEncoding) {
  let parsed: AnyObject? = NSJSONSerialization.JSONObjectWithData(jsonData, options: NSJSONReadingOptions(0), error: nil)</p>

<p>  // Actual JSON parsing section
  if let parsed = parsed as? [String:AnyObject] {</p>

<pre><code>if let success = parsed["success"] as? NSNumber {
  if success.boolValue == true {
    if let data = parsed["data"] as? NSDictionary {
      if let numbers = data["numbers"] as? NSArray {
        print(numbers)
      }
      if let animal = data["animal"] as? NSString {
        print(animal)
      }
    }
  }
}
</code></pre>

<p>  }
}
```</p>

<h3>Introducing JSON.swift</h3>

<p>这个文件之前在第四章解析JSON时用过，下面来分析下它的结构，首先是一个enum定义，因为JSON文件就是一些基本元素和dictionary或array的组合，所以使用enum和associated value来定义JSON的基本对象，这是这一解决方案的核心思想。</p>

<p><code>objectivec
enum JSONValue {    case JSONObject([String:JSONValue])     case JSONArray([JSONValue]) case JSONString(String) case JSONNumber(NSNumber)   case JSONBool(Bool) case JSONNull}
</code></p>

<p>接下来为了获取.JSONObject和.JSONArray，我们利用Swift中方便添加角标访问的方式，使用subscript技术。</p>

<p>```objectivec
subscript(i: Int) &ndash;> JSONValue? {
  get {</p>

<pre><code>switch self {
case .JSONArray(let value):
  return value[i]
default:
  return nil
}
</code></pre>

<p>  }
}</p>

<p>subscript(key: String) &ndash;> JSONValue? {
  get {</p>

<pre><code>switch self {
case .JSONObject(let value):
  return value[key]
default:
  return nil
}
</code></pre>

<p>  }
}
```</p>

<p>那么访问一般元素时呢？我们采用了computed properties来访问。</p>

<p>```objectivec
var object: [String:JSONValue]? {
  switch self {
  case .JSONObject(let value):</p>

<pre><code>return value
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}</p>

<p>var array: [JSONValue]? {
  switch self {
  case .JSONArray(let value):</p>

<pre><code>return value
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}</p>

<p>var string: String? {
  switch self {
  case .JSONString(let value):</p>

<pre><code>return value
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}</p>

<p>var integer: Int? {
  switch self {
  case .JSONNumber(let value):</p>

<pre><code>return value.integerValue
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}</p>

<p>var double: Double? {
  switch self {
  case .JSONNumber(let value):</p>

<pre><code>return value.doubleValue
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}</p>

<p>var bool: Bool? {
  switch self {
  case .JSONBool(let value):</p>

<pre><code>return value
</code></pre>

<p>  case .JSONNumber(let value):</p>

<pre><code>return value.boolValue
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}
```</p>

<p>最后将对象转化为JSONValue也需要一个方法，而且是递归调用的，</p>

<p>```objectivec
static func fromObject(object: AnyObject) &ndash;> JSONValue? {
  switch object {
  case let value as NSString:</p>

<pre><code>return JSONValue.JSONString(value)
</code></pre>

<p>  case let value as NSNumber:</p>

<pre><code>return JSONValue.JSONNumber(value)
</code></pre>

<p>  case let value as NSNull:</p>

<pre><code>return JSONValue.JSONNull
</code></pre>

<p>  case let value as NSDictionary:</p>

<pre><code>var jsonObject: [String:JSONValue] = [:]
for (k: AnyObject, v: AnyObject) in value {
  if let k = k as? NSString {
    if let v = JSONValue.fromObject(v) {
      jsonObject[k] = v
    } else {
      return nil
    }
  }
}
return JSONValue.JSONObject(jsonObject)
</code></pre>

<p>  case let value as NSArray:</p>

<pre><code>var jsonArray: [JSONValue] = []
for v in value {
  if let v = JSONValue.fromObject(v) {
    jsonArray.append(v)
  } else {
    return nil
  }
}
return JSONValue.JSONArray(jsonArray)
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}
```</p>

<h3>Putting it into practice</h3>

<p>现在让我们使用JSON.swift来完成JSON的解析，进过比较，现在只需要两层嵌套就完成了原来五层的嵌套解析，而且由于使用了Optional类型，也增加了安全性。所以在Swift中一定要注重利用enum这些新特性，它非常适用于可以预定义为一组不同的子类型的类型，就像JSON。</p>

<p>```objectivec
let json = &ldquo;{\"success\&rdquo;:true,\&ldquo;data\&rdquo;:{\&ldquo;numbers\&rdquo;:[1,2,3,4,5],\&ldquo;animal\&rdquo;:\&ldquo;dog\&rdquo;}}"</p>

<p>if let jsonData = (json as NSString).dataUsingEncoding(NSUTF8StringEncoding) {
  if let parsed: AnyObject = NSJSONSerialization.JSONObjectWithData(jsonData, options: NSJSONReadingOptions(0), error: nil) {</p>

<pre><code>if let jsonParsed = JSONValue.fromObject(parsed) {

  // Actual JSON parsing section
  if jsonParsed["success"]?.bool == true {
    if let numbers = jsonParsed["data"]?["numbers"]?.array {
      print(numbers)
    }
    if let animal = jsonParsed["data"]?["animal"]?.string {
      print(animal)
    }
  }
}
</code></pre>

<p>  }
}
```</p>
]]></content>
  </entry>
  
</feed>
