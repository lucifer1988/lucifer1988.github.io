<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 刘毅的技术博客]]></title>
  <link href="http://lucifer1988.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://lucifer1988.github.io/"/>
  <updated>2015-09-16T15:39:56+08:00</updated>
  <id>http://lucifer1988.github.io/</id>
  <author>
    <name><![CDATA[刘毅]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记6]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/09/09/effective-objective-cdu-shu-bi-ji-6/"/>
    <updated>2015-09-09T16:29:01+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/09/09/effective-objective-cdu-shu-bi-ji-6</id>
    <content type="html"><![CDATA[<p>第六章的主要内容是Blocks和GCD，这可以说是Morden OC当中的三驾马车的其余两架，它们和ARC的出现，彻底改变了OC的开发模式。多线程是现代编程中任何语言都不可或缺的技术，在iOS中阻塞UI主线程往往是应用崩溃或用户体验差的重要原因，多线程就是解决这一问题的良方，而Blocks和GCD就是Apple给开发者带来的多线程解决方案。Blocks即OC中的闭包，它可以被当做一个对象，可以运行于其他上下文中。GCD基于dispatch queues提供了对线程的抽象，它会根据系统资源自动开辟、复用、销毁后台线程，同时GCD也对一些常见编程提供了简化方案，比如：创建单例、并发任务等等。</p>

<!--more-->


<h2>Item37 Understand Blocks</h2>

<p>1.Blocks作为了GCC的拓展，也存在于Clang的所有版本中。Blocks的runtime component在Mac OS X 10.4和iOS4被加入。由于是C级别的语言特性，所以可以被用于C,C++,OC当中。</p>

<h3>Block Basics</h3>

<p>1.Blcoks的类型写法类似函数指针，也可以直接当做函数来执行：</p>

<p>```objectivec
int(^addBlcok)(int a,int b) = ^(int a, int b){</p>

<pre><code>return a+b;
</code></pre>

<p>};
int add = addBlcok(2,5);//&lt;add=7
```</p>

<p>2.Blocks最重要的特性，它可以将它包含的所有内容进行复制，也就意味着范围内的任何变量都可以使用：</p>

<p>```objectivec
int additional = 5;
int(^addBlcok)(int a,int b) = ^(int a, int b){</p>

<pre><code>return a+b+additional;
</code></pre>

<p>};
int add = addBlcok(2,5);//&lt;add=12
```</p>

<p>3.默认Blocks是不能改变外部变量的，但是可以通过添加__blcok关键字，来声明变量可以改变。</p>

<p>```objectivec
NSArray <em>array = @[@0,@1,@2,@3,@4,@5];
__blcok NSInteger count = 0;
[array enumerateObjectsUsingBlock:^(NSNumber </em>number, NSUInteger idx, BOOL *stop){</p>

<pre><code>if([number compare:@2] == NSOrderedAscending){
    count++;
}
</code></pre>

<p>}];
//count = 2
```</p>

<p>4.上例也说明了Block作为内联参数的使用，这也是它的重要用法，取代了之前传selector name这样的方式，增加了代码可读性。<br/>
5.Block内部引用的变量会被隐性添加retain，然后在block release时再调用一次release，所以blcok可以被理解为一个一般的OC对象，它也是有retain count的。<br/>
6.那么在一个类中的实例方法中声明使用block，然后在block中使用了类的实例变量，那么其实是对self进行了一次retain，如果这时这个block被self的变量再retain一次，那么就会形成循环引用，解决方法在Item40会详细说，其实就是声明一个self的__weak替代对象就好了。</p>

<h3>The Guts of Block</h3>

<ol>
<li>Block的实质，除了包含通常的isa（block的Class为void*），flags等，block的三个主要组成为：invoke、descriptor、Captured variables。</li>
<li>invoke是一个函数指针，类型为void(<em>)(void </em>,&hellip;)，至少包含的void *其实就是block自身，因为block的Captured variables包含了所有据有变量的copy，invoke指向的就是block的实现部分，所以也证明了block实质上就是Apple对函数指针的一次高级封装，便于开发者使用。</li>
<li>descriptor指向一个结构体，包含了：size（blcok总大小），copy和dispose（都是函数指针，copy在blcok被拷贝时执行，dispose在block retain或release据有的对象时执行）。</li>
<li>Captured variables就是block据有的所有变量的copy，注意这里的copy是指针拷贝。</li>
</ol>


<h3>Global，Stack，and Heap Blocks</h3>

<p>1.Block声明的时候是存在于stack上的，类似下面的代码是不安全的，因为if/else中声明的blcok是存在于stack上的，在if/else结束时，系统可能会收回这些内存重用，而且这个问题在编译中不会报出：</p>

<p>```objectivec
void(^blcok)();
if(/<em>some condition</em>/){</p>

<pre><code>blcok = ^{
    NSLog(@"Block A");
};
</code></pre>

<p>} else {</p>

<pre><code>blcok = ^{
    NSLog(@"Block B");
};
</code></pre>

<p>}
block();
```</p>

<p>2.解决这一问题的方法，就是对声明的block进行copy，这样的话，block被copy到了heap上，这样的block和其他一般对象就一样了，也不会出现上述问题，使用ARC的话，block会在之后自动释放，而MRC将要自己去添加release方法，这也是类在为block类型的property添加属性时，一般都是copy类型的。<br/>
3.所谓的global Block就是类似于之前说的NSString和NSNumber的常量声明，如果Block内部没有任何状态变化，也不依赖于外部的状态变化，在编译期间就可以知道其所需要的空间大小，系统就会对其做优化，生成一个global block，它是被声明在global memory上，而不是stack上，而且copy对于它也是一个空操作，也不会被释放，实际就是一个单例，类似：</p>

<p>```objectivec
void(^block)() = ^{</p>

<pre><code>NSLog(@"This is a global blcok!");
</code></pre>

<p>};
```</p>

<!--more-->


<h2>Item38 Create typedefs for Common Block Types</h2>

<p>1.由于Block的类型像函数指针一样，参数多的话会很长，而且类型名又在中间，很难使用和记住，所以我们可以使用C语言的typedef来做类型定义，这么做也方便将来可能的修改：</p>

<p>```objectivec
typedef int(^EOCSomeBlock)(BOOL flag,int value);
EOCSomeBlock block = ^(BOOL flag,int value){</p>

<pre><code>//Implementation
</code></pre>

<p>};
```</p>

<p>2.对block命名时还是要遵循OC的命名习惯，使用命名空间，也不要还害怕对相同类型使用多个命名，有时候这是必须的，一是命名更加清楚，二是方便将来重构。</p>

<!--more-->


<h2>Item39 Use Handler Blocks to Reduce Code Separation</h2>

<ol>
<li>异步多线程执行任务，之前一直是采用Delegate模式，但现在我们可以通过定义block作为handler来完成同样的任务，而且代码简洁，可读性强。</li>
<li>尤其出现一个类中同时使用多个同种类型的实例，采用一套回调时，那么使用Delegate则会大大增加代码的复杂度，会在很多地方出现switch的判断，而使用block则能避免这一问题。</li>
<li>作者列举了两个例子使用这一模式的场景，都是针对网络请求回调，一是，使用两个block分别处理失败和成功，二是使用一个block，使用error来判断失败和成功（这两种写法都在作者的AFNetworking里出现过）。</li>
<li>方案一的好处是，代码清晰，使用者只需对不同情况填空即可；方案二的好处是，可以更灵活的处理这一问题，如出现一些数据异常、下载中断这些情况，业务端也可以自行按失败来进行处理。</li>
<li>在设计API时，有时会出现，需要在特定线程执行代码的需求，这时我们可以在接口中加入(NSOperationQueue*)queue这样的参数，可以是缺省的。</li>
</ol>


<!--more-->


<h2>Item40 Avoid Retain Cycles Introduced by Blocks Referencing the Object Owning Them</h2>

<ol>
<li>block出现循环引用一般是因为ClassA使用了ClassB的实例，ClassB有block的实例，而ClassA在block中使用了自己的其他实例，造成了block retain了ClassA，ClassA retain了ClassB，ClassB retain了block，这样循环引用就形成了。</li>
<li>解决方案一是在block中完成所有操作时，将ClassB的实例置为nil，这样retain环就断裂了，但这么做也有问题，如果这段block代码没有被执行，那么retain环还存在。</li>
<li>还有一种更隐蔽的情况，ClassA不在把ClassB当做实例变量，只是用做局部变量，但在block中使用了ClassB的局部变量，这样会出现，block retain了ClassB，ClassB ratain了block，所以形成了二元retain环，不过解决很简单，在ClassB中完成对block的最终调用后，将它的block实例置为nil。</li>
<li>这样也凸显了不将block作为外部property的好处（使用者只能通过初始化方法赋值），如果block直接暴露给使用者，你只能要求使用者去清除block property，但这通常是不合理的设计。</li>
</ol>


<!--more-->


<h2>Item41 Prefer Dispatch Queues to Locks for Synchronization</h2>

<p>1.OC大部分线程操作都是默认多线程的，但如果有些情况需要单线程，就需要开发者自己实现，GCD之前有两种方式。<br/>
2.一是synchronization block，它将包含的代码进行加锁操作，参数是self，这可以实现类的不同实例可以分别运行这个方法，但缺点是如果过度使用，会导致性能问题，也会出现代码被不知名的锁所阻塞的问题。</p>

<p>```objectivec
&ndash;(void)synchronizedMethod{</p>

<pre><code>@synchronized(self){
    //Safe
}
</code></pre>

<p>}
```</p>

<p>3.二是NSLock，而且也有专门为递归设计的NSRecursiveLock，但是NSLock一个最大的问题是会出现死锁问题，所以二者都不是最佳方案。</p>

<p>```objectivec
_lock = [[NSLock alloc] init];
&ndash;(void)synchronizedMethod {</p>

<pre><code>[_lock lock];
//Safe
[_lock unlock];
</code></pre>

<p>}
```</p>

<p>4.那么对比使用atomic属性的property，Item6也说过，我们手动实现时，可以利用synchronization block来实现，但是问题就是当多个property这么做时，会出现propertys之间出现阻塞，而且在多次频繁访问一个property时，其他线程可能会对其修改，会造成返回值不同。<br/>
5.替代方案就是GCD的serial synchronization queue，它可以使读写property在一个队列中执行，也就避免了上述问题，代码更加简化，而且利用了GCD底层的优化，而且你不用担心对象之间的相互阻塞。</p>

<p>```objectivec
_syncQueue = dispatch_queue_creat(&ldquo;com.EOC.syncQueue&rdquo;, NULL);
&ndash;(NSString*)someString{</p>

<pre><code>__block NSString *localSomeString;
dispatch_sync(_syncQueue,^{
    localSomeString = _someString;
});
return localSomeString;
</code></pre>

<p>}
&ndash;(void)setSomeString:(NSString*)someString{</p>

<pre><code>dispatch_sync(_syncQueue, ^{
    _someString = someString;
});
</code></pre>

<p>}
```</p>

<p>6.对于这一方案还有优化，优化一是可以将setter方法使用异步执行，因为setter方法不会有返回值，而且由于和getter还是在一个队列执行，还是能保持读取的同步，但是涉及到一个问题，异步需要将block copy到异步线程，那么如果block内容很简单，可能copy的时间和执行的时间差不多，也就达不到优化的效果，但是当block内容比较复杂时，这一手段还是有效地。</p>

<p>```objectivec
&ndash;(void)setSomeString:(NSString*)someString{</p>

<pre><code>dispatch_async(_syncQueue,^{
    _someString = someString;
});
</code></pre>

<p>}
```</p>

<p>7.第二种优化想实现，可以同时并发执行多个getter，但同步执行setter，且它们还要在同一线程，这对于synchronization block或NSLock来说，都是极难实现的，但是我们利用GCD的特性dispatch_barrier_sync()可以轻松实现，getter可以并行执行，如果出现barrier的setter，那么线程会等之前的所有getter都执行完，然后单独执行setter，执行完之后照常并行执行getter操作。</p>

<p>```objectivec
_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
&ndash;(NSString*)someString{</p>

<pre><code>__block NSString *localSomeString;
dispatch_sync(_syncQueue,^{
    localSomeString = _someString;
});
return localSomeString;
</code></pre>

<p>}
&ndash;(void)setSomeString:(NSString*)someString{</p>

<pre><code>dispatch_barrier_async(_syncQueue,^{
    _someString = someString;
});
</code></pre>

<p>}
```</p>

<!--more-->


<h2>Item42 Prefer GCD to performSelector and Friends</h2>

<ol>
<li>&ndash;(id)performSelector:(SEL)selector，曾作为延时执行方法和在特定线程执行方法这些场景中的主要手段，利用runtime，可以改变selector的名称，在运行时再决定执行那个方法，但使用这一方法是有风险的。</li>
<li>如果你使用if/else来决定赋值不同的selector，然后再执行，这样的话，ARC模式下会报内存泄露的警告，原因是编译器不知道那个方法会执行，所以也没办法确定有没有返回值，返回值是autoreleased还是caller自己释放，所以ARC会保守的添加autoreleased，如果这时返回值是caller自己释放的，那么就出现了内存泄露，这一警告MRC不会报出，但也更难发现，且静态分析器也检查不出，所以这是需要注意的一点。</li>
<li>&ndash;(id)performSelector:(SEL)selector以及它的族函数，它们的返回类型都是id类型，也就是说必须是一个指针，如果返回值是void、C结构体、或数值型，那么就有可能出问题，然后最多只能添加两个参数，而且也必须是id类型，超过两个参数或类型不对的也不能用，所以说局限性是非常大的。</li>
<li>&ndash;(id)performSelector:(SEL)selector的延时执行和在特定线程执行的族函数也是一样，缺陷很明显，只支持一个参数，所以使用者必选把所有参数打包，才能使用。</li>
<li>而结合使用Blocks和GCD，你可以实现上述所有的功能，且不会有约束，代码还简洁。</li>
</ol>


<p>```objectivec
//Using dispatch_after
dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW,(INT64_t)(5.0*NSEC_PER_SEC));
dispatch_after(time,dispatch_get_main_queue(),^(void){</p>

<pre><code>[self doSomething];
</code></pre>

<p>});
//Using dispatch_async(or if waitUntileDone is YES,then dispatch_sync)
dispatch_async(dispatch_get_main_queue(),^{</p>

<pre><code>[self doSomething];
</code></pre>

<p>});
```</p>

<!--more-->


<h2>Item43 Know When to Use GCD and When to Use Operation Queues</h2>

<ol>
<li>上面介绍了很多GCD的优点，GCD在的同步机制（Item41）和单例机制（Item45）是非常优秀的，但并不是说GCD就是所有OC线程问题的最优解，在它之前的NSOperationQueue有时更为合适。</li>
<li>GCD是C类型的Api，而operation queues则是OC对象；GCD中的任务是一个block，比较轻量，而operation queues中的任务是NSOperation的子类，比较重量；但这不意味着GCD一直是最优解，有时作为对象的优势也是非常明显的。</li>
<li>使用NSBlockOperation或NSOperationQueue的addOperationWithBlock:方法，可以使operation queues非常像GCD，下面是它的一些优势。</li>
</ol>


<h3>Cancelling operations</h3>

<ol>
<li>NSOperation很容易就可以实现cancel，执行它的cancel方法即可，但已经执行的operation就不能cancel了，但是对于GCD也一样，不能cancel一个已经在执行的block，这类机制就是“fire and forget”，但在GCD上实现cancel，需要自己去实现，而这需要很多工作。</li>
</ol>


<h3>Operation dependencies</h3>

<ol>
<li>operation可以实现依赖，这样开发者可以自己组织执行的优先顺序，例如下载一些文件之前需要先下载验证文件，下验证文件的operation就是其他下载operation的依赖，如果其他下载是并发的，那么它们会等下载完验证文件后再并发执行。</li>
</ol>


<h3>Key-Value Observing of operation properties</h3>

<ol>
<li>Operation的很多property是很适合KVO的，比如：<em>isCancelled，isFinished</em>去监测operation是否取消或完成，如果你的代码需要对operation做到如此细粒度的控制的话，那么更应该使用operation。</li>
</ol>


<h3>Operation priorities</h3>

<ol>
<li>operation可以设置优先级（即queuePriority，从verylow到veryhigh五个枚举值），高优先级的operation会先执行，GCD无法设置每个block的执行优先级，而只能设置整个queue的优先级，所以这也是operation的一大特性。另外，operation还有一个相关的线程优先级（即threadPriority，从0.0到1.0），可以指定operation执行时线程分配的优先级，我理解它和前者一个是时间上的优先级，一个是空间上的优先级，这两者均可通过operation的property直接设置。</li>
</ol>


<h3>Reuse of operation</h3>

<ol>
<li>除非你使用内建的NSOperation的子类，比如NSBlockOperation，你一般都需要自己继承NSOperation，所以这就意味着你可以添加实例和方法，和进行复用。</li>
<li>综上operation有这很多的优点，主要集中于你可以对单个operation进行更加细粒度的操作，而不用自己去组织相关代码，这是对比GCD的block的优势之处。</li>
<li>Apple的NSNotificationCenter有一个方法，如下，其中的NSOperationQueue可以换成dispatch queue的，但是开发者不想对GCD产生无谓的依赖，在这个实例中，两者是没什么区别的。总之，GCD和Operation queue都是视情况使用，而不是一味遵从使用高级接口或底层接口，各有好处。</li>
</ol>


<p><code>objectivec
-(id)addObserverForName:(NSString*)name object:(id)object queue:(NSOperationQueue*)queue usingBlock:(void(^)(NSNotification*))block;
</code></p>

<!--more-->


<h2>Item44 Use Dispatch Groups to Take Advantage of Platform Scaling</h2>

<p>1.Dispatch Groups是GCD的一个特性，为了方便开发者对任务进行分组，你可以等待一组任务完成或者通过回调来被通知一组任务完成了。当你想让一组方法并行执行，但同时希望在它们完成时得到通知，那么你该使用这一特性。例如批量压缩文件。<br/>
2.一个group是一个简单的结构体，也没有标识，下面是group的类型和将task和group关联的方法，其实只是在正常的dipatch执行方法上关联了group而已：</p>

<p><code>objectivec
dispatch_group_t dispatch_group_creat();
void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);
</code></p>

<p>3.另一个方法是使用下面这对方法，enter和leave要配合使用，类似retain和release，必须保持平衡，如果缺少一个leave，那么这个group就永远不会结束了。</p>

<p>```objectivec
void dispatch_group_enter(dispatch_group_t group);
void dispatch_group_leave(dispatch_group_t group);
//Example
dispatch_group_t group = dispatch_group_create();
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
//A
dispatch_group_async(group,queue,^{</p>

<pre><code>//...
</code></pre>

<p>});
//B
dispatch_group_enter(group);
dispatch_async(queue,^{</p>

<pre><code>//...
dispatch_group_leave(group);
</code></pre>

<p>});
```</p>

<p>4.下面的方法可以阻塞目前线程，等待group中的task全部完成，timeout可以设置为一个固定值，也可以设置为DISPATCH_TIME_FOREVER，如果group在timeout内完成，返回值为0，反之则会返回非0值。</p>

<p><code>objectivec
long dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);
</code></p>

<p>5.这个方法则是wait方法的替代，该方法不会阻塞当前线程，而是允许你为group完成添加一个通知回调block，而且可以指定线程，一般在主线程中，肯定是不希望阻塞的。</p>

<p><code>objectivec
void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);
</code></p>

<p>6.下面是一个对一个数组中的对象并发执行相同操作，并在全部完成后进行后续操作的实例，如果不希望阻塞主线程，那么要把wait换为notify，<a href="http://stackoverflow.com/questions/10643797/wait-until-multiple-networking-requests-have-all-executed-including-their-comp/10644282#comment13830651_10644282">StackOverflow另一实例</a>。</p>

<p>```objectivec
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
dispatch_group_t group = dispatch_group_create();
//Plan A, block main queue
for(id object in collection){</p>

<pre><code>dispatch_group_async(group,queue,^{
    [object performTask];
});
</code></pre>

<p>}
dispatch_group_wait(group,DISPATCH_TIME_FOREVER);
//Continue processing after copleting tasks
dispatch_release(group);
//Plan B, not block main queue
for(id object in collection){</p>

<pre><code>dispatch_group_enter(group);
dispatch_async(queue,^{
    [object performTask];
    dispatch_group_leave(group);
});
</code></pre>

<p>}
dispatch_queue_t notifyQueue = dispatch_get_main_queue();
dispatch_group_notify(group,notifyQueue,^{</p>

<pre><code>//Continue processing after completing tasks
</code></pre>

<p>});
```</p>

<p>7.可以通过创建不同优先级的dispatch_queue，来实现task进行优先级分类，但是依然并发执行，并在全部完成后统一处理。<br/>
8.如果你在一个串行的queue中加入多个任务，那么group其实是不起作用的，因为本来这些任务就会串行执行，你只需要继续添加一个block，就可以实现所有任务完成后统一处理。</p>

<p>```objectivec
dispatch_queue_t queue = dispatch_queue_create(&ldquo;com.EOC.queue&rdquo;,NULL);
for(id object in collection){</p>

<pre><code>dispatch_async(queue,^{
    [object performTask];
});
</code></pre>

<p>}
dispatch_async(queue,^{</p>

<pre><code>//Continue processing after completing tasks
</code></pre>

<p>});
```</p>

<p>9.如果你不是自己创建queue，而是使用系统方法返回的queue，那么加入的task，系统会根据系统资源开辟一定数量的线程，来执行这些task，再配合group特性，你只需要关注你的业务逻辑即可，而不用去在如何安排和控制它们的线程开辟和同步上面花费精力。<br/>
10.类似上面多次执行相同的任务，还有一个专门的方法来实现它，如下，传入的iterations类似for循环的最大值，i会从0循环到最大值减一。但dispatch_apply的缺点是会阻塞当前线程，如果你希望在后台线程运行，那么还要使用group的notify方法。</p>

<p>```objectivec
void dispatch_apply(size_t iterations, dispatch_queue_t queue,void(^block)(size_t));
//A serial
dispatch_queue_t queue = dispatch_queue_create(&ldquo;com.EOC.queue&rdquo;);
dispatch_apple(10,queue,^{</p>

<pre><code>//perform task
</code></pre>

<p>});
//B concurrent
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
dispatch_apply(array.count,queue,^(size_t i){</p>

<pre><code>id object = array[i];
[object peformTask];
</code></pre>

<p>});
```</p>

<!--more-->


<h2>Item45 Use dispatch_once for Thread-Safe Single-Time Code Execution</h2>

<p>1.GCD之前的单例模式实现，使用了synchronization block是为了线程安全：</p>

<p>```objectivec
+(id)sharedInstance{</p>

<pre><code>static EOCClass *sharedInstance = nil;
@synchronized(self){
    if(!sharedInstance){
        sharedInstance = [[self alloc] init];
    }
}
return sharedInstance;
</code></pre>

<p>}
```</p>

<p>2.这是GCD之后的版本，使用了dispatch_once，新类型dispatch_once_t保证了，对于每一个该类型的token，dispatch_once只会执行它对应的block一次，而且是线程安全的，为了保证token的唯一性，token也必须声明为static或global类型。</p>

<p>```objectivec
void dispatch_once(dispatch_once_t *token,dispatch_block_t block);
//singleton
+(id)sharedInstance{</p>

<pre><code>static EOCClass *sharedInstance = nil;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken,^{
    sharedInstance = [[self alloc] init];
});
return sharedInstance;
</code></pre>

<p>}
```</p>

<p>3.相比较synchronization block的版本，dispatch_once版本效率更高，因为前者在每次运行这段代码时都会进行加锁操作，它对dispatch token进行了原子型的访问来确定代码是否执行过，作者测试使用dispatch_once较synchronization block快将近两倍。</p>

<!--more-->


<h2>Item46 Avoid dispatch_get_current_queue</h2>

<ol>
<li>使用GCD时，获得当前运行的queue是一个常见的需求，而Apple也提供了一个方法：<em>dispatch_queue_t dispatch_get_current_queue()</em>，但是作者告诉我们，这个方法像retainCount一样，并不可靠，iOS6已经将其弃用，目前只可以在debug模式下使用。</li>
<li>回想Item41的getter/setter最终方案，可能会出现这样的场景，就是调用getter的queue和getter中的synchronization queue是同一队列，这样就会产生死锁，dispatch_sync会一直等待queue可用，而这个queue实际上就是当前的queue，所以block永远不会执行。所以就会想到用dispatch_get_current_queue()来判断当前的queue是否是synchronization queue，如果是就直接执行block，不是的话用dispatch_sync()。</li>
<li>如果在简单场景下应该是没问题，如果考虑到一些特殊情况，比如queueA->queueB->queueA嵌套执行，且所有的操作都是同步操作，那么内部的queueA关联的block还是会出现死锁，因为外层的queueA block还未执行完。</li>
<li>所以这个例子中，使用dispatch_get_current_queue()并不是一个可靠地解决方法，而还是应该单独建立一个queue专门供synchronization使用，并确保该queue中会调用getter方法。</li>
<li>从更为普遍的角度讲，因为dispatch queues是存在等级划分的，也就是说在当前queueA中的block加入了在queueB中执行的block，那么queueB上执行的block同样执行与queueA上，而顶层的queue则是global concurrent queues的其中一个。</li>
<li>只有两个queue不存在这种包含关系，才可以并行执行，反之，如果两个queue存在包含的关系，那么在他们中执行同步操作，怎要特别关注死锁问题。这也就是dispatch_get_current_queue()这个方法意义不大的根本原因，因为它只能返回当前的queue，而无法得知整个queue的包含链。</li>
<li>最容易产生这个问题的场景是Api需要你传入想运行的queue，而Api内部在另一个queue上使用了串行同步操作，然后将它的结果在传入的queue中返回，使用者一般会假设dispatch_get_current_queue()会返回自己传入的queue，但结果会返回内部的同步queue。</li>
<li>Queue-specific data是解决上述问题的一个方案，它可以将任意数据和queue绑定，最重要的是，如果没发现与对应key绑定的值，系统会一直沿包含链向上，知道找到对应的queue被找到，或者到root queue。</li>
<li><em>dispatch_queue_set_specific()</em>方法是这一技术的核心，给queue关联的是一个类似键值对的结构，键值均为空指针类型，对于key来说，需要注意的是，作为key的是指针的值而不是指向内容的值，所以其实更像Item10中介绍的associated references。value也是空指针类型，所以理论上你可以将任何值作为value，但是你希望自己管理它的内存，如果在ARC下，使用OC对象就很难做到这一点，所以作者推荐使用了CFString，因为ARC不会管理CoreFoundation的对象，而且也可以很方便转化为OC对象，所以很合适。最后的参数希望传入一个函数指针，它将用作析构函数，将在value从key移除时调用，这可能是queue被释放或者value被赋新值时。dispatch_function_t的类型是只有一个指针且返回空值，示例中CFRelease作为了参数，对应传入的CFString，如果传入的是自己定义的对象，开发者也可以自己重写CFRelease函数，做一些清除工作。</li>
</ol>


<p>```objectivec
void dispatch_queue_set_specific(dispatch_queue_t queue,const void <em>key,void </em>context,dispatch_function_t destructor);
typedef void(<em>dispatch_function_t)(void</em>)
//Example
dispatch_queue_t queueA = dispatch_queue_create(&ldquo;com.EOC.queueA&rdquo;,NULL);
dispatch_queue_t queueB = dispatch_queue_create(&ldquo;com.EOC.queueB&rdquo;,NULL);
dispatch_set_target_queue(queueB,queueA);
static int kQueueSpecific;
CFStringRef queueSpecificValue = CFSTR(&ldquo;queueA&rdquo;);
dispatch_queue_set_specific(queueA,&amp;kQueueSpecific,(void*)queueSpecificValue,(dispatch_function_t)CFRelease);
dispatch_sync(queueB,^{</p>

<pre><code>dispatch_block_t block = ^{NSLog(@"No deadlock!");};
CFStringRef retrievedValue = dispatch_get_specific(&amp;kQueueSpecific);
if(retrievedValue){
    block();
} else {
    dispatch_sync(queueA,block);
}
</code></pre>

<p>});
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记5]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/08/28/effective-objective-cdu-shu-bi-ji-5/"/>
    <updated>2015-08-28T11:45:07+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/08/28/effective-objective-cdu-shu-bi-ji-5</id>
    <content type="html"><![CDATA[<p>第五部分开始将讨论OC的核心技术，Reference Counting，也就是使用引用计数来进行内存管理，这一部分涉及到底层内存管理机制，ARC相关技术细节和在开发中涉及到内存管理需要注意的常见问题。</p>

<!--more-->


<h2>Item29 Understand Reference Counting</h2>

<ol>
<li>Reference Counting是OC管理内存的方式，当一个对象的RC为0时，将被释放，iOS没有垃圾回收机制。</li>
</ol>


<h3>How Reference Counting Works</h3>

<ol>
<li>在NSObject Protocol中有三个方法可以改变RC，<em>retain,release,autorelease</em>。</li>
<li>retainCount这个方法可以查看对象当前的RC值，但是并不推荐使用，Item36会讨论。</li>
<li>对象之间往往是互相持有的，当该持有关系是<em>strong</em>时，被持有对象的RC加1，而持有链的最顶端是根对象，Mac OSX是NSApplication，iOS是UIApplication，都是应用创建的单例。</li>
<li>举例一个NSMutableArray添加一个NSNumber，虽然在array添加number后，释放number，number的RC还是1，调用number理论上是可以的，但是并不推荐这么做，因为如果任何其他原因使number的RC为0，这一做法会导致崩溃。</li>
<li>对象被释放后，它的内存将进入可用内存池，如果调用发生在内存被复写之前，不会发生错误，所以之类bug有时会很难复现，所以在MRC中往往在调用release后会赋值nil。</li>
</ol>


<h3>Memory Management in Property Accessors</h3>

<ol>
<li>strong命名的property的setter方法，是新值retain，然后旧值release，然后赋值，这一顺序不能错，因为如果先release再retain，且正好两个对象是同一个，可能会导致对象提前释放，RC为0，成为野指针，再调用retain则会出错。想按照这个顺序来，必须判断新旧两值是否是同一对象。</li>
</ol>


<h3>Autorelease Pools</h3>

<ol>
<li>借助autorelease pool替代release操作的autorelease，常用于需要返回新建对象的方法，具体释放时间在下一次事件循环（Item34将讨论）。</li>
<li>在直接调用该方法时不用额外的内存空间，直接调用即可。</li>
<li>但是如果返回对象需要持有时，比如赋值给一个实例变量，它需要retain一次，然后使用完后手动release，所以可以将autorelease理解为延长对象的生命周期，可以至少保证到方法调用的边界。</li>
</ol>


<h3>Retain Cycles</h3>

<ol>
<li>循环引用一般是指两个或多个对象直接互相存在强引用，而导致RC都不能为0，所有对象都不能释放。</li>
<li>在垃圾回收机制下，retain cycle会被定义为孤岛，而直接被全部释放，而在RC机制下，只能通过定义weak引用或者依靠外部帮助来使其中某个对象交出对其他对象的引用。</li>
</ol>


<!--more-->


<h2>Item30 Use ARC to Make Reference Counting Easier</h2>

<ol>
<li>Clang编译器带来了一个静态分析器，可以定位出现RC问题的位置，例如没有添加release，除此之外，该分析器可以为你自动添加retain，release这些操作，这也就是ARC技术的基础。</li>
<li>在ARC机制下，retain、release、autorelease、dealloc这些操作都是不允许的，因为这回影响编译器判断添加语句的位置。</li>
<li>事实上，ARC并没有直接调用上述这些方法，而是调用了他们的C的替代方法，例如objc_retain，这么做的好处是，因为这些操作会频繁调用，使用C方法可以提高效率。这也是为什么不允许直接重写retain，release这些方法，因为这方法并不是直接调用的。</li>
</ol>


<h3>Method-Naming Rules Applied by ARC</h3>

<ol>
<li>内存管理指定方法名在OC里一直是惯例，而ARC将其加强了，含有以下名称的方法：<em>alloc、new、copy、mutableCopy</em>，所返回的对象的所有者为方法的调用者，而其他方法返回的对象为autorelease，会保持到方法调用边界。</li>
<li>而ARC会依据方法名的开头添加响应的语句，例如上述四个关键字开头的，会直接返回，而一般方法，ARC会在返回对象前加上autorelease。</li>
<li>而在调用这些方法时，第一类方法返回的对象，ARC会在方法结束前添加release方法，而第二类方法因为有autorelease，所以不会添加操作。</li>
<li>ARC通过命名规范来规范内存管理，再加上之前的命名空间，OC是少有的如此强调命名的语言之一。</li>
<li>ARC可以做一些无法手动完成的优化，比如，它将在编译期间取消多余的retain和release操作。</li>
<li>ARC在runtime也有进行优化，举例：EOCPerson的一般初始化方法返回的值（添加了autorelease），被赋值给一个对象的strong属性实例，按照之前的原则，需要在返回的对象加retain，这里的autorelease和retain看起来是多余的，ARC确实可以为了性能，直接去掉autorelease这个方法，所有返回的对象都为RC+1，但为了兼容MRC，ARC还是需要特殊处理。</li>
<li>ARC确实对这种现象做了处理，在返回对象之前它调用了<em>objc_autoreleaseReturnValue</em>，如果被发现该对象是需要retain的，则会添加一个flag，而不是调用autorelease。同样的，调用者也会调用<em>objc_retainAutoreleasedReturnValue</em>，而不是retain，该方法也会先检测flag，如果存在，则不会retain，这样提高了效率：</li>
</ol>


<p>```objectivec
//Within EOCPerson class
+(EOCPerson<em>)personWithName:(NSString</em>)name {</p>

<pre><code>EOCPerson *person = [[EOCPerson alloc] init];
person.name = name;
objc_autoreleaseReturnValue(person);
</code></pre>

<p>}
//Code using EOCPerson class
EOCPerson *tmp = [EOCPerson personWithName:@&ldquo;Matt&rdquo;];
_myPerson = objc_retainAutoreleasedReturnValue(tmp);</p>

<p>//objc_autoreleaseReturnValue
id objc_autoreleaseReturnValue(id object) {</p>

<pre><code>if(/*caller will retain object*/){
    set_flag(object);
    return object;//no autorelease
} else {
    return [object autorelease];
}
</code></pre>

<p>}</p>

<p>//objc_retainAutoreleasedReturnValue
id objc_retainAutoreleasedReturnValue(id object) {</p>

<pre><code>if(get_flag(object)){
    clear_flag(object);
    return object;//no retain
} else {
    return [object retain];
}
</code></pre>

<p>}
```</p>

<h3>Memory-Management Semantics of Variables</h3>

<ol>
<li>ARC也同时管理着本地变量和实例变量的内存，默认每个变量对于对象是strong引用。</li>
<li>在setter方法中，ARC中直接对旧值赋值即可，ARC会自动添加正确的代码。</li>
<li>声明实例变量时，也可以改变内存管理方式，<strong>strong（默认，赋值将被retain）、</strong>unsafe_retained（赋值同assign，但指针不会自动置空，可能出现野指针）、<strong>weak（赋值同assign，对象被释放时，指针会自动置为nil，所以是安全的，iOS5后可用）、</strong>autoreleasing（多用与方法的返回值）。</li>
<li>__weak用于本地变量时，常用于避免循环引用，比如在block中：</li>
</ol>


<p>```objectivec
NSURL <em>url = [NSURL URLWithString:@&ldquo;<a href="http://www.example.com/">http://www.example.com/</a>&rdquo;];
EOCNetworkRetcher </em>fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];
EOCNetworkFetcher * __weak weakFetcher = fetcher;
[fetcher startWithCompletion:^(BOOL success){</p>

<pre><code>NSLog(@"Finished fetching from %@", weakFetcher.url);
</code></pre>

<p>}];
```</p>

<h3>ARC Handling of Instance Variables</h3>

<ol>
<li>在ARC中，你一般不需要再重写dealloc方法，ARC借用Objective-C++的特性，Objective-C++对象在释放时会调用所有持有对象的析构方法，当编译器发现对象包含C++对象时，会生成<em>.cxx_destruct</em>方法，ARC借助这个方法，在其中执行清除内存的代码。</li>
<li>但有时你仍需要重写dealloc方法，像CoreFoundation对象和堆上开辟的内存（如malloc），以及KVO、的解除，都需要手动释放，但注意<em>在ARC中，不需要在dealloc中写[super dealloc]</em>，因为ARC在<em>.cxx_destruct</em>中已经调用了这一方法。</li>
</ol>


<h3>Overriding the Memory-Management Methods</h3>

<ol>
<li>在MRC中，重写内存相关方法是允许的，比如单例常常重写release方法为一个空操作，这样单例就不会被释放。</li>
<li>但在ARC中是不允许的，一是会导致ARC对对象周期的误判，二是ARC对内存管理做了深度的优化，当需要执行retain、release、autorelease时，ARC在OC的message dispatch做了优化处理，不能重写或调用这些方法则是该优化的前提。</li>
</ol>


<!--more-->


<h2>Item31 Release References and Clean Up Observation State Only in dealloc</h2>

<p>1.dealloc方法会在对象的引用计数为0时自动调用，但什么时候调用并不能保证，即使是在MRC中，手动控制release也一样，因为很多库会在你不知道的情况下修改对象，这会导致调用dealloc的时间发生变化。所以你千万不要手动去调用dealloc，runtime会在合适的时间调用。<br/>
2.那么在ARC下，重写dealloc的话，一是用于释放CoreFoundation的对象，二是取消NSNotificationCenter中注册该对象的监听或KVO。<br/>
3.如果你的类中使用到了文件描述集，sockets、或者开辟了大块儿内存，由于dealloc的调用时间不明，你可能在你不需要使用的时候即可释放这些内存，而不用等到dealloc触发，这样需要自定义一个清除方法，该方法必须在dealloc之前调用，不然就算异常了。<br/>
4.清除资源需要另一个方法的原因是创建的对象并不是都会被调用dealloc，因为一部分对象在应用退出后台时并不会释放，它们只有在应用彻底被系统回收后才会释放，这是一种优化措施，但也会导致大量的资源被无故占用，所以在-(void)applicationWillTerminate:(UIApplication*)application中调用一些对象的clean方法是必要的。<br/>
5.有时可以在dealloc中也可以去调用clean方法，这可以避免忘记调用clean，但最好还是手动去先执行clean，所以还是要提示下或者严重的话直接直接抛出异常：</p>

<p>```objectivec
&ndash;(void)close {</p>

<pre><code>/*clean up resources*/
_close = YES;
</code></pre>

<p>}</p>

<p>&ndash;(void)dealloc {</p>

<pre><code>if(!_closed) {
    NSLog(@"ERROR:close was not called before dealloc!");
    [self close];
}
</code></pre>

<p>}
```</p>

<p>6.除了上述特例，一般是不允许在dealloc中调用类的其他实例方法，因为有可能导致方法执行前，该对象可能已经释放了。而且，dealloc方法是在导致对象最终释放的线程上执行的，所以需要在特定线程执行的方法在此调用，不能保证线程正确，即使是通过代码强制在某线程执行，也是不安全的，因为对象处于释放状态。
7.另外dealloc中也不可调用property的setter、getter方法，尤其是被重写的accessor，也有可能触发KVO的回调，导致未知的错误。</p>

<!--more-->


<h2>Item32 Beware of Memory Management with Exception-Safe Code</h2>

<ol>
<li>Exception是OC和C++中用于处理严重异常的对象，但有时你也需要通过代码处理这些异常，例如去注销一个KVO，但之前并没有注册过的情况。</li>
<li>在try/catch中创建对象，并需要自己释放时，需要将释放代码写到finally中，这样才能保证无论是否异常都能保证对象释放。</li>
<li>但在ARC中可以自动添加额外的处理代码，使用<em>-fobjc-arc-exceptions</em>这个flag来控制，但默认是关闭的，因为exception出现时application直接crash，资源也会回收，所以没必要再做处理，而且会带来性能问题，只有编译器处于Objective-C++时才会开启，因为OC++添加代码带来性能损耗没有ARC添加时那么大，另外OC++中Exception是被大量使用的。</li>
<li>如果在ARC下需要单独处理exception，那么可以开启flag，但如果你有很多exception处理，那么你该考虑NSError了，如Item21所讲。</li>
</ol>


<!--more-->


<h2>Item33 Use Weak References to Avoid Retain Cycles</h2>

<ol>
<li>循环引用带来的问题主要是，引用环中的对象将不能再被调用，但也不能释放，从而导致内存泄露。</li>
<li>Java会有垃圾回收来解决这类问题，但iOS和Mac OS X 10.8之后是没有垃圾回收的，所以只能开发者自己去避免。</li>
<li>使用unsafe_unretained可以避免这一问题，它类似assign，但assign一般用于数值型，而unsafe_unretained用于对象，但如字面意思一样，它不会因为所指向的对象被释放而置为空值，所以调用unsafe_unretained的对象，可能会因为所指对象不存在而崩溃，所以是不安全的。</li>
<li>在ARC中我们常用的是weak字段，该字段与unsafe_unretained功能一致，但是它会在所指对象释放后自动指向nil，所以是安全的。</li>
<li>关于循环引用，总的原则就是，如果你不持有一个对象，那么你就不该retain它（数组，集合不直接持有包含的对象，但是会retain它们，是个例外）。一般场景有，controller的UI控件（一般weak属性），一个对象的delegate属性（一般为weak属性）。</li>
</ol>


<!--more-->


<h2>Item34 Use Autorelease Pool Blocks to Reduce High-Memory Waterline</h2>

<p>1.<em>@autoreleasepool{}</em>这是OC中建立autorelease pool的方法，但我们一般不必去手动创建。<br/>
2.main函数中的autorelease pool并不是必须的，只是UIApplicationMain()函数中需要autorelease的对象没有对应的pool，但它们在程序终止时时肯定会被释放的。<br/>
3.autorelease pool可以嵌套，autorelease的对象总是被添加最里面的pool中。<br/>
4.利用上述特性，我们可以对一些大量循环执行一个可能产生很多autorelease对象的方法做优化，如下EOCPerson的创建可能产生大量autorelease对象，这样产生的autorelease对象会在自己建的autorelease pool结束时释放，而不是长期存在于线程自己的autorelease pool，避免了出现应用内存陡升陡降这种“瀑布现象”：</p>

<p>```objectivec
NSArray <em>databaseRecords = /</em>&hellip;<em>/;
NSMutableArray </em>people = [NSMutableArray new];
for(NSDictionary *record in databaseRecords){</p>

<pre><code>@autoreleasepool{
    EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];
    [people addObject:person];
}
</code></pre>

<p>}
```</p>

<p>5.autorelease pool可以被理解为放入了一个栈中，新建的pool会在最顶端，当它释放后会被移出栈，当一个对象调用了autorelease，它将被添加到最顶端的autorelease pool。<br/>
6.使用autorelease pool来优化瀑布现象并不是必要的，这取决你的应用，如果确实导致了问题，那么去使用它，如果不必要使用，那么就不要添加多于的autorelease pool。<br/>
7.ARC之前使用autorelease pool是使用NSAutoreleasePool，因为它属于重量级对象，所以一般是隔段时间进行释放：</p>

<p>```objectivec
NSArray <em>databaseRecords = /</em>&hellip;<em>/;
NSMutableArray </em>people = [NSMutableArray new];
int i=0;
NSAutoreleasePool <em>pool = [[NSAutoreleasePool alloc] init];
for(NSDictionary </em>record in databaseRecords){</p>

<pre><code>EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];
[people addObject:person];
//Drain the pool only every 10 cycles
if(++i == 10){
    [pool drain];
}
</code></pre>

<p>}
//Also drain at the end in case the loop is not multiple of 10
[pool drain];
```</p>

<p>8.推荐使用新语法@autoreleasepool，更加轻量，而且一个重要特性，NSAutoreleasePool中创建的autoreleased对象在执行drain之后还能使用，这可能造成崩溃，且很多时候难以发现，而使用@autoreleasepool，这类代码不会被编过，也就及早避免了这一问题。</p>

<!--more-->


<h2>Item35 Use Zombies to Help Debug Memory-Management Problems</h2>

<p>1.内存问题一般很难处理，原因是被释放的那块内存不一定就很快被重写，或者正好被一个同类的对象重写，这样有时不会导致崩溃，有时却会，所以开发者有时会无从下手。<br/>
2.Cocoa的Zombies特性会帮助我们解决这一问题，当该模式启用，所有被释放的对象会转化为NSZombie对象，其占用过的内存也不会被重用，当该对象收到消息时，会抛出异常，告知开发者所收到的消息，原来的对象类型这些信息。</p>

<p>```objectivec
void PrintClassInfo(id obj){</p>

<pre><code>Class cls = object_getClass(obj);
Class superCls = class_getSuperclass(cls);
NSLog(@"===%s:%s===",class_getName(cls),class_getName(superCls));
</code></pre>

<p>}
int main(int argc, char *argv[]){</p>

<pre><code>EOCClass *obj = [[EOCClass alloc] init];
NSLog(@"Before release:");
printClassInfo(obj);
[obj release];
NSLog(@"After release");
PrintClassInfo(obj);
</code></pre>

<p>}
//result
//Before release:
//===EOCClass:NSObject===
//After release:
//===_NSZombie_EOCClass:nil===
```</p>

<p>3.通过上述手段我们得知obj在dealloc后变为了<em>NSZombie_EOCClass，但并没有它的父类，实际上，它是通过对原类型的类名修改，然后对</em>NSZombie<em>类型执行objc_duplicateClass()，完全拷贝zombie类并使用新类名（也可使用继承，但不如copy效率），制造出obj对应的zombie类，然后用objc_setClass()修改obj的isa指针，改变其类型，这一切都是利用runtime完成的（通过method swizzles对dealloc方法替换）。<br/>
4.由于</em>NSZombie<em>没有实现任何方法，所以向它或者它的copy类型发送任何消息，会直接进入forwarding mechanism，在寻求转发时如果发现类型名以</em>NSZombie_开头，那么直接抛出异常，并打印出message、原类型这些信息。</p>

<!--more-->


<h2>Item36 Avoid Using retainCount</h2>

<ol>
<li><em>retainCount</em>是NSObject Protocol的一个方法，用于返回对象目前的引用计数值，在ARC中已经弃用，但即使在MRC中，任然应该避免使用它。</li>
<li>原因一是<em>retainCount</em>返回的是实时的count值，也就是说像autorelease这样将要发生的count减少的情况，不会在该方法反映出来，所以依据该值去执行一些改变count的方法，往往会出问题。</li>
<li>有时retainCount会返回一个极大的值，这是NSString或NSNumber直接设置常量时，系统会将其作为一个单例的常量，而不是去创建一个对应的对象，这些对象的ratainCount是不会改变的，但只是对一些特例的优化。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记4]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/08/24/effective-objective-cdu-shu-bi-ji-4/"/>
    <updated>2015-08-24T11:35:10+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/08/24/effective-objective-cdu-shu-bi-ji-4</id>
    <content type="html"><![CDATA[<p>第四部分开始讨论OC的两大重要特性，Protocols和Categories。Protocols类似Java中的interfaces，弥补了OC没有多继承的缺点，常被用于实现OC委托模式，但还有很多其他方面的用途。Categories则是提供了不继承而向类添加拓展的方法，这要归功于OC动态语言特性，但同时了解它使用时的常见问题也非常重要。</p>

<!--more-->


<h2>Item23 Use Delegate and Data Source Protocols for Interobject Communication</h2>

<ol>
<li>Delegate是用于对象之间进行数据交互的设计模式，使用它的好处是可以让不同的业务逻辑解耦，实现代码模块化。而在OC中实现这一模式，主要依靠Protocols。</li>
<li>怎么使用Delegate不介绍了，注意点是：1）命名最好和你需要委托的类相关，例如UITableView,UITableViewDelegate；2）类的delegate property是weak属性，原因是接受委托的对象一般会持有需要委托的对象，如果delegate设置为strong，需要委托的对象也会持有接受委托的对象，这样就会出现retain cycle。</li>
<li>Delegate一般都定义为option，除非一些方法是一定要被委托者实现的，同时对于option的方法，委托者需要在调用之前使用<em>respondsToSelector:</em>来内省，确保被委托者实现了该方法。</li>
<li>Delegate中定义的方法一定要清楚，而且一定要包括被委托者自身作为其中一个参数，这样如果存在同类型多个实例对象时，委托者可以在同一个方法中区分这些实例变量。</li>
<li>Protocols还可以用于DataSource模式，与Delegate模式区别是，对于一个Class来说，Delegate的信息是流出Class的，而DataSource的信息是流入Class的，设计Protocols也可以参照这一原则。</li>
<li>对于option的方法要进行<em>respondsToSelector:</em>来检测，但是对于一些需要频繁调用的方法，采用这一方式非常影响性能，作者利用了C中的由多个1bit字段组成的结构体来标识被委托对象是否响应所有方法，这基于被委托对象一般不会动态改变对方法的响应：</li>
</ol>


<p>```objectivec
@interface EOCNetworkFetcher(){</p>

<pre><code>struc {
    unsigned int didReceiveData:1;
    unsigned int didFailWithError:1;
    unsigned int didUpdateProgressTo:1;
} _delegateFlags;
</code></pre>

<p>}
@end</p>

<p>@implementation EOCNetworkFetcher</p>

<p>&ndash;(void)setDelegate:(id<EOCNetworkFetcherDelegate>delegate) {</p>

<pre><code>_delegate = delegate;
_delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher: didReceiveData:)];
_delegateFlags.didFailWithError = [delegate respondsToSelector:@selector(networkFetcher: didFailWithError:)];
_delegateFlags.didUpdateProgressTo = [delegate respondsToSelector:@selector(networkFetcher: didUpdateProgressTo:)];
</code></pre>

<p>}</p>

<p>//调用委托时
/*
if(_delegateFlags.didUpdateProgressTo) {</p>

<pre><code>[_delegate networkFetcher:self didUpdateProgressTo:currentProgress];
</code></pre>

<p>}
*/</p>

<p>@end
```</p>

<!--more-->


<h2>Item24 Use Categories to Break Class Implementations into Manageable Segments</h2>

<ol>
<li>分类这一特性主要为了解决一个类在开发中无限膨胀的问题，将一个类的方法按照功能进行分类处理是常规做法。</li>
<li>第二种用途是为了对代码进行分割增加可读性，例如NSURLRequest想增加专门的HTTP请求，单纯继承不是一个很好的选择，原因是NSURLRequest封装了一组针对CFURLRequest的C方法，无法通过继承获得，而直接添加这些HTTP的方法则会导致一些代码理解错误，例如开发者使用FTP协议，去发现可以调用关于HTTP的方法，所以将HTTP部分的方法做成NSHTTPURLRequest的分类是最好的选择。</li>
<li>第三个用途是方便调试，原因是分类中的方法在日志里会显示为类似：<em>&ndash;[EOCPerson(Friendship) addFriend:]</em>，可以方便定位该方法。</li>
<li>另外，在做一个库时，把一些私有方法用名为Private的分类封装，这样这些方法不用暴露在外，而内部又可以随意调用，而且外部万一用到了，也可以在日志中看到private的标志，起到了文档的作用。</li>
</ol>


<!--more-->


<h2>Item25 Always Prefix Category Names on Third-Party Classes</h2>

<ol>
<li>为一个类添加分类后，运行时runtime会遍历category每个方法，顺便加入类的方法列表，如果这时category重写了类的某个方法，这将覆盖原有的方法，如果多个category都出现这个情况，那么最后被载入的那个分类的方法会被采用，这两种情况都将导致Bug，且难以定位。</li>
<li>解决这一问题的方法只能是添加namespace，规则参考Item15，最好就是公司+项目这样的方式，而且最好将分类的名字也加namespace，这样可以避免warning。</li>
<li>要记住添加到一个类的category中的方法，只要被添加，在所有类的示例都可以调用（这里还是需要导入这个category才可以），尤其在为Cocoa中的类添加分类时时刻注意添加命名空间，去刻意重写类中的方法是一个非常坏的习惯，它带来的问题可能比好处大得多。</li>
</ol>


<!--more-->


<h2>Item26 Avoid Properties in Categories</h2>

<ol>
<li>category默认是不支持添加property的（匿名分类除外），虽然这一做法可以在技术上实现，但是依然不推荐这么做。</li>
<li>category不支持property，主要是无法自动合成setter和getter方法，解决这一问题有两个方法：1）使用Item12的做法，用@dynamic声明，重写message-forwarding的方法，在runtime添加setter和getter方法；2）使用Item10，使用associated objects，自己在getter和setter进行关联。</li>
<li>上述两个方法均可行，但作者认为这两个方法都不完美，缺点有二：1）内存管理，你很容易忘记这个property的特殊性，而只去修改property的关键字，而忘记去修改setter方法；2）如果你想让自己的property对象在内部支持mutable，可以在内部声明一个，mutable拷贝，但是这又会出现一个进入源代码的混乱路径，所以在category中定义property的代价是很高的。</li>
<li>作者建议的方法是把所有的变量都放入原类中，而category只提供额外的方法。</li>
<li>但有时category中可以添加只读变量，而且也不涉及读写原类的变量，但是虽然不报错，还是推荐使用一个方法来完成，因为真的没必要这么做。</li>
</ol>


<!--more-->


<h2>Item27 Use the Class-Continuation Category to Hide Implementation Detail</h2>

<p>1.OC是没有真正的私有方法的，但我们还是不希望把不需要暴露的方法和变量暴露在外，所以匿名分类就是一种隐藏这些细节的手段。<br/>
2.你可以将实例变量声明在匿名变量或implementation中，可以完全不用暴露你要导入的头文件等一切信息，例如：</p>

<p>```objectivec
@interface EOCPerson(){</p>

<pre><code>NSString *_anInstanceVariable;
</code></pre>

<p>}
//Method declarations here
@end</p>

<p>@implemenation EOCPerson {</p>

<pre><code>int _anotherInstanceVariable;
</code></pre>

<p>}
//Method implemenations here</p>

<p>@end
```</p>

<p>3.一般OC代码中使用C++一般两种情况：一些游戏相关的后端代码需要用C++，使用的第三方库使用了C++，而你作为使用者除非特殊情况，一定要使用匿名分类来使用C++，这样其他类使用你的类时，不用再因为C++的原因，将.m文件命名为.mm，而使编译器将其编为Objective-C++。Cocoa的web browser framework和CoreAnimation使用了这一模式。<br/>
4.还有一种应用就是在外部声明readonly的property，然后在匿名分类中再将其声明为readwrite，这样可以实现外部只能通过方法设置值，而内部可以正常使用该变量，可能会出现外部在访问，内部同时在赋值同步的问题，将在Item41讨论。<br/>
5.接下来就是可以在匿名分类声明私有方法，虽然这不是必须的，而作者比较推荐先列好方法，理清思路，再开始实现，如果是比较大的项目，还是需要这么干的。<br/>
6.最后就是可以在匿名分类添加委托。</p>

<!--more-->


<h2>Item28 Use a Protocol to Provide Anonymous Objects</h2>

<ol>
<li>利用Protocol可以实现创建一些匿名对象，例如：id<EOCDelegate> delegate。</li>
<li>例子1：来自多个第三方类库的数据库管理对象对应不同数据库类型，现在需要提供一个统一的Manager，来返回这些不同的对象，依靠基类继承是不可能的，只能通过定义一组数据库通用的操作作为Protocol，然后分别继承这些类，而新类则遵从这一protocol，这样Manager只需返回id<Protocol>类型的对象即可，而使用者也只需要知道它们实现了这些方法也足够了。</li>
<li>例子2：已确定只有一个类型，但其是一个内部使用的数据类型，不需要将其所有细节暴露，只需要暴露其中一部分方法即可，那么将这些方法声明为Protocol，然后返回类型定义为id<Protocol>即可，其实就是实现了对对象的大部分封装。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记3]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/08/17/effective-objective-cdu-shu-bi-ji-3/"/>
    <updated>2015-08-17T14:15:03+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/08/17/effective-objective-cdu-shu-bi-ji-3</id>
    <content type="html"><![CDATA[<p>第二部分主要讲了一些OC底层的运作机制，这一部分开始，主要涉及实践部分，第三部分的主题是：Interface and API Design。</p>

<!--more-->


<h2>Item15 Use Prefix Names to Avoid Namespace Clashes</h2>

<ol>
<li>OC是没有内建的命名空间的，所以必须采取措施避免这一问题。</li>
<li>解决方案是自己在所有类都添加自定义的前缀，一般是项目名缩写，但推荐使用三个字母，因为两个字母被苹果使用，所以重名的概率大。</li>
<li>在.m文件中的纯C函数和全局变量也有可能出现重名，所以定义时需格外注意，也要加上前缀。</li>
<li>还有一种可能，你自己封装的类库A和应用使用了同一类库B，而应用也使用了你的类库A，这样的话，只能手动将你自己使用的类库B的所有加上类库A的前缀，虽然麻烦，但是如果是大工程的话，必须这么做。</li>
</ol>


<!--more-->


<h2>Item16 Have a Designated Initializer</h2>

<ol>
<li>一个类可能有很多初始化方法，但其中基本初始化方法只需有一个，其他初始化方法只是参数变化，这样保证数据在一个方法中赋值，便于维护。</li>
<li>为了避免用户使用原始的<em>init:</em>方法而出现错误，该类中应该重写<em>init:</em>方法，可以做一个默认的赋值，或者直接抛出异常。</li>
<li>继承一个拥有基本初始化方法的类，子类的初始化方法要调用父类的基本初始化方法，而且需要重写父类的基本初始化方法，与上一条的理由一致。</li>
<li>有时可能需要两个基本初始化方法，特例比如遵循NSCoding的类，要有一个-(id)initWithCoder:(NSCoder*)decoder的初始化方法，而该类的子类也必须重写initWithCoder:，同时调用父类initWithCoder:。</li>
</ol>


<h2>Item17 Implement the description Method</h2>

<p>1.重写对象的-(NSString*)description方法，可以获得更多的实用信息，默认的只是类名和指针地址，这也是NSObject协议的其中一项。<br/>
2.这是一种将NSDictionary特性结合起来的description写法。</p>

<p>```objectivec
&ndash;(NSString *)description {</p>

<pre><code>return [NSString stringWithFormat:@"&lt;%@:%p,%@&gt;",
[self class],
self,
@{@"title": _title,
@"latitude": @(_latitude),
@"longitude": @(_longitude)}
];
</code></pre>

<p>}
```</p>

<p>3.LLDB中的<em>po</em>命令会执行print-object函数，它返回的是NSObject协议的另一方法-(NSString *)debugDescription，而这一方法默认返回的是description的结果，如果需要隐藏部分信息，可以分别重写这两个方法，OC默认类型很多就是这么干的，例如NSArray。</p>

<!--more-->


<h2>Item18 Prefer Immutable Objects</h2>

<ol>
<li>设计类的时候，其中的property除非必须可变，都应设计为不可变只读类型，之前Item8也讨论过类似问题，一个可变集合加入两个可变数组，然后设法改变数组，可能会出现集合中有相同数组，而不会报错的问题。</li>
<li>解决这个问题的设计是在.h文件中设置property为readonly，而在.m文件中添加匿名分类，重新定义相同的property为readwrite，这样实现了对外只读，而内部可以进行修改。</li>
<li>如果需要对外提供修改变量的方法，也不建议直接把可变变量暴露，而是对外还是暴露只读变量，内部再定义一个可变的内部变量，外部的只读变量的getter方法返回内部可变变量的copy，而同时添加增删的外部方法来操作内部变量。</li>
</ol>


<!--more-->


<h2>Item19 Use Clear and Consistent Naming</h2>

<ol>
<li>OC命名方式是尽量详细，多使用一些介词，表明方法功能，同时使用驼峰命名法。</li>
</ol>


<h3>Method Naming</h3>

<ol>
<li>如果一个方法返回了一个新对象，那么方法一般以该对象的类型开头。</li>
<li>一个参数前需要加一个名词来描述他的类型。</li>
<li>一个方法描述对一个对象进行操作时，需要包含一个动词，然后每个参数前依旧需要名词描述。</li>
<li>避免使用缩写，而使用全称，例如：<em>str</em>和<em>string</em>。</li>
<li><em>Boolean</em>类型的property的getter方法用<em>is</em>前缀，返回<em>Boolean</em>的方法应该以<em>has</em>或<em>is</em>作为前缀。</li>
<li>保留<em>get</em>关键字，在方法并无返回值，但是通过传入的参数，进行值的返回时使用get，比如：-(void)getCharacters:(unichar *)buffer range:(NSRange)aRange。</li>
</ol>


<h3>Class and Protocol Naming</h3>

<ol>
<li>主要是注意你继承的类要以其类名结尾，但前缀不要，要加上自己的前缀，协议要以Delegate结尾。</li>
</ol>


<!--more-->


<h2>Item20 Prefix Private Method Names</h2>

<ol>
<li>用特殊前缀标记类的私有方法，会在调试时更加方便，Matt的方式是在方法前加<em>p_</em>前缀，例如：<em>&ndash;(void)p_privateMethod</em>，当然你最好定义自己的方式。</li>
<li>Apple的方式是在方法前加<em>_</em>来标识私有方法，但不推荐开发者这么做，因为如果你继承了Cocoa的类，很容易覆盖原来的私有方法。</li>
</ol>


<!--more-->


<h2>Item21 Understand the Objective-C Error Model</h2>

<p>1.抛出exception后，本来将要释放的对象将得不到释放，所以会造成内存泄露，所以抛异常时一定是非常严重的错误出现的场景。<br/>
2.场景一是基类的一些必须被子类重写的方法可以抛出异常已告知开发者去重写，因为OC没有基类的特殊概念。</p>

<p>```objectivec
&ndash;(void)mustOverrideMethod {</p>

<pre><code>NSString *reason = [NSString stringWithFormat:@"%@ must be overridden", NSStringRromSelector(_cmd)];
@throw[NSException exceptionWithName:NSInternalInconsistencyException reason:reason userInfo:nil];
</code></pre>

<p>}
```</p>

<p>3.而处理一般的异常OC通常使用NSError，该类包含以下信息：<br/>
1）Error domain(String):表明错误发生的域，一般是自定义的全局变量，例如：<em>NSURLErrorDomain</em>。
2）Error code(Integer):表明特定域的错误码，参考HTTP的状态码。<br/>
3）Userinfo(Dictionary):额外的信息，包括本地化描述信息和导致该错误的原因。<br/>
4.NSError的一些使用场景：<br/>
1）被用于Delegate中，例如：-(void)connection:(NSURLConnection <em>)connection didFailWithError:(NSError </em>)error。<br/>
2）用于返回型参数，参照Item19，类似：<br/>
```objectivec
//&ndash;(BOOL)doSomething:(NSError<em>*)error
NSError </em>error = nil;
BOOL ret = [object doSomething:&amp;error];
if(error) {</p>

<pre><code>//There was an error
</code></pre>

<p>}
```<br/>
5.上述方法传入的是NSError<em><em>类型，开启ARC时该类型会转化为NSError</em> __autoreleasing</em>类型，该对象会在方法执行后自动释放，这么做，是因为doSomething:不能确定调用者会不会对NSError释放，大部分方法return的对象也是一样会添加autorelease（除了new，alloc，copy，mutableCopy等）。<br/>
6.doSomething的内部实现：</p>

<p>```objectivec
&ndash;(BOOL)doSomething:(NSError**)error {</p>

<pre><code>//Do something that may cause an error
if(/*there was an error*/) {
    //有必要检查error，有可能传入nil值
    if(error) {
        //Pass error through the out-parameter
        *error = [NSError errorWithDomain:domain code:code userInfo:userInfo];
    }
    return NO;
} else {
    return YES;
}
</code></pre>

<p>}
```</p>

<!--more-->


<h2>Item22 Understand the NSCopying Protocol</h2>

<p>1.想要让自定义对象实现copy功能，必须遵循NSCopying协议，其中只有一个方法需要重写：-(id)copyWithZone:(NSZone*)zone。<br/>
2.一个重写copyWithZone:方法的例子，<em>friends是内部变量，所以使用了copy-></em>friends：</p>

<p>```objectivec
&ndash;(id)copyWithZone:(NSZone *)zone {</p>

<pre><code>EOCPerson *copy = [[[self class] allocWithZone:zone] initWithFirstName:_firstName andLastName:_lastName];
copy-&gt;_friends = [_friends mutableCopy];
return copy;
</code></pre>

<p>}
```</p>

<p>3.关于这儿是否需要对_friends进行copy的讨论，作者认为如果原变量是可变的，是需要深拷贝的，而如果原变量是不可变的，则直接进行指针赋值即可，这样可以省一部分内存。<br/>
4.如果你的类有mutable和immutable两个类型，那么应该分别遵循NSMutableCopying和NSCopying协议，分别返回可变和不可变的copy。<br/>
5.采取这种方式的好处是可以提供一个可变与不可变类型的转换，而且采用copy，immutableCopy，mutableCopy三个方法的缺陷是我们很难判断将要复制的对象是不是可变的。<br/>
6.接下来讨论的是深拷贝和浅拷贝的问题，OC默认的Copy协议支持的都是浅拷贝，也就是指针拷贝，但是一些类的初始化方法提供了深拷贝，例如NSSet的：-(id)initWithSet:(NSArray*)array copyItems:(BOOL)copyItems。所以如果你需要进行深拷贝，必须自己定义：</p>

<p>```objectivec
&ndash;(id)deepCopy {</p>

<pre><code>EOCPerson *copy = [[[self class] alloc] initWithFirstName:_firstName andLastName:_lastName];
copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:YES];
return copy;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记2]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/07/22/effective-objective-cdu-shu-bi-ji-2/"/>
    <updated>2015-07-22T17:09:55+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/07/22/effective-objective-cdu-shu-bi-ji-2</id>
    <content type="html"><![CDATA[<p>继续上一篇，这篇的主题是Objects，Messaging，and the Runtime。</p>

<!--more-->


<h2>Item6 Understand Properties</h2>

<ol>
<li>在C++和Java中常使用@public和@private来声明实例变量，但在OC中由于对象是在编译期间定义的，所以按照这种定义方法，在新增变量后会导致访问偏移量出错，除非重新编译，但是这样就失去了动态语言的优势。</li>
<li>OC的解决方案是将实例变量作为可存储内存偏移量的类对象，这同时可以将实例变量定义到实现文件中，从而实现隐藏。Apple鼓励使用存取方法而不是直接访问实例变量，也是为了解决这一问题，@property就是为了方便提供getter和setter方法。</li>
<li>OC中的点方法类似C中访问结构体的成员，但其实是编译器转化为了对应的getter方法。</li>
</ol>


<h3>Property Attributes</h3>

<ol>
<li>主要说下有关内存管理的property属性，主要有assign，strong，weak，unsafe_unretained，copy。</li>
<li>assign：主要用于标量的property属性，简单的赋值操作，引用计数不变。</li>
<li>strong：声明的是持有关系，新值会被retain，旧值release，引用计数加1。</li>
<li>weak：声明的是非持有关系，与assign类似，如果指向的对象被释放，该值也会被释放。</li>
<li>unsafe_unretained：可以理解为针对对象的assign属性，但是所指向的对象被释放后，该值不会被释放，所以容易造成野指针，一般很少用到它。</li>
<li>copy：与strong类似，只不过所赋值的引用计数不变，旧值会被赋给一个所赋值copy的引用计数为1的对象，一般用于不可变对象，可能被赋可变对象的值时，这样可确保旧值改变时，不可变对象不发生变化。</li>
<li>get=&lt;>：可以自定义getter方法的名字，一般用于布尔型property，一般getter方法以is开头。</li>
<li>额外1：如果对一不可变对象复制，copy是指针复制（浅拷贝）和mutableCopy就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。</li>
<li>额外2：不要在init（包括自定义的初始化方法）和dealloc中使用setter和getter方法。</li>
<li>atomic用以确保线程安全，但是iOS平台的property基本都是nonatomic的，主要是因为性能问题，而且atomic也并非完全是线程安全的（例如一个线程频繁访问一个对象时，另一线程同时在写入，前一线程也会拿到不同的值），而在Mac OS X就不存在这个性能瓶颈了。</li>
</ol>


<!--more-->


<h2>Item7 Access Instance Variables Primarliy Directly When Accessing Them Internally</h2>

<ol>
<li>本章讨论的是如何在内部使用实例变量，有两种方式，一是使用生成的存取方法，二是直接使用实例变量。</li>
<li>优缺点如下：

<ol>
<li>直接访问对象，速度会快，绕开了OC的method dispatch，编译器会直接访问存储对象的内存。</li>
<li>直接访问对象会绕开与内存相关的setter方法，例如你设置的copy型的setter，只会按照retain来执行。</li>
<li>直接访问对象不会触发KVO。</li>
<li>使用存取方法会使调试变得简单，你可以在getter/setter添加断点。</li>
</ol>
</li>
<li>比较推荐的做法是，在存对象的时候使用setter方法，而在读取对象时直接读取，这样既享受了快速读取，也可以利用property控制保存对象。</li>
<li>但是这么做还是有一些需要注意的地方：

<ol>
<li>在初始化方法中，一定要使用直接赋值的方法，主要是因为怕子类复写了对象的setter方法，而导致异常，如果一个对象声明在了父类的内部，而子类不能直接访问它，你也不能直接访问读取该变量，这种情况只能通过setter赋值
2.如果实例变量使用了延时加载，那么读取一定要使用getter方法，不然这个对象永远都不会有值。</li>
</ol>
</li>
</ol>


<!--more-->


<h2>Item8 Understand Object Equality</h2>

<ol>
<li>比较两个对象，不使用==，那样只会比较指针的值，而一般使用<em>isEqual:</em>，如果对象有自己的专有比较方法，例如<em>isEqualToString:</em>，优先使用这些方法，速度会快些。</li>
<li><em>&ndash;(NSUIntegetr)hash;</em>是一个与比较对象息息相关的方法，hash相同的对象不一定相同，而相同的对象hash值一定相同。</li>
<li>所以自定义对象重写<em>isEqual:</em>方法，也一定要重写hash方法，共有三种方案：

<ol>
<li>返回一个常数，这个方案优点是使用单个对象时快，但是如果把大量对象放入同一集合，由于hash值相同，集合会挨个检查这些对象是否真的相同，从而导致向一个集合添加大量对象时就会很慢；</li>
<li>使用一个拼接的唯一字符串，然后进行hash，这个方案避免了上面的问题，但是出现了单个对象需要生成一个字符串，从而影响了速度的问题；</li>
<li>先取一系列变量的hash值，再将其异或，这个方案算是为了避免上述问题的折衷方案。</li>
</ol>
</li>
</ol>


<h3>Class-Specific Equality Methods</h3>

<ol>
<li>自定义类可以通过重写<em>isEqual:</em>方法，在方法里判断如果是同一类型，就调用上面的比较方法，如不是就调用父类的<em>isEqual:</em>方法，这样可以实现子类也可以与父类进行比较。</li>
</ol>


<h3>Deep versus Shallow Equality</h3>

<ol>
<li>有时你并不需要判断对象的所有信息是否相同，比如来自数据库的信息，可能只通过判断id就可以进行判断，所谓的浅比较就是这样。</li>
</ol>


<h3>Equality of Mutable Classes in Containers</h3>

<ol>
<li>这一部分主要讲的是，向集合添加可变对象，然后改变该对象，是有可能让集合出现重复对象的，这点值得关注。</li>
</ol>


<!--more-->


<h2>Item9 Use the Class Cluster Pattern to Hide Implementation Detail</h2>

<ol>
<li>类簇是OC中很重要的一个设计模式，例如UIButton的创建，类簇解决的问题是需要统一创建同一基本类型的不同对象，而同时避免暴露子类和父类内部复杂的switch语句。</li>
</ol>


<h3>Creating a Class Cluster</h3>

<ol>
<li>创建类簇的思路：一个基类，一些空方法，一个创建对象的工厂方法，继承的子类对空方法重写。这样的类簇有个缺点就是用户可能以为自己使用的类就是那个基类，而不知道其实是它的子类。</li>
</ol>


<h3>Class Clusters in Cocoa</h3>

<ol>
<li>由于很多Cocoa类都是使用了类簇模式，所以类似<em>[maybeAnArray class] == [NSArray class]</em>这样的校验类型的方法是不会返回正确值的，而要使用<em>[maybeAnArray isKindOfClass:[NSArray class]]</em>。</li>
<li>添加一个类簇的子类而不去改写其基类的工厂方法，对于NSArray是可以的，但是有三点要求：1、必须是该类簇基类的子类；2、该子类必须定义自己的存储空间，也就是说内部要有一个NSArray的对象来实现数据的存储；3、子类必须重写类簇文档中规定重写的方法。</li>
</ol>


<!--more-->


<h2>Item10 Use Associated Objects to Attach Custom Data to Existing Classes</h2>

<ol>
<li>有时为了为一个类绑定一些信息，而又不方便添加多余的property或者继承这个类，可以考虑使用<em>association</em>，类似字典型的键值读取，也可以设置内存管理策略，但是需要注意绑定的key必须是唯一的指针，而不只是值相同，所以一般使用全局的静态变量作为key。</li>
</ol>


<h3>An Example of Using Associated Objects</h3>

<ol>
<li>通过使用<em>Associated Objects</em>实现了UIAlertView的回调Block化，使得代码的可读性更好，也更方便。</li>
<li><em>Associated Objects</em>提供了一个将对象之间互相绑定的方法，但是并不推荐大范围使用该方法，因为会导致调试变的更难。</li>
</ol>


<!--more-->


<h2>Item11 Understand the Role of objec_msgSend</h2>

<ol>
<li>OC利用动态绑定成为了真正的动态语言，OC中传递消息最终被转化为函数<em>void objc_msgSend(id self, SEL cmd, &hellip;)</em>，例如：<em>id returnValue = [someObkect messageName:parameter];</em>转化后，<em>id returnValue = objc_msgSend(someObject, @sleector(messageName:), parameter);</em>。</li>
<li><em>objc_msgSend</em>执行的顺序是先在接受者实现的方法中找符合的方法来执行，如没有，向继承链上方逐级寻找符合的实现方法。</li>
<li><em>objc_msgSend</em>会为每个类缓存一张查找表，来加速这一过程，但即使如此，还是比在C中直接调用静态调用函数慢，但这常常不是应用的瓶颈，这样来换取程序的灵活性还是值得的。</li>
<li><em>objc_msgSend</em>是针对确定消息的处理，下面还有一些处理个别案例的方法。</li>
<li><em>objc_msgSend_stret</em>用于处理用户返回适用于CPU寄存器的结构体的消息（不太懂）。</li>
<li><em>objc_msgSend_fpret</em>用于处理返回浮点值的消息，一些结构需要在函数调用时对浮点数寄存器特殊处理，所以这是该方法存在的意义（不太懂）。</li>
<li><em>objc_msgSendSuper</em>直接把消息转发给父类执行，类的所有方法都是一个个类似<em>&lt;return_type> Class_selector(id self, SEL _CMD, &hellip;)</em>这样的原型，这些方法指针存在该类的一个查找表中等待调用，该原型与<em>objc_msgSend</em>是相同的，也就实现了<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html">尾部递归调用</a>的可能，这样会实现调用栈的空间复杂度保持O(1)，不会产生溢出。</li>
</ol>


<!--more-->


<h2>Item12 Understand Message Forwarding</h2>

<ol>
<li>转发路径是为了处理接受者无法处理消息的情况，分为两条路径：1、<em>dynamic method resolution</em>期望接收者自己在runtime添加处理方法；2、<em>full forwarding mechanism</em>到了这一步，runtime得知接收者是不可能对消息做出响应了，所以要求接收者自己处理该消息，又分为两步：(1)询问是否有其他对象可以接收消息，如果有则转发给该对象；(2)如果也没有替代的接收者，那么将使用<em>NSInvocation</em>来对消息进行封装，然后交给原接收者去处理。<a href="http://bugly.qq.com/blog/?p=64">这儿也做了详细解释</a>。</li>
</ol>


<h3>Dynamic Method Resolution</h3>

<ol>
<li><em>+(BOOL)resolveInstanceMethod:(SEL)selector</em>用于表明类有无实例方法可处理该消息，可以说是给予该类的第二次机会。</li>
<li>这类方法是存在的，例如CoreData的@dynamic的property的accessing方法，而<em>+(BOOL)resolveInstanceMethod:(SEL)selector</em>对其的处理是判断是否是@dynamic property，如果是，向该类添加预备好的getter，setter方法，已确保类可以响应该消息。</li>
</ol>


<h3>Replacement Receiver</h3>

<ol>
<li><em>&ndash;(id)forwardTargetForSelector:(SEL)selector</em>用于返回可以替代原接收者的对象（如果其存在的话），这其实提供了一些多继承的特性，即原类内部可以有其他对象来实现这一方法。但是无法对消息进行修改，只是转发，如需修改消息，则需要采取最后一步。</li>
</ol>


<h3>Full Forwarding Mechanism</h3>

<ol>
<li>&ndash;(void)forwardInvocation:(NSInvocation*)invocation用于转发接收到的NSInvocation消息，可以进行简单转发，但这和上述的方法没有区别，而更为常见的用途是修改消息，如增加参数或者改变方法等。</li>
<li>重写该方法时需要调用父类的相同方法来处理改invocation，这样会最终调用NSObject的<em>doesNotRecognizeSelector</em>，最终抛出异常，但如果你不希望程序崩溃，就不要去调用父类的方法。</li>
</ol>


<h3>The Full Picture</h3>

<ol>
<li>具体图表见<a href="http://bugly.qq.com/blog/?p=64">这儿</a>。</li>
<li>解决的代价是越来越高的，所以最好在第一阶段解决这一问题。</li>
</ol>


<h3>Full Example of Dynamic Method Resolution</h3>

<ol>
<li>举例说明，将一个model中的所有对象都存在一个dictionary中，而这些对象申明为@dynamic，在<em>+(BOOL)resolveInstanceMethod:(SEL)selector</em>中根据selector的信息对相应的对象动态添加setter，getter方法，大幅减少代码量，但缺点是想特殊处理某个对象，就变得比较麻烦了。</li>
</ol>


<!--more-->


<h2>Item13 Consider Method Swizzling to Debug Opaque Methods</h2>

<ol>
<li><em>Method Swizzling</em>主要用于不知道类的源码，且不用继承、重写，即可为原方法添加hook的手段（其实是在runtime中先交换，再执行一次原方法而已-_-）。</li>
<li>通过添加一个类的分类，在分类添加一个方法，在这个方法中进行递归调用，然后与目标方法进行交换，这时再执行原方法时，会依次执行这两个方法。<a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411">另外一篇文章也有说明</a>。</li>
</ol>


<!--more-->


<h2>Item14 Understand What a Class Object Is</h2>

<ol>
<li>Class本身也是一个结构体指针，叫objc_class，Class也有一个Class类型的isa指针，说明Class本身也是一个OC对象，他的类型叫做metaclass，Class有Class类型的super_class指针，用来指向他的父类Class。</li>
</ol>


<h3>Inspecting the Class Hierarchy</h3>

<ol>
<li><em>isMemberOfClass:</em>用于判断是否属于该类，<em>isKindOfClass:</em>用于判断是否属于该类或者该类的子类。原理还是利用上述的Class的isa和super_class指针。</li>
<li>内省（自我类型检查）是OC中的重要技术，应用也很广泛，除了上述方法，也可利用<em>[object class] == [EOCSomeClass class]</em>来判断，之所以这么写是合理的，是因为每个class的Class类型是一个单例对象，所以可以直接比较指针。</li>
<li>但是还是推荐使用默认的类型检测方法，因为这样可以利用消息转发技术，如果一个对象的所有方法都是代理对象执行的，那么调用class方法只会返回代理对象的类型，而调用<em>isKindOfClass:</em>方法，代理会把消息转给被代理的对象，会得到正确的类型。</li>
</ol>

]]></content>
  </entry>
  
</feed>
