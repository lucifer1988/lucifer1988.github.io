<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 刘毅的技术博客]]></title>
  <link href="http://lucifer1988.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://lucifer1988.github.io/"/>
  <updated>2015-11-25T11:16:21+08:00</updated>
  <id>http://lucifer1988.github.io/</id>
  <author>
    <name><![CDATA[刘毅]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Functional Programming]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/23/swift-by-tutorials-functional-programming/"/>
    <updated>2015-11-23T14:09:04+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/23/swift-by-tutorials-functional-programming</id>
    <content type="html"><![CDATA[<p>前几篇分别介绍了泛型、类、枚举、范围运算符这些Swift的语言新特性，当然有一部分是对已有技术的改进，但这已经表明Swift是比OC更具表现力和更简洁的语言。而Swift不仅仅是提供了更好的语法，在Swift中，函数式编程会成为编程中可行的并且非常重要的编程工具。函数式编程，简而言之，就是一种通过数学式的函数概括计算的编程范式，不可变且具表现力，同时使用最少的变量和状态值。函数式编程对于测试是非常友好的。随着多核设备的普及，并行和并发处理显得非常重要，而函数式编程就是可以很好处理并行和并发处理的，这也是它日趋重要的原因之一。</p>

<!--more-->


<h2>Simple array filtering</h2>

<p>这个简单的例子要求我们在1到10之间找到所有的偶数的数字，看起来是一个简单的工作，但是是介绍函数式编程的一大步。</p>

<h3>Filtering the old way</h3>

<p>```objectivec
var evens = <a href="">Int</a>
for i in 1&hellip;10 {</p>

<pre><code>if i % 2 == 0 {
evens.append(i)
}
</code></pre>

<p>}
print(evens)
```</p>

<p>这是一个很简单的小程序，而且运行也没问题，但是最核心的逻辑，检测一个数是否偶数，被隐藏在了for循环中。另外，添加数字到数组的逻辑在判断条件中，如果你想要打印每个偶数，那么除了复制粘贴，没法儿复用这部分代码。</p>

<h3>Functional filtering</h3>

<p>让我们来看看函数式的解决方案，其中filter是核心，通过传递isEven给filter，直接返回了我们需要的新数组。</p>

<p>```objectivec
func isEven(number: Int) &ndash;> Bool {</p>

<pre><code>return number%2 == 0
</code></pre>

<p>}
evens = Array(1&hellip;10).filter(isEven)
print(evens)
```</p>

<p>通过上一章我们知道函数只是有名字的闭包，按照之前的介绍，利用type inference我们可以对该方案进一步简化。</p>

<p><code>objectivec
evens = Array(1...10).filter { number in number % 2 == 0 }
println(evens)
</code></p>

<p>或者最简化的使用参数简化符号。</p>

<p><code>objectivec
evens = Array(1...10).filter{ $0%2 == 0 }
print(evens)
</code></p>

<p>对于简化符号的使用，作者表示，对于比较简单的逻辑（如上例）推荐使用简化符号，而对于复杂的逻辑，则不推荐使用，因为即使减少了代码量，但牺牲了可读性，还是不太划算。</p>

<p>上面的函数式编程较上一节的方案，更为简洁，而同时它也反映了，函数式编程三个共同的特点。</p>

<ol>
<li>Higher-order functons：你需要将这些函数当做参数传入其他函数，该例中isEven即是Higher-order functons。</li>
<li>First-class function：这也是我们多次强调的一点，函数作为第一类对象，可以作为参数或者返回结果，这也是函数式编程的基础，Swift全面支持这一点。</li>
<li>Closures：闭包，可以使代码更简洁，相当于匿名函数。</li>
</ol>


<p>你可能觉得OC的block也具有类似的特点，但Swift较之更胜一筹，主要是因为它拥有很多内建的函数式语法，比如该例中的filter就是。</p>

<h3>The magic behind filter</h3>

<p>通过自定义一个myFilter方法，让我们来看一下filter的背后实现。</p>

<p>```objectivec
func myFilter<T>(source: [T], predicate:(T) &ndash;> Bool) &ndash;> [T] {</p>

<pre><code>var result = [T]()
for i in source {
    if predicate(i) {
        result.append(i)
    }
}
return result
</code></pre>

<p>}
```</p>

<p>从上面发现，实际上的实现和我们在第一节的逻辑是相同的，只不过通过泛型和函数作为参数完成了filter这一过程的抽象，这也是函数式编程的本质。</p>

<p>原文还提出一个将myFilter()作为Array的一个方法，而不是函数，其实只需要添加一个Array的扩展，将泛型改为Array自身的元素就行，下面给出自己的解答。</p>

<p>```objectivec
extension Array {</p>

<pre><code>func myFilter&lt;T&gt;(predicate:(T) -&gt; Bool) -&gt; [T] {
    var result = [T]()
    for i in self {
        if predicate(i as! T) {
            result.append(i as! T)
        }
    }
    return result
}
</code></pre>

<p>}
evens = Array(1&hellip;10).myFilter{$0%2 == 0}
```</p>

<h2>Reducing</h2>

<p>这一节将介绍Swift中内建的，比较复杂的reduce函数，进一步了解函数式编程。</p>

<h3>Manual reduction</h3>

<p>reduce的效果是输入一个数组，但最终得到一个结果，例子是要求我们找出1到10的所有偶数，并计算出他们的和，先看下常规控制流的实现。</p>

<p>```objectivec
var evens = <a href="">Int</a>
for i in 1&hellip;10 {</p>

<pre><code>if i % 2 == 0 {
    evens.append(i)
}
</code></pre>

<p>}
var evenSum = 0
for i in evens {</p>

<pre><code>evenSum += i
</code></pre>

<p>}
print(evenSum)
```</p>

<h3>Functional reduce</h3>

<p>下面是reduce的函数式实现，这里采用的是全简写符号。</p>

<p><code>objectivec
let evenSum = Array(1...10).filter{$0%2 == 0}.reduce(0){$0+$1}
print(evenSum)
</code></p>

<p>reduce的函数原型如下，有两个参数，initial和combine，initial为U类型，最终的返回值也是U类型，而combine的参数是U和T类型，返回值也是U类型，每次执行完后，返回值都会成为combine新的参数，所以实现了上述的累加效果。</p>

<p><code>objectivec
func reduce&lt;U&gt;(initial: U, combine: (U, T) -&gt; U) -&gt; U
</code></p>

<p>这里还有一个寻找数组中最大值的例子。</p>

<p><code>objectivec
let maxNumber = Array(1...10).reduce(0){total, number in max(total, number)}
print(maxNumber)
</code></p>

<p>我们发现，输入值T和最终返回值U可以是不同的类型，所以可以有更多的应用，比如下面的字符串输出。</p>

<p><code>objectivec
let numbers = Array(1...10).reduce("numbers:"){$0+"\($1)"}
print(numbers)
</code></p>

<p>这里又有一个附加问题，要求输入一个[&ldquo;3&rdquo;, &ldquo;1&rdquo;, &ldquo;4&rdquo;, &ldquo;1&rdquo;]数组，而输出Int值3141，我的思路是先拼接字符串，然后转为Int。</p>

<p><code>objectivec
let digits = Int(["3", "1", "4", "1"].reduce(""){$0+$1})
print(digits)
</code></p>

<h3>The magic behind reduce</h3>

<p>下面我们自己为Array添加一个自定义的reduce方法，实现方法与我们在之前的实现是一致的，还是做了一步抽象。</p>

<p>```objectivec
extension Array {</p>

<pre><code>func myReduce&lt;T, U&gt;(seed:U, combiner:(U, T) -&gt; U) -&gt; U {
    var result = seed;
    for i in self {
        result = combiner(result, i as! T)
    }
    return result
}
</code></pre>

<p>}
```</p>

<h2>Building an index</h2>

<p>接下来，我们将实践一次函数式编程，题目是将下面的String数组，按照首字母进行分组。</p>

<p><code>objectivec
let words = ["Cat", "Chicken", "fish", "Dog", "Mouse", "Guinea Pig", "monkey"]
</code></p>

<p>首先现有一个大致的思路，建立一个元组，包含首字母和其对应的String数组，最后通过一个函数返回一个该元组的数组，然后就完成了任务。</p>

<p>```objectivec
typealias Entry = (Character, [String])</p>

<p>func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>return [Entry]()
</code></pre>

<p>}
```</p>

<h3>Building an index imperatively</h3>

<p>下面是常规控制流实现，使用了两个for循环，一个用于记录所有的首字母key，第二个用于将原数组添加到对应的元组中。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {
  var result = <a href="">Entry</a>
  var letters = <a href="">Character</a>
  for word in words {</p>

<pre><code>let firstLetter = Character(word.substringToIndex(
  advance(word.startIndex, 1)).uppercaseString)
if !contains(letters, firstLetter) {
  letters.append(firstLetter)
}
</code></pre>

<p>  }
  for letter in letters {</p>

<pre><code>var wordsForLetter = [String]()
for word in words {
  let firstLetter = Character(word.substringToIndex(
    advance(word.startIndex, 1)).uppercaseString)
  if firstLetter == letter {
    wordsForLetter.append(word)
  }
}
result.append((letter, wordsForLetter))
</code></pre>

<p>  }
  return result
}
```</p>

<h3>Building an index the functional way</h3>

<p>下面是该问题的函数式解决方案，首先我们利用Array的map函数，得到words对应的首字母数组。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>let letters = words.map { word -&gt; Character in
Character(word.substringToIndex(word.startIndex.advancedBy(1)).uppercaseString)
}
return [Entry]()
</code></pre>

<p>}
```</p>

<p>map与前面的filter，reduce一样都是Array的内建函数，它的作用是输出一个与原数组对应的相关数组。而且数组元素可以与原数组不同，这里通过map得到了words对应的首字母数组，但是不足的是重复字母并没有过滤。我们可以像之前一样自定义一个过滤相同字母的函数。</p>

<p>```objectivec
func distinct&lt;T: Equatable> (source: [T]) &ndash;> [T] {</p>

<pre><code>var unique = [T]()
for item in source {
    if !unique.contains(item) {
        unique.append(item)
    }
}
return unique
</code></pre>

<p>}
```</p>

<p>利用这一函数，过滤重复字母。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>let letters = words.map { word -&gt; Character in 
Character(word.substringToIndex(word.startIndex.advancedBy(1)).uppercaseString)
}
let distinctLetters = distinct(letters)
print(distinctLetters)
return [Entry]()
</code></pre>

<p>}
```</p>

<p>最后，我们利用map和filter的嵌套使用，完成最终的结果数组。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>let letters = words.map { word -&gt; Character in 
Character(word.substringToIndex(word.startIndex.advancedBy(1)).uppercaseString)
}
let distinctLetters = distinct(letters)

return distinctLetters.map { letter -&gt; Entry in
    return (letter, words.filter { word -&gt; Bool in 
    Character(word.substringToIndex(word.startIndex.advancedBy(1)).uppercaseString) == letter
        })
}
</code></pre>

<p>}
```</p>

<p>在完成基础上我们可以进一步重构，我们在buildIndex()函数中声明了一个新的函数firstLetter()，该函数的作用范围只在外围函数中，这得益于Swift中function作为第一类对象，所以可以被视作本地变量，也有作用范围。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>func firstLetter(str: String) -&gt; Character {
    return Character(str.substringToIndex(str.startIndex.advancedBy(1)).uppercaseString)
}

let letters = words.map { word -&gt; Character in
    return firstLetter(word)
}
let distinctLetters = distinct(letters)
print(distinctLetters)

return distinctLetters.map { letter -&gt; Entry in
    return (letter, words.filter { word -&gt; Bool in
        firstLetter(word) == letter
        })
}
</code></pre>

<p>}
```</p>

<p>然而，这还不是最简形式，追求最简形式，可以将所有函数连续调用，这是没问题的，以下是最终结果。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>func firstLetter(str: String) -&gt; Character {
    return Character(str.substringToIndex(str.startIndex.advancedBy(1)).uppercaseString)
}

return distinct(words.map(firstLetter))
    .map {
      letter -&gt; Entry in
      return (letter, words.filter {
        word -&gt; Bool in
        firstLetter(word) == letter
      })
    }
</code></pre>

<p>}
```</p>

<p>通过比较，你会发现，在常规做法中，你会声明很多临时变量，而在函数式编程中，你会使用对应的常量替代，这就意味着是不可变的，而不可变的类型更容易测试和协助并发，函数式编程与不可变类型是一体的，而且会导致你的代码更简洁，错误更少。</p>

<p>这节的挑战任务是需要输出的结果按字母排序，我们可以添加之前介绍过的最简的sort()方法，在distinct()之后进行调用。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>func firstLetter(str: String) -&gt; Character {
    return Character(str.substringToIndex(str.startIndex.advancedBy(1)).uppercaseString)
}

return distinct(words.map(firstLetter)).sort(&lt;)
    .map {
      letter -&gt; Entry in
      return (letter, words.filter {
        word -&gt; Bool in
        firstLetter(word) == letter
      })
    }
</code></pre>

<p>}
```</p>

<h2>Partial application and currying</h2>

<p>前面几节围绕Array的三个方法，map，reduce，filter来介绍函数式编程。这一节将进一步介绍函数式编程的Partial application和currying。这里有一篇<a href="http://segmentfault.com/a/1190000000765247">博客</a>也进行了简单的介绍。</p>

<h3>Partial application</h3>

<p>为了说明Partial application，先提出一个问题，切割字符串为数组，我们的常用解决方案就是就是直接调用NSString的componentsSeparatedByString()方法。</p>

<p><code>objectivec
import Foundation
let data = "5,7;3,4;55,6"
print(data.componentsSeparatedByString(";"))
print(data.componentsSeparatedByString(","))
</code></p>

<p>这么调用也没问题，但是如果有场景需要我们多次用分号，或者逗号切割字符串，这样处理会出现许多重复代码，那么partical application就是这类问题的解决方案。</p>

<p>```objectivec
func creatSplitter(separator: String) &ndash;> (String &ndash;> [String]) {</p>

<pre><code>func split(source: String) -&gt; [String] {
    return source.componentsSeparatedByString(separator)
}
return split
</code></pre>

<p>}</p>

<p>let commaSplitter = creatSplitter(&ldquo;,&rdquo;)
print(commaSplitter(data))</p>

<p>let semiColonSplitter = creatSplitter(&ldquo;;&rdquo;)
print(semiColonSplitter(data))
```</p>

<p>我们创建了一个产生分割字符串方法的工厂方法，输入分隔符号，返回一个该符号的分割方法，也就是我们先实现了函数的一部分，将函数从二元降为了一元，最主要的是，我们可以反复使用这一得到的方法，可能在该例中优点体现不太明显，但是如果逻辑更复杂，参数更多后，partical application带来的效率提高就非常可观了。</p>

<h3>A mild curry</h3>

<p>使用curry也可以实现上例中的结果，如下，但是调用和工厂方法的写法都会改变。</p>

<p>```objectivec
func createSplitter(separator: String)(source: String) &ndash;> [String] {</p>

<pre><code>return source.componentsSeparatedByString(separator)
</code></pre>

<p>}</p>

<p>let commaSplitter = createSplitter(&ldquo;,&rdquo;)
print(commaSplitter(source: data))</p>

<p>let semiColonSplitter = createSplitter(&ldquo;;&rdquo;)
print(semiColonSplitter(source: data))
```</p>

<p>curry实现了相同的目的，但是它创建的方法包含了两组“分开的”参数，而当你输入第一个参数时，会返回一个函数，你可以继续输入第二个参数（第二个参数需要使用外部参数名，与一般函数一致）。</p>

<h3>A hotter curry</h3>

<p>让我们进一步了解curry，将下面的三元函数进行curry化。</p>

<p>```objectivec
func addNumbers(one:Int, two:Int, three:Int) &ndash;> Int {</p>

<pre><code>return one + two + three
</code></pre>

<p>}
let sum = addNumbers(2, two: 5, three: 4)
print(sum)
```</p>

<p>```objectivec
func curryAddNumbers(one:Int)(two:Int)(three:Int) &ndash;> Int {</p>

<pre><code>return one+two+three
</code></pre>

<p>}
```</p>

<p>接着让我们分部对curry函数进行调用，每一步都会返回一个函数，最后一步返回最终结果。</p>

<p><code>objectivec
let stepOne = curryAddNumbers(2)
let stepTwo = stepOne(two: 5)
let result = stepTwo(three: 4)
</code></p>

<p>也可以像一般函数一样，一次性直接调用。</p>

<p><code>objectivec
let result2 = curryAddNumbers(2)(two: 5)(three: 4)
</code></p>

<p>当然，也可以在每一步添加多个参数。</p>

<p>```objectivec
func curryAddNumbers2(one:Int, two: Int)(three: Int) &ndash;> Int {</p>

<pre><code>return one+two+three
</code></pre>

<p>}
let result3 = curryAddNumbers2(2, two: 5)(three: 4)
```</p>

<h3>Practical curring</h3>

<p>上面两例主要为了说明curry的使用，这里看下它在实际开发中的用法。</p>

<p><code>objectivec
let text = "Swift"let paddedText = text.stringByPaddingToLength(10, withString: ".", startingAtIndex: 0)print(paddedText)
</code></p>

<p>这是一个调用了NSString的填充字符串的方法（额外注意一点startingAtIndex:是指明要填充的字符串从哪位开始填充，所以不能超过withString:参数的长度）。我们在他基础之上要封装一个四元的curry函数。</p>

<p>```objectivec
func curriedPadding(startingAtIndex: Int, withString: String)
  (source: String, length: Int) &ndash;> String {</p>

<pre><code>return source.stringByPaddingToLength(length,
  withString: withString, startingAtIndex: startingAtIndex);
</code></pre>

<p>}
```</p>

<p>然后在它基础上创建一个只用点填充字符串的方法。</p>

<p><code>objectivec
let dotPadding = curriedPadding(0, withString: ".")
let dotPadded = dotPadding(source: "Curry!", length: 10)
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Enums and Switch Statements]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/20/swift-by-tutorials-enums-and-switch-statements/"/>
    <updated>2015-11-20T10:11:34+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/20/swift-by-tutorials-enums-and-switch-statements</id>
    <content type="html"><![CDATA[<p>enum枚举类型是很多编程语言的基本特性，一般是用来存储一组表示不同type的值，比如UILabel使用的NSTextAlignment，会有.Center，.Left多个type。而在Swift中，enum除了原始的用法，它的用法更像class或struct，enum可以拥有自己的方法，甚至是构造方法，然后通过配合Switch，可以实现更灵活的代码流控制，所以才会专门拿出来讲解，足见enum+switch在Swift的重要性。</p>

<!--more-->


<h2>Basic enumerations</h2>

<p>先看一个Swift中定义的简单enum，如下：</p>

<p>```objectivec
enum Shape {</p>

<pre><code>case Rectangle
case Square
case Triangle
case Circle
</code></pre>

<p>}
```</p>

<p>而使用时，可以按照下面两种方式赋值，如果事先定义了类型，那么可以不用在后面写类型，这还是Swift type inference的表现。</p>

<p><code>objectivec
var aShape = Shape.Triangle
var bShape: Shape = .Triangle
</code></p>

<p>而在之后的再次赋值中，都不用再指定类型。</p>

<p><code>objectivec
aShape = .Square
</code></p>

<h3>Raw values</h3>

<p>在OC中，我们一般使用NS_ENUM()来定义枚举，并可以指定值的类型，也可以单独指定某个type的值。而在Swift中，也可以做到，而且更简单。</p>

<p>```objectivec
enum Shape: Int {</p>

<pre><code>case Rectangle
case Square
case Triangle
case Circle
</code></pre>

<p>}
```</p>

<p>使用上述代码就指定了enum的原始值类型为Int，同时该enum获得了一个property，<strong>rawValue</strong>，用于读取当前枚举值的raw value，和一个新的初始化方法，<strong>init(rawValue:)</strong>，用raw value来初始化enum。</p>

<p><code>objectivec
var triangle = Shape.Triangle
triangle.rawValue
var square = Shape(rawValue: 1)
</code></p>

<p>有一点需要注意，就是通过<strong>init(rawValue:)</strong>生成的enum值，是Optional类型的，因为可能会出现输入的raw value没有对应的enum，如下，会返回nil。</p>

<p><code>objectivec
var notAShape = Shape(rawValue: 100)
</code></p>

<p>enum可以直接给某个type赋值，然后其他未赋值的type会自动加1。</p>

<p>```objectivec
enum Shape: Int {</p>

<pre><code>case Rectangle = 10
case Square
case Triangle
case Circle
</code></pre>

<p>}
```</p>

<p>此外，enum可以使用其他类型的raw value，比如Double，Float，String，但是需要为所有type指定对应的raw value，因为除了Int，其他类型的enum是不会对没赋值的enum自动加1的。</p>

<p>```objectivec
enum Shape: String {</p>

<pre><code>case Rectangle = "Rectangle"
case Square = "Square"
case Triangle = "Triangle"
case Circle = "Circle"
</code></pre>

<p>}
```</p>

<h2>Switch statements</h2>

<p>switch与enum的配合在很多语言都是常见的用法，Swift中一样可以，而且有很多实用的改进。</p>

<p>```objectivec
enum Shape {</p>

<pre><code>case Rectangle
case Square
case Triangle
case Circle
</code></pre>

<p>}</p>

<p>var aShape = Shape.Rectangle</p>

<p>switch(aShape) {
case .Rectangle:</p>

<pre><code>print("a rectangle")
</code></pre>

<p>case .Square:</p>

<pre><code>print("a square")
</code></pre>

<p>default:</p>

<pre><code>print("other shape")
</code></pre>

<p>}
```</p>

<p>之前在控制流的章节我们介绍过Swift中的switch，它是需要所有case全部覆盖的，如果你实现了全部case的覆盖，则不用添加default，反之，一定要添加defaut处理。而且，你不需要在每个case后添加break，系统会自动为你添加。</p>

<p>```objectivec
switch(aShape) {
case .Rectangle, .Square:</p>

<pre><code>print("a quadrilateral")
</code></pre>

<p>case .Circle:</p>

<pre><code>print("a circle")
</code></pre>

<p>default:</p>

<pre><code>break
</code></pre>

<p>}
```</p>

<p>一个case处理多个值也很简单，只需要逗号隔开多个值即可，并不需要其他语言中，用不加break的多行处理。</p>

<h2>Associated values</h2>

<p>Associated values是Swift与其他语言的enum类型最大的不同之处，你可以向每个type添加一个类似元组类型的附加值，来作为二级判断条件，下面是有附带值的enum声明，可以为参数添加参数名。</p>

<p>```objectivec
enum Shape {</p>

<pre><code>case Rectangle(width: Float, height: Float)
case Square(side: Float)
case Triangle(base: Float, height: Float)
case Circle(radius: Float)
</code></pre>

<p>}
```</p>

<p>使用时，可以像类或结构体初始化一样赋值，但记住不能像两者一样用<strong>.</strong>来访问。</p>

<p><code>objectivec
var rectangle = Shape.Rectangle(width: 5, height: 10)
</code></p>

<p>你可以使用这些associated values的场景只能是在switch语句中，同时你还可以使用where关键字，为case添加二级条件。</p>

<p>```objectivec
switch (rectangle) {
case .Rectangle(let width, let height) where width &lt;= 10:</p>

<pre><code>print("Narrow rectangle:\(width)*\(height)")
</code></pre>

<p>case .Rectangle(let width, let height):</p>

<pre><code>print("Wide rectangle:\(width)*\(height)")
</code></pre>

<p>default:</p>

<pre><code>print("other shape")
</code></pre>

<p>}
```</p>

<p>需要注意的是，判断条件越来越复杂，便会出现符合多个case的情况，但像前面所说，系统会自动在case后添加break，所以也只会执行最先符合的case，这需要注意。</p>

<h2>Eunms as types</h2>

<p>Swift中的enum还有另外一个重要特性，就是可以添加方法，配合associated value，可以封转一些方便的方法，比如为上面的Shape添加一个计算面积的方法。</p>

<p>```objectivec
func area() &ndash;> Float {</p>

<pre><code>switch(self) {
case .Rectangle(let width, let height):
    return width * height
case .Square(let side):
    return side * side
case .Triangle(let base, let height):
    return 0.5 * base * height
case .Circle(let radius):
    return Float(M_PI) * powf(radius, 2)
}
</code></pre>

<p>}
```</p>

<p>然后申明一个Shape的变量，就可以直接调用该方法计算面积了。</p>

<p><code>objectivec
var circle = Shape.Circle(radius: 5)
circle.area()
</code></p>

<p>除此之外，可以添加新的构建方法，这是Shape实例的构造方法，所以切记一定要给self赋值，否则self没有值是无法返回对象的。</p>

<p>```objectivec
init(_ rect: CGRect) {</p>

<pre><code>let width = Float(CGRectGetWidth(rect))
let height = Float(CGRectGetHeight(rect))
if width == height {
    self = Square(side: width)
} else {
    self = Rectangle(width: width, height: height)
}
</code></pre>

<p>}
```</p>

<p><code>objectivec
var shape = Shape(CGRectMake(0, 0, 5, 10))
</code></p>

<p>所以如下这个构建方法是不合法的，因为会存在无法给self赋值的情况。</p>

<p>```objectivec
init(_ string: String) {</p>

<pre><code>switch(string) {
case "rectangle":
    self = Rectangle(width: 5, height: 10)
case "square":
    self = Square(side: 5)
case "triangle":
    self = Triangle(base: 5, height: 10)
case "circle":
    self = Circle(radius: 5)
default:
    break
}
</code></pre>

<p>}
```</p>

<p>但是想通过这种思路来初始化Shape，也可以实现，就是构建一个static的工厂方法，这样就不存在一定要有值的限制了，可以返回Optional类型。</p>

<p>```objectivec
static func fromString(string: String) &ndash;> Shape? {
switch(string) {</p>

<pre><code>case "rectangle":
    return Rectangle(width: 5, height: 10)
case "square":
    return Square(side: 5)
case "triangle":
    return Triangle(base: 5, height: 10)
case "circle":
    return Circle(radius: 5)
default:
    return nil
}
</code></pre>

<p>}
```</p>

<p>对应的，使用时也要用if来拆包。</p>

<p>```objectivec
if let anotherShape = Shape.fromString(&ldquo;rectangle&rdquo;) {</p>

<pre><code>anotherShape.area()
</code></pre>

<p>}
```</p>

<h3>Optionals are enums</h3>

<p>Swift的Optional类型是enum类型，下面是部分实现：</p>

<p><code>objectivec
enum Optional&lt;T&gt; : NilLiteralConvertible {
  case None  case Some(T)  init()  init(_ some: T)  static func convertFromNilLiteral() -&gt; T?
}
</code></p>

<p>这里使用了泛型，并将该类型作为Some的associated value，可以使Optional持有任何类型的值。</p>

<p>同时enum可以实现协议，NilLiteralConvertible协议使你可以用nil来替代optional，编译器自动会将赋值nil时去调用<strong>convertFromNilLiteral</strong>，最终转化为.None。正是因为实现了这个协议，才可以对optional类型赋nil值，不然会报错。</p>

<h2>JSON parsing using enums</h2>

<p>本节用解析JSON这一常见用例，来实践enum在Swift中的使用。</p>

<h3>Parsing JSON the hard way</h3>

<p>这是常规的解析方法，看起来确实比较繁琐（但相比OC是还是简单多了）。</p>

<p>```objectivec
let json = &ldquo;{\"success\&rdquo;:true,\&ldquo;data\&rdquo;:{\&ldquo;numbers\&rdquo;:[1,2,3,4,5],\&ldquo;animal\&rdquo;:\&ldquo;dog\&rdquo;}}"</p>

<p>if let jsonData = (json as NSString).dataUsingEncoding(NSUTF8StringEncoding) {
  let parsed: AnyObject? = NSJSONSerialization.JSONObjectWithData(jsonData, options: NSJSONReadingOptions(0), error: nil)</p>

<p>  // Actual JSON parsing section
  if let parsed = parsed as? [String:AnyObject] {</p>

<pre><code>if let success = parsed["success"] as? NSNumber {
  if success.boolValue == true {
    if let data = parsed["data"] as? NSDictionary {
      if let numbers = data["numbers"] as? NSArray {
        print(numbers)
      }
      if let animal = data["animal"] as? NSString {
        print(animal)
      }
    }
  }
}
</code></pre>

<p>  }
}
```</p>

<h3>Introducing JSON.swift</h3>

<p>这个文件之前在第四章解析JSON时用过，下面来分析下它的结构，首先是一个enum定义，因为JSON文件就是一些基本元素和dictionary或array的组合，所以使用enum和associated value来定义JSON的基本对象，这是这一解决方案的核心思想。</p>

<p><code>objectivec
enum JSONValue {    case JSONObject([String:JSONValue])     case JSONArray([JSONValue]) case JSONString(String) case JSONNumber(NSNumber)   case JSONBool(Bool) case JSONNull}
</code></p>

<p>接下来为了获取.JSONObject和.JSONArray，我们利用Swift中方便添加角标访问的方式，使用subscript技术。</p>

<p>```objectivec
subscript(i: Int) &ndash;> JSONValue? {
  get {</p>

<pre><code>switch self {
case .JSONArray(let value):
  return value[i]
default:
  return nil
}
</code></pre>

<p>  }
}</p>

<p>subscript(key: String) &ndash;> JSONValue? {
  get {</p>

<pre><code>switch self {
case .JSONObject(let value):
  return value[key]
default:
  return nil
}
</code></pre>

<p>  }
}
```</p>

<p>那么访问一般元素时呢？我们采用了computed properties来访问。</p>

<p>```objectivec
var object: [String:JSONValue]? {
  switch self {
  case .JSONObject(let value):</p>

<pre><code>return value
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}</p>

<p>var array: [JSONValue]? {
  switch self {
  case .JSONArray(let value):</p>

<pre><code>return value
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}</p>

<p>var string: String? {
  switch self {
  case .JSONString(let value):</p>

<pre><code>return value
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}</p>

<p>var integer: Int? {
  switch self {
  case .JSONNumber(let value):</p>

<pre><code>return value.integerValue
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}</p>

<p>var double: Double? {
  switch self {
  case .JSONNumber(let value):</p>

<pre><code>return value.doubleValue
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}</p>

<p>var bool: Bool? {
  switch self {
  case .JSONBool(let value):</p>

<pre><code>return value
</code></pre>

<p>  case .JSONNumber(let value):</p>

<pre><code>return value.boolValue
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}
```</p>

<p>最后将对象转化为JSONValue也需要一个方法，而且是递归调用的，</p>

<p>```objectivec
static func fromObject(object: AnyObject) &ndash;> JSONValue? {
  switch object {
  case let value as NSString:</p>

<pre><code>return JSONValue.JSONString(value)
</code></pre>

<p>  case let value as NSNumber:</p>

<pre><code>return JSONValue.JSONNumber(value)
</code></pre>

<p>  case let value as NSNull:</p>

<pre><code>return JSONValue.JSONNull
</code></pre>

<p>  case let value as NSDictionary:</p>

<pre><code>var jsonObject: [String:JSONValue] = [:]
for (k: AnyObject, v: AnyObject) in value {
  if let k = k as? NSString {
    if let v = JSONValue.fromObject(v) {
      jsonObject[k] = v
    } else {
      return nil
    }
  }
}
return JSONValue.JSONObject(jsonObject)
</code></pre>

<p>  case let value as NSArray:</p>

<pre><code>var jsonArray: [JSONValue] = []
for v in value {
  if let v = JSONValue.fromObject(v) {
    jsonArray.append(v)
  } else {
    return nil
  }
}
return JSONValue.JSONArray(jsonArray)
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}
```</p>

<h3>Putting it into practice</h3>

<p>现在让我们使用JSON.swift来完成JSON的解析，进过比较，现在只需要两层嵌套就完成了原来五层的嵌套解析，而且由于使用了Optional类型，也增加了安全性。所以在Swift中一定要注重利用enum这些新特性，它非常适用于可以预定义为一组不同的子类型的类型，就像JSON。</p>

<p>```objectivec
let json = &ldquo;{\"success\&rdquo;:true,\&ldquo;data\&rdquo;:{\&ldquo;numbers\&rdquo;:[1,2,3,4,5],\&ldquo;animal\&rdquo;:\&ldquo;dog\&rdquo;}}"</p>

<p>if let jsonData = (json as NSString).dataUsingEncoding(NSUTF8StringEncoding) {
  if let parsed: AnyObject = NSJSONSerialization.JSONObjectWithData(jsonData, options: NSJSONReadingOptions(0), error: nil) {</p>

<pre><code>if let jsonParsed = JSONValue.fromObject(parsed) {

  // Actual JSON parsing section
  if jsonParsed["success"]?.bool == true {
    if let numbers = jsonParsed["data"]?["numbers"]?.array {
      print(numbers)
    }
    if let animal = jsonParsed["data"]?["animal"]?.string {
      print(animal)
    }
  }
}
</code></pre>

<p>  }
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CALayer&amp;CoreAnimation]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/09/calayer-and-coreanimation/"/>
    <updated>2015-11-09T10:18:03+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/09/calayer-and-coreanimation</id>
    <content type="html"><![CDATA[<p>这两天打算系统的整理一下CALayer和CoreAnimation相关的知识，之前开发中只是在具体场景中使用时才会去找相应的解决方法，而没有系统的进行整理，所以打算开一篇专门介绍。这一篇<a href="http://www.cnblogs.com/kenshincui/p/3972100.html">博客</a>也做了详尽的介绍，本文的思路也与其基本一致，另外会记录自己的一些理解。</p>

<!--more-->


<h2>CALayer相关</h2>

<p>CALayer包含在QuartzCore框架中。它与UIView的区别是，UIView是UIResponder的子类，是可以接受事件并做出响应的，而CALayer是NSObject的子类，它只是用来展示内容的类。而UIView有一个layer属性就是用来绘制其图像的，而复杂的图层结构在CALayer中是以树的形式存储的，而CoreAnimation中的动画都是在CALayer上进行操作的，可能我们在开发中大部分是直接在UIView组织动画，而这些其实是CoreAnimation在UIView层的封装，本质还是对其layer属性进行操作。</p>

<p><img src="http://lucifer1988.github.io/images/CALayerTree.png"></p>

<h3>CALayer属性</h3>

<p>下表列出了CALayer常用的一些属性：</p>

<table>
<thead>
<tr>
<th></th>
<th> 属性 </th>
<th> 说明 </th>
<th align="center"> 是否支持隐式动画 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> anchorPoint </td>
<td> 锚点，CGPoint类型，默认为(0.5,0.5)，可以理解为layer的重心，始终与position位置重合 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> backgroundColor </td>
<td> 背景色  </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> borderColor </td>
<td> 边框颜色  </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> borderWidth </td>
<td> 边框宽度  </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> bounds </td>
<td> 范围大小  </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> contents </td>
<td> id类型，layer显示内容，通常是CGImageRef类型 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> contentsRect </td>
<td> layer内容的位置和范围  </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> cornerRadius </td>
<td> 圆角半径 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> doubleSided </td>
<td> 图层背面是否显示，默认YES  </td>
<td align="center"> 否 </td>
</tr>
<tr>
<td></td>
<td> frame </td>
<td> layer的位置和范围，由于不支持隐式动画，所以改变layer的位置和大小，通常使用修改bounds和position来替代 </td>
<td align="center"> 否 </td>
</tr>
<tr>
<td></td>
<td> hidden </td>
<td> 是否隐藏 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> mask </td>
<td> 图层蒙版 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> maskToBounds </td>
<td> 子图层是否剪切图层边界，默认NO </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> opacity </td>
<td> 透明度，类似UIView的alpha </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> position </td>
<td> layer中心位置，类似UIView的center </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> shadowColor </td>
<td> 阴影颜色 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> shadowOffset </td>
<td> 阴影偏移量 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> shadowOpacity </td>
<td> 阴影透明度，默认为0，所以设置阴影时必须设置此值 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> shadowPath</td>
<td> 阴影形状 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> shadowRadius </td>
<td> 阴影模糊半径 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> sublayers </td>
<td> 子图层数组 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> sublayerTransform </td>
<td> 子图层形变 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> transform </td>
<td> 图层形变 </td>
<td align="center"> 是 </td>
</tr>
</tbody>
</table>


<h3>隐式动画</h3>

<p>CALayer很多属性在修改时就能形成动画，被称为隐式动画，但是需要注意UIView的根视图layer的属性修改并不会形成动画，因为根图层一般是作为容器来使用，修改它的属性可能会直接影响子图层。另外，UIView的根图层是由系统创建的，而无法重新创建，但可以添加子图层。</p>

<p>隐式动画的本质是这些属性的变化默认实现了CABasicAnimation，具体见<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/AnimatableProperties/AnimatableProperties.html#//apple_ref/doc/uid/TP40004514-CH11-SW2">Apple文档</a>，具体示例见<a href="https://github.com/lucifer1988/AnimationCase">AnimationCase</a>中的AnimatablePropertiesTest。</p>

<p>```objectivec
@interface ACAnimatablePropertiesViewController () {</p>

<pre><code>CALayer *layer;
</code></pre>

<p>}</p>

<p>@end</p>

<p>static CGFloat width = 150.0;</p>

<p>@implementation ACAnimatablePropertiesViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  layer = [[CALayer alloc] init];
  layer.bounds = CGRectMake(0, 0, width, width);
  layer.position = self.view.center;
  layer.backgroundColor = [UIColor blueColor].CGColor;
  layer.cornerRadius = width/2;</p>

<p>  layer.shadowColor = [UIColor grayColor].CGColor;
  layer.shadowOffset = CGSizeMake(2, 3);
  layer.shadowOpacity = 0.9;</p>

<p>  layer.borderWidth = 2.0;
  layer.borderColor = [UIColor greenColor].CGColor;</p>

<p>  [self.view.layer addSublayer:layer];
}</p></li>
<li><p>(void)touchesEnded:(NSSet<UITouch *> <em>)touches withEvent:(UIEvent </em>)event {
  UITouch *touch = [touches anyObject];
  CGFloat randWidth = arc4random()%200+100;
  layer.bounds = CGRectMake(0, 0, randWidth, randWidth);
  layer.cornerRadius = randWidth/2;
  layer.position = [touch locationInView:self.view];
  layer.backgroundColor = [UIColor colorWithRed:arc4random()%225/225.0 green:arc4random()%225/225.0 blue:arc4random()%225/225.0 alpha:1.0].CGColor;
  layer.borderColor = [UIColor colorWithRed:arc4random()%225/225.0 green:arc4random()%225/225.0 blue:arc4random()%225/225.0 alpha:1.0].CGColor;
}</p></li>
</ul>


<p>@end
```</p>

<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Reference/CALayer_class/index.html#//apple_ref/occ/instp/CALayer/anchorPoint">AnchorPoint</a>的作用：图层的锚点，范围在（0~1,0~1）表示在x、y轴的比例，这个点永远可以同position重合，当图层中心点固定后，调整anchorPoint即可达到调整图层显示位置的作用（因为它永远和position重合），类似旋转动画中，改变anchorPoint的值可以改变旋转的中心位置，详见<a href="https://github.com/lucifer1988/AnimationCase">AnimationCase</a>中的AnchorPointTest。</p>

<p>```objectivec
@interface ACAnchorPointViewController () <UITextFieldDelegate> {</p>

<pre><code>CALayer *layer;
</code></pre>

<p>}</p>

<p>@property (weak, nonatomic) IBOutlet UITextField <em>xField;
@property (weak, nonatomic) IBOutlet UITextField </em>yField;</p>

<p>@end</p>

<p>@implementation ACAnchorPointViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  layer = [[CALayer alloc] init];
  layer.backgroundColor = [UIColor lightGrayColor].CGColor;
  layer.position = self.view.center;
  layer.bounds = CGRectMake(0, 0, 150.0, 150.0);</p>

<p>  CABasicAnimation <em>rotationAnimation = [CABasicAnimation animationWithKeyPath:@&ldquo;transform.rotation.z&rdquo;];
  rotationAnimation.duration = 2;
  rotationAnimation.repeatCount = HUGE_VALF;
  rotationAnimation.removedOnCompletion = NO;
  rotationAnimation.fromValue = [NSNumber numberWithFloat:0];
  rotationAnimation.toValue = [NSNumber numberWithFloat:3.1415926</em>2];
  [layer addAnimation:rotationAnimation forKey:@&ldquo;rotationTransform&rdquo;];</p>

<p>  [self.view.layer addSublayer:layer];
}</p></li>
</ul>


<h1>pragma mark &ndash; UITextFieldDelegate</h1>

<ul>
<li>(BOOL)textFieldShouldReturn:(UITextField <em>)textField {
  double value = textField.text.length ? textField.text.doubleValue : 0.5;
  if (value &lt; 0 || value > 1) {
      UIAlertController </em>alert = [UIAlertController alertControllerWithTitle:@&ldquo;输入值必须介于0到1&rdquo; message:nil preferredStyle:UIAlertControllerStyleAlert];
      [alert addAction:[UIAlertAction actionWithTitle:@&ldquo;我知道了&rdquo; style:UIAlertActionStyleCancel handler:nil]];
      [self presentViewController:alert animated:YES completion:nil];
      return NO;
  }
  if (textField == self.xField) {
      CGPoint point = layer.anchorPoint;
      point.x = value;
      layer.anchorPoint = point;
  } else {
      CGPoint point = layer.anchorPoint;
      point.y = value;
      layer.anchorPoint = point;
  }
  [textField resignFirstResponder];
  return YES;
}</li>
</ul>


<p>@end
```</p>

<h3>CALayer绘图</h3>

<p>CALayer的绘图方法主要有两种，不过都需要调用layer的setNeedDisplay方法（需要注意的是必须是layer调用，而不是UIView，因为UIView也有一个setNeedDisplay方法）。</p>

<ul>
<li>通过实现代理方法<strong>drawLayer:inContext:</strong>来绘制</li>
<li>通过自定义图层<strong>drawInContext:</strong>来绘制</li>
</ul>


<h4>实现代理方法绘制layer</h4>

<p>通过代理方法进行图层绘图只要指定图层的代理，然后在代理对象中重写-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx方法即可。需要注意这个方法虽然是代理方法但是不用手动实现CALayerDelegate，因为CALayer定义中给NSObject做了分类扩展，所有的NSObject都包含这个方法。另外设置完代理后必须要调用图层的setNeedDisplay方法，否则绘制的内容无法显示。</p>

<p>使用代理方法绘制图形、图像时在drawLayer:inContext:方法中可以通过事件参数获得绘制的图层和图形上下文。在这个方法中绘图时所有的位置都是相对于图层而言的，图形上下文指的也是当前图层的图形上下文，详见<a href="https://github.com/lucifer1988/AnimationCase">AnimationCase</a>中的DrawLayerByDelegateTest。</p>

<p>```objectivec
@interface ACDrawLayerByDelegateViewController () {</p>

<pre><code>CALayer *layer;
</code></pre>

<p>}</p>

<p>@end</p>

<p>static CGFloat width = 150.0;</p>

<p>@implementation ACDrawLayerByDelegateViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  layer = [[CALayer alloc] init];
  layer.bounds = CGRectMake(0, 0, width, width);
  layer.position = self.view.center;
  layer.backgroundColor = [UIColor blueColor].CGColor;
  layer.cornerRadius = width/2;
  layer.masksToBounds = YES;</p>

<p>  layer.borderWidth = 2.0;
  layer.borderColor = [UIColor grayColor].CGColor;</p>

<p>  layer.delegate = self;</p>

<p>  [self.view.layer addSublayer:layer];</p>

<p>  [layer setNeedsDisplay];
}</p></li>
<li><p>(void)dealloc {
  layer.delegate = nil;
}</p></li>
</ul>


<h1>pragma mark &ndash; layer delegate</h1>

<ul>
<li><p>(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx {
  CGContextSaveGState(ctx);</p>

<p>  CGContextScaleCTM(ctx, 1, -1);
  CGContextTranslateCTM(ctx, 0, -width);</p>

<p>  UIImage *image = [UIImage imageNamed:@&ldquo;avatar.png&rdquo;];
  CGContextDrawImage(ctx, CGRectMake(0, 0, width, width), image.CGImage);</p>

<p>  CGContextRestoreGState(ctx);
}</p></li>
</ul>


<p>@end
```</p>

<p>另外需要注意的是上面代码中绘制图片圆形裁切效果时如果不设置masksToBounds是无法显示圆形，但是对于其他图形却没有这个限制。原因就是当绘制一张图片到图层上的时候会重新创建一个图层添加到当前图层，这样一来如果设置了圆角之后虽然底图层有圆角效果，但是子图层还是矩形，只有设置了masksToBounds为YES让子图层按底图层剪切才能显示圆角效果。同样的，有些朋友经常在网上提问说为什么使用UIImageView的layer设置圆角后图片无法显示圆角，只有设置masksToBounds才能出现效果，也是类似的问题。</p>

<h4>自定义layer来绘制</h4>

<p>在自定义图层中绘图时只要自己编写一个类继承于CALayer然后在drawInContext:中绘图即可。同前面在代理方法绘图一样，要显示图层中绘制的内容也要调用图层的setNeedDisplay方法，否则drawInContext方法将不会调用，详见<a href="https://github.com/lucifer1988/AnimationCase">AnimationCase</a>中的DrawLayerByCustomTest。</p>

<p>```objectivec
@implementation ACCustomLayer</p>

<ul>
<li><p>(void)drawInContext:(CGContextRef)ctx {
  CGContextSetRGBFillColor(ctx, 135.0/255.0, 232.0/255.0, 84.0/255.0, 1);
  CGContextSetRGBStrokeColor(ctx, 135.0/255.0, 232.0/255.0, 84.0/255.0, 1);
  CGPoint center = CGPointMake(width/2, width/2);
  CGContextMoveToPoint(ctx, center.x, center.y &ndash; 60.0);
  for(int i = 1; i &lt; 5; ++i) {
      CGFloat x = 60.0 * sinf(i * 4.0 * M_PI / 5.0);
      CGFloat y = 60.0 * cosf(i * 4.0 * M_PI / 5.0);
      CGContextAddLineToPoint(ctx, center.x &ndash; x, center.y &ndash; y);
      NSLog(@&ldquo;x:%f, y:%f&rdquo;, center.x &ndash; x, center.y &ndash; y);
  }</p>

<p>  CGContextClosePath(ctx);</p>

<p>  CGContextDrawPath(ctx, kCGPathFillStroke);
}</p></li>
</ul>


<p>@end
```</p>

<p>```objectivec
@interface ACDrawLayerCustomViewController ()</p>

<p>@end</p>

<p>@implementation ACDrawLayerCustomViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  ACCustomLayer *layer = [[ACCustomLayer alloc] init];
  layer.bounds = CGRectMake(0, 0, width, width);
  layer.position = self.view.center;
  layer.backgroundColor = [UIColor blueColor].CGColor;</p>

<p>  [self.view.layer addSublayer:layer];
  [layer setNeedsDisplay];
}</p></li>
</ul>


<p>@end
```</p>

<h3>带阴影效果的圆形图片裁切</h3>

<p>如果设置了masksToBounds=YES之后确实可以显示图片圆角效果，但遗憾的是设置了这个属性之后就无法设置阴影效果。因为masksToBounds=YES就意味着外边框不能显示，而阴影恰恰作为外边框绘制的，这样两个设置就产生了矛盾。要解决这个问题不妨换个思路:使用两个大小一样的图层，下面的图层负责绘制阴影，上面的图层用来显示图片。</p>

<p>```objectivec
@interface ACCircleAvatarWithShadowViewController () {</p>

<pre><code>CALayer *layer;
</code></pre>

<p>}</p>

<p>@end</p>

<p>static CGFloat width = 150.0;</p>

<p>@implementation ACCircleAvatarWithShadowViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  CALayer *shadowLayer = [[CALayer alloc] init];
  shadowLayer.bounds = CGRectMake(0, 0, width, width);
  shadowLayer.position = self.view.center;
  shadowLayer.backgroundColor = [UIColor whiteColor].CGColor;
  shadowLayer.cornerRadius = width/2;
  shadowLayer.shadowOffset = CGSizeMake(2, 2);
  shadowLayer.shadowColor = [UIColor grayColor].CGColor;
  shadowLayer.shadowOpacity = 1.0;</p>

<p>  [self.view.layer addSublayer:shadowLayer];</p>

<p>  layer = [[CALayer alloc] init];
  layer.bounds = CGRectMake(0, 0, width, width);
  layer.position = self.view.center;
  layer.backgroundColor = [UIColor blueColor].CGColor;
  layer.cornerRadius = width/2;
  layer.masksToBounds = YES;</p>

<p>  layer.borderWidth = 2.0;
  layer.borderColor = [UIColor grayColor].CGColor;</p>

<p>  layer.delegate = self;</p>

<p>  [self.view.layer addSublayer:layer];</p>

<p>  [layer setNeedsDisplay];
}</p></li>
<li><p>(void)dealloc
{
  layer.delegate = nil;
}</p></li>
</ul>


<h1>pragma mark &ndash; layer delegate</h1>

<ul>
<li><p>(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx {
  CGContextSaveGState(ctx);</p>

<p>  CGContextScaleCTM(ctx, 1, -1);
  CGContextTranslateCTM(ctx, 0, -width);</p>

<p>  UIImage *image = [UIImage imageNamed:@&ldquo;avatar.png&rdquo;];
  CGContextDrawImage(ctx, CGRectMake(0, 0, width, width), image.CGImage);</p>

<p>  CGContextRestoreGState(ctx);
}</p></li>
</ul>


<p>@end
```</p>

<h3>CALayer形变</h3>

<p>从上面代码中大家不难发现使用Core Graphics绘制图片时会倒立显示，对图层的图形上下文进行了反转。可以控制图层直接旋转而不用借助于图形上下文的形变操作。对于上面的程序，只需要设置图层的transform属性即可。需要注意的是transform是CATransform3D类型，形变可以在三个维度上进行，而且都有对应的形变设置方法（如：CATransform3DMakeTranslation()、CATransform3DMakeScale()、CATransform3DMakeRotation()）。</p>

<p>事实上如果仅仅就显示一张图片在图层中当然没有必要那么麻烦，直接设置图层contents就可以了，不牵涉到绘图也就没有倒立的问题了。</p>

<p>```objectivec
//Plan B
CALayer <em>anotherlayer = [[CALayer alloc] init];
anotherlayer.bounds = CGRectMake(0, 0, width, width);
center = self.view.center;
center.y += width;
anotherlayer.position = center;
anotherlayer.backgroundColor = [UIColor blueColor].CGColor;
anotherlayer.cornerRadius = width/2;
anotherlayer.masksToBounds = YES;
anotherlayer.borderColor = [UIColor grayColor].CGColor;
anotherlayer.borderWidth = 2.0;
UIImage </em>image=[UIImage imageNamed:@&ldquo;avatar.png&rdquo;];
[anotherlayer setContents:(id)image.CGImage];</p>

<p>[self.view.layer addSublayer:anotherlayer];
```</p>

<p>在动画开发中形变往往不是直接设置transform，而是通过keyPath进行设置。这种方法设置形变的本质和前面没有区别，只是利用了KVC可以动态修改其属性值而已，但是这种方式在动画中确实很常用的，因为它可以很方便的将几种形变组合到一起使用。key path的所有设置类型，见<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html#//apple_ref/doc/uid/TP40004514-CH12-SW1">Apple文档</a>，同样是解决动画旋转问题，只要将前面的旋转代码改为下面的代码即可：</p>

<p><code>objectivec
[layer setValue:@M_PI forKeyPath:@"transform.rotation.x"];
</code></p>

<h2>CoreAnimation相关</h2>

<p>在iOS中CoreAnimation分为几类：基础动画、关键帧动画、动画组、转场动画。各个类的关系大致如下：</p>

<p><img src="http://lucifer1988.github.io/images/CAAnimationTree.png"></p>

<ul>
<li>CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议。</li>
<li>CAPropertyAnimation：属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用。</li>
<li>CAAnimationGroup：动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行。</li>
<li>CATransition：转场动画，主要通过滤镜进行动画效果设置。</li>
<li>CABasicAnimation：基础动画，通过属性修改进行动画参数控制，只有初始状态和结束状态。</li>
<li>CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制。</li>
</ul>


<p>基础动画、关键帧动画都属于属性动画，就是通过修改属性值产生动画效果，开发人员只需要设置初始值和结束值，中间的过程动画（又叫“补间动画”）由系统自动计算产生。和基础动画不同的是关键帧动画可以设置多个属性值，每两个属性中间的补间动画由系统自动完成，因此从这个角度而言基础动画又可以看成是有两个关键帧的关键帧动画。</p>

<h3>基础动画</h3>

<p>在开发过程中很多情况下通过基础动画就可以满足开发需求，使用的UIView代码块制作的动画也是基础动画（在iOS7中UIView也对关键帧动画进行了封装），只是UIView装饰方法隐藏了更多的细节。如果不使用UIView封装的方法，动画创建一般分为以下几步：</p>

<ol>
<li><p>初始化动画并设置动画属性</p></li>
<li><p>设置动画属性初始值（可以省略）、结束值以及其他动画属性</p></li>
<li><p>给图层添加动画</p></li>
</ol>


<h4>移动动画</h4>

<p>下面以一个移动动画为例进行演示，在这个例子中点击屏幕哪个位置落花将飞向哪里：</p>

<p>```objectivec
@interface ACMoveAnimationViewController () {</p>

<pre><code>CALayer *petalLayer;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation ACMoveAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.
  UIImage *backgroundImage = [UIImage imageNamed:@&ldquo;background.jpg&rdquo;];
  self.view.layer.contents = (id)backgroundImage.CGImage;</p>

<p>  petalLayer = [[CALayer alloc] init];
  petalLayer.bounds = CGRectMake(0, 0, 10, 20);
  petalLayer.position = CGPointMake(50, 150);
  petalLayer.contents = (id)[UIImage imageNamed:@&ldquo;petal.png&rdquo;].CGImage;</p>

<p>  [self.view.layer addSublayer:petalLayer];
}</p></li>
<li><p>(void)touchesEnded:(NSSet<UITouch *> <em>)touches withEvent:(UIEvent </em>)event {
  UITouch *touch = touches.anyObject;
  [self animationMoveTo:[touch locationInView:self.view]];
}</p></li>
</ul>


<h1>pragma mark &ndash; Animation</h1>

<ul>
<li>(void)animationMoveTo:(CGPoint)location {
  CABasicAnimation *moveAnimation = [CABasicAnimation animationWithKeyPath:@&ldquo;position&rdquo;];
  moveAnimation.toValue = [NSValue valueWithCGPoint:location];
  moveAnimation.duration = 5.0;
  moveAnimation.repeatCount = 0;
  moveAnimation.removedOnCompletion = YES;
  [petalLayer addAnimation:moveAnimation forKey:@&ldquo;petalLayer_moveAnimation&rdquo;];
}</li>
</ul>


<p>@end
```</p>

<h4>完整移动动画</h4>

<p>上面实现了一个基本动画效果，但是这个动画存在一个问题：动画结束后动画图层回到了原来的位置。</p>

<p>图层动画的本质就是将图层内部的内容转化为位图经硬件操作形成一种动画效果，其实图层本身并没有任何的变化。上面的动画中图层并没有因为动画效果而改变它的位置（对于缩放动画其大小也是不会改变的），所以动画完成之后图层还是在原来的显示位置没有任何变化，如果这个图层在一个UIView中你会发现在UIView移动过程中你要触发UIView的点击事件也只能点击原来的位置（即使它已经运动到了别的位置），因为它的位置从来没有变过。</p>

<p>通过给动画设置一个代理去监听动画的开始和结束事件，在动画开始前给动画添加一个自定义属性“petalLayer_moveAnimation_destination”存储动画终点位置，然后在动画结束后设置动画的位置为终点位置。在<strong>&ndash; (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag</strong>中设置代码关闭了position的隐式动画，否则会导致两次移动，另外添加了使花瓣匀速移动的时间计算，和防止多次点击的flag控制。</p>

<p>```objectivec
@interface ACMoveAnimationFullEditionViewController () {</p>

<pre><code>CALayer *petalLayer;
BOOL isMoving;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation ACMoveAnimationFullEditionViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];</p>

<p>  isMoving = NO;
  UIImage *backgroundImage = [UIImage imageNamed:@&ldquo;background.jpg&rdquo;];
  self.view.layer.contents = (id)backgroundImage.CGImage;</p>

<p>  petalLayer = [[CALayer alloc] init];
  petalLayer.bounds = CGRectMake(0, 0, 10, 20);
  petalLayer.position = CGPointMake(50, 150);
  petalLayer.contents = (id)[UIImage imageNamed:@&ldquo;petal.png&rdquo;].CGImage;</p>

<p>  [self.view.layer addSublayer:petalLayer];
}</p></li>
<li><p>(void)didReceiveMemoryWarning {
  [super didReceiveMemoryWarning];
  // Dispose of any resources that can be recreated.
}</p></li>
<li><p>(void)touchesEnded:(NSSet<UITouch *> <em>)touches withEvent:(UIEvent </em>)event {
  if (isMoving) {
      return;
  }</p>

<p>  UITouch *touch = touches.anyObject;
  [self animationMoveTo:[touch locationInView:self.view]];
}</p></li>
</ul>


<h1>pragma mark &ndash; Animation</h1>

<ul>
<li><p>(void)animationMoveTo:(CGPoint)location {
  CABasicAnimation *moveAnimation = [CABasicAnimation animationWithKeyPath:@&ldquo;position&rdquo;];
  moveAnimation.toValue = [NSValue valueWithCGPoint:location];
  moveAnimation.duration = [self petalMoveDuring:location];
  moveAnimation.repeatCount = 0;
  moveAnimation.removedOnCompletion = YES;</p>

<p>  moveAnimation.delegate = self;
  [moveAnimation setValue:[NSValue valueWithCGPoint:location] forKey:@&ldquo;petalLayer_moveAnimation_destination&rdquo;];</p>

<p>  [petalLayer addAnimation:moveAnimation forKey:@&ldquo;petalLayer_moveAnimation&rdquo;];
}</p></li>
<li><p>(NSTimeInterval)petalMoveDuring:(CGPoint)destination {
  CGFloat deltaX = destination.x &ndash; petalLayer.position.x;
  CGFloat deltaY = destination.y &ndash; petalLayer.position.y;
  CGFloat distance = sqrt(deltaX<em>deltaX + deltaY</em>deltaY);
  return (NSTimeInterval)distance/50.0;
}</p></li>
</ul>


<h1>pragma mark &ndash; Animation Delegate</h1>

<ul>
<li><p>(void)animationDidStart:(CAAnimation *)anim {
  isMoving = YES;
}</p></li>
<li><p>(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag {
  [CATransaction begin];
  //禁用隐式动画
  [CATransaction setDisableActions:YES];
  petalLayer.position=[[anim valueForKey:@&ldquo;petalLayer_moveAnimation_destination&rdquo;] CGPointValue];
  [CATransaction commit];
  isMoving = NO;
}</p></li>
</ul>


<p>@end
```</p>

<h4>旋转动画</h4>

<p>图层的形变都是基于锚点进行的。例如旋转，旋转的中心点就是图层的锚点，这在最开始的锚点例子中也有介绍。</p>

<p>需要注意的是只给移动动画设置了代理，在旋转动画中并没有设置代理，否则代理方法会执行两遍。由于旋转动画会无限循环执行（上面设置了重复次数无穷大），并且两个动画的执行时间没有必然的关系，这样一来移动停止后可能还在旋转，为了让移动动画停止后旋转动画停止就需要使用到动画的暂停和恢复方法。</p>

<p>核心动画的运行有一个媒体时间的概念，假设将一个旋转动画设置旋转一周用时60秒的话，那么当动画旋转90度后媒体时间就是15秒。如果此时要将动画暂停只需要让媒体时间偏移量设置为15秒即可，并把动画运行速度设置为0使其停止运动。类似的，如果又过了60秒后需要恢复动画（此时媒体时间为75秒），这时只要将动画开始开始时间设置为当前媒体时间75秒减去暂停时的时间（也就是之前定格动画时的偏移量）15秒（开始时间=75-15=60秒），那么动画就会重新计算60秒后的状态再开始运行，与此同时将偏移量重新设置为0并且把运行速度设置1。这个过程中真正起到暂停动画和恢复动画的其实是动画速度的调整，媒体时间偏移量以及恢复时的开始时间设置主要为了让动画更加连贯。</p>

<p>```objectivec
&ndash; (void)animationRotate {</p>

<pre><code>CABasicAnimation *rotateAnimation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.z"];
rotateAnimation.duration = 6;
rotateAnimation.repeatCount = HUGE_VALF;
rotateAnimation.removedOnCompletion = NO;
rotateAnimation.autoreverses = YES;
rotateAnimation.toValue = [NSNumber numberWithFloat:M_PI_2*3];
[petalLayer addAnimation:rotateAnimation forKey:@"petalLayer_rotationAnimation"];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)animationPause {
  //取得指定图层动画的媒体时间，后面参数用于指定子图层，这里不需要
  CFTimeInterval interval = [petalLayer convertTime:CACurrentMediaTime() fromLayer:nil];
  //设置时间偏移量，保证暂停时停留在旋转的位置
  [petalLayer setTimeOffset:interval];
  //速度设置为0，暂停动画
  petalLayer.speed = 0;
}</p></li>
<li><p>(void)animationResume {
  //获得暂停的时间
  CFTimeInterval beginTime = CACurrentMediaTime() &ndash; petalLayer.timeOffset;
  //设置偏移量
  petalLayer.timeOffset = 0;
  //设置开始时间
  petalLayer.beginTime = beginTime;
  //设置动画速度，开始运动
  petalLayer.speed = 1.0;
}
```</p></li>
</ul>


<h3>关键帧动画</h3>

<p>熟悉flash开发的朋友对于关键帧动画应该不陌生，这种动画方式在flash开发中经常用到。关键帧动画就是在动画控制过程中开发者指定主要的动画状态，至于各个状态间动画如何进行则由系统自动运算补充（每两个关键帧之间系统形成的动画称为“补间动画”），这种动画的好处就是开发者不用逐个控制每个动画帧，而只要关心几个关键帧的状态即可。</p>

<p>关键帧动画开发分为两种形式：一种是通过设置不同的属性值进行关键帧控制，另一种是通过绘制路径进行关键帧控制。后者优先级高于前者，如果设置了路径则属性值就不再起作用。</p>

<h4>设置属性值的关键帧控制</h4>

<p>对于前面的落花动画效果而言其实落花的过程并不自然，很显然实际生活中它不可能沿着直线下落，这里我们不妨通过关键帧动画的values属性控制它在下落过程中的属性。</p>

<p>```objectivec
@interface ACKeyFrameAnimationViewController () {</p>

<pre><code>CALayer *petalLayer;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation ACKeyFrameAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.
  UIImage *backgroundImage = [UIImage imageNamed:@&ldquo;background.jpg&rdquo;];
  self.view.layer.contents = (id)backgroundImage.CGImage;</p>

<p>  petalLayer = [[CALayer alloc] init];
  petalLayer.bounds = CGRectMake(0, 0, 10, 20);
  petalLayer.position = CGPointMake(50, 150);
  petalLayer.contents = (id)[UIImage imageNamed:@&ldquo;petal.png&rdquo;].CGImage;</p>

<p>  [self.view.layer addSublayer:petalLayer];</p>

<p>  [self addKeyframeMoveAnimation];
}</p></li>
<li><p>(void)didReceiveMemoryWarning {
  [super didReceiveMemoryWarning];
  // Dispose of any resources that can be recreated.
}</p></li>
</ul>


<h1>pragma mark &ndash; animation</h1>

<ul>
<li><p>(void)addKeyframeMoveAnimation {
  CAKeyframeAnimation <em>keyframeAnimation = [CAKeyframeAnimation animationWithKeyPath:@&ldquo;position&rdquo;];
  //关键帧动画的初始值不能省略
  NSValue </em>key1 = [NSValue valueWithCGPoint:petalLayer.position];
  NSValue <em>key2 = [NSValue valueWithCGPoint:CGPointMake(80, 320)];
  NSValue </em>key3 = [NSValue valueWithCGPoint:CGPointMake(45, 400)];
  NSValue <em>key4 = [NSValue valueWithCGPoint:CGPointMake(55, 500)];
  NSArray </em>values = @[key1, key2, key3, key4];</p>

<p>  keyframeAnimation.values = values;
  keyframeAnimation.duration = 8.0;
  keyframeAnimation.beginTime = CACurrentMediaTime()+2;
  keyframeAnimation.delegate = self;
  [keyframeAnimation setValue:key4 forKey:@&ldquo;petalLayer_keyframeAnimation_destination&rdquo;];</p>

<p>  [petalLayer addAnimation:keyframeAnimation forKey:@&ldquo;petalLayer_keyframeAnimation_position&rdquo;];
}</p></li>
</ul>


<h1>pragma mark &ndash; animation delegate</h1>

<ul>
<li><p>(void)animationDidStart:(CAAnimation *)anim {
}</p></li>
<li><p>(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag {
  [CATransaction begin];
  [CATransaction setDisableActions:YES];
  petalLayer.position = [[anim valueForKey:@&ldquo;petalLayer_keyframeAnimation_destination&rdquo;] CGPointValue];
  [CATransaction commit];
}</p></li>
</ul>


<p>@end
```</p>

<h4>通过设置路径的关键帧控制</h4>

<p>上面的方式固然比前面使用基础动画效果要好一些，但其实还是存在问题，那就是落花飞落的路径是直线的，当然这个直线是根据程序中设置的四个关键帧自动形成的，那么如何让它沿着曲线飘落呢？这就是第二种类型的关键帧动画，通过描绘路径进行关键帧动画控制。假设让落花沿着一条贝塞尔曲线飘落：</p>

<p>```objectivec
&ndash; (void)addKeyframeMoveAnimation {</p>

<pre><code>CAKeyframeAnimation *keyframeAnimation = [CAKeyframeAnimation animationWithKeyPath:@"position"];

CGMutablePathRef path = CGPathCreateMutable();
CGPathMoveToPoint(path, NULL, petalLayer.position.x, petalLayer.position.y);
CGPathAddCurveToPoint(path, NULL, 300, 250, -100, 450, 100, 550);

keyframeAnimation.path = path;
CGPathRelease(path);
keyframeAnimation.duration = 8.0;
keyframeAnimation.beginTime = CACurrentMediaTime()+2;
keyframeAnimation.delegate = self;
[keyframeAnimation setValue:[NSValue valueWithCGPoint:CGPointMake(100, 550)] forKey:@"petalLayer_keyframeAnimation_destination"];

[petalLayer addAnimation:keyframeAnimation forKey:@"petalLayer_keyframeAnimation_position"];
</code></pre>

<p>}
```</p>

<h4>关键帧动画的其他重要属性</h4>

<ul>
<li>keyTimes：各个关键帧的时间控制。前面使用values设置了四个关键帧，默认情况下每两帧之间的间隔为:8/(4-1)秒。如果想要控制动画从第一帧到第二针占用时间4秒，从第二帧到第三帧时间为2秒，而从第三帧到第四帧时间2秒的话，就可以通过keyTimes进行设置。keyTimes中存储的是时间占用比例点，此时可以设置keyTimes的值为0.0，0.5，0.75，1.0（当然必须转换为NSNumber），也就是说1到2帧运行到总时间的50%，2到3帧运行到总时间的75%，3到4帧运行到8秒结束。</li>
<li>caculationMode：动画计算模式。还拿上面keyValues动画举例，之所以1到2帧能形成连贯性动画而不是直接从第1帧经过8/3秒到第2帧是因为动画模式是连续的（值为kCAAnimationLinear，这是计算模式的默认值）；而如果指定了动画模式为kCAAnimationDiscrete离散的那么你会看到动画从第1帧经过8/3秒直接到第2帧，中间没有任何过渡。其他动画模式还有：kCAAnimationPaced（均匀执行，会忽略keyTimes）、kCAAnimationCubic（平滑执行，对于位置变动关键帧动画运行轨迹更平滑）、kCAAnimationCubicPaced（平滑均匀执行）。</li>
</ul>


<p><img src="http://lucifer1988.github.io/images/caculationMode.png"></p>

<h3>组合动画</h3>

<p>实际开发中一个物体的运动往往是复合运动，单一属性的运动情况比较少，但恰恰属性动画每次进行动画设置时一次只能设置一个属性进行动画控制(不管是基础动画还是关键帧动画都是如此)，这样一来要做一个复合运动的动画就必须创建多个属性动画进行组合。对于一两种动画的组合或许处理起来还比较容易，但是对于更多动画的组合控制往往会变得很麻烦，动画组的产生就是基于这样一种情况而产生的。动画组是一系列动画的组合，凡是添加到动画组中的动画都受控于动画组，这样一来各类动画公共的行为就可以统一进行控制而不必单独设置，而且放到动画组中的各个动画可以并发执行，共同构建出复杂的动画效果。</p>

<p>动画组使用起来并不复杂，首先单独创建单个动画（可以是基础动画也可以是关键帧动画），然后将基础动画添加到动画组，最后将动画组添加到图层即可。</p>

<p>前面关键帧动画部分，路径动画看起来效果虽然很流畅，但是落花本身的旋转运动没有了，这里不妨将基础动画部分的旋转动画和路径关键帧动画进行组合使得整个动画看起来更加的和谐、顺畅。</p>

<p>```objectivec
@interface ACGroupAnimationViewController () {</p>

<pre><code>CALayer *petalLayer;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation ACGroupAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  UIImage *backgroundImage = [UIImage imageNamed:@&ldquo;background.jpg&rdquo;];
  self.view.layer.contents = (id)backgroundImage.CGImage;</p>

<p>  petalLayer = [[CALayer alloc] init];
  petalLayer.bounds = CGRectMake(0, 0, 10, 20);
  petalLayer.position = CGPointMake(100, 150);
  petalLayer.contents = (id)[UIImage imageNamed:@&ldquo;petal.png&rdquo;].CGImage;</p>

<p>  [self.view.layer addSublayer:petalLayer];</p>

<p>  [self addAnimationGroup];
}</p></li>
<li><p>(void)addAnimationGroup {
  CAAnimationGroup *animationGroup = [CAAnimationGroup animation];</p>

<p>  CABasicAnimation <em>rotateAnimation = [self rotateAnimation];
  CAKeyframeAnimation </em>keyframeMoveAnimation = [self keyframeMoveAnimation];
  animationGroup.animations = @[rotateAnimation, keyframeMoveAnimation];</p>

<p>  animationGroup.delegate = self;
  animationGroup.duration = 8.0;
  animationGroup.beginTime = CACurrentMediaTime()+2;</p>

<p>  [petalLayer addAnimation:animationGroup forKey:nil];
}</p></li>
<li><p>(CAKeyframeAnimation <em>)keyframeMoveAnimation {
  CAKeyframeAnimation </em>keyframeAnimation = [CAKeyframeAnimation animationWithKeyPath:@&ldquo;position&rdquo;];</p>

<p>  CGMutablePathRef path = CGPathCreateMutable();
  CGPathMoveToPoint(path, NULL, petalLayer.position.x, petalLayer.position.y);
  CGPathAddCurveToPoint(path, NULL, 300, 250, -100, 450, 100, 550);</p>

<p>  keyframeAnimation.path = path;
  CGPathRelease(path);
  [keyframeAnimation setValue:[NSValue valueWithCGPoint:CGPointMake(100, 550)] forKey:@&ldquo;petalLayer_keyframeAnimation_destination&rdquo;];
  return keyframeAnimation;
}</p></li>
<li><p>(CABasicAnimation <em>)rotateAnimation {
  CABasicAnimation </em>rotateAnimation = [CABasicAnimation animationWithKeyPath:@&ldquo;transform.rotation.z&rdquo;];
  rotateAnimation.repeatCount = HUGE_VALF;
  rotateAnimation.removedOnCompletion = NO;
  rotateAnimation.autoreverses = YES;
  rotateAnimation.toValue = [NSNumber numberWithFloat:M_PI_2<em>3];
  [rotateAnimation setValue:[NSNumber numberWithFloat:M_PI_2</em>3] forKey:@&ldquo;rotateAnimation_toValue&rdquo;];</p>

<p>  return rotateAnimation;
}</p></li>
</ul>


<h1>pragma mark &ndash; animation delegate</h1>

<ul>
<li><p>(void)animationDidStop:(CAAnimation <em>)anim finished:(BOOL)flag {
  CAAnimationGroup </em>animationGroup = (CAAnimationGroup <em>)anim;
  CABasicAnimation </em>rotateAnimation = (CABasicAnimation <em>)animationGroup.animations[0];
  CAKeyframeAnimation </em>keyframeMoveAnimation = (CAKeyframeAnimation *)animationGroup.animations[1];
  CGFloat toValue = [[rotateAnimation valueForKey:@&ldquo;rotateAnimation_toValue&rdquo;] floatValue];
  CGPoint toPoint = [[keyframeMoveAnimation valueForKey:@&ldquo;petalLayer_keyframeAnimation_destination&rdquo;] CGPointValue];</p>

<p>  [CATransaction begin];
  [CATransaction setDisableActions:YES];
  petalLayer.position = toPoint;
  petalLayer.transform = CATransform3DMakeRotation(toValue, 0, 0, 1);
  [CATransaction commit];
}</p></li>
</ul>


<p>@end
```</p>

<h3>转场动画</h3>

<p>转场动画就是从一个场景以动画的形式过渡到另一个场景。转场动画的使用一般分为以下几个步骤：</p>

<ol>
<li>创建转场动画</li>
<li>设置转场类型、子类型（可选）及其他属性</li>
<li>设置转场后的新视图并添加动画到图层</li>
</ol>


<p>Apple公开的只有四个转场动画类型：</p>

<ol>
<li>fade(kCATransitionFade，支持方向)</li>
<li>moveIn(kCATransitionMoveIn，支持方向)</li>
<li>push(kCATransitionPush，支持方向)</li>
<li>reveal(kCATransitionReveal，支持方向)</li>
</ol>


<p>另外还有一些私有API可以使用，但是只能用字符串来设置：</p>

<ol>
<li>cube(支持方向)</li>
<li>oglFlip(支持方向)</li>
<li>suckEffect(不支持方向)</li>
<li>rippleEffect(不支持方向)</li>
<li>pageCurl(支持方向)</li>
<li>pageUnCurl(支持方向)</li>
<li>cameraIrisHollowOpen(不支持方向)</li>
<li>cameraIrisHollowClose(不支持方向)</li>
</ol>


<p>支持方向的类型还可以选择四个subtype：</p>

<ol>
<li>kCATransitionFromRight</li>
<li>kCATransitionFromLeft</li>
<li>kCATransitionFromTop</li>
<li>kCATransitionFromBottom</li>
</ol>


<p>下面代码展示了全部效果：</p>

<p>```objectivec
@interface ACTransitionAnimationViewController () {</p>

<pre><code>UIImageView *imageView;
NSArray *transitionTypes;
</code></pre>

<p>}</p>

<p>@end</p>

<p>static int transitionTypeIndex;</p>

<p>@implementation ACTransitionAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.
  transitionTypes = @[@&ldquo;fade&rdquo;, @&ldquo;moveIn&rdquo;, @&ldquo;push&rdquo;, @&ldquo;reveal&rdquo;, @&ldquo;cube&rdquo;, @&ldquo;oglFlip&rdquo;, @&ldquo;suckEffect&rdquo;, @&ldquo;rippleEffect&rdquo;, @&ldquo;pageCurl&rdquo;, @&ldquo;pageUnCurl&rdquo;, @&ldquo;cameraIrisHollowOpen&rdquo;, @&ldquo;cameraIrisHollowClose&rdquo;];
  transitionTypeIndex = 0;</p>

<p>  imageView = [[UIImageView alloc] initWithFrame:[UIScreen mainScreen].bounds];
  [imageView setImage:[UIImage imageNamed:@&ldquo;background.jpg&rdquo;]];
  [self.view addSubview:imageView];</p>

<p>  UISwipeGestureRecognizer *swipeGesture = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipe:)];
  swipeGesture.direction = UISwipeGestureRecognizerDirectionLeft;
  [self.view addGestureRecognizer:swipeGesture];
}</p></li>
<li><p>(void)swipe:(UISwipeGestureRecognizer <em>)gestureRecognizer {
  if (transitionTypeIndex > 11) {
      transitionTypeIndex = 0;
  }
  CATransition </em>transition = [[CATransition alloc] init];
  transition.type = transitionTypes[transitionTypeIndex];
  transition.subtype = kCATransitionFromRight;
  transition.duration = 1.0;
  [imageView.layer addAnimation:transition forKey:@&ldquo;imageView_transition&rdquo;];</p>

<p>  transitionTypeIndex++;
}</p></li>
</ul>


<p>@end
```</p>

<h3>逐帧动画</h3>

<p>前面介绍了核心动画中大部分动画类型，但是做过动画处理的朋友都知道，在动画制作中还有一种动画类型“逐帧动画”。说到逐帧动画相信很多朋友第一个想到的就是UIImageView，通过设置UIImageView的animationImages属性，然后调用它的startAnimating方法去播放这组图片。当然这种方法在某些场景下是可以达到逐帧的动画效果，但是它也存在着很大的性能问题，并且这种方法一旦设置完图片中间的过程就无法控制了。</p>

<p>虽然在CoreAnimation中没有直接提供逐帧动画类型，但是却提供了用于完成逐帧动画的相关对象CADisplayLink。CADisplayLink是一个计时器，但是同NSTimer不同的是，CADisplayLink的刷新周期同屏幕完全一致。例如在iOS中屏幕刷新周期是60次/秒，CADisplayLink刷新周期同屏幕刷新一致也是60次/秒，这样一来使用它完成的逐帧动画（又称为“时钟动画”）完全感觉不到动画的停滞情况。</p>

<p>要将CADisplayLink加入到主线程的Runloop，它的时钟周期就和主运行循环保持一致，而主运行循环周期就是屏幕刷新周期。在CADisplayLink加入到主运行循环队列后就会循环调用目标方法，在这个方法中更新视图内容就可以完成逐帧动画。</p>

<p>当然这里不得不强调的是逐帧动画性能势必较低，但是对于一些事物的运动又不得不选择使用逐帧动画，例如人的运动，这是一个高度复杂的运动，基本动画、关键帧动画是不可能解决的。所大家一定要注意在循环方法中尽可能的降低算法复杂度，同时保证循环过程中内存峰值尽可能低。下面以一个鱼的运动为例为大家演示一下逐帧动画。</p>

<p>```objectivec
@interface ACFrameByFrameAnimationViewController () {</p>

<pre><code>UIImageView *imageView;
CALayer *layer;
NSMutableArray *imageArray;
</code></pre>

<p>}</p>

<p>@end</p>

<p>static int frameIndex = 0;</p>

<p>@implementation ACFrameByFrameAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  UIImage *backgroundImage = [UIImage imageNamed:@&ldquo;background1.png&rdquo;];
  self.view.layer.contents = (id)backgroundImage.CGImage;</p>

<p>  imageArray = [@[] mutableCopy];
  for (int i=0; i&lt;10; i++) {
      UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@&ldquo;fish%d.png&rdquo;, i]];
      [imageArray addObject:image];
  }</p>

<p>  //PlanA use UIImageView&rsquo;s AnimationImages
//    imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 87, 32)];
//    imageView.center = self.view.center;
//    imageView.animationDuration = imageArray.count/30;
//    [imageView setAnimationImages:imageArray];
//    [self.view addSubview:imageView];
//    [imageView startAnimating];</p>

<p>  //PlanB use CADisplayLink
  layer = [[CALayer alloc] init];
  layer.bounds = CGRectMake(0, 0, 87, 32);
  layer.position = self.view.center;
  [self.view.layer addSublayer:layer];</p>

<p>  CADisplayLink *displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(nextFrame)];
  [displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];
}</p></li>
</ul>


<p>//60fps
&ndash; (void)nextFrame {</p>

<pre><code>static int i = 0;
//30fps
if (++i%2 == 0) {
    UIImage *image = imageArray[frameIndex];
    layer.contents = (id)image.CGImage;
    frameIndex = (frameIndex+1)%10;
}
</code></pre>

<p>}</p>

<p>@end
```</p>

<h2>UIView动画封装</h2>

<p>其实UIView本身对于基本动画和关键帧动画、转场动画都有相应的封装，在对动画细节没有特殊要求的情况下使用起来也要简单的多。可以说在日常开发中90%以上的情况使用UIView的动画封装方法都可以搞定，因此在熟悉了核心动画的原理之后还是有必要给大家简单介绍一下UIView中各类动画使用方法的。</p>

<h3>基本动画</h3>

<h4>移动动画</h4>

<p>下面是之前移动动画在UIView层的封装，使用了block封装，也可以选用之前的beginAnimations单独设置，效果是一样的。</p>

<p>```objectivec
@interface ACViewMoveAnimationViewController () {</p>

<pre><code>UIImageView *petalView;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation ACViewMoveAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.
  UIImage *backgroundImage = [UIImage imageNamed:@&ldquo;background.jpg&rdquo;];
  self.view.layer.contents = (id)backgroundImage.CGImage;</p>

<p>  petalView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&ldquo;petal.png&rdquo;]];
  petalView.center = CGPointMake(50, 150);
  [self.view addSubview:petalView];
}</p></li>
<li><p>(void)touchesEnded:(NSSet<UITouch *> <em>)touches withEvent:(UIEvent </em>)event {
  UITouch <em>touch = touches.anyObject;
  CGPoint location = [touch locationInView:self.view];
  //方法1：block方式
  /</em>开始动画，UIView的动画方法执行完后动画会停留在重点位置，而不需要进行任何特殊处理
   duration:执行时间
   delay:延迟时间
   options:动画设置，例如自动恢复、匀速运动等
   completion:动画完成回调方法
   <em>/
  [UIView animateWithDuration:[self petalMoveDuring:[touch locationInView:self.view]] delay:0.0 options:UIViewAnimationOptionCurveLinear animations:^{
      petalView.center = location;
  } completion:nil];
  //方法2：静态方法
  //开始动画
  //[UIView beginAnimations:@&ldquo;KCBasicAnimation&rdquo; context:nil];
  //[UIView setAnimationDuration:5.0];
  //[UIView setAnimationDelay:1.0];//设置延迟
  //[UIView setAnimationRepeatAutoreverses:NO];//是否回复
  //[UIView setAnimationRepeatCount:10];//重复次数
  //[UIView setAnimationStartDate:(NSDate </em>)];//设置动画开始运行的时间
  //[UIView setAnimationDelegate:self];//设置代理
  //[UIView setAnimationWillStartSelector:(SEL)];//设置动画开始运动的执行方法
  //[UIView setAnimationDidStopSelector:(SEL)];//设置动画运行结束后的执行方法
  //petalView.center = location;
  //开始动画
  //[UIView commitAnimations];
}</p></li>
<li><p>(NSTimeInterval)petalMoveDuring:(CGPoint)destination {
  CGFloat deltaX = destination.x &ndash; petalView.center.x;
  CGFloat deltaY = destination.y &ndash; petalView.center.y;
  CGFloat distance = sqrt(deltaX<em>deltaX + deltaY</em>deltaY);
  NSLog(@&ldquo;%f&rdquo;, distance);
  return (NSTimeInterval)distance/50.0;
}</p></li>
</ul>


<p>@end
```</p>

<h4>弹簧动画效果</h4>

<p>iOS7新加入了一个弹性动画的接口，具体实现见代码。</p>

<p>```objectivec
@interface ACViewSpringAnimationViewController () {</p>

<pre><code>UIImageView *ballView;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation ACViewSpringAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  ballView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&ldquo;ball&rdquo;]];
  ballView.center = self.view.center;
  [self.view addSubview:ballView];
}</p></li>
<li><p>(void)touchesEnded:(NSSet<UITouch *> <em>)touches withEvent:(UIEvent </em>)event {
  UITouch <em>touch = touches.anyObject;
  CGPoint location = [touch locationInView:self.view];
  /</em>创建弹性动画
   damping:阻尼，范围0-1，阻尼越接近于0，弹性效果越明显
   velocity:弹性复位的速度
   */
  [UIView animateWithDuration:[self petalMoveDuring:location] delay:0 usingSpringWithDamping:0.5 initialSpringVelocity:0 options:UIViewAnimationOptionCurveLinear animations:^{
      ballView.center = location;
  } completion:nil];
}</p></li>
<li><p>(NSTimeInterval)petalMoveDuring:(CGPoint)destination {
  CGFloat deltaX = destination.x &ndash; ballView.center.x;
  CGFloat deltaY = destination.y &ndash; ballView.center.y;
  CGFloat distance = sqrt(deltaX<em>deltaX + deltaY</em>deltaY);
  NSLog(@&ldquo;%f&rdquo;, distance);
  return (NSTimeInterval)distance/150.0;
}</p></li>
</ul>


<p>@end
```</p>

<h4>UIView动画设置参数</h4>

<p>在动画方法中有一个NS_OPTION参数，UIViewAnimationOptions类型，它是一个枚举类型，动画参数分为三类，对应CoreAnimation的各类设置，可以组合使用：</p>

<ol>
<li>常规动画属性设置（可以同时选择多个进行设置）

<ul>
<li>UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。</li>
<li>UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。</li>
<li>UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。</li>
<li>UIViewAnimationOptionRepeat：重复运行动画。</li>
<li>UIViewAnimationOptionAutoreverse ：动画运行到结束点后仍然以动画方式回到初始点。</li>
<li>UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。</li>
<li>UIViewAnimationOptionOverrideInheritedCurve：忽略嵌套动画速度设置。</li>
<li>UIViewAnimationOptionAllowAnimatedContent：动画过程中重绘视图（注意仅仅适用于转场动画）。</li>
<li>UIViewAnimationOptionShowHideTransitionViews：视图切换时直接隐藏旧视图、显示新视图，而不是将旧视图从父视图移除（仅仅适用于转场动画）</li>
<li>UIViewAnimationOptionOverrideInheritedOptions ：不继承父动画设置或动画类型。</li>
</ul>
</li>
<li>动画速度控制（可从其中选择一个设置）

<ul>
<li>UIViewAnimationOptionCurveEaseInOut：动画先缓慢，然后逐渐加速。</li>
<li>UIViewAnimationOptionCurveEaseIn ：动画逐渐变慢。</li>
<li>UIViewAnimationOptionCurveEaseOut：动画逐渐加速。</li>
<li>UIViewAnimationOptionCurveLinear ：动画匀速执行，默认值。</li>
</ul>
</li>
<li>转场类型（仅适用于转场动画设置，可以从中选择一个进行设置，基本动画、关键帧动画不需要设置）

<ul>
<li>UIViewAnimationOptionTransitionNone：没有转场动画效果。</li>
<li>UIViewAnimationOptionTransitionFlipFromLeft ：从左侧翻转效果。</li>
<li>UIViewAnimationOptionTransitionFlipFromRight：从右侧翻转效果。</li>
<li>UIViewAnimationOptionTransitionCurlUp：向后翻页的动画过渡效果。</li>
<li>UIViewAnimationOptionTransitionCurlDown ：向前翻页的动画过渡效果。</li>
<li>UIViewAnimationOptionTransitionCrossDissolve：旧视图溶解消失显示下一个新视图的效果。</li>
<li>UIViewAnimationOptionTransitionFlipFromTop ：从上方翻转效果。</li>
<li>UIViewAnimationOptionTransitionFlipFromBottom：从底部翻转效果。</li>
</ul>
</li>
</ol>


<h3>UIView关键帧动画</h3>

<p>从iOS7开始UIView动画中封装了关键帧动画，下面就来看一下如何使用UIView封装方法进行关键帧动画控制，这里实现前面关键帧动画部分对于落花的控制。</p>

<p>```objectivec
@interface ACViewKeyframeAnimationViewController () {</p>

<pre><code>UIImageView *petalView;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation ACViewKeyframeAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  self.view.layer.contents = (id)[UIImage imageNamed:@&ldquo;background.jpg&rdquo;].CGImage;</p>

<p>  petalView = [[UIImageView alloc] init];
  petalView.frame = CGRectMake(50, 150, 0, 0);
  petalView.image = [UIImage imageNamed:@&ldquo;petal&rdquo;];
  [petalView sizeToFit];
  [self.view addSubview:petalView];</p>

<p>  [self addKeyframeAnimation];
}</p></li>
<li><p>(void)addKeyframeAnimation {
  [UIView animateKeyframesWithDuration:5.0 delay:0.0 options:UIViewKeyframeAnimationOptionCalculationModeLinear animations:^{
      [UIView addKeyframeWithRelativeStartTime:0.0 relativeDuration:0.5 animations:^{
          petalView.center = CGPointMake(80.0, 220.0);
      }];
      [UIView addKeyframeWithRelativeStartTime:0.5 relativeDuration:0.25 animations:^{
          petalView.center = CGPointMake(45.0, 300.0);
      }];
      [UIView addKeyframeWithRelativeStartTime:0.75 relativeDuration:0.25 animations:^{
          petalView.center = CGPointMake(55.0, 400.0);
      }];
  } completion:nil];
}</p></li>
</ul>


<p>@end
```</p>

<h4>UIView关键帧动画设置参数</h4>

<p>对于关键帧动画也有一些动画参数设置options，UIViewKeyframeAnimationOptions类型，和上面基本动画参数设置有些差别，关键帧动画设置参数分为两类，可以组合使用：</p>

<ol>
<li><p>常规动画属性设置（可以同时选择多个进行设置）</p>

<ul>
<li>UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。</li>
<li>UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。</li>
<li>UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。</li>
<li>UIViewAnimationOptionRepeat：重复运行动画。</li>
<li>UIViewAnimationOptionAutoreverse：动画运行到结束点后仍然以动画方式回到初始点。</li>
<li>UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。</li>
<li>UIViewAnimationOptionOverrideInheritedOptions：不继承父动画设置或动画类型。</li>
</ul>
</li>
<li><p>动画模式设置（同前面关键帧动画动画模式一一对应，可以从其中选择一个进行设置）</p>

<ul>
<li>UIViewKeyframeAnimationOptionCalculationModeLinear：连续运算模式。</li>
<li>UIViewKeyframeAnimationOptionCalculationModeDiscrete：离散运算模式。</li>
<li>UIViewKeyframeAnimationOptionCalculationModePaced：均匀执行运算模式。</li>
<li>UIViewKeyframeAnimationOptionCalculationModeCubic：平滑运算模式。</li>
<li>UIViewKeyframeAnimationOptionCalculationModeCubicPaced：平滑均匀运算模式。</li>
</ul>
</li>
</ol>


<p>注意：前面说过关键帧动画有两种形式，上面演示的是属性值关键帧动画，路径关键帧动画目前UIView还不支持。</p>

<h3>UIView转场动画</h3>

<p>从iOS4.0开始，UIView直接封装了转场动画。</p>

<p>```objectivec
@interface ACViewTransitionAnimationViewController () {</p>

<pre><code>UIImageView *imageView;
NSArray *transitionTypes;
</code></pre>

<p>}</p>

<p>@end</p>

<p>static int transitionTypeIndex;</p>

<p>@implementation ACViewTransitionAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.
  transitionTypes = @[[NSNumber numberWithUnsignedInteger:UIViewAnimationOptionTransitionFlipFromRight], [NSNumber numberWithUnsignedInteger:UIViewAnimationOptionTransitionCurlUp], [NSNumber numberWithUnsignedInteger:UIViewAnimationOptionTransitionCrossDissolve], [NSNumber numberWithUnsignedInteger:UIViewAnimationOptionTransitionFlipFromBottom]];
  transitionTypeIndex = 0;</p>

<p>  imageView = [[UIImageView alloc] initWithFrame:[UIScreen mainScreen].bounds];
  [imageView setImage:[UIImage imageNamed:@&ldquo;background.jpg&rdquo;]];
  [self.view addSubview:imageView];</p>

<p>  UISwipeGestureRecognizer *swipeGesture = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipe:)];
  swipeGesture.direction = UISwipeGestureRecognizerDirectionLeft;
  [self.view addGestureRecognizer:swipeGesture];
}</p></li>
<li><p>(void)swipe:(UISwipeGestureRecognizer *)gestureRecognizer {
  if (transitionTypeIndex > 3) {
      transitionTypeIndex = 0;
  }</p>

<p>  UIViewAnimationOptions option;
  option = [transitionTypes[transitionTypeIndex] unsignedIntegerValue];
  option = option|UIViewAnimationOptionCurveLinear;
  [UIView transitionWithView:imageView duration:1.0 options:option animations:^{
      [imageView setImage:[UIImage imageNamed:@&ldquo;background.jpg&rdquo;]];
  } completion:nil];</p>

<p>  transitionTypeIndex++;
}</p></li>
</ul>


<p>@end
```</p>

<p>如果有两个完全不同的视图，并且每个视图布局都很复杂，此时要在这两个视图之间进行转场可以使用以下方法进行两个视图间的转场，需要注意的是默认情况下转出的视图会从父视图移除，转入后重新添加，可以通过UIViewAnimationOptionShowHideTransitionViews参数设置，设置此参数后转出的视图会隐藏（不会移除）转入后再显示。</p>

<p><code>objectivec
+(void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion;
</code></p>

<p>注意：转场动画设置参数完全同基本动画参数设置；同直接使用转场动画不同的是使用UIView的装饰方法进行转场动画其动画效果较少，因为这里无法直接使用私有API。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发备忘录1]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/05/ioskai-fa-bei-wang-lu-1/"/>
    <updated>2015-11-05T13:41:03+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/05/ioskai-fa-bei-wang-lu-1</id>
    <content type="html"><![CDATA[<p>总结一些iOS开发必备的知识点，结构可能会比较杂，可以当做备忘录使用，不断更新中。</p>

<!--more-->


<h2>1.library和framework的比较</h2>

<p>library也就是我们常用的.a文件，而framework就是.framework文件，当然还有.dylib这样的文件。</p>

<h3>静态库和动态库的区别</h3>

<ul>
<li>静态库：链接时完整地拷贝至可执行文件夹中，被多次使用时会有多份冗余拷贝。</li>
<li>动态库：链接时不复制，程序运行是由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。</li>
</ul>


<h3>iOS库的形式</h3>

<ul>
<li>静态库：.a和.framework</li>
<li>动态库：.dylib和.framework</li>
<li>系统提供的.framework是动态的，而自己开发的.framework是静态的</li>
</ul>


<h3>.a和.framework区别</h3>

<ul>
<li>.a就是一个纯二进制的文件，而.framework还会包含头文件和资源文件</li>
<li>.a一般是要配合.h头文件使用的，.framework是可以直接使用的</li>
<li>实际上.framework = .a + .h + sourceFile</li>
</ul>


<h3>需要注意的问题</h3>

<ul>
<li>注意理解：无论是.a静态库还.framework静态库，我们需要的都是二进制文件+.h+其它资源文件的形式，不同的是，.a本身就是二进制文件，需要我们自己配上.h和其它文件才能使用，而.framework本身已经包含了.h和其它文件，可以直接使用。</li>
<li>图片资源的处理：两种静态库，一般都是把图片文件单独的放在一个.bundle文件中，一般.bundle的名字和.a或.framework的名字相同。.bundle文件很好弄，新建一个文件夹，把它改名为.bundle就可以了，右键，显示包内容可以向其中添加图片资源。</li>
<li>category是我们实际开发项目中经常用到的，把category打成静态库是没有问题的，但是在用这个静态库的工程中，调用category中的方法时会有找不到该方法的运行时错误（selector not recognized），解决办法是：在使用静态库的工程中配置other linker flags的值为-ObjC。</li>
<li>如果一个静态库很复杂，需要暴露的.h比较多的话，就可以在静态库的内部创建一个.h文件（一般这个.h文件的名字和静态库的名字相同），然后把所有需要暴露出来的.h文件都集中放在这个.h文件中，而那些原本需要暴露的.h都不需要再暴露了，只需要把.h暴露出来就可以了。</li>
<li>创建.a文件的一篇<a href="http://www.raywenderlich.com/41377/creating-a-static-library-in-ios-tutorial">博客</a>，创建.framework的一篇<a href="http://www.raywenderlich.com/65964/create-a-framework-for-ios">博客</a>。</li>
</ul>


<!--more-->


<h2>2.事件响应链The Responder Chain</h2>

<h3>事件的传递顺序</h3>

<p>当用户触发的一个事件发生，UIKit会创建一个包含要处理的事件信息的事件对象。然后她会将事件对象放入active app’s（应用程序对象，每个程序对应唯一一个）事件队列。对于触摸事件，事件对象就是UIEvent对象封装的一系列触摸集合。对于动作事件，这个事件对象依赖于使用的framework和你关心哪种动作事件。</p>

<h3>事件类型</h3>

<p>事件通过特殊的路径传递直到被传递到一个可以处理该事件的对象。首先，单例的UIApplication对象从顶层的队列中获取事件，然后分发。典型的，它将事件发送到App的key window对象，window则为了处理该事件而发送它到初始化对象（initial object），这个初始化对像依靠事件类型。</p>

<ul>
<li>触摸事件（Touch events）。对于触摸事件，window对象首先会尝试将事件传递给事件发生的view。这个view就是所谓的hit-test view。寻找hit-test view的方法叫hit-testing，具体描述见<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW4">Apple文档</a>。</li>
<li>动作事件和远程控制事件（Motion and remote control events）。在这些事件中，window对象发送事件到第一个响应器。第一个响应器的具体描述见<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW1">Apple文档</a>。</li>
</ul>


<p>事件传递路径的最终目的时找出能处理和响应该事件的对象。因此，UIKit给适合处理该事件的对象发送事件。对于触摸事件，这个对象就是hit-test view，对于其他事件，这个对象就是第一个响应器（first responder）。</p>

<h3>触摸事件的响应链</h3>

<p>iOS使用hit-testing寻找触摸的view。 Hit-Testing通过检查触摸点是否在关联的view边界内，如果在，则递归地（recursively）检查该view的所有子view。在层级上处于lowest（就是用户直接接触view）且边界范围包含触摸点的view成为hit-test view。确定hit-test view后，它传递触摸事件给该view。</p>

<p>举例说明，假设用户触摸了图中的view E。iOS通过如下顺序查找hit-test view。</p>

<p><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png" alt="image" /></p>

<ol>
<li>触摸点在view A中，所以要检查子view B和C。</li>
<li>触摸点不在view B中，但在C中，所以检查C的子view D和E。</li>
<li>触摸点不在D中，但在E中。</li>
</ol>


<p><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/hitTest:withEvent:">hitTest:withEvent:</a>方法通过传递进来CGPoint和UIEvent返回hit test view。该方法调用<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/pointInside:withEvent:">pointInside:withEvent:</a>方法，如果传入hitTest:withEvent:的point在view的边界范围内，则pointInside:withEvent:返回YES。然后，这个方法会在view的所有子view中递归的调用hitTest:withEvent:。</p>

<p>如果传入hitTest:withEvent:的point不在view的边界范围内，则pointInside:withEvent:返回NO。这个point会被忽略，hitTest:withEvent:返回nil。如果一个子view返回NO，则它所在的view的层级上的分支的子view都会被忽略。</p>

<p>Hit-test view是处理触摸事件的第一选择，如果hit-test view不能处理事件，该事件将从事件响应链中寻找响应器，直到系统找到一个处理事件的对象。</p>

<h3>响应器链</h3>

<p>一些类型的事件的传递依赖响应器链。响应器链（responder chain）是一系列相关的响应器对象。它开始于第一个响应器终止于应用对象（application object）。如果第一个responder不处理事件，则会根据responder chain将event传递给下一个responder。</p>

<p>Responder object，即可以响应和处理事件的对象。UIResponder类是所有responder对象的基类，它定义了动态的接口，不仅处理事件也包括处理响应行为。包括UIApplication，UIViewController，和UIView类都是responder，这意味着所有view和大部分关键的controller对象都是responder。但是Core Animation layers不是responders。</p>

<p>First responder被设计来第一个接收事件。典型的，first responder是一个view object。之所以成为第一个responder由于两个原因：</p>

<ol>
<li>覆盖canBecomeFirstResponder方法，返回YES。</li>
<li>接收becomeFirstResponder消息。如果必须，一个object能发送给自身这个消息。</li>
</ol>


<h3>响应器链的传输路径</h3>

<p>如果初始化对象（initial object）—— 即hit-test view或者first responder —— 不处理事件，UIKit会将事件传递给responder chain的下一个responder。每个responder决定它是传递事件还是通过nextResponder方法传递给它的下一个responder。这个操作继续直到一个responder处理event或者没有responder了。</p>

<p>Responder chain 序列在iOS确定一个事件并将它传递给initial object（通常是view）时开始。所以initial view有处理事件的第一个机会。下图描述了两个不同的事件传递路径（因为不同的app 设置）。一个App的事件传递路径由app特殊的构成决定，但事件传递路径会遵守相同的规则。</p>

<p><img src="http://lucifer1988.github.io/images/responser_chain.jpeg"></p>

<h3>手动指定当前view不响应事件</h3>

<p>```objectivec
&ndash;(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event {</p>

<pre><code>for (UIView *view in self.subviews) {
    if (!view.hidden &amp;&amp; view.userInteractionEnabled &amp;&amp; [view pointInside:[self convertPoint:point toView:view] withEvent:event])
        return YES;
}
return NO;
</code></pre>

<p>}
```</p>

<h3>总结</h3>

<p>事件的传递和响应分两个链：</p>

<ul>
<li>传递链：由系统向离用户最近的view传递。UIKit –> active app’s event queue –> window –> root view –>……–>lowest view</li>
<li>响应链：由离用户最近的view向系统传递。initial view –> super view –> …..–> view controller –> window –> Application</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回答Sunny的55道iOS面试题2]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/30/hui-da-sunnyde-55dao-iosmian-shi-ti-2/"/>
    <updated>2015-10-30T14:36:08+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/30/hui-da-sunnyde-55dao-iosmian-shi-ti-2</id>
    <content type="html"><![CDATA[<p>百度知道的<a href="http://weibo.com/u/1364395395">微博@我就叫Sunny怎么了</a>出了55道iOS的面试题，很多题目是很有深度，这次会将剩下的题目完成解答。</p>

<!--more-->


<h3>25. <code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？</h3>

<p><strong>我的解答：</strong></p>

<p><code>_objc_msgForward</code>用于消息的转发，直接调用会直接进入消息转发阶段。</p>

<p><strong>大神解答：</strong></p>

<blockquote><p><code>_objc_msgForward</code>是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p></blockquote>

<p>我们可以这样创建一个<code>_objc_msgForward</code>对象：</p>

<pre><code>IMP msgForwardIMP = _objc_msgForward;
</code></pre>

<p>在<a href="http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1/">上篇</a>中的《objc中向一个对象发送消息<code>[obj foo]</code>和<code>objc_msgSend()</code>函数之间有什么关系？》曾提到<code>objc_msgSend</code>在“消息传递”中的作用。在“消息传递”过程中，<code>objc_msgSend</code>的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用<code>_objc_msgForward</code>函数指针代替 IMP 。最后，执行这个 IMP 。</p>

<p>Objective-C运行时是开源的，所以我们可以看到它的实现。打开<a href="http://www.opensource.apple.com/tarballs/objc4/"> <strong><em>Apple Open Source 里Mac代码里的obj包</em></strong> </a>下载一个最新版本，找到 <code>objc-runtime-new.mm</code>，进入之后搜索<code>_objc_msgForward</code>。</p>

<p><img src="http://i.imgur.com/rGBfaoL.png" alt="enter image description here" /></p>

<p>里面有对<code>_objc_msgForward</code>的功能解释：</p>

<p><img src="http://i.imgur.com/vcThcdA.png" alt="enter image description here" /></p>

<p><code>objectivec
/***********************************************************************
* lookUpImpOrForward.
* The standard IMP lookup.
* initialize==NO tries to avoid +initialize (but sometimes fails)
* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)
* Most callers should use initialize==YES and cache==YES.
* inst is an instance of cls or a subclass thereof, or nil if none is known.
*   If cls is an un-initialized metaclass then a non-nil inst is faster.
* May return _objc_msgForward_impcache. IMPs destined for external use
*   must be converted to _objc_msgForward or _objc_msgForward_stret.
*   If you don't want forwarding at all, use lookUpImpOrNil() instead.
**********************************************************************/
</code></p>

<p>对 <code>objc-runtime-new.mm</code>文件里与<code>_objc_msgForward</code>有关的三个函数使用伪代码展示下：</p>

<p>```objectivec
//  objc-runtime-new.mm 文件里与 _objc_msgForward 有关的三个函数使用伪代码展示
//  Created by <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
//  Copyright &copy;  微博@iOS程序犭袁(<a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>). All rights reserved.
//  同时，这也是 obj_msgSend 的实现过程</p>

<p>id objc_msgSend(id self, SEL op, &hellip;) {</p>

<pre><code>if (!self) return nil;
IMP imp = class_getMethodImplementation(self-&gt;isa, SEL op);
imp(self, op, ...); //调用这个函数，伪代码...
</code></pre>

<p>}</p>

<p>//查找IMP
IMP class_getMethodImplementation(Class cls, SEL sel) {</p>

<pre><code>if (!cls || !sel) return nil;
IMP imp = lookUpImpOrNil(cls, sel);
if (!imp) return _objc_msgForward; //_objc_msgForward 用于消息转发
return imp;
</code></pre>

<p>}</p>

<p>IMP lookUpImpOrNil(Class cls, SEL sel) {</p>

<pre><code>if (!cls-&gt;initialize()) {
    _class_initialize(cls);
}

Class curClass = cls;
IMP imp = nil;
do { //先查缓存,缓存没有时重建,仍旧没有则向父类查询
    if (!curClass) break;
    if (!curClass-&gt;cache) fill_cache(cls, curClass);
    imp = cache_getImp(curClass, sel);
    if (imp) break;
} while (curClass = curClass-&gt;superclass);

return imp;
</code></pre>

<p>}
<code>``
虽然Apple没有公开</code>_objc_msgForward`的实现源码，但是我们还是能得出结论：</p>

<blockquote><p><code>_objc_msgForward</code>是一个函数指针（和 IMP 的类型一样），是用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p>

<p>在<a href="http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1/">上篇</a>中的《objc中向一个对象发送消息<code>[obj foo]</code>和<code>objc_msgSend()</code>函数之间有什么关系？》曾提到<code>objc_msgSend</code>在“消息传递”中的作用。在“消息传递”过程中，<code>objc_msgSend</code>的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用<code>_objc_msgForward</code>函数指针代替 IMP 。最后，执行这个 IMP 。</p></blockquote>

<p>为了展示消息转发的具体动作，这里尝试向一个对象发送一条错误的消息，并查看一下<code>_objc_msgForward</code>是如何进行转发的。</p>

<p>首先开启调试模式、打印出所有运行时发送的消息：
可以在代码里执行下面的方法：</p>

<p><code>objectivec
(void)instrumentObjcMessageSends(YES);
</code></p>

<p>或者断点暂停程序运行，并在 gdb 中输入下面的命令：</p>

<p><code>objectivec
call (void)instrumentObjcMessageSends(YES)
</code></p>

<p>以第二种为例，操作如下所示：</p>

<p><img src="http://i.imgur.com/uEwTCC4.png" alt="enter image description here" /></p>

<p>之后，运行时发送的所有消息都会打印到<code>/tmp/msgSend-xxxx</code>文件里了。</p>

<p>终端中输入命令前往：</p>

<p><code>objectivec
open /private/tmp
</code></p>

<p><img src="http://i.imgur.com/Fh5hhCw.png" alt="enter image description here" /></p>

<p>可能看到有多条，找到最新生成的，双击打开</p>

<p>在模拟器上执行执行以下语句（这一套调试方案仅适用于模拟器，真机不可用，关于该调试方案的拓展链接：<a href="http://stackoverflow.com/a/10750398/3395008"> <strong><em>Can the messages sent to an object in Objective-C be monitored or printed out?</em></strong> </a>），向一个对象发送一条错误的消息：</p>

<p>```objectivec
//
//  main.m
//  CYLObjcMsgForwardTest
//
//  Created by <a href="http://weibo.com/luohanchenyilong/.">http://weibo.com/luohanchenyilong/.</a>
//  Copyright &copy; 2015年 微博@iOS程序犭袁. All rights reserved.
//</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<h1>import &ldquo;AppDelegate.h&rdquo;</h1>

<h1>import &ldquo;CYLTest.h&rdquo;</h1>

<p>int main(int argc, char * argv[]) {</p>

<pre><code>@autoreleasepool {
    CYLTest *test = [[CYLTest alloc] init];
    [test performSelector:(@selector(iOS程序犭袁))];
    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
}
</code></pre>

<p>}</p>

<p>```</p>

<p><img src="http://i.imgur.com/UjbmVvB.png" alt="enter image description here" /></p>

<p>你可以在<code>/tmp/msgSend-xxxx</code>（我这一次是<code>/tmp/msgSend-9805</code>）文件里，看到打印出来：</p>

<p><img src="http://i.imgur.com/AAERz1T.png" alt="enter image description here" /></p>

<p><code>objectivec
+ CYLTest NSObject initialize
+ CYLTest NSObject alloc
- CYLTest NSObject init
- CYLTest NSObject performSelector:
+ CYLTest NSObject resolveInstanceMethod:
+ CYLTest NSObject resolveInstanceMethod:
- CYLTest NSObject forwardingTargetForSelector:
- CYLTest NSObject forwardingTargetForSelector:
- CYLTest NSObject methodSignatureForSelector:
- CYLTest NSObject methodSignatureForSelector:
- CYLTest NSObject class
- CYLTest NSObject doesNotRecognizeSelector:
- CYLTest NSObject doesNotRecognizeSelector:
- CYLTest NSObject class
</code></p>

<p>结合<a href="https://developer.apple.com/library/prerelease/watchos/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/#//apple_ref/doc/uid/20000050-SW11">《NSObject官方文档》</a>，排除掉 NSObject 做的事，剩下的就是<code>_objc_msgForward</code>消息转发做的几件事：</p>

<ol>
<li><p>调用<code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始<code>objc_msgSend</code>流程。这一次对象会响应这个选择器，一般是因为它已经调用过<code>class_addMethod</code>。如果仍没实现，继续下面的动作。</p></li>
<li><p>调用<code>forwardingTargetForSelector:</code>方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。</p></li>
<li><p>调用<code>methodSignatureForSelector:</code>方法，尝试获得一个方法签名。如果获取不到，则直接调用<code>doesNotRecognizeSelector</code>抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给<code>forwardInvocation:</code>。</p></li>
<li><p>调用<code>forwardInvocation:</code>方法，将第3步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。</p></li>
<li><p>调用<code>doesNotRecognizeSelector:</code> ，默认的实现是抛出异常。如果第3步没能获得一个方法签名，执行该步骤。</p></li>
</ol>


<p>上面前4个方法均是模板方法，开发者可以override，由 runtime 来调用。最常见的实现消息转发：就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的</p>

<p>也就是说<code>_objc_msgForward</code>在进行消息转发的过程中会涉及以下这几个方法：</p>

<ol>
<li><p><code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。</p></li>
<li><p><code>forwardingTargetForSelector:</code>方法</p></li>
<li><p><code>methodSignatureForSelector:</code>方法</p></li>
<li><p><code>forwardInvocation:</code>方法</p></li>
<li><p><code>doesNotRecognizeSelector:</code> 方法</p></li>
</ol>


<p>为了能更清晰地理解这些方法的作用，git仓库里也给出了一个Demo，名称叫“ <code>_objc_msgForward_demo</code> ”,可运行起来看看。</p>

<p>下面回答下第二个问题“直接<code>_objc_msgForward</code>调用它将会发生什么？”</p>

<p>直接调用<code>_objc_msgForward</code>是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。</p>

<p>就好像跑酷，干得好，叫“耍酷”，干不好就叫“作死”。</p>

<p>正如前文所说：</p>

<blockquote><p><code>_objc_msgForward</code>是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p></blockquote>

<p>如何调用<code>_objc_msgForward</code>？<br/>
<code>_objc_msgForward</code>隶属 C 语言，有三个参数 ：</p>

<table>
<thead>
<tr>
<th>序号</th>
<th> <code>_objc_msgForward</code>参数</th>
<th> 类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td> 1. </td>
<td> 所属对象 </td>
<td> id类型</td>
</tr>
<tr>
<td> 2. </td>
<td>方法名 </td>
<td> SEL类型 </td>
</tr>
<tr>
<td> 3. </td>
<td>可变参数 </td>
<td>可变参数类型</td>
</tr>
</tbody>
</table>


<p>首先了解下如何调用 IMP 类型的方法，IMP类型是如下格式：</p>

<p>为了直观，我们可以通过如下方式定义一个 IMP类型 ：</p>

<p><code>objectivec
typedef void (*voidIMP)(id, SEL, ...)
</code>
一旦调用<code>_objc_msgForward</code>，将跳过查找 IMP 的过程，直接触发“消息转发”，</p>

<p>如果调用了<code>_objc_msgForward</code>，即使这个对象确实已经实现了这个方法，你也会告诉<code>objc_msgSend</code>：</p>

<blockquote><p>“我没有在这个对象里找到这个方法的实现”</p></blockquote>

<p>想象下<code>objc_msgSend</code>会怎么做？通常情况下，下面这张图就是你正常走<code>objc_msgSend</code>过程，和直接调用<code>_objc_msgForward</code>的前后差别：</p>

<p><img src="http://ww1.sinaimg.cn/bmiddle/6628711bgw1eecx3jef23g206404tkbi.gif" alt="enter image description here" /></p>

<p>有哪些场景需要直接调用<code>_objc_msgForward</code>？最常见的场景是：你想获取某方法所对应的<code>NSInvocation</code>对象。举例说明：</p>

<p><a href="https://github.com/bang590/JSPatch">JSPatch （Github 链接）</a>就是直接调用<code>_objc_msgForward</code>来实现其核心功能的：</p>

<blockquote><p> JSPatch 以小巧的体积做到了让JS调用/替换任意OC方法，让iOS APP具备热更新的能力。</p></blockquote>

<p>作者的博文<a href="http://blog.cnbang.net/tech/2808/">《JSPatch实现原理详解》</a>详细记录了实现原理，有兴趣可以看下。</p>

<h3>26. runtime如何实现weak变量的自动置nil？</h3>

<p><strong>我的解答：</strong></p>

<p>原理不清楚。</p>

<p><strong>大神解答：</strong></p>

<blockquote><p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p></blockquote>

<p>在<a href="http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1/">上篇</a>中的《runtime 如何实现 weak 属性》有论述。（注：在<a href="http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1/">上篇</a>的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到<code>__weak</code>引用的解除时间。）</p>

<p>我们可以设计一个函数（伪代码）来表示上述机制：</p>

<p><code>objc_storeWeak(&amp;a, b)</code>函数：</p>

<p><code>objc_storeWeak</code>函数把第二个参数&mdash;赋值对象（b）的内存地址作为键值key，将第一个参数&mdash;weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，</p>

<p>你可以把<code>objc_storeWeak(&amp;a, b)</code>理解为：<code>objc_storeWeak(value, key)</code>，并且当key变nil，将value置nil。</p>

<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>

<p>而如果a是由assign修饰的，则：
在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。</p>

<p>下面我们将基于<code>objc_storeWeak(&amp;a, b)</code>函数，使用伪代码模拟“runtime如何实现weak属性”：</p>

<p>```objectivec
// 使用伪代码模拟：runtime如何实现weak属性
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a></p>

<p> id obj1;
 objc_initWeak(&amp;obj1, obj);
/<em>obj引用计数变为0，变量作用域结束</em>/
 objc_destroyWeak(&amp;obj1);
```</p>

<p>下面对用到的两个方法<code>objc_initWeak</code>和<code>objc_destroyWeak</code>做下解释：</p>

<p>总体说来，作用是：
通过<code>objc_initWeak</code>函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过<code>objc_destoryWeak</code>函数释放该变量（obj1）。</p>

<p>下面分别介绍下方法的内部实现：</p>

<p><code>objc_initWeak</code>函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用<code>objc_storeWeak</code>函数。</p>

<p><code>objectivec
obj1 = 0；
obj_storeWeak(&amp;obj1, obj);
</code></p>

<p>也就是说：</p>

<blockquote><p> weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）</p></blockquote>

<p>然后<code>obj_destroyWeak</code>函数将0（nil）作为参数，调用<code>objc_storeWeak</code>函数。</p>

<p><code>objc_storeWeak(&amp;obj1, 0);</code></p>

<p>前面的源代码与下列源代码相同。</p>

<p>```objectivec
// 使用伪代码模拟：runtime如何实现weak属性
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a></p>

<p>id obj1;
obj1 = 0;
objc_storeWeak(&amp;obj1, obj);
/<em> &hellip; obj的引用计数变为0，被置nil &hellip; </em>/
objc_storeWeak(&amp;obj1, 0);
```</p>

<p><code>objc_storeWeak</code>函数把第二个参数&mdash;赋值对象（obj）的内存地址作为键值，将第一个参数&mdash;weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除。</p>

<h3>27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3>

<p><strong>我的解答：</strong></p>

<p>不能向编译后得到的类添加实例变量，可以向运行时创建的类添加实例变量，OC是动态语言，可以在运行时向类添加实例变量和方法，原理不知道。</p>

<p><strong>大神解答：</strong></p>

<ul>
<li>不能向编译后得到的类中增加实例变量；</li>
<li>能向运行时创建的类中添加实例变量；</li>
</ul>


<p>解释下：</p>

<ul>
<li><p>因为编译后的类已经注册在 runtime 中，类结构体中的 <code>objc_ivar_list</code> 实例变量的链表 和 <code>instance_size</code> 实例变量的内存大小已经确定，同时runtime 会调用 <code>class_setIvarLayout</code> 或 <code>class_setWeakIvarLayout</code> 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；</p></li>
<li><p>运行时创建的类是可以添加实例变量，调用 <code>class_addIvar</code> 函数。但是得在调用 <code>objc_allocateClassPair</code> 之后，<code>objc_registerClassPair</code> 之前，原因同上。</p></li>
</ul>


<h3>28. runloop和线程有什么关系？</h3>

<p><strong>我的解答：</strong></p>

<p>额，看大神的。</p>

<p><strong>大神解答：</strong></p>

<p>总的说来，Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分， Cocoa 和 CoreFundation 都提供了 run loop 对象方便配置和管理线程的 run loop （以下都以 Cocoa 为例）。每个线程，包括程序的主线程（ main thread ）都有与之相应的 run loop 对象。</p>

<p> runloop 和线程的关系：</p>

<ol>
<li>主线程的run loop默认是启动的。</li>
</ol>


<p> iOS的应用程序里面，程序启动后会有一个如下的main()函数</p>

<p>```objectivec
int main(int argc, char * argv[]) {</p>

<pre><code>@autoreleasepool {
    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
}
</code></pre>

<p>}
```</p>

<p> 重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p>

<ol>
<li><p>对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。</p></li>
<li><p>在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。</p></li>
</ol>


<p><code>objectivec
NSRunLoop *runloop = [NSRunLoop currentRunLoop];
</code></p>

<p>参考链接：<a href="http://blog.csdn.net/wzzvictory/article/details/9237973">《Objective-C之run loop详解》</a>。</p>

<h3>29. runloop的mode作用是什么？</h3>

<p><strong>我的解答：</strong></p>

<p>额，继续看大神的。</p>

<p><strong>大神解答：</strong></p>

<p>model 主要是用来指定事件在运行循环中的优先级的，分为：</p>

<ul>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态</li>
<li>UITrackingRunLoopMode：ScrollView滑动时</li>
<li>UIInitializationRunLoopMode：启动时</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合</li>
</ul>


<p>苹果公开提供的 Mode 有两个：</p>

<ol>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）</li>
</ol>


<h3>30. 以+ scheduledTimerWithTimeInterval&hellip;的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3>

<p><strong>我的解答：</strong></p>

<p>应该和上面的Runloop的mode优先级有关，具体原因不明。</p>

<p><strong>大神解答：</strong></p>

<p>RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunLoopMode模式下处理的事件会影响scrllView的滑动。</p>

<p>如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候,
ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。</p>

<p>同时因为mode还是可定制的，所以：</p>

<p> Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决。代码如下：</p>

<p>```objectivec
//
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a> (微博@iOS程序犭袁)
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a></p>

<p>//将timer添加到NSDefaultRunLoopMode中
NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0</p>

<pre><code> target:self
 selector:@selector(timerTick:)
 userInfo:nil
 repeats:YES];
</code></pre>

<p>//然后再添加到NSRunLoopCommonModes里
NSTimer *timer = [NSTimer timerWithTimeInterval:1.0</p>

<pre><code> target:self
 selector:@selector(timerTick:)
 userInfo:nil
 repeats:YES];
</code></pre>

<p>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
```</p>

<h3>31. 猜想runloop内部是如何实现的？</h3>

<p><strong>我的解答：</strong></p>

<p>额，继续看大神的。</p>

<p><strong>大神解答：</strong></p>

<blockquote><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑
是这样的：</p></blockquote>

<pre><code>function loop() {
    initialize();
    do {
        var message = get_next_message();
        process_message(message);
    } while (message != quit);
}
</code></pre>

<p>或使用伪代码来展示下:</p>

<pre><code>// 
// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)
// https://github.com/ChenYilong
int main(int argc, char * argv[]) {
 //程序一直运行状态
 while (AppIsRunning) {
      //睡眠状态，等待唤醒事件
      id whoWakesMe = SleepForWakingUp();
      //得到唤醒事件
      id event = GetEvent(whoWakesMe);
      //开始处理事件
      HandleEvent(event);
 }
 return 0;
}
</code></pre>

<p>参考链接：</p>

<ol>
<li><a href="http://blog.ibireme.com/2015/05/18/runloop/#base">《深入理解RunLoop》</a></li>
<li>摘自博文<a href="https://github.com/ming1016/study/wiki/CFRunLoop"><strong><em>CFRunLoop</em></strong></a>，原作者是<a href="http://weibo.com/u/1364395395">微博@我就叫Sunny怎么了</a></li>
</ol>


<h3>32. objc使用什么机制管理对象内存？</h3>

<p><strong>我的解答：</strong></p>

<p>通过retain count，即引用计数，来管理对象内存，当retain count大于0时对象内存就不会释放，而retain count为0时对象会自动释放内存，通过retain、release来增加/减少retain count。</p>

<p><strong>大神解答：</strong></p>

<p>通过 retainCount 的机制来决定对象是否需要释放。
每次 runloop 的时候，都会检查对象的 retainCount，如果retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。</p>

<h3>33. ARC通过什么方式帮助开发者管理内存？</h3>

<p><strong>我的解答：</strong></p>

<p>ARC引入了新的关键字strong、weak来描述对象的持有关系，更加简化了对象对内存的占有关系，而在实现时还是使用retain count机制，只是编译器会自动添加内存相关的代码，而且很多地方作了特殊的优化，比如：对象创建方法和普通方法返回对象时，会添加不同的内存关键字，所以ARC还是强烈推荐的。</p>

<p><strong>大神解答：</strong></p>

<p> <p><del>编译时根据代码上下文，插入 retain/release
</del></p>
ARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单。应该是编译期和运行期两部分共同帮助开发者管理内存。</p>

<p>在编译期，ARC用的是更底层的C接口实现的retain/release/autorelease，这样做性能更好，也是为什么不能在ARC环境下手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化（即忽略掉不必要的操作）；ARC也包含运行期组件，这个地方做的优化比较复杂，但也不能被忽略。【TODO:后续更新会详细描述下】</p>

<h3>34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h3>

<p><strong>我的解答：</strong></p>

<p>该对象加入最近创建的的autoreleasepool中，而该autoreleasepool会在当前runloop循环结束时，执行drain操作，而此时其内的对象都会被执行一次release操作。</p>

<p><strong>大神解答：</strong></p>

<p>分两种情况：手动干预释放时机、系统自动去释放。</p>

<ol>
<li>手动干预释放时机&mdash;指定autoreleasepool
就是所谓的：当前作用域大括号结束时释放。</li>
<li>系统自动去释放&mdash;不手动指定autoreleasepool</li>
</ol>


<p>  Autorelease对象出了作用域之后，会被添加到最近一次创建的自动释放池中，并会在当前的 runloop 迭代结束时释放。</p>

<p>释放的时机总结起来，可以用下图来表示：</p>

<p><img src="http://i61.tinypic.com/28kodwp.jpg" alt="autoreleasepool与 runloop 的关系图" /></p>

<p>下面对这张图进行详细的解释：</p>

<p>从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</p>

<p>我们都是知道：
<strong>所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。</strong></p>

<p>但是如果每次都放进应用程序的 <code>main.m</code> 中的 autoreleasepool 中，迟早有被撑满的一刻。这个过程中必定有一个释放的动作。何时？</p>

<p>在一次完整的运行循环结束之前，会被销毁。</p>

<p>那什么时间会创建自动释放池？运行循环检测到事件并启动后，就会创建自动释放池。</p>

<p>子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。</p>

<p>自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如： 自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。</p>

<p>但对于 blockOperation 和 invocationOperation 这种默认的Operation ，系统已经帮我们封装好了，不需要手动创建自动释放池。</p>

<p>@autoreleasepool 当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release 消息，释放自动释放池中的所有对象。</p>

<p> 如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。</p>

<p>参考链接：<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">《黑幕背后的Autorelease》</a></p>

<h3>35. BAD_ACCESS在什么情况下出现？</h3>

<p><strong>我的解答：</strong></p>

<p>当所访问的对象指针指向的内存已经释放，但指针没有置nil，成为野指针，会报BAD_ACCESS错误。</p>

<p><strong>大神解答：</strong></p>

<p>访问了野指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。</p>

<h3>36. 苹果是如何实现autoreleasepool的？</h3>

<p><strong>我的解答：</strong></p>

<p>autoreleasepool在内存中是以栈的形式储存的，在顶端的的pool会最先经行drain操作。</p>

<p><strong>大神解答：</strong></p>

<p>autoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成.</p>

<ol>
<li><code>objc_autoreleasepoolPush</code></li>
<li><code>objc_autoreleasepoolPop</code></li>
<li><code>objc_autorelease</code></li>
</ol>


<p>看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。</p>

<p>举例说明：我们都知道用类方法创建的对象都是 Autorelease 的，那么一旦 Person 出了作用域，当在 Person 的 dealloc 方法中打上断点，我们就可以看到这样的调用堆栈信息：</p>

<p> <img src="http://i60.tinypic.com/15mfj11.jpg" alt="enter image description here" /></p>

<h3>37. 使用block时什么情况会发生引用循环，如何解决？</h3>

<p><strong>我的解答：</strong></p>

<p>当block本身作为类的强引用，而在block内部又对self的属性进行的使用，因为block会默认retain包含的对象，所以此时block会与self相互引用，而导致循环引用，解决方法一般是声明__weak属性的self替代，而在block内部使用weak替代，这样block就不会对self有强引用，从而解除这一循环。</p>

<p><strong>大神解答：</strong></p>

<p>一个对象中强引用了block，在block中又使用了该对象，就会发射循环引用。
解决方法是将该对象使用<strong>weak或者</strong>block修饰符修饰之后再在block中使用。</p>

<ol>
<li>id weak weakSelf = self;
或者 weak __typeof(&amp;*self)weakSelf = self该方法可以设置宏</li>
<li>id __block weakSelf = self;</li>
</ol>


<h3>38. 在block内如何修改block外部变量？</h3>

<p><strong>我的解答：</strong></p>

<p>使用__block关键字来修饰需要改变的对象，该对象可在block内修改。</p>

<p><strong>大神解答：</strong></p>

<p>默认情况下，在block中访问的外部变量是复制过去的，即：<strong>写操作不对原变量生效</strong>。但是你可以加上<code>__block</code>来让其写操作生效，示例代码如下:</p>

<pre><code>__block int a = 0;
void  (^foo)(void) = ^{ 
    a = 1; 
}
f00(); 
//这里，a的值被修改为1
</code></pre>

<p>参考链接：<a href="http://weibo.com/tangqiaoboy">微博@唐巧_boy</a>的著作《iOS开发进阶》中的第11.2.3章节</p>

<h3>39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h3>

<p><strong>我的解答：</strong></p>

<p>不需要，因为这些block并不被当前类型实例持有，即使在内部使用了self的实例变量，也不会造成引用循环。</p>

<p><strong>大神解答：</strong></p>

<p>系统的某些block api中，UIView的block版本写动画时不需要考虑，但也有一些api 需要考虑：</p>

<p>所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block 强引用 self ）没有问题，比如这些：</p>

<p><code>objectivec
[UIView animateWithDuration:duration animations:^{ [self.superview layoutIfNeeded]; }];
</code></p>

<p><code>objectivec
[[NSOperationQueue mainQueue] addOperationWithBlock:^{ self.someProperty = xyz; }];
</code></p>

<p>```objectivec
[[NSNotificationCenter defaultCenter] addObserverForName:@&ldquo;someNotification&rdquo;</p>

<pre><code>                                              object:nil 
                       queue:[NSOperationQueue mainQueue]
                                          usingBlock:^(NSNotification * notification) {
                                                self.someProperty = xyz; }]; 
</code></pre>

<p>```</p>

<p>这些情况不需要考虑“引用循环”。</p>

<p>但如果你使用一些参数中可能含有 ivar 的系统 api ，如 GCD 、NSNotificationCenter就要小心一点：比如GCD 内部如果引用了 self，而且 GCD 的其他参数是 ivar，则要考虑到循环引用：</p>

<p><code>objectivec
__weak __typeof__(self) weakSelf = self;
dispatch_group_async(_operationsGroup, _operationsQueue, ^
{
__typeof__(self) strongSelf = weakSelf;
[strongSelf doSomething];
[strongSelf doSomethingElse];
} );
</code>
类似的：</p>

<p>```objectivec
  <strong>weak </strong>typeof<em>_(self) weakSelf = self;
  </em>observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&ldquo;testKey&rdquo;</p>

<pre><code>                                                            object:nil
                                                             queue:nil
                                                        usingBlock:^(NSNotification *note) {
  __typeof__(self) strongSelf = weakSelf;
  [strongSelf dismissModalViewControllerAnimated:YES];
</code></pre>

<p>  }];
```
self &mdash;> _observer &mdash;> block &mdash;> self 显然这也是一个循环引用。</p>

<h3>40. GCD的队列（<code>dispatch_queue_t</code>）分哪两种类型？</h3>

<p><strong>我的解答：</strong></p>

<p>执行的时候分同步和异步。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>串行队列Serial Dispatch Queue</li>
<li>并行队列Concurrent Dispatch Queue</li>
</ol>


<h3>41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h3>

<p><strong>我的解答：</strong></p>

<p>使用dispatch group技术，将多个dispatch queue加入同一group中，然后在group任务结束时，统一执行合成任务。</p>

<p><strong>大神解答：</strong></p>

<p>使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。</p>

<p>```objectivec
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, queue, ^{ /<em>加载图片1 </em>/ });
dispatch_group_async(group, queue, ^{ /<em>加载图片2 </em>/ });
dispatch_group_async(group, queue, ^{ /<em>加载图片3 </em>/ });
dispatch_group_notify(group, dispatch_get_main_queue(), ^{</p>

<pre><code>    // 合并图片
</code></pre>

<p>});
```</p>

<h3>42. <code>dispatch_barrier_async</code>的作用是什么？</h3>

<p><strong>我的解答：</strong></p>

<p>是用来阻塞当前queue内的并发线程，然后执行阻塞的任务，任务执行完后，继续并发操作。</p>

<p><strong>大神解答：</strong></p>

<p> 在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。
 <code>dispatch_barrier_async</code> 函数会等待追加到Concurrent Dispatch Queue并行队列中的操作全部执行完之后，然后再执行 <code>dispatch_barrier_async</code> 函数追加的处理，等 <code>dispatch_barrier_async</code> 追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。</p>

<p>打个比方：比如你们公司周末跟团旅游，高速休息站上，司机说：大家都去上厕所，速战速决，上完厕所就上高速。超大的公共厕所，大家同时去，程序猿很快就结束了，但程序媛就可能会慢一些，即使你第一个回来，司机也不会出发，司机要等待所有人都回来后，才能出发。 <code>dispatch_barrier_async</code> 函数追加的内容就如同 “上完厕所就上高速”这个动作。</p>

<p>（注意：使用 <code>dispatch_barrier_async</code> ，该函数只能搭配自定义并行队列 <code>dispatch_queue_t</code> 使用。不能使用： <code>dispatch_get_global_queue</code> ，否则 <code>dispatch_barrier_async</code> 的作用会和 <code>dispatch_async</code> 的作用一模一样。 ）</p>

<h3>43. 苹果为什么要废弃<code>dispatch_get_current_queue</code>？</h3>

<p><strong>我的解答：</strong></p>

<p>因为<code>dispatch_get_current_queue</code>并不能保证获取到的queue就是代码逻辑上正在运行的queue，尤其在dispatch互相嵌套时，按照<code>dispatch_get_current_queue</code>来判断，容易造成死锁。</p>

<p><strong>大神解答：</strong></p>

<p><code>dispatch_get_current_queue</code>容易造成死锁</p>

<h3>44. 以下代码运行结果如何？</h3>

<pre><code>- (void)viewDidLoad
{
    [super viewDidLoad];
    NSLog(@"1");
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@"2");
    });
    NSLog(@"3");
}
</code></pre>

<p><strong>我的解答：</strong></p>

<p>输出1，造成死锁。</p>

<p><strong>大神解答：</strong></p>

<p>只输出：1 。发生主线程锁死。</p>

<h3>45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h3>

<p><strong>我的解答：</strong></p>

<p>observer是监听者，keyPath是要监听的字段，option可以定义值以何种情况下改变触发监听，context不常用，实现的回调是：</p>

<p><code>objectivec
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;
</code></p>

<p><strong>大神解答：</strong></p>

<p><code>objectivec
// 添加键值观察
/*
1 观察者，负责处理监听事件的对象
2 观察的属性
3 观察的选项
4 上下文
*/
[self.person addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@"Person Name"];
</code>
observer中需要实现一下方法：</p>

<p><code>objectivec
// 所有的 kvo 监听到事件，都会调用此方法
/*
 1. 观察的属性
 2. 观察的对象
 3. change 属性变化字典（新／旧）
 4. 上下文，与监听的时候传递的一致
 */
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;
</code></p>

<h3>46. 如何手动触发一个value的KVO</h3>

<p><strong>我的解答：</strong></p>

<p>改变所监听属性的值即可触发。</p>

<p><strong>大神解答：</strong></p>

<p>所谓的“手动触发”是区别于“自动触发”：</p>

<p>自动触发是指类似这种场景：在注册 KVO 之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。</p>

<p>想知道如何手动触发，必须知道自动触发 KVO 的原理：</p>

<p>键值观察通知依赖于 NSObject 的两个方法:  <code>willChangeValueForKey:</code> 和 <code>didChangevlueForKey:</code> 。在一个被观察属性发生改变之前，  <code>willChangeValueForKey:</code> 一定会被调用，这就
会记录旧的值。而当改变发生后，  <code>didChangeValueForKey:</code> 会被调用，继而 <code>observeValueForKey:ofObject:change:context:</code> 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了。</p>

<p>那么“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。</p>

<p>具体做法如下：</p>

<p>如果这个  <code>value</code> 是  表示时间的 <code>self.now</code> ，那么代码如下：最后两行代码缺一不可。</p>

<p>```objectivec
//  .m文件
//  Created by <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
//  微博@iOS程序犭袁(<a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>).
//  手动触发 value 的KVO，最后两行代码缺一不可。</p>

<p>//@property (nonatomic, strong) NSDate *now;
&ndash; (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad];
[self willChangeValueForKey:@"now"]; // “手动触发self.now的KVO”，必写。
[self didChangeValueForKey:@"now"]; // “手动触发self.now的KVO”，必写。
</code></pre>

<p>}
```</p>

<p>但是平时我们一般不会这么干，我们都是等系统去“自动触发”。“自动触发”的实现原理：</p>

<blockquote><p>比如调用 <code>setNow:</code> 时，系统还会以某种方式在中间插入 <code>wilChangeValueForKey:</code> 、 <code>didChangeValueForKey:</code>  和 <code>observeValueForKeyPath:ofObject:change:context:</code> 的调用。</p></blockquote>

<p>大家可能以为这是因为 <code>setNow:</code> 是合成方法，有时候我们也能看到人们这么写代码:</p>

<p>```objectivec
&ndash; (void)setNow:(NSDate *)aDate {</p>

<pre><code>[self willChangeValueForKey:@"now"]; // 没有必要
_now = aDate;
[self didChangeValueForKey:@"now"];// 没有必要
</code></pre>

<p>}
<code>``
这是完全没有必要的代码，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用</code>willChangeValueForKey:<code> ，之后总是调用</code>didChangeValueForkey:` 。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。下文《apple用什么方式实现对一个对象的KVO？》会有详述。</p>

<p>参考链接： <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOCompliance.html#//apple_ref/doc/uid/20002178-SW3">Manual Change Notification&mdash;-Apple 官方文档</a></p>

<h3>47. 若一个类有实例变量 <code>NSString *_foo</code> ，调用setValue:forKey:时，可以以foo还是 <code>_foo</code> 作为key？</h3>

<p><strong>我的解答：</strong></p>

<p>都行。</p>

<p><strong>大神解答：</strong></p>

<p>都可以。</p>

<h3>48. KVC的keyPath中的集合运算符如何使用？</h3>

<p><strong>我的解答：</strong></p>

<p>没用过。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>必须用在集合对象上或普通对象的集合属性上</li>
<li>简单集合运算符有@avg， @count ， @max ， @min ，@sum，</li>
<li>格式 @&ldquo;@sum.age"或 @"集合属性.@max.age&rdquo;</li>
</ol>


<h3>49. KVC和KVO的keyPath一定是属性么？</h3>

<p><strong>我的解答：</strong></p>

<p>不清楚有其他类型。</p>

<p><strong>大神解答：</strong></p>

<p>KVO支持实例变量</p>

<h3>50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</h3>

<p><strong>我的解答：</strong></p>

<p>额，不知道。</p>

<p><strong>大神解答：</strong></p>

<p>不常用，大神也没解释，请参考：<a href="http://tech.glowing.com/cn/implement-kvo/">《如何自己动手实现 KVO》</a></p>

<h3>51. apple用什么方式实现对一个对象的KVO？</h3>

<p><strong>我的解答：</strong></p>

<p>额，不清楚。</p>

<p><strong>大神解答：</strong></p>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html">Apple 的文档</a>对 KVO 实现的描述：</p>

<blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling&hellip; When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class &hellip;</p></blockquote>

<p>从<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html">Apple 的文档</a>可以看出：Apple 并不希望过多暴露 KVO 的实现细节。不过，要是借助 runtime 提供的方法去深入挖掘，所有被掩盖的细节都会原形毕露：</p>

<blockquote><p>当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象：值的更改。最后通过 <code>isa 混写（isa-swizzling）</code> 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。我画了一张示意图，如下所示：</p></blockquote>

<p><img src="http://i62.tinypic.com/sy57ur.jpg" alt="enter image description here" /></p>

<p> KVO 确实有点黑魔法：</p>

<blockquote><p>Apple 使用了 <code>isa 混写（isa-swizzling）</code>来实现 KVO 。</p></blockquote>

<p>下面做下详细解释：</p>

<p>键值观察通知依赖于 NSObject 的两个方法:  <code>willChangeValueForKey:</code> 和 <code>didChangevlueForKey:</code> 。在一个被观察属性发生改变之前，  <code>willChangeValueForKey:</code> 一定会被调用，这就会记录旧的值。而当改变发生后，  <code>didChangeValueForKey:</code> 会被调用，继而 <code>observeValueForKey:ofObject:change:context:</code> 也会被调用。可以手动实现这些调用，但很少有人这么做。一般我们只在希望能控制回调的调用时机时才会这么做。大部分情况下，改变通知会自动调用。</p>

<p> 比如调用 <code>setNow:</code> 时，系统还会以某种方式在中间插入 <code>wilChangeValueForKey:</code> 、 <code>didChangeValueForKey:</code>  和 <code>observeValueForKeyPath:ofObject:change:context:</code> 的调用。大家可能以为这是因为 <code>setNow:</code> 是合成方法，有时候我们也能看到人们这么写代码:</p>

<p>```objectivec
&ndash; (void)setNow:(NSDate *)aDate {</p>

<pre><code>[self willChangeValueForKey:@"now"]; // 没有必要
_now = aDate;
[self didChangeValueForKey:@"now"];// 没有必要
</code></pre>

<p>}
<code>``
这是完全没有必要的代码，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用</code>willChangeValueForKey:<code> ，之后总是调用</code>didChangeValueForkey:<code>。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。第一次对一个对象调用</code>addObserver:forKeyPath:options:context:` 时，框架会创建这个类的新的 KVO 子类，并将被观察对象转换为新子类的对象。在这个 KVO 特殊子类中， Cocoa 创建观察属性的 setter ，大致工作原理如下:</p>

<p>```objectivec
&ndash; (void)setNow:(NSDate *)aDate {</p>

<pre><code>[self willChangeValueForKey:@"now"];
[super setValue:aDate forKey:@"now"];
[self didChangeValueForKey:@"now"];
</code></pre>

<p>}
```
这种继承和方法注入是在运行时而不是编译时实现的。这就是正确命名如此重要的原因。只有在使用KVC命名约定时，KVO才能做到这一点。</p>

<p>KVO 在实现中通过 <code>isa 混写（isa-swizzling）</code> 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。这在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html">Apple 的文档</a>可以得到印证：</p>

<blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling&hellip; When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class &hellip;</p></blockquote>

<p>然而 KVO 在实现中使用了 <code>isa 混写（ isa-swizzling）</code> ，这个的确不是很容易发现：Apple 还重写、覆盖了 <code>-class</code> 方法并返回原来的类。 企图欺骗我们：这个类没有变，就是原本那个类。。。</p>

<p>但是，假设“被监听的对象”的类对象是 <code>MYClass</code> ，有时候我们能看到对 <code>NSKVONotifying_MYClass</code> 的引用而不是对  <code>MYClass</code>  的引用。借此我们得以知道 Apple 使用了 <code>isa 混写（isa-swizzling）</code>。具体探究过程可参考<a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html"> 这篇博文 </a>。</p>

<h3>52. IBOutlet连出来的视图属性为什么可以被设置成weak?</h3>

<p><strong>我的解答：</strong></p>

<p>忘了。如果做成strong，需要手动去释放这些控件。</p>

<p><strong>大神解答：</strong></p>

<p>参考链接：<a href="http://stackoverflow.com/questions/7678469/should-iboutlets-be-strong-or-weak-under-arc"> <strong><em>Should IBOutlets be strong or weak under ARC?</em></strong> </a></p>

<p>文章告诉我们：</p>

<blockquote><p>因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了。</p></blockquote>

<p>不过这个回答漏了个重要知识，使用storyboard（xib不行）创建的vc，会有一个叫_topLevelObjectsToKeepAliveFromStoryboard的私有数组强引用所有top level的对象，所以这时即便outlet声明成weak也没关系</p>

<h3>53. IB中User Defined Runtime Attributes如何使用？</h3>

<p><strong>我的解答：</strong></p>

<p>可以对控件添加额外的属性。</p>

<p><strong>大神解答：</strong></p>

<p>它能够通过KVC的方式配置一些你在interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller</p>

<h3>54. 如何调试BAD_ACCESS错误</h3>

<p><strong>我的解答：</strong></p>

<p>通过开启NSZombies，可以在对象释放后创建其对应的Zombie对象，并记录对其发送的消息，然后打印给开发者，从而告知开发者造成内存泄露的对象类型和方法。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>重写object的respondsToSelector方法，现实出现EXEC_BAD_ACCESS前访问的最后一个object</li>
<li><p>通过 Zombie
<img src="http://i.stack.imgur.com/ZAdi0.png" alt="enter image description here" /></p></li>
<li><p>设置全局断点快速定位问题代码所在行</p></li>
<li>Xcode 7 已经集成了BAD_ACCESS捕获功能：<strong>Address Sanitizer</strong>。
用法如下：在配置中勾选✅Enable Address Sanitizer
<img src="https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Art/xc7-asan_2x.png" alt="enter image description here" /></li>
</ol>


<h3>55. lldb（gdb）常用的调试命令？</h3>

<p><strong>我的解答：</strong></p>

<p>用过po命令打印出当前对象的值。</p>

<p><strong>大神解答：</strong></p>

<ul>
<li>breakpoint 设置断点定位到某一个函数</li>
<li>n 断点指针下一步</li>
<li>po打印对象</li>
</ul>


<p>更多 lldb（gdb） 调试命令可查看</p>

<ol>
<li><a href="http://lldb.llvm.org/lldb-gdb.html"> <strong><em>The LLDB Debugger</em></strong> </a>；</li>
<li>苹果官方文档：<a href="https://developer.apple.com/library/ios/technotes/tn2239/_index.html"> <strong><em>iOS Debugging Magic</em></strong> </a>。</li>
</ol>

]]></content>
  </entry>
  
</feed>
