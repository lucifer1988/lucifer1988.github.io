<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 刘毅的技术博客]]></title>
  <link href="http://lucifer1988.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://lucifer1988.github.io/"/>
  <updated>2015-10-15T11:02:42+08:00</updated>
  <id>http://lucifer1988.github.io/</id>
  <author>
    <name><![CDATA[刘毅]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Classes and Structs]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/12/swift-by-tutorials-classes-and-structs/"/>
    <updated>2015-10-12T15:26:48+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/12/swift-by-tutorials-classes-and-structs</id>
    <content type="html"><![CDATA[<p>继上两章对Swift的基本类型的学习，这一章开始介绍Swift中的Class和Struct，Class对所有面向对象的语言都不陌生，而Struct可能用的比较少，因为大部分用于C中，但Swift中的Struct与C还有很多不同，这章会一一介绍，而且同时会讲到Class与Struct之间的不同与使用场景，以及它们的扩展，也是这一章的重点。</p>

<h2>Getting started</h2>

<h3>The class concept</h3>

<p>1.类是通过总结一些对象的共同特点，定义基本类型，通过继承来创建具体使用的子类型，它拥有自己的数据和方法，可以视为数据的容器。</p>

<h2>My first class</h2>

<p>1.介绍示例项目的Class设计。</p>

<h3>Creating the class</h3>

<p>1.import语句用于导入Swift的库文件，记性好的话，之前Apple在OC中加入了@import来替代#import（如：@import Foundation;替代#import &lt;Foundation/Foundation.h>），其实Swift中的import是和这个一致的。<br/>
2.定义一个类如下即可，但是如果如下，有未初始化赋值的非optional变量，那么会提示你增加初始化方法。</p>

<p>```objectivec
class Treasure {</p>

<pre><code>let what: String
let latitude: Double
let longitude:Double
</code></pre>

<p>}
init(what: String, latitude: Double, longitude: Double) {</p>

<pre><code>self.what = waht
self.latitude = latitude
self.longitude = longitude
</code></pre>

<p>}
```</p>

<h3>A struct-ural improvement</h3>

<p>1.下一步的优化是把经纬度信息做成一个结构体，那么就涉及到了Swift中的Struct，Swift中Struct和Class一样，都可以存储数据和拥有自己的方法，但要记住Struct始终是一个数值型的容器，它的用途只是持有数据，不要让它承担更多的功能。</p>

<p>```objectivec
struct GeoLocation {</p>

<pre><code>var latitude: Double
var longitude: Double
</code></pre>

<p>}
```</p>

<p>2.在Swift中，在工程中的文件是相互自动import的，所以你不用再去手动导入，这一点在你开发library和framework也是一样的。</p>

<h3>Reference types vs. value types</h3>

<p>1.Swift中，Struct与Class的最大区别是，Class在本质上是指针引用类型，而Struct是值类型，在赋值过程中，Class传递的是指针，而Struct则会copy一份新值，从如下的例子即可看出。</p>

<p>```objectivec
struct MyStruct {</p>

<pre><code>var foo: Double = 0.0
</code></pre>

<p>}
class MyClass {</p>

<pre><code>var foo: Double = 0.0
</code></pre>

<p>}
var structA = MyStruct()
var structB = structA
structB.foo = 1.0
print(structA.foo)
//0.0
print(structB.foo)
//1.0
var classA = MyClass()
var classB = classA
classB.foo = 1.0
print(classA.foo)
//1.0
print(classB.foo)
//0.0
```</p>

<p>2.需要说明的一点，Swift在copy一个Struct时是很智能的，只会在确定必要的时候copy，也就是说structB = structA并不会创建出拷贝，只有你开始改变其中一个值时，runtime会开始执行copy。<br/>
3.另外关于let类型的Struct和Class还有一些细微的区别，对于二者的var实例，是没有区别的，都可以改变各自的属性或将自身赋值给其他实例，但对于let实例，Class依然可以修改自己的属性变量，但是不能将自己赋值给其他实例，而Struct既不能改变自己的属性变量，也不能将自己赋值给其他实例，这也是为什么Array和Dictionary是Struct而不是Class。</p>

<p>```objectivec
struct MyStruct {</p>

<pre><code>var foo: Double = 0.0
</code></pre>

<p>}
class MyClass {</p>

<pre><code>var foo: Double = 0.0
</code></pre>

<p>}
var classA = MyClass()
let classB = MyClass()
classA.foo = 1.0
classB.foo = 1.0
classB = classA
//error
var structA = MyStruct()
let structB = MyStruct()
structA.foo = 1.0
structB.foo = 1.0
//error
structB = structA
//error
```</p>

<h3>Convenience initializers</h3>

<p>1.在实例中其实还是不必要将GeoLocation暴露给使用者，可以直接给出更方便的初始化方法，这就用到了convenience initializer，在该初始化方法中跳转到了原初始化方法中，也称为designated initializer。</p>

<p>```objectivec
convenience init(what: String, latitude: Double, longitude: Double) {</p>

<pre><code>let location = GeoLocation(latitude: latitude, longitude: longitude)
self.init(what: what, location: location)
</code></pre>

<p>}
```</p>

<p>2.Struct不需要显式的初始化方法，Swift为你自动添加了，你只需要按Struct的属性顺序一一初始化就行了，这也是为什么上述方法中可以自动初始化GeoLocation。</p>

<h3>Class inheritance</h3>

<p>1.Swift中的继承是怎样的？如下例：</p>

<p>```objectivec
class HistoryTreasure: Treasure {</p>

<pre><code>let yaer: Int
init(what: String, year: Int, latitude: Double, longitude: Double) {
    self.year = year
    let location = GeoLocation(latitude: latitude, longitude: longitude)
    super.init(what: what, location: location)
}
</code></pre>

<p>}
```</p>

<p>2.子类如果有自己新的属性时，需要自己的designated initializer，而子类的designated initializer必须引用父类的一个designated initializer（注意不可以是convenience initializer），所以和上一节比较相当于做了重复工作。<br/>
3.这里有与OC不同的一点，在OC中子类的init()方法中，是先调用父类的init()，再进行子类属性的赋值，而在Swift中是最后调用父类的init()，因为在Swift中是initializer来初始化所有属性，最后交给父类来处理，父类的init()要放在最后，是因为它不知道子类中声明的新属性，必须在它之前把这些新属性初始化。</p>

<!--more-->


<h2>Swift and MapKit</h2>

<p>1.重写父类方法，Swift中需要在方法前加上override关键字，增加了可读性，同时如果你写的方法不存在于父类，那么编译器会报error通知你。</p>

<p>```objectivec
override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()
</code></pre>

<p>}
```</p>

<h3>Class extensions and computed properties</h3>

<p>1.示例中需要将Treasure类型的变量显示在MKMapView上，那么就要使Treasure遵循MKAnnotation协议，我们使用了extension来实现：</p>

<p>```objectivec
import MapKit
extension Treasure: MKAnnotation {</p>

<pre><code>var coordinate: CLLocationCoordinate2D {
    return self.location.coordinate
}
var title: String {
    return self.what
}
</code></pre>

<p>}
```</p>

<p>2.extension类似OC的category，都是扩展类的技术，但是优于category，因为extension不但可以添加方法，还可以添加新属性。<br/>
3.这里添加的两个property有些特别，它们是Swift中的computed properties，每次访问它们都会执行后面的方法，用法与普通的properties是一致的。</p>

<h3>Your first struct extension</h3>

<p>1.Struct也可以添加extension，下例中的extension起到了分割代码，增加可读性的作用，这是extension的习惯用法。</p>

<p>```objectivec
import MapKit
extension GeoLocation {</p>

<pre><code>var coordinate: CLLocationCoordinate2D {
    return CLLocationCoordinate2DMake(self.latitude, self.longitude)
}
var mapPoint: MKMapPoint {
    return MKMapPointForCoordinate(self.coordinate)
}
</code></pre>

<p>}
```</p>

<h3>Inheriting from NSObject</h3>

<p>1.类遵循MKAnnotation同时，也应该遵循NSObject协议，因为MKAnnotation继承自NSObject协议。</p>

<h3>Pinning the map</h3>

<p>1.在viewDidLoad()中添加以下代码，完成mapView上打点的工作。</p>

<p><code>objectivec
self.mapView.delegate = self
self.mapView.addAnnotations(self.treasures)
</code></p>

<p>2.然后添加viewController的extension，并实现MKMapViewDelegate的方法：</p>

<p>```objectivec
extension ViewController: MKMapViewDelegate {</p>

<pre><code>func mapView(mapView: MKMapView, viewForAnnotation annotation: MKAnnotation) -&gt; MKAnnotationView
{
    if let treasure = annotation as? Treasure {
        var view = mapView.dequeueReusableAnnotationViewWithIdentifier("pin") as! MKPinAnnotationView!
        if view = nil {
            view = MKPinAnnotationView(annotation: annotation, reuseIdentifier: "pin")
            view.canShowCallout = true
            view.animatesDrop = false
            view.calloutOffset = CGPoint(x: -5, y: 5)
            view.rightCalloutAccessoryView = UIButton(type: .DetailDisclosure) as UIView
        } else {
            view.annotation = annotation
        }
        return view
    }
    return nil
}
</code></pre>

<p>}
```</p>

<p>3.在实现的mapView:viewForAnnotation方法中，annotation参数类型为MKAnnotation!，是一个隐式拆解的optional类型，但是我们还是进行了if/let的检查，因为这个方法是OC的API，是没有optional的，所以为了兼容Swift只能声明为这个类型，所以还需要显式拆解。<br/>
4.同时除了检查是否为nil，我们还要注意传入的类型是否为Treasure类型，这儿用到了inline downcasting技术，也是Swift的一种简写语法，if let treasure = annotation as？ Treasure{}，如果annotation不是Treasure类型，那么也不会进入if，这是Swift中确保类型正确的一种技术。<br/>
5.获取MKPinAnnotationView利用了一贯的复用技术，另外此处又一次用到了downcast技术，只不过因为返回的类型肯定可以确定都是MKPinAnnotationView，所以用了非optional版本。</p>

<h3>The reduce algorithm</h3>

<p>1.这一节是为了解决app载入后不能直接定位到目标位置，而要先定位自己的位置这个bug。</p>

<p><code>objectivec
let rectToDisplay = self.treasures.reduce(MKMapRectNull) {
  (mapRect: MKMapRect, treasure: Treasure) -&gt; MKMapRect in
  let treasurePointRect = MKMapRect(origin: treasure.location.mapPoint, size: MKMapSize(width: 0, height: 0))
  return MKMapRectUnion(mapRect, treasurePointRect)
}
self.mapView.setVisibleMapRect(rectToDisplay, edgePadding: UIEdgeInsetsMake(74, 10, 10, 10), animated: false)
</code></p>

<p>2.为了达到这一优化，实际就是要获取可以展示全部treasures的最小地图范围，然后在地图绘制这一区域。而输入是一个数组，需要一个它们逐个计算的结果，这里使用了函数式编程中的Reduce函数，这是处理这一问题的最佳方案，下面是Swift中reduce的原型，需要一个初始值initial，这里对应的是MKMapRectNull，是一个空区域，然后combine的方法是(mapRect: MKMapRect, treasure: Treasure) &ndash;> MKMapRect类型的方法，mapRect是每次执行后的返回值，初始值就是initial，而treasure是array每个元素的遍历，最后可以得到一个MKMapRect类型的区域，包含了所有元素的最小区域，然后setVisibleMapRect()，并加了边距来适应其他页面元素，最终达到了目的，Swift中的函数式编程还会在第七章继续讲解。</p>

<p><code>objectivec
reduce(initial: U, combine: (U, T) -&gt; U) -&gt; U
</code></p>

<!--more-->


<h2>Polymorphism</h2>

<p>1.现在又有新需求了，需要不同类型的Treasure在地图上显示Annotation颜色不同，这可以通过多态来实现，首先在父类中添加方法，再在子类中重写该方法：</p>

<p><code>objectivec
//in parent class
func pinColor() -&gt; MKPinAnnotationColor  {
  return MKPinAnnotationColor.Red
}
//in subclass
override func pinColor() -&gt; MKPinAnnotationColor  {
  return MKPinAnnotationColor.Purple
}
</code></p>

<p>2.然后在绘制MKPinAnnotationView那儿调用该方法：</p>

<p><code>objectivec
view.pinColor = treasure.pinColor()
</code></p>

<h3>Dynamic dispatch and final classes</h3>

<p>1.对于上面的Treasure多态，runtime是怎么执行的呢？是靠dynamic dispatch实现的，这一技术其实在OC里用的很普遍，OC作为动态语言，可以在runtime修改所传递的消息，甚至消息的接收者，都是靠动态分发(详细过程可参照前一部的Effective Objective-C2.0的笔记)。<br/>
2.Dynamic dispatch在Swift中依然存在，就是为了实现多态这类特性，不同于OC的消息分发机制，Swift的分发更像C++，它通过virtual tables(简称vtables)来实现。<br/>
3.如上例，当编译器遇到pinColor()调用，因为Treasure有很多子类，它便会去使用vtable去查找，而如果是Treasure的子类调用pinColor()，编译器依然会去先去查找vtable，而不是直接去调用pinColor()方法，因为它并不知道有没有类继续在继承，虽然开发者知道它是没有子类的。<br/>
4.所以通过告知编译器某些类没有子类，会提高app的效率，缩短运行时间，我们可以通过在类型前加final关键字来告知编译器这一信息。</p>

<p><code>objectivec
final class HistoryTreasure: Treasure
</code></p>

<!--more-->


<h2>Adding annotations</h2>

<p>1.继续，新的需求是用户点击每个annotation时弹出一个alertView来告知用户一些信息。因为每个alert提示的信息不同，所以打算将生成alert的任务交给treasure，然后viewController负责显示，采用的是利用protocol技术。<br/>
2.首先在Treasure.swift文件中声明Alertable协议，然后Treasure的子类分别遵循并实现其中的方法。</p>

<p>```objectivec
@objc protocol Alertable {</p>

<pre><code>fun alert() -&gt; UIAlertController
</code></pre>

<p>}
```</p>

<p>```objectivec
extension HistoryTreasure: Alertable {<br/>
  func alert() &ndash;> UIAlertController {</p>

<pre><code>let alert = UIAlertController(title: "History", message: "From \(self.year):\n\(self.what)", preferredStyle: UIAlertControllerStyle.Alert)
return alert
</code></pre>

<p>  }
}
```</p>

<p>3.然后在viewController中实现MapView点击Annotation的委托方法。</p>

<p>```objectivec
func mapView(mapView: MKMapView, annotationView view: MKAnnotationView, calloutAccessoryControlTapped control: UIControl) {
  if let treasure = view.annotation as? Treasure {</p>

<pre><code>if let alertable = treasure as? Alertable {
  let alert = alertable.alert()
  alert.addAction(UIAlertAction(title: "OK", style: UIAlertActionStyle.Default, handler: nil))
  self.presentViewController(alert, animated: true, completion: nil)
}
</code></pre>

<p>  }
}
```</p>

<!--more-->


<h2>Sorting an array</h2>

<p>1.新需求，用户可以在找到第一个treasure后能有选项可以使其找到下一个最近的treasure。首先我们给GeoLocation添加一个计算点之间的方法。</p>

<p><code>objectivec
func distanceBetween(other: GeoLocation) -&gt; Double {
  let locationA = CLLocation(latitude: self.latitude, longitude: self.longitude)
  let locationB = CLLocation(latitude: other.latitude, longitude: other.longitude)
  return locationA.distanceFromLocation(locationB)
}
</code></p>

<p>2.该方法是直接定义在struct的定义中的，Swift中的Struct可以定义方法，这也是它与C的Struct的最大区别，C中的Struct只能定义变量，导致与之相关的方法只能定义为全局方法，而如何按照类型归纳这些方法就需要开发者手工将其写到一个头文件中，这显然费时也不合理，而Swift真正实现了Struct中可以真正拥有自己的方法。<br/>
3.像用户点击Annotation后弹出的alert再添加一个Find Nearest的选项，并实现找到离该点最近的Treasure。</p>

<p>```objectivec
alert.addAction(UIAlertAction(title: &ldquo;Find Nearest&rdquo;, style: UIAlertActionStyle.Default) { action in
  var sortedTreasures = self.treasures
  sortedTreasures.sortInPlace {</p>

<pre><code>let distanceA = treasure.location.distanceBetween($0.location)
let distanceB = treasure.location.distanceBetween($1.location)
return distanceA &lt; distanceB
</code></pre>

<p>  }
  mapView.deselectAnnotation(treasure, animated: true)
  mapView.selectAnnotation(sortedTreasures[1], animated: true)
  })
```</p>

<p>4.上述代码的核心是sortedTreasures的排序，利用了sort()方法(Swift中改为sortInPlace())，$1和$2分别代表了传入方法的第一和第二参数，是简写形式，分别计算出两点距离当前treasure的距离，然后返回Bool告知是否已按照小大顺序排好，最后数组排序后，展示第二个元素，来展示最近的treasure。</p>

<p><code>objectivec
public mutating func sortInPlace(@noescape isOrderedBefore: (Self.Generator.Element, Self.Generator.Element) -&gt; Bool)
</code></p>

<!--more-->


<h2>Equality and operator overload</h2>

<p>1.照例，新需求，需要标记用户发现treasure的路径并在用户在已发现的treasure上操作时提示用户。<br/>
2.创建已找到Treasure的数组和要绘制的地图线，并实现MKMapViewDelegate的一个方法。</p>

<p><code>objectivec
private var foundLocations: [GeoLocation] = []
private var polyline: MKPolyline!
</code></p>

<p>```objectivec
func mapView(mapView: MKMapView, rendererForOverlay overlay: MKOverlay) &ndash;> MKOverlayRenderer {
  if let polylineOverlay = overlay as? MKPolyline {</p>

<pre><code>let renderer = MKPolylineRenderer(polyline: polylineOverlay)
renderer.strokeColor = UIColor.blueColor()
return renderer
</code></pre>

<p>  }
  return nil
}
```</p>

<p>3.在上一节添加alert的位置再添加Found项，再创建markTreasureAsFound()方法来标记已找到的Treasure，并绘制新的MKPolyline。</p>

<p><code>objectivec
alert.addAction(UIAlertAction(title: "Found", style: UIAlertActionStyle.Default) { action in
  self.markTreasureAsFound(treasure)
  })
</code></p>

<p>```objectivec
private func markTreasureAsFound(treasure: Treasure) {
  if let index = self.foundLocations.indexOf(treasure.location) {</p>

<pre><code>let alert = UIAlertController(title: "Oops!", message: "You've already found this treasure (at step \(index + 1))! Try again!", preferredStyle: .Alert)
alert.addAction(UIAlertAction(title: "OK", style: .Default, handler: nil))
self.presentViewController(alert, animated: true, completion: nil)
</code></pre>

<p>  } else {</p>

<pre><code>self.foundLocations.append(treasure.location)
if self.polyline != nil {
  self.mapView.removeOverlay(self.polyline)
}
var coordinates = self.foundLocations.map { $0.coordinate }
self.polyline = MKPolyline(coordinates: &amp;coordinates, count: coordinates.count)
self.mapView.addOverlay(self.polyline)
</code></pre>

<p>  }
}
```</p>

<p>4.首先利用find()函数（Swift2.0已弃用，改为collection的indexOf()方法）来获取目前位置是否已在foundLocations中，返回值为optional类型，所以需要if/let判断，这里就体现了这一技术的便利。<br/>
5.在创建MKPolyline时，先对foundLocations使用了map方法，map如前面提到的reduce一样，也是函数式编程的一种，它的作用是从一个数组中获取另外一个数组，这里就是从foundLocations得到了由其中每一个location的coordinate组成的新数组，$0代表每一个location。<br/>
6.这里需要实现find()方法（实际在Swift2.0已弃用），需要在GeoLocation中遵循Equatable协议，，因为find()中比较每个元素是通过==来比较的（类似OC中的isEqual()），而Class和Struc默认是不能用==比较的。这里用到了Swift的又一新特性，operator overload，既可以直接重写==这样的操作符，但需要注意下面对==的重写，并没有包含在extension中，因为operation overload都必须在定义在全局中，因为它本身并不属于某个类，它只是与一个类有关，基于要比较的的两个参数是这个类的实例。</p>

<p><code>objectivec
protocol Equatable {    func ==(lhs: Self, rhs: Self) -&gt; Bool}
</code></p>

<p><code>objectivec
extension GeoLocation: Equatable {
}
func ==(lhs: GeoLocation, rhs: GeoLocation) -&gt; Bool {
  return lhs.latitude == rhs.latitude &amp;&amp; lhs.longitude == rhs.longitude
}
</code></p>

<!--more-->


<h2>Access Control</h2>

<p>1.目前为止所有变量和方法都是public的，但Swift提供了访问权限的关键字，包括：Public(所有代码均可访问)、Internal(只在该target(library或app)下的代码可以访问，是默认权限)、Private(只有该文件可以访问)。<br/>
2.例如有一些类中的帮助方法，你不希望暴露在外，因为他们可以改变着一些不该暴露的内部状态信息。<br/>
3.需要注意的是Unit test通常是另外一个Target，如果你的代码有部分需要单元测试，那么需要声明为public。<br/>
4.与OC相比，OC是没有绝对的私有方法的，因为即使没有暴露在在头文件中，也可以通过runtime注入来访问私有方法。</p>

<p><code>objectivec
private func markTreasureAsFound(treasure: Treasure)
</code></p>

<p><code>objectivec
private var treasures: [Treasure] = []private var foundLocations: [GeoLocation] = [] private var polyline: MKPolyline!
</code></p>

<p>5.internal一般是不会显式声明的，如果是一个library被多个app使用，你可能会将内部类声明为internal，这样就不会被其他app中的代码使用了。<br/>
6.访问控制标志是表达你代码意图的很好的方式，可以使代码更易维护，也会减少Bug，</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Language Basics II]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/10/swift-by-tutorials-language-basics-ii/"/>
    <updated>2015-10-10T14:41:12+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/10/swift-by-tutorials-language-basics-ii</id>
    <content type="html"><![CDATA[<p>继上一篇后，本章将继续介绍Swift的基础知识，但是相比第一章会有所提升，包括了Optional类型对象的用法、Swift中的Collection类型用法以及与OC的Collection的不同之处。</p>

<!--more-->


<h2>Optionals</h2>

<p>1.空指针是一个困扰着各类语言的常见问题，在Java中，调用了空指针会直接抛出异常，在OC中向nil指针发送消息会返回nil，也就是说空指针是安全的，但有很多时候你并不希望指针为空，一般会加判断对象是否为nil的断言判断，但在Swift中，针对这个问题，有了新的解决方案。<br/>
2.Swift在对没有初始化赋值的变量使用时，会直接报错，而且像String类型也不能初始化直接赋nil值，这也保证了空指针不会出现。但是如果我们真的需要一个空值的变量怎么办呢？可以使用optional机制，它是用来指明一个变量是可能有值的，相当于给变量一个nil的默认值，这也是空指针的问题所在，它是一个合法的指针，但没有指向一个合法的对象。</p>

<h3>Declaring optionals</h3>

<p>1.使用optional很简单，如下，不赋值的话str默认为nil，在这里你可以把String?理解为一个不同于String的类型，所以能给String?直接赋值String类型实际上是Swift在内部进行了封装，Swift将String的值封装到了一个String?类型的实例中，然后再赋值给了str。</p>

<p><code>objectivec
//no assignment
var str: String?
//an assignment
var str: String? = "Swift by Tutorials!"
</code></p>

<p>2.如果你现在对str使用uppercaseString方法，会报错，这也验证了上面所说String?已是另一个类型的说法，那么如何让str使用String的方法呢？如下即可，通过if语句对str进行解封，并将其赋值给一个let型的String，这就是optional和if在Swift中的经典配合，这么做的好处就是让开发者可以在必选确认指针不为空的时候强制去进行空指针的检查。</p>

<p>```objectivec
if let unwrappedStr = str {</p>

<pre><code>print("Unwrapped! \(unwrappedStr.uppercaseString)")
</code></pre>

<p>} else {</p>

<pre><code>print("Was nil")
</code></pre>

<p>}
```</p>

<h3>Forced unwrapping</h3>

<p>1.在你了解optional机制下，在一些optional中你确定有值的时候，你可以使用强制解封，如下：</p>

<p><code>objectivec
var str: String? = "Swift by Tutorials!"
print("Force unwrapped! \(str!.uppercaseString)")
</code></p>

<p>2.但是需要注意的是，如果optional类型中的是nil值，那么会出现runtime error，所以使用强制解封，<strong>一定要在你100%确定你的optional对象不是空值</strong>。</p>

<h3>Implicit unwrapping</h3>

<p>1.你也可以不用!或者let来进行optional解封，使用以下方法，可以直接对变量使用方法，这看起来和没使用optional差不多，但是它在实质上和上述两种解封方法是一致的，只是语法不通而已，如果不去初始化赋值，那么你会得到和强制解封一个nil的optional的值一样的error。</p>

<p><code>objectivec
var str: String! = "Swift by Tutorials!"
str = str.lowercaseString
print(str)
</code></p>

<p>2.你也可以通过if来检查隐式解封的optional值，但你会发现这和OC中的做法一样，只不过在OC中你拿nil作为一个false的判断条件，而在Swift中你将nil作为一个无值的状态来判断。</p>

<p>```objectivec
if str != nil {</p>

<pre><code>str = str.lowercaseString
print(str)
</code></pre>

<p>}
```</p>

<p>3.<strong>最后注意，你要将隐式解封和强制解封一样重视，因为除了声明的地方，它和普通变量是一样的，这很容易忽视。</strong></p>

<h3>Optional chaining</h3>

<p>1.最后要介绍的是Optional chaining，这是上述三个解封方式之外的另一种optional来执行方法的方式，它的设计参照了OC中常用的delegate模式，即在optional类型变量执行方法时会先判断它是否为nil，不是nil的话直接执行，而如果是nil的话，则直接返回nil，其实和OC中对nil发送消息的处理是一样的。</p>

<p><code>objectivec
var maybeString: String? = "Swift by Tutorials!"
let uppercase = maybeString?.uppercaseString
</code></p>

<p>2.由于在对象声明和方法执行时两次使用optional，所以形成了Optional chaining。</p>

<!--more-->


<h2>Collection</h2>

<p>1.任何语言都会有集合类型，OC中有NSArray、NSDictionary、NSSet，其中包含可变和不可变类型，而在Swift中只保留了Array和Dictionary两种类型。</p>

<h3>Arrays</h3>

<p>1.Swift的Array有着其他语言中共同的特性，如下：</p>

<p><code>objectivec
//initialize array
var array = [1, 2, 3, 4, 5]
print(array[2])
//add an element
array.append(6)
print(array)
</code></p>

<p>2.Swift中你可以通过添加一个序列来扩展一个Array，比如上一节提到的Range。</p>

<p><code>objectivec
//add 7,8,9,10
//Swift2.0中将extend()改为了appendContentsOf()
//array.extend(7...10)
array.appendContentsOf(7...10)
</code></p>

<p>3.在上述数组中试图添加一个String，会直接报错，这在OC中可能是很正常的需求，可以在一个数组中添加不同类型的对象，但在Swift中只能在一个数组中添加同一类型的对象，在上面的Array初始化中是使用了type interface，如果制定类型声明的话应该是<em>var array: Array<Int> = [1, 2, 3, 4, 5]</em>（会在第四章详细说明），不过更常见的写法是<em>var arrray: [Int] = [1, 2, 3, 4, 5]</em>，这是Apple的语法糖，用来简化语法。</p>

<p><code>objectivec
//Array Initializer
var array: Array&lt;Int&gt; = [1, 2, 3, 4, 5]
var arrray: [Int] = [1, 2, 3, 4, 5]
</code></p>

<p>4.当然也可以让Array像NSArray那样工作，可以将类型声明为Array<Any>，但是仍然不推荐这么做，因为这样Swift的很多Array方法会因为类型不一而不能使用，而且也会失去Swift的提供的安全性保护。</p>

<p><code>objectivec
//add multiple type instance
var array: Array&lt;Any&gt; = []
array.append(6)
array.append("Swift By Tutorials!")
</code></p>

<h3>Dictionaries</h3>

<p>1.Swift的Dictionary与OC的NSDicionary大致相同，只是语法上略有变化，但需要注意的是，Dictionary也存在只能添加固定类型的键值对的情况，与上述的Array相同。</p>

<p><code>objectivec
var dictionary = [1: "Dog", 2: "Cat"]
//Another Initializer
//var dictionary: Dictionary&lt;Int:String&gt; = [1: "Dog", 2: "Cat"]
//var dictionary: [Int:String] = [1: "Dog", 2: "Cat"]
print(dictionary[1])
dictionary[3] = "Mouse"
print(dictionary)
dictionary[3] = nil
print(dictionary)
</code></p>

<p>2.从Dictionary中通过key直接获取值时，该值是optional类型的，因为有可能是不存在该key对应的值的，所以推荐读取Dictionary时还是使用上一章中介绍的安全拆解的方法，这又是Swift强制开发者随时考虑安全问题的一个表现。</p>

<p>```objectivec
if let value = dictionary[1] {</p>

<pre><code>print("Value is \(value)")
</code></pre>

<p>}
```</p>

<h3>Reference and copies</h3>

<p>1.这一节讨论Dictionary和Array在Swift中与OC所不同的内存管理策略，如下，从结果发现，Swift中将一个Dictionary直接赋值给另外的变量或常量，都是执行copy操作的，即改变新变量，并不会影响原来的Dictionary。</p>

<p><code>objectivec
var dictionaryA = [1: 1, 2: 4, 3: 9, 4: 16]
var dictionaryB = dictionaryA
print(dictionaryA)
print(dictionaryB)
dictionaryB[4] = nil
print(dictionaryA)
print(dictionaryB)
</code></p>

<p>2.那么关于Array呢？答案是一样的，Array也是会执行copy操作，这与OC中的NSDictionary和NSArray的指针赋值是完全不同的，所以单独强调一下。</p>

<p><code>objectivec
var arrayA = [1, 2, 3, 4, 5]
var arrayB = arrayA
print(arrayA)
print(arrayB)
arrayB.removeAtIndex(0)
print(arrayA)
print(arrayB)
</code></p>

<h3>Constant collection</h3>

<p>1.上面都是定义的var类型的Dictionary和Array，那么如果定义为let的话，Dictionary和Array是不能进行任何修改操作的（其实就是OC中的不可变类型）。</p>

<p><code>objectivec
let constantArray = [1, 2, 3, 4, 5]
//error
constantArray.append(6)
constantArray.removeAtIndex(0)
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Language Basics I]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/08/swift-by-tutorials-language-basics-i/"/>
    <updated>2015-10-08T14:26:37+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/08/swift-by-tutorials-language-basics-i</id>
    <content type="html"><![CDATA[<p>Swift更新到2.0了，是时候来一波Swift的集中学习了，这次用的教材是raywenderlich出版的Swift by Tutorials，我手里的版本是2014年12月份的，可能有些在Swift2.0中发生了变化，我会尽量标注出来。开始第一章，介绍一些Swift的基本语法。</p>

<!--more-->


<h2>Variables,constants and strings</h2>

<p>1.Playground是Xcode新加入的一种文件，实际上就是一个可以自动编译的swift文件，可以用来测试一些简单的代码，也能显示一些资源文件，下面是申明一个string类型，可以直接在playground运行。</p>

<p><code>objectivec
var greeting: String = "Hello"
//也可以不指名类型
//var greeting = "Hello"
//如对greeting赋值int型，会报错
//greeting = 9
print(greeting)
</code></p>

<p>2.string可以不声明类型，即可运行，是源于Swift的type interface的特性，即通过赋值自动确定变量的类型，但是之后再对其赋值整形，则会报错。因为Swift是静态输入语言，编译期间会进行类型检查。<strong>type interface是推荐使用的，可以使代码简洁，增加可读性</strong>。<br/>
3.Swift的string类型是可变的，而且改变方式不像NSMutableString那么复杂，直接使用+=方式即可。</p>

<p><code>objectivec
var greeting = "Hello"
greeting += "World"
print(greeting)
</code></p>

<p>4.如果想声明不可变String，只需添加let关键字即可。在Swift中，控制内建类型的可变性是通过添加let或var关键字来实现的，这不同于OC，需要两种类型来实现。<strong>你应该尽量使用不可变类型，这不仅使你的程序更加健壮，也会使编译器做更多优化，实际上let使用的场景是远远多于var的</strong>。</p>

<p><code>objectivec
let greeting = "Hello"
</code></p>

<p>5.let关键字不仅限于Swift内建类型，自定义的结构体和类也可以使用，但有些细微不同，这将在第三章中详细讲到。<br/>
6.改变string也可以利用append()方法，这是Swift String自带的一些API，但是数量不多。幸运的是，Swift String与OC的NSString是可转换的，NSString的全部方法，String也可全部使用，但是还是推荐尽量使用String自带的API，比较简洁。</p>

<p>```objectivec
//Swift String API
greeting.append(Character(&ldquo;!&rdquo;))
//bridge to NSString
//logout Hello World
import Foundation</p>

<p>var greeting = &ldquo;hello world&rdquo;.capitalizedString
print(greeting)
//NSString style append
import Foundation</p>

<p>var greeting = &ldquo;hello&rdquo;.stringByAppendingString(&ldquo; world&rdquo;)
print(greeting)
```</p>

<p>7.Swift String是一个值类型，当它被赋值给变量、常量、或者作为参数传入方法时，它的值是被copy的，如下例，改变alternateGreeting不会影响greeting的值。</p>

<p><code>objectivec
var alternateGreeting = greeting
alternateGreeting += " and beyond!"
print(alternateGreeting)
print(greeting)
</code></p>

<!--more-->


<h2>Semicolons(分号)</h2>

<ol>
<li>Swift中分号只有在同一行中添加多条代码时才强制使用，其他情况可以省略不写，<strong>这又是Swift代码简洁的一大表现</strong>。</li>
</ol>


<!--more-->


<h2>Numeric types and conversion</h2>

<p>1.这一节主要讲Swift的数值类型，下面创建了两个变量，Int类型的radius和Double类型的pi，Swift还有很多其他类型，如Int8、UInt16、Float等。除非你有特殊需求，那么Int和Double类型是你的首选，这两个类型有广泛的使用，而且编译器会自动选择Int的最佳长度，32或64，基于机器的字长，来生成最高效的代码。</p>

<p><code>objectivec
var radius = 4
let pi = 3.14159
</code></p>

<p>2.在Swift中，你可以使用<strong>_</strong>来作为千分号，如下。</p>

<p><code>objectivec
let milion = 1_000_000
</code></p>

<p>3.以下代码会报错，是因为*无法直接将Int和Double相乘，而Swift中也不会隐式转化，需要开发者显式转化，需要注意这里并不是类型转化，而是新生成了一个Double类型，在第三章中会详细讲解初始化方法。</p>

<p><code>objectivec
//error
var area = radius * radius * pi
//soluation
var area = Double(radius) * Double(radius) * pi
</code></p>

<p>4.显式转化变量是Swift的安全策略之一，另外一个是越界检查，下列代码在其他语言中可能会生成一个负数，而在Swift中会直接将其视为一个runtime error。同时，为了避免integer的越界计算error，Apple提供了&amp;+、&amp;-、&amp;*、&amp;/、&amp;%这些越界运算符，使用后会像常规计算一样，生成负数。</p>

<p><code>objectivec
var overflow = Int.max + 1
//overflow operators
var overflow = Int.max &amp;+ 1
</code></p>

<!--more-->


<h2>Booleans</h2>

<p>1.Swift的布尔类型为Bool，值为true或false，需要说明的一点是，作为Swift的安全特性之一，控制流中需要进行布尔判断的只能使用Bool类型，而不同于在OC中，可以将任意非零值作为判断条件，例如你不能在Swift中使用一个整数当做判断条件。</p>

<p><code>objectivec
let alwaysTrue = true
</code></p>

<!--more-->


<h2>Tuples(元组)</h2>

<p>1.元组用来将多个值组成一个类型，但是不像类和结构体，你不需要显式的定义这个类型，如下，你可以通过索引来访问每个值，也可以通过索引来改变每个值（前提是你得元组的是可变的），而越界访问，编译器会报error。</p>

<p><code>objectivec
var address = (742, "Evergreen Terrace")
print(address.0)
print(address.1)
address.0 = 744
</code></p>

<p>2.你也可以声明元组的类型，如下。如果想将元组的Int值类型改为Double有三种方式，同如下：</p>

<p><code>objectivec
var address: (Int, String) = (742, "Evergreen Terrace")
//change Int to Double
//1)using a type annotation
var address1: (Double, String) = (742, "Evergreen Terrace")
//2)by explicit creation of a Double
var address2 = (Double(742), "Evergreen Terrace")
//3)by using a double literal value
var address3 = (742.0, "Evergreen Terrace")
</code></p>

<p>3.你也可以把元组解析成单个元素，而这也是一个copy操作，改变新值不会影响原始的元组值，如下：</p>

<p><code>objectivec
var address = (742, "Evergreen Terrace")
let (house, street) = address
print(house)
print(street)
</code></p>

<p>4.此外，你可以为元组的每个值加一个key，提高可读性，同时上述的访问方法依然有效。</p>

<p><code>objectivec
var address = (number: 742, street: "Evergreen Terrace")
print(address.number)
print(address.street)
</code></p>

<p>5.元组只是一个类型，也可以进行嵌套，元组作为其他元组的一个元素，类和结构体虽然包含了元组的所有功能，但是在一些轻量的场景下，元组可以更加快速简单地去构建一个复合类型。</p>

<!--more-->


<h2>String interpolation</h2>

<p>1.打印出一个类的信息，是常见的需求，例如OC中NSObject的description方法，如果我们想打印出上一节中元组的信息，我们可能这么做：</p>

<p><code>objectivec
var address = (742, "Evergreen Terrace")
let (house, street) = address
print("I live at " + String(house) + ", " + street)
</code></p>

<p>2.这利用了Swift的+拼接字符串的技术，不过在Swift中有更加方便的字符串拼接技术来处理这一场景，string interpolation，如下：</p>

<p><code>objectivec
var address = (742, "Evergreen Terrace")
let (house, street) = address
print("I live at \(house), \(street)")
</code></p>

<p>3.当然这不是打印日志专用的，在你需要从一系列变量中构建String时，都可使用。</p>

<p>```objectivec
import Foundation</p>

<p>var address = (742, &ldquo;Evergreen Terrace&rdquo;)
let (house, street) = address
let str = &ldquo;I live at (house+10), (street.uppercaseString)&rdquo;
```</p>

<p>4.最后，如果想只打印出\时，请用\\转义。</p>

<!--more-->


<h2>Control flow</h2>

<h3>For loops</h3>

<p>1.首先要介绍的Swift中的for循环的新特性是closed range operator，即闭区间运算符，例子如下：</p>

<p>```objectivec
let greeting = &ldquo;Swift by Tutorials!&rdquo;
for i in 1&hellip;5 {</p>

<pre><code>print("\(i) - \(greeting)")
</code></pre>

<p>}
```</p>

<p>2.注意，其中的i并不是一个var类型的变量，而是每次循环创建一个let的常量，是不可被赋值的。<br/>
3.1&hellip;5是一个Range类型，与for循环并无关系，下例说明了这一问题：</p>

<p>```objectivec
var range = 1&hellip;5
for i in range {</p>

<pre><code>print("\(i) - \(greeting)")
</code></pre>

<p>}
//what&rsquo;s 1..5?
var range = Range(start: 1, end: 6)
```</p>

<p>4.x&hellip;y只是Range类型的一个简化的语法糖，你可以用x..&lt;y来创建半开半闭的区间，最后一个值为y-1。</p>

<p><code>objectivec
//means 1,2,3,4,5
var range1 = 1...5
//means 1,2,3,4
var range2 = 1..&lt;5
</code></p>

<p>5.那么还有个问题，for循环是怎么处理这个Range的？从而实现循环？其实是这样的，for循环可以处理很多可遍历的Swift类型，例如array、dictionary，还比如string也可以，所以range只是这些可遍历类型的其中之一而已。</p>

<p>```objectivec
for i in &ldquo;Swift&rdquo; {</p>

<pre><code>print(i)
</code></pre>

<p>}
```</p>

<p>6.<strong>再挖的深一点，为什么String和Range一样可以被遍历？去看一下它们的定义就可以得知，它们都遵循了Sequence protocol，通过实现协议中的方法，就可以得到generator，继而循环请求其中的值，在第四章我们将自己创建类型来实现这一协议和利用generator。</strong></p>

<h3>While loops</h3>

<p>1.Swift同时支持while循环和do-while循环(<strong>Swift2.0将do-while改为了repeat-while</strong>)。</p>

<p>```objectivec
//while loop
let greeting = &ldquo;Swift by Tutorials!&rdquo;
var i = 0
while i &lt; 5 {</p>

<pre><code>print("\(i) - \(greeting)")
i++
</code></pre>

<p>}
//repeat-while loop
let greeting = &ldquo;Swift by Tutorials!&rdquo;
var i = 0
repeat {</p>

<pre><code>print("\(i) - \(greeting)")
i++
</code></pre>

<p>} while i &lt; 5
```</p>

<h3>If statements</h3>

<p>1.Swift支持常规的if-else用法，需要注意的就是前面提到过的，if的条件必须是Bool类型，而且<strong>还有一点就是即使只有一条执行的语句，也要用{}，这是Swift和其他语言if的一个区别，不然会报错，这也是为了避免{}误用或少写导致的bug</strong>，此外，还有一个和if有关的关于optional value的技巧会在下一章讲到。</p>

<p>```objectivec
import Foundation</p>

<p>let greeting = &ldquo;Swift by Tutorials!&rdquo;</p>

<p>for i in 1&hellip;5 {</p>

<pre><code>if i == 5 {
    print(greeting.uppercaseString)
} else {
    print(greeting)
}
</code></pre>

<p>}
```</p>

<h3>Switch statements</h3>

<p>1.Swift支持常规的switch语句，与OC不同的是，Swift的switch条件可以使任意类型，而OC只是原始类型，编译器来确保每个case的条件与switch条件类型一致。<br/>
2.第二点，Swift中的switch不需要在每个case后添加break，这是因为在Swift中，每个case执行完后，会自动跳出switch，所以不需要手动添加break，同时这也是安全策略之一。</p>

<p>```objectivec
var direction = &ldquo;up"switch direction {</p>

<pre><code>case "down":        println("Going Down!")  case "up":      println("Going Up!")    default:        println("Going Nowhere") }
</code></pre>

<p>```
3.第三，Swift的switch相当智能，如果你提供的switch条件的可能值没有在case中被全部覆盖，会提示你添加default，如上例的String类型，不然会报error；而如果你的case覆盖了switch条件的所有值，如enum类型，那么不添加default也不会报错。<br/>
4.如何在switch在一个case中匹配多个值，参照下例：</p>

<p>```objectivec
var direction = &ldquo;up"switch direction {</p>

<pre><code>case "down", "up":      println("Going Somewhere!")     default:        println("Going Nowhere") }
</code></pre>

<p>```</p>

<p>5.可以利用上一节介绍的Range来实现case的区间匹配：</p>

<p>```objectivec
var score = 570</p>

<p>switch score {</p>

<pre><code>case 1..&lt;10:
    print("novice")
case 10..&lt;100:
    print("proficient")
case 100..&lt;1000:
    print("rock-star")
default:
    print("awesome")
</code></pre>

<p>}
```</p>

<p>6.另外switch与元组的结合，可以创造出更加复杂的场景处理：</p>

<p>```objectivec
let somePoint = (1, 1)
switch somePoint {</p>

<pre><code>case (0, 0):
    print("(0, 0) is at the origin")
case (_, 0):
    print("(\(somePoint.0), 0) is on the x-axis")
case (0, _):
    print("(0,\(somePoint.1)) is on the y-axis")
case (-2...2, -2...2):
    print("(\(somePoint.0), \(somePoint.1)) is inside the box")
default:
    print("(\(somePoint.0), \(somePoint.1)) is outside the box")
</code></pre>

<p>}
```</p>

<p>7.利用value binding技术，可以在判断期间将tuple的元素赋值给let变量（当然也可以声明为var类型，且它的作用范围只存在该case中）：</p>

<p>```objectivec
let anotherPoint = (2, 0)
switch anotherPoint {</p>

<pre><code>case (let x, 0):
    print("on the x-axis with an x value of \(x)")
case (0, let y):
    print("on the y-axis with an y value of \(y)")
case let (x, y):
    print("somewhere else at (\(x), \(y))")
</code></pre>

<p>}
```</p>

<p>8.switch可以添加where语句，为每个case添加额外的判断条件：</p>

<p>```objectivec
let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {</p>

<pre><code>case let (x, y) where x == y:
    print("(\(x), \(y)) is on the line x == y")
case let (x, y) where x == -y:
    print("(\(x), \(y)) is on the line x == -y")
case let(x, y):
    print("(\(x), \(y)) is just some arbitrary point")
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记7]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/09/16/effective-objective-cdu-shu-bi-ji-7/"/>
    <updated>2015-09-16T15:42:34+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/09/16/effective-objective-cdu-shu-bi-ji-7</id>
    <content type="html"><![CDATA[<p>这是本书的最后一章了，集中讲解了有关Cocoa自带的system framework，这是开发中必须要使用的基本库，没有这些封装，很多基本的功能都无法实现，没有集合，也没有基类NSObject，可谓寸步难行，一些新的Api有时会节省我们很多工作量，同时这些库中的很多设计也是我们自己的代码需要学习的。</p>

<!--more-->


<h2>Item47 Familiarize Yourself with the System Frameworks</h2>

<ol>
<li>一个framework是将代码打包成一个动态库，会有头文件来描述接口，有时候也会有一些第三方的静态库（即.a文件），这些不能作为真正意义上的框架，但是被常常当做框架来用，所有的系统框架都使用了动态库。</li>
<li>Cocoa或Cocoa Touch是框架集，其中的基本框架就是Foundation框架，Foundation Framework不但提供了基本类型和基本集合，而且还有很多复杂功能，比如字符串处理。</li>
<li>除了另一个基础库是CoreFoundation，几乎就是Foundation的镜像库，只不过内部都是C接口和结构体，OC提供了一个名为toll-free bridging的转换特性，可以使OC对象和CF对象自由转化，toll-free bridging自身比较复杂，所以不建议自己去实现这一转化功能。除了上述两个基础框架，还有以下一些常用框架：</li>
<li>CFNetwork：基于C的网络请求基本框架，基于BSD socket提供了很多易用的请求工具，Foundation通过对它的部分封装，提供了OC类型的网络接口。</li>
<li>CoreAudio：提供了基于C的音频设备访问接口，本身是很复杂的，但OC的抽象将其变得易用不少。</li>
<li>AVFoundation：提供了用于播放和录制音视频的OC对象，例如播放视频的UI类。</li>
<li>CoreData：提供了用于数据持久化的OC对象，CoreData处理数据的存取，并能在Mac OS X与iOS之间通用。</li>
<li>CoreText：提供了基于C的文字高效的类型设置和渲染的接口。</li>
<li>使用一些C类型的框架，有时是必要的，因为通过绕过runtime，速度会更快，但是需要更加关注内存管理。</li>
<li>AppKit和UIKit分别是Mac OS X 和iOS的UI框架，提供了基于Foundation和CoreFoundation的OC类型，在它的下面是CoreAnimation和CoreGraphics在支持。</li>
<li>CoreAnimation基于OC类型，提供了渲染图像和展示动画的工具，它不是一个独立的框架，还是QuartzCore框架的一部分，但是很多情况CoreAnimation还是被优先使用。</li>
<li>CoreGraphics是基于C类型的，提供了用于2D渲染的必不可少的结构体和函数，CGPoint，CGSize，CGRect都是在这儿定义的。</li>
<li>UIKit的上层还有很多更高级的框架，例如：MapKit，Social framework。</li>
</ol>


<!--more-->


<h2>Item48 Prefer Block Enumeration to for Loops</h2>

<p>1.遍历一个集合类型是常见需求，，而OC也有很多方式，从标准的C的for循环，到OC 1.0的NSEnumerator，到OC 2.0的快速遍历，block加入OC后，又出现了遍历直接传入block进行对象处理的新方法。<br/>
2.For Loops：沿用最原始的C语言的循环，定义一个int型index，然后按照index去遍历每个对象，对于NSArray来说影响还不大，但是对于NSDictionary，NSSet来说，因为都是无序的，所以必须额外生成中间数组，这是额外的内存消耗，但倒序遍历只需要改变index为递减即可，还算方便。<br/>
3.OC 1.0 NSEnumerator：NSEnumerator是一个基类，需要重写-(NSArray*)allObjects,&ndash;(id)nextObject两个方法，而Foundation框架的集合类型都支持了NSEnumerator，可以通过不断执行nextObject()来完成遍历，它的优势是所有的集合类型的遍历方式都是类似的，而且也支持不同的enumerator来实现不同顺序来遍历，缺点是还是需要额外的enumerator，而且不能得知当前的index。</p>

<p>```objectivec
//NSArray enumerator
NSArray <em>anArray = /</em>&hellip;<em>/;
NSEnumerator </em>enumerator = [anArray objectEnumerator];
id object;
while((object = [enumerator nextObject])!=nil){</p>

<pre><code>//Do something with 'object'
</code></pre>

<p>}
//NSDictionary enumerator
NSDictionary <em>aDictionary = /</em>&hellip;*/;
id key;
while((key = [enumerator nextObject])!=nil){</p>

<pre><code>id value = aDictionary[key];
//Do something with 'key' and 'value'
</code></pre>

<p>}
//NSArray reverse enumerator
NSArray <em>anArray = /</em>&hellip;<em>/;
NSEnumerator </em>enumerator = [anArray reverseObjectEnumerator];
id object;
while((object = [enumerator nextObject])!=nil){</p>

<pre><code>//Do something with 'object'
</code></pre>

<p>}
```</p>

<p>4.Fast Enumeration：OC2.0引入了快速遍历，快速遍历详单与结合了for-loop和enumerator的双重特点，同时极大的简化了语法。实现这一技术是采用了NSFastEnumeration这一协议（只有一个方法），集合类型通过遵循这一协议，从而支持了快速遍历，实现协议中的方法使得类可以同时返回多个对象：</p>

<p><code>objectivec
//NSFastEnumeration
-(NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState*)state objects:(id*)stackbuffer count:(NSUInteger)length;
</code></p>

<p>```objectivec
//NSArray
NSArray <em>anArray = /</em>&hellip;*/;
for(id object in anArray){</p>

<pre><code>//Do something with 'object'
</code></pre>

<p>}
//NSDictionary
NSDictionary <em>aDictionary = /</em>&hellip;*/;
for(id key in aDictionary){</p>

<pre><code>id value = aDictionary[key];
//Do something with 'key' and value
</code></pre>

<p>}
```</p>

<p>如果需要反向遍历，可以通过下列方法，因为NSEnumerator也实现了NSFastEnumeration：</p>

<p>```objectivec
NSArray <em>anArray = /</em>&hellip;*/;
for(id object in [anArray reverseObjectEnumerator]){</p>

<pre><code>//Do something with 'object'
</code></pre>

<p>}
```</p>

<p>快速遍历的优点是效率很高，而且代码简洁，但是依然有两个缺陷，NSDictionary如果同时需要key和value的话，还是需要两步；同时index也是无法直接获取。</p>

<p>5.Block-Based Enumeration：是在OC引入block后的遍历集合的最新方法，下面是NSArray的基本block遍历方法，前两个参数很明显，第三个参数是用来停止遍历的：</p>

<p>```objectivec
//NSArray
&ndash;(void)enumerateObjectsUsingBlock:(void(^)(id object,NSUInteger idx,BOOL <em>stop))block;
//NSDictionary
&ndash;(void)enumerateLeysAndObjectsUsingBlock:(void(^)(id key,id object,BOOL </em>stop))block;
//example
NSArray <em>aArray = /</em>&hellip;<em>/;
[aArray enumerateObjectsUsingBlock:^(id object,NSUInteger idx,BOOL </em>stop){</p>

<pre><code>//Do something with 'object'
if(shouldStop){
    *stop = YES;
}
</code></pre>

<p>}];
```</p>

<p>block遍历虽然看起来语法比快速遍历更复杂了，但是代码还是很整洁的，而且提供了方便的停止遍历的方法，而在其他方式中需要自己添加break，另外你可以现在一次性获得所有的信息，包括：NSArray的index，NSDictionary的key和value。</p>

<p>如果NSDictionary的键值类型是确定的，那么你可以重写block中的id类型，也可以在类型出现异常时抛出警告，所以如果类型确定，还是推荐这么写的。</p>

<p>```objectivec
NSDictionary <em>aDictionary = /</em>&hellip;<em>/;
[aDictionary enumerateKeysAndObjectsUsingBlock:^(NSString </em>key,NSString <em>obj,BOOL </em>stop){</p>

<pre><code>//Do Something with 'key' and 'obj'
</code></pre>

<p>}];
```</p>

<p>除了这些，还有个最大的特点是，block遍历可以通过设置option（枚举类型）来实现各种各样的遍历方式，例如通过NSEnumerationConcurrent实现对集合中的对象并发执行方法（内部应该是利用了GCD的dispatch group），通过NSEnumerationReverse实现集合的逆向遍历，而且也可以通过位与操作，同时实现这两个option。</p>

<p><code>objectivec
//NSArray
-(void)enumerateObjectsWithOptions:(NSEnumerationOptions)options usingBlock:(void(^)(id object,NSUInteger idx,BOOL *stop))block;
//NSDictionary
-(void)enumerateLeysAndObjectsWithOptions:(NSEnumerationOptions)options usingBlock:(void(^)(id key,id object,BOOL *stop))block;
</code></p>

<p>综上，block遍历虽然语法不及快速遍历简洁，但是对于NSArray获得index，对于NSDictionary获得key和value这些信息，通过option获得并发执行遍历，都是优于其他遍历方法的。</p>

<!--more-->


<h2>Item49 Using Toll-Free Bridging for Collections with Custom Memory-Management Semantics</h2>

<p>1.Toll-Free Bridging是OC用来在Foundation定义的OC对象和CoreFoundation定义的对应的C结构体之间相互转化，使用了<strong>bridge关键字，相当于ARC依然持有OC对象，如果使用了</strong>bridge_retained，那么ARC就要交出持有权，那么在我们使用完CF指针后要执行CFRelease(aCFArray)来释放内存，反之你需要将CF指针转化为OC对象，并需要转移持有权时，要加上__bridge_transfer关键字，这三个关键字非常重要。</p>

<p><code>objectivec
NSArray *anNSArray = @[@1,@2,@3,@4,@5];
CFArrayRef aCFArray = (__bridge CFArrayRef)anNSArray;
NSLog(@"Size of array = %li", CFArrayGetCount(aCFArray));
</code></p>

<p>2.为什么要去使用CF结构体指针？当然绝大部分情况我们是不会刻意去使用的，作者列举了一个特殊的场景：NSDictionary的key是copy类型，而value是retain类型，也就意味着，不支持copy协议的类是不能作为NSDictionary的key的，如果我们需要一个value和key都是retain类型的dictionary，那要怎么办呢？<br/>
3.作者列举了一种思路，重新构建一个CF的字典类型，因为在这一级，我们可以控制key和value的回调类型，然后再通过Toll-Free Bridging来转化为需要的NSMutableDictionary，从而达到目的。</p>

<!--more-->


<h2>Item50 Use NSCache Instead of NSDictionary for Caches</h2>

<p>1.在网络请求中做缓存是常见的需求，因为一般会将data和url或者request对象做成键值对存储，所以一些年轻的程序员就会考虑用NSDictionary来做缓存，但是作者建议用NSCache来做这类缓存。<br/>
2.NSCache的优势之一是，当系统资源吃紧时，cache会被自动释放，且会优先释放最近未被使用的缓存，如果NSDictionary想实现这一点，是需要做很多额外工作的。<br/>
3.NSCache的优势之二是，NSDictionary的key是copy类型，而value是retain类型，而NSCache的key和value都是retain类型，这就意味着，NSCache可以将不实现copy协议的对象作为key，虽然根据Item49的做法，也可以把NSDictionary做成这种类型，但是实现起来很复杂。另外，NSCache是线程安全的，你可以在多个线程同时插值，在做缓存时，在主线程读取缓存，然后缓存不存在，在后台线程下载并赋值是常见的场景。<br/>
4.你可以手动控制缓存的容量，通过设置缓存数量和大小来控制，如果缓存数量或大小超过限制，也会开始自动释放，但释放的顺序是不可控的，所以想通过改变最大容量来让缓存按照顺序释放是不现实的。<br/>
5.需要注意的是，设置缓存大小容量，是基于加入缓存的对象的大小易于计算，如果计算对象大小成本过高的话，这就会影响效率，因为每次加入都会进行计算。例如去硬盘计算文件大小或去数据库查找大小就是耗时的操作，但如果是NSData作为缓存对象，那么获取它的大小代价就很小，只是读取一个property而已。<br/>
6.下面是一个使用NSCache的实例：</p>

<p>```objectivec
@implementation EOCClass{</p>

<pre><code>NSCache *_cache;
</code></pre>

<p>}
&ndash;(id)init{</p>

<pre><code>if((self = [super init])){
    _cache = [NSCache new];
    _cache.countLimit = 100;
    _cache.totalCostLimit = 5*1024*1024;
}
return self;
</code></pre>

<p>}
&ndash;(void)downloadDataForURL:(NSURL*)url{</p>

<pre><code>NSData *cachedData = [_cache objectForKey:url];
if(cacheData){
    //Cache hit
    [self useData:cachedData];
} else {
    //Cache miss
    EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];
    [fetcher startWithCompletionHandler:^(NSData *data){
        [_cache setObject:data forKey:url cost:data.length];
        [self useData:data];
    }];
}
</code></pre>

<p>}
@end
```</p>

<p>7.除了NSData，另一种可以和NSCache搭配的是NSPurgeableData，它是NSMutableData的子类，实现了NSDiscardableContent协议，NSPurgeableData的内存会在系统资源紧张时自动释放，<em>isContentDiscard</em>是协议中的一个方法，返回内存是否已释放。<br/>
8.NSPurgeableData在使用之前要用<em>beginContentAccess</em>确保目前内存不被释放，然后使用完后调用<em>endContentAccess</em>告知系统可以被释放，这一对操作可以嵌套，类似retain/release。<br/>
9.如果NSPurgeableData添加到NSCache，释放的对象会自动移出cache，这可以被<em>evictsObjectsWithDiscardedContent</em>这一property关闭或开启。<br/>
10.下面是一个NSPurgeableData的实例，注意NSPurgeableData被创建时就相当于+1purge reference count与alloc类似，所以不必再加<em>beginContentAccess</em>，但用完要加<em>endContentAccess</em>。</p>

<p>```objectivec
&ndash;(void)downloadDataForURL:(NSURL*)url{</p>

<pre><code>NSPurgeableData *cacheData = [_cache objectForKey:url];
if(cachedData){
    //Stop the data being purged
    [cacheData beginContentAccess];
    //Use the cached data
    [self useData:cachedData];
    //Mark that the data may be purged again
    [cacheData endContentAccess];
} else {
    //Cache miss
    EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];
    [fetcher startWithCompletionHandler:^(NSData *data){
        NSPurgeableData *purgeableData = [NSPurgeableData dataWithData:data];
        [_cache setObject:purgeableData forKey:url cost:purgeableData.length];
        //Don't need to beginContentAccess as it begins with access already marked
        [self useData:data];
        //Mark that the data may be purged now
        [purgeable endContentAccess];
    }];
}
</code></pre>

<p>}
```</p>

<!--more-->


<h2>Item51 Keep initialize and load Implementations Lean</h2>

<ol>
<li>一个类总会有有自己的初始化方法，由于OC中类型大部分继承于NSObject，所有有很多继承于NSObject的初始化方法，第一个就是<em>*(void)load</em>方法。</li>
<li><em>load</em>方法在每个class和category中会且只会被调用一次，这个方法发生在包含该类的library在加载后，一般是应用加载中，而且只是iOS代码的独有的，Mac OS X有更灵活的dynamic loading，可以使library在应用加载后加载，而category的load在其原class加载后加载。</li>
<li>想重写<em>load</em>方法的问题是，它运行时runtime处于不稳定的状态，所有父类的<em>load</em>方法是先于其他类的<em>load</em>调用的，所依赖库中的所有<em>load</em>方法会先调用。但在一个库中，这些类的<em>load</em>方法的调用顺序就是不可控的了。</li>
<li>作者举例：EOCClassB中实现了<em>load</em>方法，它导入了Foundation.h和EOCClassA.h头文件，而EOCClassA和它同属一个库，EOCClassB在其<em>load</em>方法中使用了NSLog输出NSString，也实例化了EOCClassA并进行了操作。那么NSLog和NSString的使用是没问题的，因为Foundation.h中的class肯定先于EOCClassB的<em>load</em>方法，但使用EOCClassA就有问题了，你不能保证EOCClassA的<em>load</em>是否已经在EOCClassB的<em>load</em>方法之前调用了，因为有可能EOCClassA在<em>load</em>之前是不可用的。</li>
<li><em>load</em>方法并不遵循于一般的继承规则，一个类没有实现<em>load</em>的话，是不会调用该方法的，即使它的父类实现了；<em>load</em>方法可同时存在于类和它的category中，且category的<em>load</em>会在本类的<em>load</em>之后调用。</li>
<li>所以综上，<em>load</em>方法并不适合我们自己做初始化工作，因为我们不能确保所有的类型都已经加载，所以实际上它的用途最好仅停留在测试层面，因为如果在<em>load</em>中加载过多任务，也会影响应用的加载时间，是很影响用户体验的。</li>
<li>第二个初始化方法是<em>+(void)initialize</em>方法，它也是会且只会被调用一次，它是被runtime调用的，而不能被直接调用，它与<em>load</em>有相似的地方，也有很多不同，概括有三点。</li>
<li>区别一是<em>initialize</em>是懒加载，只有一个类被第一次用到之前才会调用，因此会出现一个类的<em>initialize</em>永远没被调用过的情况，这也意味着不像<em>load</em>会出现所有的<em>load</em>方法在同一时间加载，而且会阻塞应用加载。</li>
<li>区别二是<em>initialize</em>在执行时，runtime是稳定状态，调用其他类的方法是安全的，而且runtime保证了<em>initialize</em>的线程安全，意味着只有执行<em>initialize</em>的线程可以和class和其实例交互，其他线程将会被阻塞，知道<em>initialize</em>完成。</li>
<li>区别三是<em>initialize</em>与其他消息一样，如果类的<em>initialize</em>没实现，但是父类实现了，那么父类的<em>initialize</em>会被调用。</li>
<li>作者举例父类实现了<em>initialize</em>，但是子类没有实现，但在log中会看到该方法被调用了两次，原因是使用一个类时，其父类的<em>initialize</em>会先调用，然后到子类时，由于没有实现该方法，所以继续沿响应链得知父类实现了该方法，所以又执行一次，为了避免这一问题，在<em>initialize</em>中加上<em>if(self == [EOCBaseClass class])</em>的判断就好了。</li>
<li>虽然<em>initialize</em>比<em>load</em>灵活一些了，但是作者依然不推荐在<em>initialize</em>中做很复杂的初始化工作，原因也有三。</li>
<li>原因一，一个类的<em>initialize</em>可能在任意线程，如果它发生在UI线程，而且<em>initialize</em>做了很多工作的话，可能导致主线程阻塞。预测哪个线程会先使用一个类是不可靠的，所以强制一个固定线程去触发类的<em>initialize</em>方法是不现实的。</li>
<li>原因二，你不能控制一个类什么时候<em>initialize</em>，它是确定会在一个类被第一次使用之前调用，但是假设它会在某个固定时间执行是不可靠的，runtime可能会有所更新，导致细微改变类的初始化方式，那么你对类已经初始化完毕的设想可能是错误的。</li>
<li>原因三，比较特殊，就是两个或多个类之间的初始化方法中出现了内部数据的相互调用，可能会出现，一个类需要另一个类初始化完毕，但是第二个类还依赖于第一个类的初始化完毕，造成了两个类之间的相互等待，和循环引用有一定程度的类似。</li>
<li>综上，<em>initialize</em>中并不适合做大量的工作，尤其是调用其他类或自己的方法，如果自己的方法必须依赖自己已经初始化完毕，那么也会出现上述问题，所以<em>initialize</em>的正确用法是去初始化那些，无法在编译期间赋值的全局静态变量和全局变量，比如static NSMutableArray *kSomeObjects，因为这些OC对象必须等到runtime激活后才能使用。</li>
<li>所以始终保持<em>initialize</em>和<em>load</em>方法简洁是一个好习惯，能避免大量的奇葩问题。</li>
</ol>


<!--more-->


<h2>Item52 Remember that NSTimer Retains Its Target</h2>

<p>1.NSTimer是一个常用的类，用来定时执行一些方法，或循环执行一些方法，它是需要和一个run loop关联的，你既可以在当前run loop预设置，也可以自己创建NSTimer对象自行设置。<br/>
2.NSTimer预设置的方法需要传入target和selector，timer会retain target，而会在timer失效时release它，一个timer可以通过直接调用invalidate（一般是循环的）或者启动后（一般是一次性的）就会失效。<br/>
3.因为timer会retain target，所以在循环执行时特别容易出现循环引用，如下，startPolling后，便会出现EOCClass和timer相互引用的结果，目前想解决这一问题，只能通过要求调用方自行调用stopPolling，但如果这时一个对外使用的类的话，这是不可控的；而寄希望于dealloc去解开这一循环，是不现实的，因为对于循环引用的两个对象，是不会出现一方先释放的。而且如果这一引用存在，会一直循环去执行这个任务，带来的问题不光是内存泄露。</p>

<p>```objectivec
 #import &lt;Foundation/Foundation.h>
@interface EOCClass:NSObject
&ndash;(void)startPolling;
&ndash;(void)stopPolling;
@end
@implementation EOCClass{</p>

<pre><code>NSTimer *_pollTimer;
</code></pre>

<p>}
&ndash;(id)init{</p>

<pre><code>return [super init];
</code></pre>

<p>}
&ndash;(void)dealloc{</p>

<pre><code>[_pollTimer invalidate];
</code></pre>

<p>}
&ndash;(void)stopPolling{</p>

<pre><code>[_pollTimer invalidate];
_pollTimer = nil;
</code></pre>

<p>}
&ndash;(void)startPolling{</p>

<pre><code>_pollTimer = [NSTimer scheduledTimerWithTimeInterval:5.0 target:self selector:@selector(p_doPoll) userInfo:nil repeats:YES];
</code></pre>

<p>}
&ndash;(void)p_doPoll{</p>

<pre><code>//Poll the resource
</code></pre>

<p>}
```</p>

<p>4.那么要想解决这个问题，又不依赖外部，一个方案是做一个NSTimer的block分类，如下，block被设置为userInfo参数，timer也会对它retain，block要进行一次copy，从stack移到heap上，这在Item37说过，现在的target变成了NSTimer这个类本身，因为NSTimer作为一个类对象，是一个单例，所以不用担心释放问题，虽然也存在循环引用，但是没关系。</p>

<p>```objectivec
 #import &lt;Foundation/Foundation.h>
@interface NSTimer(EOCBlockSupport)
+(NSTimer<em>)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats;
@end
@implementation NSTimer(EOCBlockSupport)
+(NSTimer</em>)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats{</p>

<pre><code>return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(eoc_blockInvoke:) userInfo:[block copy] repeats:repeats];
</code></pre>

<p>}
+(void)eoc_blockInvoke:(NSTimer*)timer{</p>

<pre><code>void(^block)()=timer.userInfo;
if(block){
    block();
} 
</code></pre>

<p>}
```</p>

<p>5.回到新方法的使用，像下面这样直接调用的话，还是会导致循环引用，因为block会retain self，而timer会在userInfo处retain block，而timer本身被self引用，所以正确的做法是做一个self的weak变量，在block中再声明一个strong的临时变量，确保block retain一个weak对象，而在block内部又不会提前释放掉，这也是解决block retain cycle的常见策略。</p>

<p>```objectivec
//wrong
&ndash;(void)startPolling{</p>

<pre><code>_polTimer = [NSTimer eoc_scheduledTimerWithTimeInterval:5.0 block:^{
    [self p_doPoll];
}
repeats:YES
];
</code></pre>

<p>}
//right
&ndash;(void)startPolling{</p>

<pre><code>__weak __typeof(self)weakSelf = self;
_polTimer = [NSTimer eoc_scheduledTimerWithTimeInterval:5.0 block:^{
    __strong __typeof(weakSelf)strongSelf = weakSelf; 
    [strongSelf p_doPoll];
}
repeats:YES
];
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记6]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/09/09/effective-objective-cdu-shu-bi-ji-6/"/>
    <updated>2015-09-09T16:29:01+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/09/09/effective-objective-cdu-shu-bi-ji-6</id>
    <content type="html"><![CDATA[<p>第六章的主要内容是Blocks和GCD，这可以说是Morden OC当中的三驾马车的其余两架，它们和ARC的出现，彻底改变了OC的开发模式。多线程是现代编程中任何语言都不可或缺的技术，在iOS中阻塞UI主线程往往是应用崩溃或用户体验差的重要原因，多线程就是解决这一问题的良方，而Blocks和GCD就是Apple给开发者带来的多线程解决方案。Blocks即OC中的闭包，它可以被当做一个对象，可以运行于其他上下文中。GCD基于dispatch queues提供了对线程的抽象，它会根据系统资源自动开辟、复用、销毁后台线程，同时GCD也对一些常见编程提供了简化方案，比如：创建单例、并发任务等等。</p>

<!--more-->


<h2>Item37 Understand Blocks</h2>

<p>1.Blocks作为了GCC的拓展，也存在于Clang的所有版本中。Blocks的runtime component在Mac OS X 10.4和iOS4被加入。由于是C级别的语言特性，所以可以被用于C,C++,OC当中。</p>

<h3>Block Basics</h3>

<p>1.Blcoks的类型写法类似函数指针，也可以直接当做函数来执行：</p>

<p>```objectivec
int(^addBlcok)(int a,int b) = ^(int a, int b){</p>

<pre><code>return a+b;
</code></pre>

<p>};
int add = addBlcok(2,5);//&lt;add=7
```</p>

<p>2.Blocks最重要的特性，它可以将它包含的所有内容进行复制，也就意味着范围内的任何变量都可以使用：</p>

<p>```objectivec
int additional = 5;
int(^addBlcok)(int a,int b) = ^(int a, int b){</p>

<pre><code>return a+b+additional;
</code></pre>

<p>};
int add = addBlcok(2,5);//&lt;add=12
```</p>

<p>3.默认Blocks是不能改变外部变量的，但是可以通过添加__blcok关键字，来声明变量可以改变。</p>

<p>```objectivec
NSArray <em>array = @[@0,@1,@2,@3,@4,@5];
__blcok NSInteger count = 0;
[array enumerateObjectsUsingBlock:^(NSNumber </em>number, NSUInteger idx, BOOL *stop){</p>

<pre><code>if([number compare:@2] == NSOrderedAscending){
    count++;
}
</code></pre>

<p>}];
//count = 2
```</p>

<p>4.上例也说明了Block作为内联参数的使用，这也是它的重要用法，取代了之前传selector name这样的方式，增加了代码可读性。<br/>
5.Block内部引用的变量会被隐性添加retain，然后在block release时再调用一次release，所以blcok可以被理解为一个一般的OC对象，它也是有retain count的。<br/>
6.那么在一个类中的实例方法中声明使用block，然后在block中使用了类的实例变量，那么其实是对self进行了一次retain，如果这时这个block被self的变量再retain一次，那么就会形成循环引用，解决方法在Item40会详细说，其实就是声明一个self的__weak替代对象就好了。</p>

<h3>The Guts of Block</h3>

<ol>
<li>Block的实质，除了包含通常的isa（block的Class为void*），flags等，block的三个主要组成为：invoke、descriptor、Captured variables。</li>
<li>invoke是一个函数指针，类型为void(<em>)(void </em>,&hellip;)，至少包含的void *其实就是block自身，因为block的Captured variables包含了所有据有变量的copy，invoke指向的就是block的实现部分，所以也证明了block实质上就是Apple对函数指针的一次高级封装，便于开发者使用。</li>
<li>descriptor指向一个结构体，包含了：size（blcok总大小），copy和dispose（都是函数指针，copy在blcok被拷贝时执行，dispose在block retain或release据有的对象时执行）。</li>
<li>Captured variables就是block据有的所有变量的copy，注意这里的copy是指针拷贝。</li>
</ol>


<h3>Global，Stack，and Heap Blocks</h3>

<p>1.Block声明的时候是存在于stack上的，类似下面的代码是不安全的，因为if/else中声明的blcok是存在于stack上的，在if/else结束时，系统可能会收回这些内存重用，而且这个问题在编译中不会报出：</p>

<p>```objectivec
void(^blcok)();
if(/<em>some condition</em>/){</p>

<pre><code>blcok = ^{
    NSLog(@"Block A");
};
</code></pre>

<p>} else {</p>

<pre><code>blcok = ^{
    NSLog(@"Block B");
};
</code></pre>

<p>}
block();
```</p>

<p>2.解决这一问题的方法，就是对声明的block进行copy，这样的话，block被copy到了heap上，这样的block和其他一般对象就一样了，也不会出现上述问题，使用ARC的话，block会在之后自动释放，而MRC将要自己去添加release方法，这也是类在为block类型的property添加属性时，一般都是copy类型的。<br/>
3.所谓的global Block就是类似于之前说的NSString和NSNumber的常量声明，如果Block内部没有任何状态变化，也不依赖于外部的状态变化，在编译期间就可以知道其所需要的空间大小，系统就会对其做优化，生成一个global block，它是被声明在global memory上，而不是stack上，而且copy对于它也是一个空操作，也不会被释放，实际就是一个单例，类似：</p>

<p>```objectivec
void(^block)() = ^{</p>

<pre><code>NSLog(@"This is a global blcok!");
</code></pre>

<p>};
```</p>

<!--more-->


<h2>Item38 Create typedefs for Common Block Types</h2>

<p>1.由于Block的类型像函数指针一样，参数多的话会很长，而且类型名又在中间，很难使用和记住，所以我们可以使用C语言的typedef来做类型定义，这么做也方便将来可能的修改：</p>

<p>```objectivec
typedef int(^EOCSomeBlock)(BOOL flag,int value);
EOCSomeBlock block = ^(BOOL flag,int value){</p>

<pre><code>//Implementation
</code></pre>

<p>};
```</p>

<p>2.对block命名时还是要遵循OC的命名习惯，使用命名空间，也不要还害怕对相同类型使用多个命名，有时候这是必须的，一是命名更加清楚，二是方便将来重构。</p>

<!--more-->


<h2>Item39 Use Handler Blocks to Reduce Code Separation</h2>

<ol>
<li>异步多线程执行任务，之前一直是采用Delegate模式，但现在我们可以通过定义block作为handler来完成同样的任务，而且代码简洁，可读性强。</li>
<li>尤其出现一个类中同时使用多个同种类型的实例，采用一套回调时，那么使用Delegate则会大大增加代码的复杂度，会在很多地方出现switch的判断，而使用block则能避免这一问题。</li>
<li>作者列举了两个例子使用这一模式的场景，都是针对网络请求回调，一是，使用两个block分别处理失败和成功，二是使用一个block，使用error来判断失败和成功（这两种写法都在作者的AFNetworking里出现过）。</li>
<li>方案一的好处是，代码清晰，使用者只需对不同情况填空即可；方案二的好处是，可以更灵活的处理这一问题，如出现一些数据异常、下载中断这些情况，业务端也可以自行按失败来进行处理。</li>
<li>在设计API时，有时会出现，需要在特定线程执行代码的需求，这时我们可以在接口中加入(NSOperationQueue*)queue这样的参数，可以是缺省的。</li>
</ol>


<!--more-->


<h2>Item40 Avoid Retain Cycles Introduced by Blocks Referencing the Object Owning Them</h2>

<ol>
<li>block出现循环引用一般是因为ClassA使用了ClassB的实例，ClassB有block的实例，而ClassA在block中使用了自己的其他实例，造成了block retain了ClassA，ClassA retain了ClassB，ClassB retain了block，这样循环引用就形成了。</li>
<li>解决方案一是在block中完成所有操作时，将ClassB的实例置为nil，这样retain环就断裂了，但这么做也有问题，如果这段block代码没有被执行，那么retain环还存在。</li>
<li>还有一种更隐蔽的情况，ClassA不在把ClassB当做实例变量，只是用做局部变量，但在block中使用了ClassB的局部变量，这样会出现，block retain了ClassB，ClassB ratain了block，所以形成了二元retain环，不过解决很简单，在ClassB中完成对block的最终调用后，将它的block实例置为nil。</li>
<li>这样也凸显了不将block作为外部property的好处（使用者只能通过初始化方法赋值），如果block直接暴露给使用者，你只能要求使用者去清除block property，但这通常是不合理的设计。</li>
</ol>


<!--more-->


<h2>Item41 Prefer Dispatch Queues to Locks for Synchronization</h2>

<p>1.OC大部分线程操作都是默认多线程的，但如果有些情况需要单线程，就需要开发者自己实现，GCD之前有两种方式。<br/>
2.一是synchronization block，它将包含的代码进行加锁操作，参数是self，这可以实现类的不同实例可以分别运行这个方法，但缺点是如果过度使用，会导致性能问题，也会出现代码被不知名的锁所阻塞的问题。</p>

<p>```objectivec
&ndash;(void)synchronizedMethod{</p>

<pre><code>@synchronized(self){
    //Safe
}
</code></pre>

<p>}
```</p>

<p>3.二是NSLock，而且也有专门为递归设计的NSRecursiveLock，但是NSLock一个最大的问题是会出现死锁问题，所以二者都不是最佳方案。</p>

<p>```objectivec
_lock = [[NSLock alloc] init];
&ndash;(void)synchronizedMethod {</p>

<pre><code>[_lock lock];
//Safe
[_lock unlock];
</code></pre>

<p>}
```</p>

<p>4.那么对比使用atomic属性的property，Item6也说过，我们手动实现时，可以利用synchronization block来实现，但是问题就是当多个property这么做时，会出现propertys之间出现阻塞，而且在多次频繁访问一个property时，其他线程可能会对其修改，会造成返回值不同。<br/>
5.替代方案就是GCD的serial synchronization queue，它可以使读写property在一个队列中执行，也就避免了上述问题，代码更加简化，而且利用了GCD底层的优化，而且你不用担心对象之间的相互阻塞。</p>

<p>```objectivec
_syncQueue = dispatch_queue_creat(&ldquo;com.EOC.syncQueue&rdquo;, NULL);
&ndash;(NSString*)someString{</p>

<pre><code>__block NSString *localSomeString;
dispatch_sync(_syncQueue,^{
    localSomeString = _someString;
});
return localSomeString;
</code></pre>

<p>}
&ndash;(void)setSomeString:(NSString*)someString{</p>

<pre><code>dispatch_sync(_syncQueue, ^{
    _someString = someString;
});
</code></pre>

<p>}
```</p>

<p>6.对于这一方案还有优化，优化一是可以将setter方法使用异步执行，因为setter方法不会有返回值，而且由于和getter还是在一个队列执行，还是能保持读取的同步，但是涉及到一个问题，异步需要将block copy到异步线程，那么如果block内容很简单，可能copy的时间和执行的时间差不多，也就达不到优化的效果，但是当block内容比较复杂时，这一手段还是有效地。</p>

<p>```objectivec
&ndash;(void)setSomeString:(NSString*)someString{</p>

<pre><code>dispatch_async(_syncQueue,^{
    _someString = someString;
});
</code></pre>

<p>}
```</p>

<p>7.第二种优化想实现，可以同时并发执行多个getter，但同步执行setter，且它们还要在同一线程，这对于synchronization block或NSLock来说，都是极难实现的，但是我们利用GCD的特性dispatch_barrier_sync()可以轻松实现，getter可以并行执行，如果出现barrier的setter，那么线程会等之前的所有getter都执行完，然后单独执行setter，执行完之后照常并行执行getter操作。</p>

<p>```objectivec
_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
&ndash;(NSString*)someString{</p>

<pre><code>__block NSString *localSomeString;
dispatch_sync(_syncQueue,^{
    localSomeString = _someString;
});
return localSomeString;
</code></pre>

<p>}
&ndash;(void)setSomeString:(NSString*)someString{</p>

<pre><code>dispatch_barrier_async(_syncQueue,^{
    _someString = someString;
});
</code></pre>

<p>}
```</p>

<!--more-->


<h2>Item42 Prefer GCD to performSelector and Friends</h2>

<ol>
<li>&ndash;(id)performSelector:(SEL)selector，曾作为延时执行方法和在特定线程执行方法这些场景中的主要手段，利用runtime，可以改变selector的名称，在运行时再决定执行那个方法，但使用这一方法是有风险的。</li>
<li>如果你使用if/else来决定赋值不同的selector，然后再执行，这样的话，ARC模式下会报内存泄露的警告，原因是编译器不知道那个方法会执行，所以也没办法确定有没有返回值，返回值是autoreleased还是caller自己释放，所以ARC会保守的添加autoreleased，如果这时返回值是caller自己释放的，那么就出现了内存泄露，这一警告MRC不会报出，但也更难发现，且静态分析器也检查不出，所以这是需要注意的一点。</li>
<li>&ndash;(id)performSelector:(SEL)selector以及它的族函数，它们的返回类型都是id类型，也就是说必须是一个指针，如果返回值是void、C结构体、或数值型，那么就有可能出问题，然后最多只能添加两个参数，而且也必须是id类型，超过两个参数或类型不对的也不能用，所以说局限性是非常大的。</li>
<li>&ndash;(id)performSelector:(SEL)selector的延时执行和在特定线程执行的族函数也是一样，缺陷很明显，只支持一个参数，所以使用者必选把所有参数打包，才能使用。</li>
<li>而结合使用Blocks和GCD，你可以实现上述所有的功能，且不会有约束，代码还简洁。</li>
</ol>


<p>```objectivec
//Using dispatch_after
dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW,(INT64_t)(5.0*NSEC_PER_SEC));
dispatch_after(time,dispatch_get_main_queue(),^(void){</p>

<pre><code>[self doSomething];
</code></pre>

<p>});
//Using dispatch_async(or if waitUntileDone is YES,then dispatch_sync)
dispatch_async(dispatch_get_main_queue(),^{</p>

<pre><code>[self doSomething];
</code></pre>

<p>});
```</p>

<!--more-->


<h2>Item43 Know When to Use GCD and When to Use Operation Queues</h2>

<ol>
<li>上面介绍了很多GCD的优点，GCD在的同步机制（Item41）和单例机制（Item45）是非常优秀的，但并不是说GCD就是所有OC线程问题的最优解，在它之前的NSOperationQueue有时更为合适。</li>
<li>GCD是C类型的Api，而operation queues则是OC对象；GCD中的任务是一个block，比较轻量，而operation queues中的任务是NSOperation的子类，比较重量；但这不意味着GCD一直是最优解，有时作为对象的优势也是非常明显的。</li>
<li>使用NSBlockOperation或NSOperationQueue的addOperationWithBlock:方法，可以使operation queues非常像GCD，下面是它的一些优势。</li>
</ol>


<h3>Cancelling operations</h3>

<ol>
<li>NSOperation很容易就可以实现cancel，执行它的cancel方法即可，但已经执行的operation就不能cancel了，但是对于GCD也一样，不能cancel一个已经在执行的block，这类机制就是“fire and forget”，但在GCD上实现cancel，需要自己去实现，而这需要很多工作。</li>
</ol>


<h3>Operation dependencies</h3>

<ol>
<li>operation可以实现依赖，这样开发者可以自己组织执行的优先顺序，例如下载一些文件之前需要先下载验证文件，下验证文件的operation就是其他下载operation的依赖，如果其他下载是并发的，那么它们会等下载完验证文件后再并发执行。</li>
</ol>


<h3>Key-Value Observing of operation properties</h3>

<ol>
<li>Operation的很多property是很适合KVO的，比如：<em>isCancelled，isFinished</em>去监测operation是否取消或完成，如果你的代码需要对operation做到如此细粒度的控制的话，那么更应该使用operation。</li>
</ol>


<h3>Operation priorities</h3>

<ol>
<li>operation可以设置优先级（即queuePriority，从verylow到veryhigh五个枚举值），高优先级的operation会先执行，GCD无法设置每个block的执行优先级，而只能设置整个queue的优先级，所以这也是operation的一大特性。另外，operation还有一个相关的线程优先级（即threadPriority，从0.0到1.0），可以指定operation执行时线程分配的优先级，我理解它和前者一个是时间上的优先级，一个是空间上的优先级，这两者均可通过operation的property直接设置。</li>
</ol>


<h3>Reuse of operation</h3>

<ol>
<li>除非你使用内建的NSOperation的子类，比如NSBlockOperation，你一般都需要自己继承NSOperation，所以这就意味着你可以添加实例和方法，和进行复用。</li>
<li>综上operation有这很多的优点，主要集中于你可以对单个operation进行更加细粒度的操作，而不用自己去组织相关代码，这是对比GCD的block的优势之处。</li>
<li>Apple的NSNotificationCenter有一个方法，如下，其中的NSOperationQueue可以换成dispatch queue的，但是开发者不想对GCD产生无谓的依赖，在这个实例中，两者是没什么区别的。总之，GCD和Operation queue都是视情况使用，而不是一味遵从使用高级接口或底层接口，各有好处。</li>
</ol>


<p><code>objectivec
-(id)addObserverForName:(NSString*)name object:(id)object queue:(NSOperationQueue*)queue usingBlock:(void(^)(NSNotification*))block;
</code></p>

<!--more-->


<h2>Item44 Use Dispatch Groups to Take Advantage of Platform Scaling</h2>

<p>1.Dispatch Groups是GCD的一个特性，为了方便开发者对任务进行分组，你可以等待一组任务完成或者通过回调来被通知一组任务完成了。当你想让一组方法并行执行，但同时希望在它们完成时得到通知，那么你该使用这一特性。例如批量压缩文件。<br/>
2.一个group是一个简单的结构体，也没有标识，下面是group的类型和将task和group关联的方法，其实只是在正常的dipatch执行方法上关联了group而已：</p>

<p><code>objectivec
dispatch_group_t dispatch_group_creat();
void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);
</code></p>

<p>3.另一个方法是使用下面这对方法，enter和leave要配合使用，类似retain和release，必须保持平衡，如果缺少一个leave，那么这个group就永远不会结束了。</p>

<p>```objectivec
void dispatch_group_enter(dispatch_group_t group);
void dispatch_group_leave(dispatch_group_t group);
//Example
dispatch_group_t group = dispatch_group_create();
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
//A
dispatch_group_async(group,queue,^{</p>

<pre><code>//...
</code></pre>

<p>});
//B
dispatch_group_enter(group);
dispatch_async(queue,^{</p>

<pre><code>//...
dispatch_group_leave(group);
</code></pre>

<p>});
```</p>

<p>4.下面的方法可以阻塞目前线程，等待group中的task全部完成，timeout可以设置为一个固定值，也可以设置为DISPATCH_TIME_FOREVER，如果group在timeout内完成，返回值为0，反之则会返回非0值。</p>

<p><code>objectivec
long dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);
</code></p>

<p>5.这个方法则是wait方法的替代，该方法不会阻塞当前线程，而是允许你为group完成添加一个通知回调block，而且可以指定线程，一般在主线程中，肯定是不希望阻塞的。</p>

<p><code>objectivec
void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);
</code></p>

<p>6.下面是一个对一个数组中的对象并发执行相同操作，并在全部完成后进行后续操作的实例，如果不希望阻塞主线程，那么要把wait换为notify，<a href="http://stackoverflow.com/questions/10643797/wait-until-multiple-networking-requests-have-all-executed-including-their-comp/10644282#comment13830651_10644282">StackOverflow另一实例</a>。</p>

<p>```objectivec
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
dispatch_group_t group = dispatch_group_create();
//Plan A, block main queue
for(id object in collection){</p>

<pre><code>dispatch_group_async(group,queue,^{
    [object performTask];
});
</code></pre>

<p>}
dispatch_group_wait(group,DISPATCH_TIME_FOREVER);
//Continue processing after copleting tasks
dispatch_release(group);
//Plan B, not block main queue
for(id object in collection){</p>

<pre><code>dispatch_group_enter(group);
dispatch_async(queue,^{
    [object performTask];
    dispatch_group_leave(group);
});
</code></pre>

<p>}
dispatch_queue_t notifyQueue = dispatch_get_main_queue();
dispatch_group_notify(group,notifyQueue,^{</p>

<pre><code>//Continue processing after completing tasks
</code></pre>

<p>});
```</p>

<p>7.可以通过创建不同优先级的dispatch_queue，来实现task进行优先级分类，但是依然并发执行，并在全部完成后统一处理。<br/>
8.如果你在一个串行的queue中加入多个任务，那么group其实是不起作用的，因为本来这些任务就会串行执行，你只需要继续添加一个block，就可以实现所有任务完成后统一处理。</p>

<p>```objectivec
dispatch_queue_t queue = dispatch_queue_create(&ldquo;com.EOC.queue&rdquo;,NULL);
for(id object in collection){</p>

<pre><code>dispatch_async(queue,^{
    [object performTask];
});
</code></pre>

<p>}
dispatch_async(queue,^{</p>

<pre><code>//Continue processing after completing tasks
</code></pre>

<p>});
```</p>

<p>9.如果你不是自己创建queue，而是使用系统方法返回的queue，那么加入的task，系统会根据系统资源开辟一定数量的线程，来执行这些task，再配合group特性，你只需要关注你的业务逻辑即可，而不用去在如何安排和控制它们的线程开辟和同步上面花费精力。<br/>
10.类似上面多次执行相同的任务，还有一个专门的方法来实现它，如下，传入的iterations类似for循环的最大值，i会从0循环到最大值减一。但dispatch_apply的缺点是会阻塞当前线程，如果你希望在后台线程运行，那么还要使用group的notify方法。</p>

<p>```objectivec
void dispatch_apply(size_t iterations, dispatch_queue_t queue,void(^block)(size_t));
//A serial
dispatch_queue_t queue = dispatch_queue_create(&ldquo;com.EOC.queue&rdquo;);
dispatch_apple(10,queue,^{</p>

<pre><code>//perform task
</code></pre>

<p>});
//B concurrent
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
dispatch_apply(array.count,queue,^(size_t i){</p>

<pre><code>id object = array[i];
[object peformTask];
</code></pre>

<p>});
```</p>

<!--more-->


<h2>Item45 Use dispatch_once for Thread-Safe Single-Time Code Execution</h2>

<p>1.GCD之前的单例模式实现，使用了synchronization block是为了线程安全：</p>

<p>```objectivec
+(id)sharedInstance{</p>

<pre><code>static EOCClass *sharedInstance = nil;
@synchronized(self){
    if(!sharedInstance){
        sharedInstance = [[self alloc] init];
    }
}
return sharedInstance;
</code></pre>

<p>}
```</p>

<p>2.这是GCD之后的版本，使用了dispatch_once，新类型dispatch_once_t保证了，对于每一个该类型的token，dispatch_once只会执行它对应的block一次，而且是线程安全的，为了保证token的唯一性，token也必须声明为static或global类型。</p>

<p>```objectivec
void dispatch_once(dispatch_once_t *token,dispatch_block_t block);
//singleton
+(id)sharedInstance{</p>

<pre><code>static EOCClass *sharedInstance = nil;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken,^{
    sharedInstance = [[self alloc] init];
});
return sharedInstance;
</code></pre>

<p>}
```</p>

<p>3.相比较synchronization block的版本，dispatch_once版本效率更高，因为前者在每次运行这段代码时都会进行加锁操作，它对dispatch token进行了原子型的访问来确定代码是否执行过，作者测试使用dispatch_once较synchronization block快将近两倍。</p>

<!--more-->


<h2>Item46 Avoid dispatch_get_current_queue</h2>

<ol>
<li>使用GCD时，获得当前运行的queue是一个常见的需求，而Apple也提供了一个方法：<em>dispatch_queue_t dispatch_get_current_queue()</em>，但是作者告诉我们，这个方法像retainCount一样，并不可靠，iOS6已经将其弃用，目前只可以在debug模式下使用。</li>
<li>回想Item41的getter/setter最终方案，可能会出现这样的场景，就是调用getter的queue和getter中的synchronization queue是同一队列，这样就会产生死锁，dispatch_sync会一直等待queue可用，而这个queue实际上就是当前的queue，所以block永远不会执行。所以就会想到用dispatch_get_current_queue()来判断当前的queue是否是synchronization queue，如果是就直接执行block，不是的话用dispatch_sync()。</li>
<li>如果在简单场景下应该是没问题，如果考虑到一些特殊情况，比如queueA->queueB->queueA嵌套执行，且所有的操作都是同步操作，那么内部的queueA关联的block还是会出现死锁，因为外层的queueA block还未执行完。</li>
<li>所以这个例子中，使用dispatch_get_current_queue()并不是一个可靠地解决方法，而还是应该单独建立一个queue专门供synchronization使用，并确保该queue中会调用getter方法。</li>
<li>从更为普遍的角度讲，因为dispatch queues是存在等级划分的，也就是说在当前queueA中的block加入了在queueB中执行的block，那么queueB上执行的block同样执行与queueA上，而顶层的queue则是global concurrent queues的其中一个。</li>
<li>只有两个queue不存在这种包含关系，才可以并行执行，反之，如果两个queue存在包含的关系，那么在他们中执行同步操作，怎要特别关注死锁问题。这也就是dispatch_get_current_queue()这个方法意义不大的根本原因，因为它只能返回当前的queue，而无法得知整个queue的包含链。</li>
<li>最容易产生这个问题的场景是Api需要你传入想运行的queue，而Api内部在另一个queue上使用了串行同步操作，然后将它的结果在传入的queue中返回，使用者一般会假设dispatch_get_current_queue()会返回自己传入的queue，但结果会返回内部的同步queue。</li>
<li>Queue-specific data是解决上述问题的一个方案，它可以将任意数据和queue绑定，最重要的是，如果没发现与对应key绑定的值，系统会一直沿包含链向上，知道找到对应的queue被找到，或者到root queue。</li>
<li><em>dispatch_queue_set_specific()</em>方法是这一技术的核心，给queue关联的是一个类似键值对的结构，键值均为空指针类型，对于key来说，需要注意的是，作为key的是指针的值而不是指向内容的值，所以其实更像Item10中介绍的associated references。value也是空指针类型，所以理论上你可以将任何值作为value，但是你希望自己管理它的内存，如果在ARC下，使用OC对象就很难做到这一点，所以作者推荐使用了CFString，因为ARC不会管理CoreFoundation的对象，而且也可以很方便转化为OC对象，所以很合适。最后的参数希望传入一个函数指针，它将用作析构函数，将在value从key移除时调用，这可能是queue被释放或者value被赋新值时。dispatch_function_t的类型是只有一个指针且返回空值，示例中CFRelease作为了参数，对应传入的CFString，如果传入的是自己定义的对象，开发者也可以自己重写CFRelease函数，做一些清除工作。</li>
</ol>


<p>```objectivec
void dispatch_queue_set_specific(dispatch_queue_t queue,const void <em>key,void </em>context,dispatch_function_t destructor);
typedef void(<em>dispatch_function_t)(void</em>)
//Example
dispatch_queue_t queueA = dispatch_queue_create(&ldquo;com.EOC.queueA&rdquo;,NULL);
dispatch_queue_t queueB = dispatch_queue_create(&ldquo;com.EOC.queueB&rdquo;,NULL);
dispatch_set_target_queue(queueB,queueA);
static int kQueueSpecific;
CFStringRef queueSpecificValue = CFSTR(&ldquo;queueA&rdquo;);
dispatch_queue_set_specific(queueA,&amp;kQueueSpecific,(void*)queueSpecificValue,(dispatch_function_t)CFRelease);
dispatch_sync(queueB,^{</p>

<pre><code>dispatch_block_t block = ^{NSLog(@"No deadlock!");};
CFStringRef retrievedValue = dispatch_get_specific(&amp;kQueueSpecific);
if(retrievedValue){
    block();
} else {
    dispatch_sync(queueA,block);
}
</code></pre>

<p>});
```</p>
]]></content>
  </entry>
  
</feed>
