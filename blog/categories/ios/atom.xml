<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 刘毅的技术博客]]></title>
  <link href="http://lucifer1988.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://lucifer1988.github.io/"/>
  <updated>2015-10-10T14:14:27+08:00</updated>
  <id>http://lucifer1988.github.io/</id>
  <author>
    <name><![CDATA[刘毅]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Language Basics I]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/08/swift-by-tutorials-language-basics-i/"/>
    <updated>2015-10-08T14:26:37+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/08/swift-by-tutorials-language-basics-i</id>
    <content type="html"><![CDATA[<p>Swift更新到2.0了，是时候来一波Swift的集中学习了，这次用的教材是raywenderlich出版的Swift by Tutorials，我手里的版本是2014年12月份的，可能有些在Swift2.0中发生了变化，我会尽量标注出来。开始第一章，介绍一些Swift的基本语法。</p>

<!--more-->


<h2>Variables,constants and strings</h2>

<p>1.Playground是Xcode新加入的一种文件，实际上就是一个可以自动编译的swift文件，可以用来测试一些简单的代码，也能显示一些资源文件，下面是申明一个string类型，可以直接在playground运行。</p>

<p><code>objectivec
var greeting: String = "Hello"
//也可以不指名类型
//var greeting = "Hello"
//如对greeting赋值int型，会报错
//greeting = 9
print(greeting)
</code></p>

<p>2.string可以不声明类型，即可运行，是源于Swift的type interface的特性，即通过赋值自动确定变量的类型，但是之后再对其赋值整形，则会报错。因为Swift是静态输入语言，编译期间会进行类型检查。<strong>type interface是推荐使用的，可以使代码简洁，增加可读性</strong>。<br/>
3.Swift的string类型是可变的，而且改变方式不像NSMutableString那么复杂，直接使用+=方式即可。</p>

<p><code>objectivec
var greeting = "Hello"
greeting += "World"
print(greeting)
</code></p>

<p>4.如果想声明不可变String，只需添加let关键字即可。在Swift中，控制内建类型的可变性是通过添加let或var关键字来实现的，这不同于OC，需要两种类型来实现。<strong>你应该尽量使用不可变类型，这不仅使你的程序更加健壮，也会使编译器做更多优化，实际上let使用的场景是远远多于var的</strong>。</p>

<p><code>objectivec
let greeting = "Hello"
</code></p>

<p>5.let关键字不仅限于Swift内建类型，自定义的结构体和类也可以使用，但有些细微不同，这将在第三章中详细讲到。<br/>
6.改变string也可以利用append()方法，这是Swift String自带的一些API，但是数量不多。幸运的是，Swift String与OC的NSString是可转换的，NSString的全部方法，String也可全部使用，但是还是推荐尽量使用String自带的API，比较简洁。</p>

<p>```objectivec
//Swift String API
greeting.append(Character(&ldquo;!&rdquo;))
//bridge to NSString
//logout Hello World
import Foundation</p>

<p>var greeting = &ldquo;hello world&rdquo;.capitalizedString
print(greeting)
//NSString style append
import Foundation</p>

<p>var greeting = &ldquo;hello&rdquo;.stringByAppendingString(&ldquo; world&rdquo;)
print(greeting)
```</p>

<p>7.Swift String是一个值类型，当它被赋值给变量、常量、或者作为参数传入方法时，它的值是被copy的，如下例，改变alternateGreeting不会影响greeting的值。</p>

<p><code>objectivec
var alternateGreeting = greeting
alternateGreeting += " and beyond!"
print(alternateGreeting)
print(greeting)
</code></p>

<!--more-->


<h2>Semicolons(分号)</h2>

<ol>
<li>Swift中分号只有在同一行中添加多条代码时才强制使用，其他情况可以省略不写，<strong>这又是Swift代码简洁的一大表现</strong>。</li>
</ol>


<!--more-->


<h2>Numeric types and conversion</h2>

<p>1.这一节主要讲Swift的数值类型，下面创建了两个变量，Int类型的radius和Double类型的pi，Swift还有很多其他类型，如Int8、UInt16、Float等。除非你有特殊需求，那么Int和Double类型是你的首选，这两个类型有广泛的使用，而且编译器会自动选择Int的最佳长度，32或64，基于机器的字长，来生成最高效的代码。</p>

<p><code>objectivec
var radius = 4
let pi = 3.14159
</code></p>

<p>2.在Swift中，你可以使用<strong>_</strong>来作为千分号，如下。</p>

<p><code>objectivec
let milion = 1_000_000
</code></p>

<p>3.以下代码会报错，是因为*无法直接将Int和Double相乘，而Swift中也不会隐式转化，需要开发者显式转化，需要注意这里并不是类型转化，而是新生成了一个Double类型，在第三章中会详细讲解初始化方法。</p>

<p><code>objectivec
//error
var area = radius * radius * pi
//soluation
var area = Double(radius) * Double(radius) * pi
</code></p>

<p>4.显式转化变量是Swift的安全策略之一，另外一个是越界检查，下列代码在其他语言中可能会生成一个负数，而在Swift中会直接将其视为一个runtime error。同时，为了避免integer的越界计算error，Apple提供了&amp;+、&amp;-、&amp;*、&amp;/、&amp;%这些越界运算符，使用后会像常规计算一样，生成负数。</p>

<p><code>objectivec
var overflow = Int.max + 1
//overflow operators
var overflow = Int.max &amp;+ 1
</code></p>

<!--more-->


<h2>Booleans</h2>

<p>1.Swift的布尔类型为Bool，值为true或false，需要说明的一点是，作为Swift的安全特性之一，控制流中需要进行布尔判断的只能使用Bool类型，而不同于在OC中，可以将任意非零值作为判断条件，例如你不能在Swift中使用一个整数当做判断条件。</p>

<p><code>objectivec
let alwaysTrue = true
</code></p>

<!--more-->


<h2>Tuples(元组)</h2>

<p>1.元组用来将多个值组成一个类型，但是不像类和结构体，你不需要显式的定义这个类型，如下，你可以通过索引来访问每个值，也可以通过索引来改变每个值（前提是你得元组的是可变的），而越界访问，编译器会报error。</p>

<p><code>objectivec
var address = (742, "Evergreen Terrace")
print(address.0)
print(address.1)
address.0 = 744
</code></p>

<p>2.你也可以声明元组的类型，如下。如果想将元组的Int值类型改为Double有三种方式，同如下：</p>

<p><code>objectivec
var address: (Int, String) = (742, "Evergreen Terrace")
//change Int to Double
//1)using a type annotation
var address1: (Double, String) = (742, "Evergreen Terrace")
//2)by explicit creation of a Double
var address2 = (Double(742), "Evergreen Terrace")
//3)by using a double literal value
var address3 = (742.0, "Evergreen Terrace")
</code></p>

<p>3.你也可以把元组解析成单个元素，而这也是一个copy操作，改变新值不会影响原始的元组值，如下：</p>

<p><code>objectivec
var address = (742, "Evergreen Terrace")
let (house, street) = address
print(house)
print(street)
</code></p>

<p>4.此外，你可以为元组的每个值加一个key，提高可读性，同时上述的访问方法依然有效。</p>

<p><code>objectivec
var address = (number: 742, street: "Evergreen Terrace")
print(address.number)
print(address.street)
</code></p>

<p>5.元组只是一个类型，也可以进行嵌套，元组作为其他元组的一个元素，类和结构体虽然包含了元组的所有功能，但是在一些轻量的场景下，元组可以更加快速简单地去构建一个复合类型。</p>

<!--more-->


<h2>String interpolation</h2>

<p>1.打印出一个类的信息，是常见的需求，例如OC中NSObject的description方法，如果我们想打印出上一节中元组的信息，我们可能这么做：</p>

<p><code>objectivec
var address = (742, "Evergreen Terrace")
let (house, street) = address
print("I live at " + String(house) + ", " + street)
</code></p>

<p>2.这利用了Swift的+拼接字符串的技术，不过在Swift中有更加方便的字符串拼接技术来处理这一场景，string interpolation，如下：</p>

<p><code>objectivec
var address = (742, "Evergreen Terrace")
let (house, street) = address
print("I live at \(house), \(street)")
</code></p>

<p>3.当然这不是打印日志专用的，在你需要从一系列变量中构建String时，都可使用。</p>

<p>```objectivec
import Foundation</p>

<p>var address = (742, &ldquo;Evergreen Terrace&rdquo;)
let (house, street) = address
let str = &ldquo;I live at (house+10), (street.uppercaseString)&rdquo;
```</p>

<p>4.最后，如果想只打印出\时，请用\\转义。</p>

<!--more-->


<h2>Control flow</h2>

<h3>For loops</h3>

<p>1.首先要介绍的Swift中的for循环的新特性是closed range operator，即闭区间运算符，例子如下：</p>

<p>```objectivec
let greeting = &ldquo;Swift by Tutorials!&rdquo;
for i in 1&hellip;5 {</p>

<pre><code>print("\(i) - \(greeting)")
</code></pre>

<p>}
```</p>

<p>2.注意，其中的i并不是一个var类型的变量，而是每次循环创建一个let的常量，是不可被赋值的。<br/>
3.1&hellip;5是一个Range类型，与for循环并无关系，下例说明了这一问题：</p>

<p>```objectivec
var range = 1&hellip;5
for i in range {</p>

<pre><code>print("\(i) - \(greeting)")
</code></pre>

<p>}
//what&rsquo;s 1..5?
var range = Range(start: 1, end: 6)
```</p>

<p>4.x&hellip;y只是Range类型的一个简化的语法糖，你可以用x..&lt;y来创建半开半闭的区间，最后一个值为y-1。</p>

<p><code>objectivec
//means 1,2,3,4,5
var range1 = 1...5
//means 1,2,3,4
var range2 = 1..&lt;5
</code></p>

<p>5.那么还有个问题，for循环是怎么处理这个Range的？从而实现循环？其实是这样的，for循环可以处理很多可遍历的Swift类型，例如array、dictionary，还比如string也可以，所以range只是这些可遍历类型的其中之一而已。</p>

<p>```objectivec
for i in &ldquo;Swift&rdquo; {</p>

<pre><code>print(i)
</code></pre>

<p>}
```</p>

<p>6.<strong>再挖的深一点，为什么String和Range一样可以被遍历？去看一下它们的定义就可以得知，它们都遵循了Sequence protocol，通过实现协议中的方法，就可以得到generator，继而循环请求其中的值，在第四章我们将自己创建类型来实现这一协议和利用generator。</strong></p>

<h3>While loops</h3>

<p>1.Swift同时支持while循环和do-while循环(<strong>Swift2.0将do-while改为了repeat-while</strong>)。</p>

<p>```objectivec
//while loop
let greeting = &ldquo;Swift by Tutorials!&rdquo;
var i = 0
while i &lt; 5 {</p>

<pre><code>print("\(i) - \(greeting)")
i++
</code></pre>

<p>}
//repeat-while loop
let greeting = &ldquo;Swift by Tutorials!&rdquo;
var i = 0
repeat {</p>

<pre><code>print("\(i) - \(greeting)")
i++
</code></pre>

<p>} while i &lt; 5
```</p>

<h3>If statements</h3>

<p>1.Swift支持常规的if-else用法，需要注意的就是前面提到过的，if的条件必须是Bool类型，而且<strong>还有一点就是即使只有一条执行的语句，也要用{}，这是Swift和其他语言if的一个区别，不然会报错，这也是为了避免{}误用或少写导致的bug</strong>，此外，还有一个和if有关的关于optional value的技巧会在下一章讲到。</p>

<p>```objectivec
import Foundation</p>

<p>let greeting = &ldquo;Swift by Tutorials!&rdquo;</p>

<p>for i in 1&hellip;5 {</p>

<pre><code>if i == 5 {
    print(greeting.uppercaseString)
} else {
    print(greeting)
}
</code></pre>

<p>}
```</p>

<h3>Switch statements</h3>

<p>1.Swift支持常规的switch语句，与OC不同的是，Swift的switch条件可以使任意类型，而OC只是原始类型，编译器来确保每个case的条件与switch条件类型一致。<br/>
2.第二点，Swift中的switch不需要在每个case后添加break，这是因为在Swift中，每个case执行完后，会自动跳出switch，所以不需要手动添加break，同时这也是安全策略之一。</p>

<p>```objectivec
var direction = &ldquo;up"switch direction {</p>

<pre><code>case "down":        println("Going Down!")  case "up":      println("Going Up!")    default:        println("Going Nowhere") }
</code></pre>

<p>```
3.第三，Swift的switch相当智能，如果你提供的switch条件的可能值没有在case中被全部覆盖，会提示你添加default，如上例的String类型，不然会报error；而如果你的case覆盖了switch条件的所有值，如enum类型，那么不添加default也不会报错。<br/>
4.如何在switch在一个case中匹配多个值，参照下例：</p>

<p>```objectivec
var direction = &ldquo;up"switch direction {</p>

<pre><code>case "down", "up":      println("Going Somewhere!")     default:        println("Going Nowhere") }
</code></pre>

<p>```</p>

<p>5.可以利用上一节介绍的Range来实现case的区间匹配：</p>

<p>```objectivec
var score = 570</p>

<p>switch score {</p>

<pre><code>case 1..&lt;10:
    print("novice")
case 10..&lt;100:
    print("proficient")
case 100..&lt;1000:
    print("rock-star")
default:
    print("awesome")
</code></pre>

<p>}
```</p>

<p>6.另外switch与元组的结合，可以创造出更加复杂的场景处理：</p>

<p>```objectivec
let somePoint = (1, 1)
switch somePoint {</p>

<pre><code>case (0, 0):
    print("(0, 0) is at the origin")
case (_, 0):
    print("(\(somePoint.0), 0) is on the x-axis")
case (0, _):
    print("(0,\(somePoint.1)) is on the y-axis")
case (-2...2, -2...2):
    print("(\(somePoint.0), \(somePoint.1)) is inside the box")
default:
    print("(\(somePoint.0), \(somePoint.1)) is outside the box")
</code></pre>

<p>}
```</p>

<p>7.利用value binding技术，可以在判断期间将tuple的元素赋值给let变量（当然也可以声明为var类型，且它的作用范围只存在该case中）：</p>

<p>```objectivec
let anotherPoint = (2, 0)
switch anotherPoint {</p>

<pre><code>case (let x, 0):
    print("on the x-axis with an x value of \(x)")
case (0, let y):
    print("on the y-axis with an y value of \(y)")
case let (x, y):
    print("somewhere else at (\(x), \(y))")
</code></pre>

<p>}
```</p>

<p>8.switch可以添加where语句，为每个case添加额外的判断条件：</p>

<p>```objectivec
let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {</p>

<pre><code>case let (x, y) where x == y:
    print("(\(x), \(y)) is on the line x == y")
case let (x, y) where x == -y:
    print("(\(x), \(y)) is on the line x == -y")
case let(x, y):
    print("(\(x), \(y)) is just some arbitrary point")
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记7]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/09/16/effective-objective-cdu-shu-bi-ji-7/"/>
    <updated>2015-09-16T15:42:34+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/09/16/effective-objective-cdu-shu-bi-ji-7</id>
    <content type="html"><![CDATA[<p>这是本书的最后一章了，集中讲解了有关Cocoa自带的system framework，这是开发中必须要使用的基本库，没有这些封装，很多基本的功能都无法实现，没有集合，也没有基类NSObject，可谓寸步难行，一些新的Api有时会节省我们很多工作量，同时这些库中的很多设计也是我们自己的代码需要学习的。</p>

<!--more-->


<h2>Item47 Familiarize Yourself with the System Frameworks</h2>

<ol>
<li>一个framework是将代码打包成一个动态库，会有头文件来描述接口，有时候也会有一些第三方的静态库（即.a文件），这些不能作为真正意义上的框架，但是被常常当做框架来用，所有的系统框架都使用了动态库。</li>
<li>Cocoa或Cocoa Touch是框架集，其中的基本框架就是Foundation框架，Foundation Framework不但提供了基本类型和基本集合，而且还有很多复杂功能，比如字符串处理。</li>
<li>除了另一个基础库是CoreFoundation，几乎就是Foundation的镜像库，只不过内部都是C接口和结构体，OC提供了一个名为toll-free bridging的转换特性，可以使OC对象和CF对象自由转化，toll-free bridging自身比较复杂，所以不建议自己去实现这一转化功能。除了上述两个基础框架，还有以下一些常用框架：</li>
<li>CFNetwork：基于C的网络请求基本框架，基于BSD socket提供了很多易用的请求工具，Foundation通过对它的部分封装，提供了OC类型的网络接口。</li>
<li>CoreAudio：提供了基于C的音频设备访问接口，本身是很复杂的，但OC的抽象将其变得易用不少。</li>
<li>AVFoundation：提供了用于播放和录制音视频的OC对象，例如播放视频的UI类。</li>
<li>CoreData：提供了用于数据持久化的OC对象，CoreData处理数据的存取，并能在Mac OS X与iOS之间通用。</li>
<li>CoreText：提供了基于C的文字高效的类型设置和渲染的接口。</li>
<li>使用一些C类型的框架，有时是必要的，因为通过绕过runtime，速度会更快，但是需要更加关注内存管理。</li>
<li>AppKit和UIKit分别是Mac OS X 和iOS的UI框架，提供了基于Foundation和CoreFoundation的OC类型，在它的下面是CoreAnimation和CoreGraphics在支持。</li>
<li>CoreAnimation基于OC类型，提供了渲染图像和展示动画的工具，它不是一个独立的框架，还是QuartzCore框架的一部分，但是很多情况CoreAnimation还是被优先使用。</li>
<li>CoreGraphics是基于C类型的，提供了用于2D渲染的必不可少的结构体和函数，CGPoint，CGSize，CGRect都是在这儿定义的。</li>
<li>UIKit的上层还有很多更高级的框架，例如：MapKit，Social framework。</li>
</ol>


<!--more-->


<h2>Item48 Prefer Block Enumeration to for Loops</h2>

<p>1.遍历一个集合类型是常见需求，，而OC也有很多方式，从标准的C的for循环，到OC 1.0的NSEnumerator，到OC 2.0的快速遍历，block加入OC后，又出现了遍历直接传入block进行对象处理的新方法。<br/>
2.For Loops：沿用最原始的C语言的循环，定义一个int型index，然后按照index去遍历每个对象，对于NSArray来说影响还不大，但是对于NSDictionary，NSSet来说，因为都是无序的，所以必须额外生成中间数组，这是额外的内存消耗，但倒序遍历只需要改变index为递减即可，还算方便。<br/>
3.OC 1.0 NSEnumerator：NSEnumerator是一个基类，需要重写-(NSArray*)allObjects,&ndash;(id)nextObject两个方法，而Foundation框架的集合类型都支持了NSEnumerator，可以通过不断执行nextObject()来完成遍历，它的优势是所有的集合类型的遍历方式都是类似的，而且也支持不同的enumerator来实现不同顺序来遍历，缺点是还是需要额外的enumerator，而且不能得知当前的index。</p>

<p>```objectivec
//NSArray enumerator
NSArray <em>anArray = /</em>&hellip;<em>/;
NSEnumerator </em>enumerator = [anArray objectEnumerator];
id object;
while((object = [enumerator nextObject])!=nil){</p>

<pre><code>//Do something with 'object'
</code></pre>

<p>}
//NSDictionary enumerator
NSDictionary <em>aDictionary = /</em>&hellip;*/;
id key;
while((key = [enumerator nextObject])!=nil){</p>

<pre><code>id value = aDictionary[key];
//Do something with 'key' and 'value'
</code></pre>

<p>}
//NSArray reverse enumerator
NSArray <em>anArray = /</em>&hellip;<em>/;
NSEnumerator </em>enumerator = [anArray reverseObjectEnumerator];
id object;
while((object = [enumerator nextObject])!=nil){</p>

<pre><code>//Do something with 'object'
</code></pre>

<p>}
```</p>

<p>4.Fast Enumeration：OC2.0引入了快速遍历，快速遍历详单与结合了for-loop和enumerator的双重特点，同时极大的简化了语法。实现这一技术是采用了NSFastEnumeration这一协议（只有一个方法），集合类型通过遵循这一协议，从而支持了快速遍历，实现协议中的方法使得类可以同时返回多个对象：</p>

<p><code>objectivec
//NSFastEnumeration
-(NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState*)state objects:(id*)stackbuffer count:(NSUInteger)length;
</code></p>

<p>```objectivec
//NSArray
NSArray <em>anArray = /</em>&hellip;*/;
for(id object in anArray){</p>

<pre><code>//Do something with 'object'
</code></pre>

<p>}
//NSDictionary
NSDictionary <em>aDictionary = /</em>&hellip;*/;
for(id key in aDictionary){</p>

<pre><code>id value = aDictionary[key];
//Do something with 'key' and value
</code></pre>

<p>}
```</p>

<p>如果需要反向遍历，可以通过下列方法，因为NSEnumerator也实现了NSFastEnumeration：</p>

<p>```objectivec
NSArray <em>anArray = /</em>&hellip;*/;
for(id object in [anArray reverseObjectEnumerator]){</p>

<pre><code>//Do something with 'object'
</code></pre>

<p>}
```</p>

<p>快速遍历的优点是效率很高，而且代码简洁，但是依然有两个缺陷，NSDictionary如果同时需要key和value的话，还是需要两步；同时index也是无法直接获取。</p>

<p>5.Block-Based Enumeration：是在OC引入block后的遍历集合的最新方法，下面是NSArray的基本block遍历方法，前两个参数很明显，第三个参数是用来停止遍历的：</p>

<p>```objectivec
//NSArray
&ndash;(void)enumerateObjectsUsingBlock:(void(^)(id object,NSUInteger idx,BOOL <em>stop))block;
//NSDictionary
&ndash;(void)enumerateLeysAndObjectsUsingBlock:(void(^)(id key,id object,BOOL </em>stop))block;
//example
NSArray <em>aArray = /</em>&hellip;<em>/;
[aArray enumerateObjectsUsingBlock:^(id object,NSUInteger idx,BOOL </em>stop){</p>

<pre><code>//Do something with 'object'
if(shouldStop){
    *stop = YES;
}
</code></pre>

<p>}];
```</p>

<p>block遍历虽然看起来语法比快速遍历更复杂了，但是代码还是很整洁的，而且提供了方便的停止遍历的方法，而在其他方式中需要自己添加break，另外你可以现在一次性获得所有的信息，包括：NSArray的index，NSDictionary的key和value。</p>

<p>如果NSDictionary的键值类型是确定的，那么你可以重写block中的id类型，也可以在类型出现异常时抛出警告，所以如果类型确定，还是推荐这么写的。</p>

<p>```objectivec
NSDictionary <em>aDictionary = /</em>&hellip;<em>/;
[aDictionary enumerateKeysAndObjectsUsingBlock:^(NSString </em>key,NSString <em>obj,BOOL </em>stop){</p>

<pre><code>//Do Something with 'key' and 'obj'
</code></pre>

<p>}];
```</p>

<p>除了这些，还有个最大的特点是，block遍历可以通过设置option（枚举类型）来实现各种各样的遍历方式，例如通过NSEnumerationConcurrent实现对集合中的对象并发执行方法（内部应该是利用了GCD的dispatch group），通过NSEnumerationReverse实现集合的逆向遍历，而且也可以通过位与操作，同时实现这两个option。</p>

<p><code>objectivec
//NSArray
-(void)enumerateObjectsWithOptions:(NSEnumerationOptions)options usingBlock:(void(^)(id object,NSUInteger idx,BOOL *stop))block;
//NSDictionary
-(void)enumerateLeysAndObjectsWithOptions:(NSEnumerationOptions)options usingBlock:(void(^)(id key,id object,BOOL *stop))block;
</code></p>

<p>综上，block遍历虽然语法不及快速遍历简洁，但是对于NSArray获得index，对于NSDictionary获得key和value这些信息，通过option获得并发执行遍历，都是优于其他遍历方法的。</p>

<!--more-->


<h2>Item49 Using Toll-Free Bridging for Collections with Custom Memory-Management Semantics</h2>

<p>1.Toll-Free Bridging是OC用来在Foundation定义的OC对象和CoreFoundation定义的对应的C结构体之间相互转化，使用了<strong>bridge关键字，相当于ARC依然持有OC对象，如果使用了</strong>bridge_retained，那么ARC就要交出持有权，那么在我们使用完CF指针后要执行CFRelease(aCFArray)来释放内存，反之你需要将CF指针转化为OC对象，并需要转移持有权时，要加上__bridge_transfer关键字，这三个关键字非常重要。</p>

<p><code>objectivec
NSArray *anNSArray = @[@1,@2,@3,@4,@5];
CFArrayRef aCFArray = (__bridge CFArrayRef)anNSArray;
NSLog(@"Size of array = %li", CFArrayGetCount(aCFArray));
</code></p>

<p>2.为什么要去使用CF结构体指针？当然绝大部分情况我们是不会刻意去使用的，作者列举了一个特殊的场景：NSDictionary的key是copy类型，而value是retain类型，也就意味着，不支持copy协议的类是不能作为NSDictionary的key的，如果我们需要一个value和key都是retain类型的dictionary，那要怎么办呢？<br/>
3.作者列举了一种思路，重新构建一个CF的字典类型，因为在这一级，我们可以控制key和value的回调类型，然后再通过Toll-Free Bridging来转化为需要的NSMutableDictionary，从而达到目的。</p>

<!--more-->


<h2>Item50 Use NSCache Instead of NSDictionary for Caches</h2>

<p>1.在网络请求中做缓存是常见的需求，因为一般会将data和url或者request对象做成键值对存储，所以一些年轻的程序员就会考虑用NSDictionary来做缓存，但是作者建议用NSCache来做这类缓存。<br/>
2.NSCache的优势之一是，当系统资源吃紧时，cache会被自动释放，且会优先释放最近未被使用的缓存，如果NSDictionary想实现这一点，是需要做很多额外工作的。<br/>
3.NSCache的优势之二是，NSDictionary的key是copy类型，而value是retain类型，而NSCache的key和value都是retain类型，这就意味着，NSCache可以将不实现copy协议的对象作为key，虽然根据Item49的做法，也可以把NSDictionary做成这种类型，但是实现起来很复杂。另外，NSCache是线程安全的，你可以在多个线程同时插值，在做缓存时，在主线程读取缓存，然后缓存不存在，在后台线程下载并赋值是常见的场景。<br/>
4.你可以手动控制缓存的容量，通过设置缓存数量和大小来控制，如果缓存数量或大小超过限制，也会开始自动释放，但释放的顺序是不可控的，所以想通过改变最大容量来让缓存按照顺序释放是不现实的。<br/>
5.需要注意的是，设置缓存大小容量，是基于加入缓存的对象的大小易于计算，如果计算对象大小成本过高的话，这就会影响效率，因为每次加入都会进行计算。例如去硬盘计算文件大小或去数据库查找大小就是耗时的操作，但如果是NSData作为缓存对象，那么获取它的大小代价就很小，只是读取一个property而已。<br/>
6.下面是一个使用NSCache的实例：</p>

<p>```objectivec
@implementation EOCClass{</p>

<pre><code>NSCache *_cache;
</code></pre>

<p>}
&ndash;(id)init{</p>

<pre><code>if((self = [super init])){
    _cache = [NSCache new];
    _cache.countLimit = 100;
    _cache.totalCostLimit = 5*1024*1024;
}
return self;
</code></pre>

<p>}
&ndash;(void)downloadDataForURL:(NSURL*)url{</p>

<pre><code>NSData *cachedData = [_cache objectForKey:url];
if(cacheData){
    //Cache hit
    [self useData:cachedData];
} else {
    //Cache miss
    EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];
    [fetcher startWithCompletionHandler:^(NSData *data){
        [_cache setObject:data forKey:url cost:data.length];
        [self useData:data];
    }];
}
</code></pre>

<p>}
@end
```</p>

<p>7.除了NSData，另一种可以和NSCache搭配的是NSPurgeableData，它是NSMutableData的子类，实现了NSDiscardableContent协议，NSPurgeableData的内存会在系统资源紧张时自动释放，<em>isContentDiscard</em>是协议中的一个方法，返回内存是否已释放。<br/>
8.NSPurgeableData在使用之前要用<em>beginContentAccess</em>确保目前内存不被释放，然后使用完后调用<em>endContentAccess</em>告知系统可以被释放，这一对操作可以嵌套，类似retain/release。<br/>
9.如果NSPurgeableData添加到NSCache，释放的对象会自动移出cache，这可以被<em>evictsObjectsWithDiscardedContent</em>这一property关闭或开启。<br/>
10.下面是一个NSPurgeableData的实例，注意NSPurgeableData被创建时就相当于+1purge reference count与alloc类似，所以不必再加<em>beginContentAccess</em>，但用完要加<em>endContentAccess</em>。</p>

<p>```objectivec
&ndash;(void)downloadDataForURL:(NSURL*)url{</p>

<pre><code>NSPurgeableData *cacheData = [_cache objectForKey:url];
if(cachedData){
    //Stop the data being purged
    [cacheData beginContentAccess];
    //Use the cached data
    [self useData:cachedData];
    //Mark that the data may be purged again
    [cacheData endContentAccess];
} else {
    //Cache miss
    EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];
    [fetcher startWithCompletionHandler:^(NSData *data){
        NSPurgeableData *purgeableData = [NSPurgeableData dataWithData:data];
        [_cache setObject:purgeableData forKey:url cost:purgeableData.length];
        //Don't need to beginContentAccess as it begins with access already marked
        [self useData:data];
        //Mark that the data may be purged now
        [purgeable endContentAccess];
    }];
}
</code></pre>

<p>}
```</p>

<!--more-->


<h2>Item51 Keep initialize and load Implementations Lean</h2>

<ol>
<li>一个类总会有有自己的初始化方法，由于OC中类型大部分继承于NSObject，所有有很多继承于NSObject的初始化方法，第一个就是<em>*(void)load</em>方法。</li>
<li><em>load</em>方法在每个class和category中会且只会被调用一次，这个方法发生在包含该类的library在加载后，一般是应用加载中，而且只是iOS代码的独有的，Mac OS X有更灵活的dynamic loading，可以使library在应用加载后加载，而category的load在其原class加载后加载。</li>
<li>想重写<em>load</em>方法的问题是，它运行时runtime处于不稳定的状态，所有父类的<em>load</em>方法是先于其他类的<em>load</em>调用的，所依赖库中的所有<em>load</em>方法会先调用。但在一个库中，这些类的<em>load</em>方法的调用顺序就是不可控的了。</li>
<li>作者举例：EOCClassB中实现了<em>load</em>方法，它导入了Foundation.h和EOCClassA.h头文件，而EOCClassA和它同属一个库，EOCClassB在其<em>load</em>方法中使用了NSLog输出NSString，也实例化了EOCClassA并进行了操作。那么NSLog和NSString的使用是没问题的，因为Foundation.h中的class肯定先于EOCClassB的<em>load</em>方法，但使用EOCClassA就有问题了，你不能保证EOCClassA的<em>load</em>是否已经在EOCClassB的<em>load</em>方法之前调用了，因为有可能EOCClassA在<em>load</em>之前是不可用的。</li>
<li><em>load</em>方法并不遵循于一般的继承规则，一个类没有实现<em>load</em>的话，是不会调用该方法的，即使它的父类实现了；<em>load</em>方法可同时存在于类和它的category中，且category的<em>load</em>会在本类的<em>load</em>之后调用。</li>
<li>所以综上，<em>load</em>方法并不适合我们自己做初始化工作，因为我们不能确保所有的类型都已经加载，所以实际上它的用途最好仅停留在测试层面，因为如果在<em>load</em>中加载过多任务，也会影响应用的加载时间，是很影响用户体验的。</li>
<li>第二个初始化方法是<em>+(void)initialize</em>方法，它也是会且只会被调用一次，它是被runtime调用的，而不能被直接调用，它与<em>load</em>有相似的地方，也有很多不同，概括有三点。</li>
<li>区别一是<em>initialize</em>是懒加载，只有一个类被第一次用到之前才会调用，因此会出现一个类的<em>initialize</em>永远没被调用过的情况，这也意味着不像<em>load</em>会出现所有的<em>load</em>方法在同一时间加载，而且会阻塞应用加载。</li>
<li>区别二是<em>initialize</em>在执行时，runtime是稳定状态，调用其他类的方法是安全的，而且runtime保证了<em>initialize</em>的线程安全，意味着只有执行<em>initialize</em>的线程可以和class和其实例交互，其他线程将会被阻塞，知道<em>initialize</em>完成。</li>
<li>区别三是<em>initialize</em>与其他消息一样，如果类的<em>initialize</em>没实现，但是父类实现了，那么父类的<em>initialize</em>会被调用。</li>
<li>作者举例父类实现了<em>initialize</em>，但是子类没有实现，但在log中会看到该方法被调用了两次，原因是使用一个类时，其父类的<em>initialize</em>会先调用，然后到子类时，由于没有实现该方法，所以继续沿响应链得知父类实现了该方法，所以又执行一次，为了避免这一问题，在<em>initialize</em>中加上<em>if(self == [EOCBaseClass class])</em>的判断就好了。</li>
<li>虽然<em>initialize</em>比<em>load</em>灵活一些了，但是作者依然不推荐在<em>initialize</em>中做很复杂的初始化工作，原因也有三。</li>
<li>原因一，一个类的<em>initialize</em>可能在任意线程，如果它发生在UI线程，而且<em>initialize</em>做了很多工作的话，可能导致主线程阻塞。预测哪个线程会先使用一个类是不可靠的，所以强制一个固定线程去触发类的<em>initialize</em>方法是不现实的。</li>
<li>原因二，你不能控制一个类什么时候<em>initialize</em>，它是确定会在一个类被第一次使用之前调用，但是假设它会在某个固定时间执行是不可靠的，runtime可能会有所更新，导致细微改变类的初始化方式，那么你对类已经初始化完毕的设想可能是错误的。</li>
<li>原因三，比较特殊，就是两个或多个类之间的初始化方法中出现了内部数据的相互调用，可能会出现，一个类需要另一个类初始化完毕，但是第二个类还依赖于第一个类的初始化完毕，造成了两个类之间的相互等待，和循环引用有一定程度的类似。</li>
<li>综上，<em>initialize</em>中并不适合做大量的工作，尤其是调用其他类或自己的方法，如果自己的方法必须依赖自己已经初始化完毕，那么也会出现上述问题，所以<em>initialize</em>的正确用法是去初始化那些，无法在编译期间赋值的全局静态变量和全局变量，比如static NSMutableArray *kSomeObjects，因为这些OC对象必须等到runtime激活后才能使用。</li>
<li>所以始终保持<em>initialize</em>和<em>load</em>方法简洁是一个好习惯，能避免大量的奇葩问题。</li>
</ol>


<!--more-->


<h2>Item52 Remember that NSTimer Retains Its Target</h2>

<p>1.NSTimer是一个常用的类，用来定时执行一些方法，或循环执行一些方法，它是需要和一个run loop关联的，你既可以在当前run loop预设置，也可以自己创建NSTimer对象自行设置。<br/>
2.NSTimer预设置的方法需要传入target和selector，timer会retain target，而会在timer失效时release它，一个timer可以通过直接调用invalidate（一般是循环的）或者启动后（一般是一次性的）就会失效。<br/>
3.因为timer会retain target，所以在循环执行时特别容易出现循环引用，如下，startPolling后，便会出现EOCClass和timer相互引用的结果，目前想解决这一问题，只能通过要求调用方自行调用stopPolling，但如果这时一个对外使用的类的话，这是不可控的；而寄希望于dealloc去解开这一循环，是不现实的，因为对于循环引用的两个对象，是不会出现一方先释放的。而且如果这一引用存在，会一直循环去执行这个任务，带来的问题不光是内存泄露。</p>

<p>```objectivec
 #import &lt;Foundation/Foundation.h>
@interface EOCClass:NSObject
&ndash;(void)startPolling;
&ndash;(void)stopPolling;
@end
@implementation EOCClass{</p>

<pre><code>NSTimer *_pollTimer;
</code></pre>

<p>}
&ndash;(id)init{</p>

<pre><code>return [super init];
</code></pre>

<p>}
&ndash;(void)dealloc{</p>

<pre><code>[_pollTimer invalidate];
</code></pre>

<p>}
&ndash;(void)stopPolling{</p>

<pre><code>[_pollTimer invalidate];
_pollTimer = nil;
</code></pre>

<p>}
&ndash;(void)startPolling{</p>

<pre><code>_pollTimer = [NSTimer scheduledTimerWithTimeInterval:5.0 target:self selector:@selector(p_doPoll) userInfo:nil repeats:YES];
</code></pre>

<p>}
&ndash;(void)p_doPoll{</p>

<pre><code>//Poll the resource
</code></pre>

<p>}
```</p>

<p>4.那么要想解决这个问题，又不依赖外部，一个方案是做一个NSTimer的block分类，如下，block被设置为userInfo参数，timer也会对它retain，block要进行一次copy，从stack移到heap上，这在Item37说过，现在的target变成了NSTimer这个类本身，因为NSTimer作为一个类对象，是一个单例，所以不用担心释放问题，虽然也存在循环引用，但是没关系。</p>

<p>```objectivec
 #import &lt;Foundation/Foundation.h>
@interface NSTimer(EOCBlockSupport)
+(NSTimer<em>)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats;
@end
@implementation NSTimer(EOCBlockSupport)
+(NSTimer</em>)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats{</p>

<pre><code>return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(eoc_blockInvoke:) userInfo:[block copy] repeats:repeats];
</code></pre>

<p>}
+(void)eoc_blockInvoke:(NSTimer*)timer{</p>

<pre><code>void(^block)()=timer.userInfo;
if(block){
    block();
} 
</code></pre>

<p>}
```</p>

<p>5.回到新方法的使用，像下面这样直接调用的话，还是会导致循环引用，因为block会retain self，而timer会在userInfo处retain block，而timer本身被self引用，所以正确的做法是做一个self的weak变量，在block中再声明一个strong的临时变量，确保block retain一个weak对象，而在block内部又不会提前释放掉，这也是解决block retain cycle的常见策略。</p>

<p>```objectivec
//wrong
&ndash;(void)startPolling{</p>

<pre><code>_polTimer = [NSTimer eoc_scheduledTimerWithTimeInterval:5.0 block:^{
    [self p_doPoll];
}
repeats:YES
];
</code></pre>

<p>}
//right
&ndash;(void)startPolling{</p>

<pre><code>__weak __typeof(self)weakSelf = self;
_polTimer = [NSTimer eoc_scheduledTimerWithTimeInterval:5.0 block:^{
    __strong __typeof(weakSelf)strongSelf = weakSelf; 
    [strongSelf p_doPoll];
}
repeats:YES
];
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记6]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/09/09/effective-objective-cdu-shu-bi-ji-6/"/>
    <updated>2015-09-09T16:29:01+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/09/09/effective-objective-cdu-shu-bi-ji-6</id>
    <content type="html"><![CDATA[<p>第六章的主要内容是Blocks和GCD，这可以说是Morden OC当中的三驾马车的其余两架，它们和ARC的出现，彻底改变了OC的开发模式。多线程是现代编程中任何语言都不可或缺的技术，在iOS中阻塞UI主线程往往是应用崩溃或用户体验差的重要原因，多线程就是解决这一问题的良方，而Blocks和GCD就是Apple给开发者带来的多线程解决方案。Blocks即OC中的闭包，它可以被当做一个对象，可以运行于其他上下文中。GCD基于dispatch queues提供了对线程的抽象，它会根据系统资源自动开辟、复用、销毁后台线程，同时GCD也对一些常见编程提供了简化方案，比如：创建单例、并发任务等等。</p>

<!--more-->


<h2>Item37 Understand Blocks</h2>

<p>1.Blocks作为了GCC的拓展，也存在于Clang的所有版本中。Blocks的runtime component在Mac OS X 10.4和iOS4被加入。由于是C级别的语言特性，所以可以被用于C,C++,OC当中。</p>

<h3>Block Basics</h3>

<p>1.Blcoks的类型写法类似函数指针，也可以直接当做函数来执行：</p>

<p>```objectivec
int(^addBlcok)(int a,int b) = ^(int a, int b){</p>

<pre><code>return a+b;
</code></pre>

<p>};
int add = addBlcok(2,5);//&lt;add=7
```</p>

<p>2.Blocks最重要的特性，它可以将它包含的所有内容进行复制，也就意味着范围内的任何变量都可以使用：</p>

<p>```objectivec
int additional = 5;
int(^addBlcok)(int a,int b) = ^(int a, int b){</p>

<pre><code>return a+b+additional;
</code></pre>

<p>};
int add = addBlcok(2,5);//&lt;add=12
```</p>

<p>3.默认Blocks是不能改变外部变量的，但是可以通过添加__blcok关键字，来声明变量可以改变。</p>

<p>```objectivec
NSArray <em>array = @[@0,@1,@2,@3,@4,@5];
__blcok NSInteger count = 0;
[array enumerateObjectsUsingBlock:^(NSNumber </em>number, NSUInteger idx, BOOL *stop){</p>

<pre><code>if([number compare:@2] == NSOrderedAscending){
    count++;
}
</code></pre>

<p>}];
//count = 2
```</p>

<p>4.上例也说明了Block作为内联参数的使用，这也是它的重要用法，取代了之前传selector name这样的方式，增加了代码可读性。<br/>
5.Block内部引用的变量会被隐性添加retain，然后在block release时再调用一次release，所以blcok可以被理解为一个一般的OC对象，它也是有retain count的。<br/>
6.那么在一个类中的实例方法中声明使用block，然后在block中使用了类的实例变量，那么其实是对self进行了一次retain，如果这时这个block被self的变量再retain一次，那么就会形成循环引用，解决方法在Item40会详细说，其实就是声明一个self的__weak替代对象就好了。</p>

<h3>The Guts of Block</h3>

<ol>
<li>Block的实质，除了包含通常的isa（block的Class为void*），flags等，block的三个主要组成为：invoke、descriptor、Captured variables。</li>
<li>invoke是一个函数指针，类型为void(<em>)(void </em>,&hellip;)，至少包含的void *其实就是block自身，因为block的Captured variables包含了所有据有变量的copy，invoke指向的就是block的实现部分，所以也证明了block实质上就是Apple对函数指针的一次高级封装，便于开发者使用。</li>
<li>descriptor指向一个结构体，包含了：size（blcok总大小），copy和dispose（都是函数指针，copy在blcok被拷贝时执行，dispose在block retain或release据有的对象时执行）。</li>
<li>Captured variables就是block据有的所有变量的copy，注意这里的copy是指针拷贝。</li>
</ol>


<h3>Global，Stack，and Heap Blocks</h3>

<p>1.Block声明的时候是存在于stack上的，类似下面的代码是不安全的，因为if/else中声明的blcok是存在于stack上的，在if/else结束时，系统可能会收回这些内存重用，而且这个问题在编译中不会报出：</p>

<p>```objectivec
void(^blcok)();
if(/<em>some condition</em>/){</p>

<pre><code>blcok = ^{
    NSLog(@"Block A");
};
</code></pre>

<p>} else {</p>

<pre><code>blcok = ^{
    NSLog(@"Block B");
};
</code></pre>

<p>}
block();
```</p>

<p>2.解决这一问题的方法，就是对声明的block进行copy，这样的话，block被copy到了heap上，这样的block和其他一般对象就一样了，也不会出现上述问题，使用ARC的话，block会在之后自动释放，而MRC将要自己去添加release方法，这也是类在为block类型的property添加属性时，一般都是copy类型的。<br/>
3.所谓的global Block就是类似于之前说的NSString和NSNumber的常量声明，如果Block内部没有任何状态变化，也不依赖于外部的状态变化，在编译期间就可以知道其所需要的空间大小，系统就会对其做优化，生成一个global block，它是被声明在global memory上，而不是stack上，而且copy对于它也是一个空操作，也不会被释放，实际就是一个单例，类似：</p>

<p>```objectivec
void(^block)() = ^{</p>

<pre><code>NSLog(@"This is a global blcok!");
</code></pre>

<p>};
```</p>

<!--more-->


<h2>Item38 Create typedefs for Common Block Types</h2>

<p>1.由于Block的类型像函数指针一样，参数多的话会很长，而且类型名又在中间，很难使用和记住，所以我们可以使用C语言的typedef来做类型定义，这么做也方便将来可能的修改：</p>

<p>```objectivec
typedef int(^EOCSomeBlock)(BOOL flag,int value);
EOCSomeBlock block = ^(BOOL flag,int value){</p>

<pre><code>//Implementation
</code></pre>

<p>};
```</p>

<p>2.对block命名时还是要遵循OC的命名习惯，使用命名空间，也不要还害怕对相同类型使用多个命名，有时候这是必须的，一是命名更加清楚，二是方便将来重构。</p>

<!--more-->


<h2>Item39 Use Handler Blocks to Reduce Code Separation</h2>

<ol>
<li>异步多线程执行任务，之前一直是采用Delegate模式，但现在我们可以通过定义block作为handler来完成同样的任务，而且代码简洁，可读性强。</li>
<li>尤其出现一个类中同时使用多个同种类型的实例，采用一套回调时，那么使用Delegate则会大大增加代码的复杂度，会在很多地方出现switch的判断，而使用block则能避免这一问题。</li>
<li>作者列举了两个例子使用这一模式的场景，都是针对网络请求回调，一是，使用两个block分别处理失败和成功，二是使用一个block，使用error来判断失败和成功（这两种写法都在作者的AFNetworking里出现过）。</li>
<li>方案一的好处是，代码清晰，使用者只需对不同情况填空即可；方案二的好处是，可以更灵活的处理这一问题，如出现一些数据异常、下载中断这些情况，业务端也可以自行按失败来进行处理。</li>
<li>在设计API时，有时会出现，需要在特定线程执行代码的需求，这时我们可以在接口中加入(NSOperationQueue*)queue这样的参数，可以是缺省的。</li>
</ol>


<!--more-->


<h2>Item40 Avoid Retain Cycles Introduced by Blocks Referencing the Object Owning Them</h2>

<ol>
<li>block出现循环引用一般是因为ClassA使用了ClassB的实例，ClassB有block的实例，而ClassA在block中使用了自己的其他实例，造成了block retain了ClassA，ClassA retain了ClassB，ClassB retain了block，这样循环引用就形成了。</li>
<li>解决方案一是在block中完成所有操作时，将ClassB的实例置为nil，这样retain环就断裂了，但这么做也有问题，如果这段block代码没有被执行，那么retain环还存在。</li>
<li>还有一种更隐蔽的情况，ClassA不在把ClassB当做实例变量，只是用做局部变量，但在block中使用了ClassB的局部变量，这样会出现，block retain了ClassB，ClassB ratain了block，所以形成了二元retain环，不过解决很简单，在ClassB中完成对block的最终调用后，将它的block实例置为nil。</li>
<li>这样也凸显了不将block作为外部property的好处（使用者只能通过初始化方法赋值），如果block直接暴露给使用者，你只能要求使用者去清除block property，但这通常是不合理的设计。</li>
</ol>


<!--more-->


<h2>Item41 Prefer Dispatch Queues to Locks for Synchronization</h2>

<p>1.OC大部分线程操作都是默认多线程的，但如果有些情况需要单线程，就需要开发者自己实现，GCD之前有两种方式。<br/>
2.一是synchronization block，它将包含的代码进行加锁操作，参数是self，这可以实现类的不同实例可以分别运行这个方法，但缺点是如果过度使用，会导致性能问题，也会出现代码被不知名的锁所阻塞的问题。</p>

<p>```objectivec
&ndash;(void)synchronizedMethod{</p>

<pre><code>@synchronized(self){
    //Safe
}
</code></pre>

<p>}
```</p>

<p>3.二是NSLock，而且也有专门为递归设计的NSRecursiveLock，但是NSLock一个最大的问题是会出现死锁问题，所以二者都不是最佳方案。</p>

<p>```objectivec
_lock = [[NSLock alloc] init];
&ndash;(void)synchronizedMethod {</p>

<pre><code>[_lock lock];
//Safe
[_lock unlock];
</code></pre>

<p>}
```</p>

<p>4.那么对比使用atomic属性的property，Item6也说过，我们手动实现时，可以利用synchronization block来实现，但是问题就是当多个property这么做时，会出现propertys之间出现阻塞，而且在多次频繁访问一个property时，其他线程可能会对其修改，会造成返回值不同。<br/>
5.替代方案就是GCD的serial synchronization queue，它可以使读写property在一个队列中执行，也就避免了上述问题，代码更加简化，而且利用了GCD底层的优化，而且你不用担心对象之间的相互阻塞。</p>

<p>```objectivec
_syncQueue = dispatch_queue_creat(&ldquo;com.EOC.syncQueue&rdquo;, NULL);
&ndash;(NSString*)someString{</p>

<pre><code>__block NSString *localSomeString;
dispatch_sync(_syncQueue,^{
    localSomeString = _someString;
});
return localSomeString;
</code></pre>

<p>}
&ndash;(void)setSomeString:(NSString*)someString{</p>

<pre><code>dispatch_sync(_syncQueue, ^{
    _someString = someString;
});
</code></pre>

<p>}
```</p>

<p>6.对于这一方案还有优化，优化一是可以将setter方法使用异步执行，因为setter方法不会有返回值，而且由于和getter还是在一个队列执行，还是能保持读取的同步，但是涉及到一个问题，异步需要将block copy到异步线程，那么如果block内容很简单，可能copy的时间和执行的时间差不多，也就达不到优化的效果，但是当block内容比较复杂时，这一手段还是有效地。</p>

<p>```objectivec
&ndash;(void)setSomeString:(NSString*)someString{</p>

<pre><code>dispatch_async(_syncQueue,^{
    _someString = someString;
});
</code></pre>

<p>}
```</p>

<p>7.第二种优化想实现，可以同时并发执行多个getter，但同步执行setter，且它们还要在同一线程，这对于synchronization block或NSLock来说，都是极难实现的，但是我们利用GCD的特性dispatch_barrier_sync()可以轻松实现，getter可以并行执行，如果出现barrier的setter，那么线程会等之前的所有getter都执行完，然后单独执行setter，执行完之后照常并行执行getter操作。</p>

<p>```objectivec
_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
&ndash;(NSString*)someString{</p>

<pre><code>__block NSString *localSomeString;
dispatch_sync(_syncQueue,^{
    localSomeString = _someString;
});
return localSomeString;
</code></pre>

<p>}
&ndash;(void)setSomeString:(NSString*)someString{</p>

<pre><code>dispatch_barrier_async(_syncQueue,^{
    _someString = someString;
});
</code></pre>

<p>}
```</p>

<!--more-->


<h2>Item42 Prefer GCD to performSelector and Friends</h2>

<ol>
<li>&ndash;(id)performSelector:(SEL)selector，曾作为延时执行方法和在特定线程执行方法这些场景中的主要手段，利用runtime，可以改变selector的名称，在运行时再决定执行那个方法，但使用这一方法是有风险的。</li>
<li>如果你使用if/else来决定赋值不同的selector，然后再执行，这样的话，ARC模式下会报内存泄露的警告，原因是编译器不知道那个方法会执行，所以也没办法确定有没有返回值，返回值是autoreleased还是caller自己释放，所以ARC会保守的添加autoreleased，如果这时返回值是caller自己释放的，那么就出现了内存泄露，这一警告MRC不会报出，但也更难发现，且静态分析器也检查不出，所以这是需要注意的一点。</li>
<li>&ndash;(id)performSelector:(SEL)selector以及它的族函数，它们的返回类型都是id类型，也就是说必须是一个指针，如果返回值是void、C结构体、或数值型，那么就有可能出问题，然后最多只能添加两个参数，而且也必须是id类型，超过两个参数或类型不对的也不能用，所以说局限性是非常大的。</li>
<li>&ndash;(id)performSelector:(SEL)selector的延时执行和在特定线程执行的族函数也是一样，缺陷很明显，只支持一个参数，所以使用者必选把所有参数打包，才能使用。</li>
<li>而结合使用Blocks和GCD，你可以实现上述所有的功能，且不会有约束，代码还简洁。</li>
</ol>


<p>```objectivec
//Using dispatch_after
dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW,(INT64_t)(5.0*NSEC_PER_SEC));
dispatch_after(time,dispatch_get_main_queue(),^(void){</p>

<pre><code>[self doSomething];
</code></pre>

<p>});
//Using dispatch_async(or if waitUntileDone is YES,then dispatch_sync)
dispatch_async(dispatch_get_main_queue(),^{</p>

<pre><code>[self doSomething];
</code></pre>

<p>});
```</p>

<!--more-->


<h2>Item43 Know When to Use GCD and When to Use Operation Queues</h2>

<ol>
<li>上面介绍了很多GCD的优点，GCD在的同步机制（Item41）和单例机制（Item45）是非常优秀的，但并不是说GCD就是所有OC线程问题的最优解，在它之前的NSOperationQueue有时更为合适。</li>
<li>GCD是C类型的Api，而operation queues则是OC对象；GCD中的任务是一个block，比较轻量，而operation queues中的任务是NSOperation的子类，比较重量；但这不意味着GCD一直是最优解，有时作为对象的优势也是非常明显的。</li>
<li>使用NSBlockOperation或NSOperationQueue的addOperationWithBlock:方法，可以使operation queues非常像GCD，下面是它的一些优势。</li>
</ol>


<h3>Cancelling operations</h3>

<ol>
<li>NSOperation很容易就可以实现cancel，执行它的cancel方法即可，但已经执行的operation就不能cancel了，但是对于GCD也一样，不能cancel一个已经在执行的block，这类机制就是“fire and forget”，但在GCD上实现cancel，需要自己去实现，而这需要很多工作。</li>
</ol>


<h3>Operation dependencies</h3>

<ol>
<li>operation可以实现依赖，这样开发者可以自己组织执行的优先顺序，例如下载一些文件之前需要先下载验证文件，下验证文件的operation就是其他下载operation的依赖，如果其他下载是并发的，那么它们会等下载完验证文件后再并发执行。</li>
</ol>


<h3>Key-Value Observing of operation properties</h3>

<ol>
<li>Operation的很多property是很适合KVO的，比如：<em>isCancelled，isFinished</em>去监测operation是否取消或完成，如果你的代码需要对operation做到如此细粒度的控制的话，那么更应该使用operation。</li>
</ol>


<h3>Operation priorities</h3>

<ol>
<li>operation可以设置优先级（即queuePriority，从verylow到veryhigh五个枚举值），高优先级的operation会先执行，GCD无法设置每个block的执行优先级，而只能设置整个queue的优先级，所以这也是operation的一大特性。另外，operation还有一个相关的线程优先级（即threadPriority，从0.0到1.0），可以指定operation执行时线程分配的优先级，我理解它和前者一个是时间上的优先级，一个是空间上的优先级，这两者均可通过operation的property直接设置。</li>
</ol>


<h3>Reuse of operation</h3>

<ol>
<li>除非你使用内建的NSOperation的子类，比如NSBlockOperation，你一般都需要自己继承NSOperation，所以这就意味着你可以添加实例和方法，和进行复用。</li>
<li>综上operation有这很多的优点，主要集中于你可以对单个operation进行更加细粒度的操作，而不用自己去组织相关代码，这是对比GCD的block的优势之处。</li>
<li>Apple的NSNotificationCenter有一个方法，如下，其中的NSOperationQueue可以换成dispatch queue的，但是开发者不想对GCD产生无谓的依赖，在这个实例中，两者是没什么区别的。总之，GCD和Operation queue都是视情况使用，而不是一味遵从使用高级接口或底层接口，各有好处。</li>
</ol>


<p><code>objectivec
-(id)addObserverForName:(NSString*)name object:(id)object queue:(NSOperationQueue*)queue usingBlock:(void(^)(NSNotification*))block;
</code></p>

<!--more-->


<h2>Item44 Use Dispatch Groups to Take Advantage of Platform Scaling</h2>

<p>1.Dispatch Groups是GCD的一个特性，为了方便开发者对任务进行分组，你可以等待一组任务完成或者通过回调来被通知一组任务完成了。当你想让一组方法并行执行，但同时希望在它们完成时得到通知，那么你该使用这一特性。例如批量压缩文件。<br/>
2.一个group是一个简单的结构体，也没有标识，下面是group的类型和将task和group关联的方法，其实只是在正常的dipatch执行方法上关联了group而已：</p>

<p><code>objectivec
dispatch_group_t dispatch_group_creat();
void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);
</code></p>

<p>3.另一个方法是使用下面这对方法，enter和leave要配合使用，类似retain和release，必须保持平衡，如果缺少一个leave，那么这个group就永远不会结束了。</p>

<p>```objectivec
void dispatch_group_enter(dispatch_group_t group);
void dispatch_group_leave(dispatch_group_t group);
//Example
dispatch_group_t group = dispatch_group_create();
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
//A
dispatch_group_async(group,queue,^{</p>

<pre><code>//...
</code></pre>

<p>});
//B
dispatch_group_enter(group);
dispatch_async(queue,^{</p>

<pre><code>//...
dispatch_group_leave(group);
</code></pre>

<p>});
```</p>

<p>4.下面的方法可以阻塞目前线程，等待group中的task全部完成，timeout可以设置为一个固定值，也可以设置为DISPATCH_TIME_FOREVER，如果group在timeout内完成，返回值为0，反之则会返回非0值。</p>

<p><code>objectivec
long dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);
</code></p>

<p>5.这个方法则是wait方法的替代，该方法不会阻塞当前线程，而是允许你为group完成添加一个通知回调block，而且可以指定线程，一般在主线程中，肯定是不希望阻塞的。</p>

<p><code>objectivec
void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);
</code></p>

<p>6.下面是一个对一个数组中的对象并发执行相同操作，并在全部完成后进行后续操作的实例，如果不希望阻塞主线程，那么要把wait换为notify，<a href="http://stackoverflow.com/questions/10643797/wait-until-multiple-networking-requests-have-all-executed-including-their-comp/10644282#comment13830651_10644282">StackOverflow另一实例</a>。</p>

<p>```objectivec
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
dispatch_group_t group = dispatch_group_create();
//Plan A, block main queue
for(id object in collection){</p>

<pre><code>dispatch_group_async(group,queue,^{
    [object performTask];
});
</code></pre>

<p>}
dispatch_group_wait(group,DISPATCH_TIME_FOREVER);
//Continue processing after copleting tasks
dispatch_release(group);
//Plan B, not block main queue
for(id object in collection){</p>

<pre><code>dispatch_group_enter(group);
dispatch_async(queue,^{
    [object performTask];
    dispatch_group_leave(group);
});
</code></pre>

<p>}
dispatch_queue_t notifyQueue = dispatch_get_main_queue();
dispatch_group_notify(group,notifyQueue,^{</p>

<pre><code>//Continue processing after completing tasks
</code></pre>

<p>});
```</p>

<p>7.可以通过创建不同优先级的dispatch_queue，来实现task进行优先级分类，但是依然并发执行，并在全部完成后统一处理。<br/>
8.如果你在一个串行的queue中加入多个任务，那么group其实是不起作用的，因为本来这些任务就会串行执行，你只需要继续添加一个block，就可以实现所有任务完成后统一处理。</p>

<p>```objectivec
dispatch_queue_t queue = dispatch_queue_create(&ldquo;com.EOC.queue&rdquo;,NULL);
for(id object in collection){</p>

<pre><code>dispatch_async(queue,^{
    [object performTask];
});
</code></pre>

<p>}
dispatch_async(queue,^{</p>

<pre><code>//Continue processing after completing tasks
</code></pre>

<p>});
```</p>

<p>9.如果你不是自己创建queue，而是使用系统方法返回的queue，那么加入的task，系统会根据系统资源开辟一定数量的线程，来执行这些task，再配合group特性，你只需要关注你的业务逻辑即可，而不用去在如何安排和控制它们的线程开辟和同步上面花费精力。<br/>
10.类似上面多次执行相同的任务，还有一个专门的方法来实现它，如下，传入的iterations类似for循环的最大值，i会从0循环到最大值减一。但dispatch_apply的缺点是会阻塞当前线程，如果你希望在后台线程运行，那么还要使用group的notify方法。</p>

<p>```objectivec
void dispatch_apply(size_t iterations, dispatch_queue_t queue,void(^block)(size_t));
//A serial
dispatch_queue_t queue = dispatch_queue_create(&ldquo;com.EOC.queue&rdquo;);
dispatch_apple(10,queue,^{</p>

<pre><code>//perform task
</code></pre>

<p>});
//B concurrent
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
dispatch_apply(array.count,queue,^(size_t i){</p>

<pre><code>id object = array[i];
[object peformTask];
</code></pre>

<p>});
```</p>

<!--more-->


<h2>Item45 Use dispatch_once for Thread-Safe Single-Time Code Execution</h2>

<p>1.GCD之前的单例模式实现，使用了synchronization block是为了线程安全：</p>

<p>```objectivec
+(id)sharedInstance{</p>

<pre><code>static EOCClass *sharedInstance = nil;
@synchronized(self){
    if(!sharedInstance){
        sharedInstance = [[self alloc] init];
    }
}
return sharedInstance;
</code></pre>

<p>}
```</p>

<p>2.这是GCD之后的版本，使用了dispatch_once，新类型dispatch_once_t保证了，对于每一个该类型的token，dispatch_once只会执行它对应的block一次，而且是线程安全的，为了保证token的唯一性，token也必须声明为static或global类型。</p>

<p>```objectivec
void dispatch_once(dispatch_once_t *token,dispatch_block_t block);
//singleton
+(id)sharedInstance{</p>

<pre><code>static EOCClass *sharedInstance = nil;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken,^{
    sharedInstance = [[self alloc] init];
});
return sharedInstance;
</code></pre>

<p>}
```</p>

<p>3.相比较synchronization block的版本，dispatch_once版本效率更高，因为前者在每次运行这段代码时都会进行加锁操作，它对dispatch token进行了原子型的访问来确定代码是否执行过，作者测试使用dispatch_once较synchronization block快将近两倍。</p>

<!--more-->


<h2>Item46 Avoid dispatch_get_current_queue</h2>

<ol>
<li>使用GCD时，获得当前运行的queue是一个常见的需求，而Apple也提供了一个方法：<em>dispatch_queue_t dispatch_get_current_queue()</em>，但是作者告诉我们，这个方法像retainCount一样，并不可靠，iOS6已经将其弃用，目前只可以在debug模式下使用。</li>
<li>回想Item41的getter/setter最终方案，可能会出现这样的场景，就是调用getter的queue和getter中的synchronization queue是同一队列，这样就会产生死锁，dispatch_sync会一直等待queue可用，而这个queue实际上就是当前的queue，所以block永远不会执行。所以就会想到用dispatch_get_current_queue()来判断当前的queue是否是synchronization queue，如果是就直接执行block，不是的话用dispatch_sync()。</li>
<li>如果在简单场景下应该是没问题，如果考虑到一些特殊情况，比如queueA->queueB->queueA嵌套执行，且所有的操作都是同步操作，那么内部的queueA关联的block还是会出现死锁，因为外层的queueA block还未执行完。</li>
<li>所以这个例子中，使用dispatch_get_current_queue()并不是一个可靠地解决方法，而还是应该单独建立一个queue专门供synchronization使用，并确保该queue中会调用getter方法。</li>
<li>从更为普遍的角度讲，因为dispatch queues是存在等级划分的，也就是说在当前queueA中的block加入了在queueB中执行的block，那么queueB上执行的block同样执行与queueA上，而顶层的queue则是global concurrent queues的其中一个。</li>
<li>只有两个queue不存在这种包含关系，才可以并行执行，反之，如果两个queue存在包含的关系，那么在他们中执行同步操作，怎要特别关注死锁问题。这也就是dispatch_get_current_queue()这个方法意义不大的根本原因，因为它只能返回当前的queue，而无法得知整个queue的包含链。</li>
<li>最容易产生这个问题的场景是Api需要你传入想运行的queue，而Api内部在另一个queue上使用了串行同步操作，然后将它的结果在传入的queue中返回，使用者一般会假设dispatch_get_current_queue()会返回自己传入的queue，但结果会返回内部的同步queue。</li>
<li>Queue-specific data是解决上述问题的一个方案，它可以将任意数据和queue绑定，最重要的是，如果没发现与对应key绑定的值，系统会一直沿包含链向上，知道找到对应的queue被找到，或者到root queue。</li>
<li><em>dispatch_queue_set_specific()</em>方法是这一技术的核心，给queue关联的是一个类似键值对的结构，键值均为空指针类型，对于key来说，需要注意的是，作为key的是指针的值而不是指向内容的值，所以其实更像Item10中介绍的associated references。value也是空指针类型，所以理论上你可以将任何值作为value，但是你希望自己管理它的内存，如果在ARC下，使用OC对象就很难做到这一点，所以作者推荐使用了CFString，因为ARC不会管理CoreFoundation的对象，而且也可以很方便转化为OC对象，所以很合适。最后的参数希望传入一个函数指针，它将用作析构函数，将在value从key移除时调用，这可能是queue被释放或者value被赋新值时。dispatch_function_t的类型是只有一个指针且返回空值，示例中CFRelease作为了参数，对应传入的CFString，如果传入的是自己定义的对象，开发者也可以自己重写CFRelease函数，做一些清除工作。</li>
</ol>


<p>```objectivec
void dispatch_queue_set_specific(dispatch_queue_t queue,const void <em>key,void </em>context,dispatch_function_t destructor);
typedef void(<em>dispatch_function_t)(void</em>)
//Example
dispatch_queue_t queueA = dispatch_queue_create(&ldquo;com.EOC.queueA&rdquo;,NULL);
dispatch_queue_t queueB = dispatch_queue_create(&ldquo;com.EOC.queueB&rdquo;,NULL);
dispatch_set_target_queue(queueB,queueA);
static int kQueueSpecific;
CFStringRef queueSpecificValue = CFSTR(&ldquo;queueA&rdquo;);
dispatch_queue_set_specific(queueA,&amp;kQueueSpecific,(void*)queueSpecificValue,(dispatch_function_t)CFRelease);
dispatch_sync(queueB,^{</p>

<pre><code>dispatch_block_t block = ^{NSLog(@"No deadlock!");};
CFStringRef retrievedValue = dispatch_get_specific(&amp;kQueueSpecific);
if(retrievedValue){
    block();
} else {
    dispatch_sync(queueA,block);
}
</code></pre>

<p>});
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记5]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/08/28/effective-objective-cdu-shu-bi-ji-5/"/>
    <updated>2015-08-28T11:45:07+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/08/28/effective-objective-cdu-shu-bi-ji-5</id>
    <content type="html"><![CDATA[<p>第五部分开始将讨论OC的核心技术，Reference Counting，也就是使用引用计数来进行内存管理，这一部分涉及到底层内存管理机制，ARC相关技术细节和在开发中涉及到内存管理需要注意的常见问题。</p>

<!--more-->


<h2>Item29 Understand Reference Counting</h2>

<ol>
<li>Reference Counting是OC管理内存的方式，当一个对象的RC为0时，将被释放，iOS没有垃圾回收机制。</li>
</ol>


<h3>How Reference Counting Works</h3>

<ol>
<li>在NSObject Protocol中有三个方法可以改变RC，<em>retain,release,autorelease</em>。</li>
<li>retainCount这个方法可以查看对象当前的RC值，但是并不推荐使用，Item36会讨论。</li>
<li>对象之间往往是互相持有的，当该持有关系是<em>strong</em>时，被持有对象的RC加1，而持有链的最顶端是根对象，Mac OSX是NSApplication，iOS是UIApplication，都是应用创建的单例。</li>
<li>举例一个NSMutableArray添加一个NSNumber，虽然在array添加number后，释放number，number的RC还是1，调用number理论上是可以的，但是并不推荐这么做，因为如果任何其他原因使number的RC为0，这一做法会导致崩溃。</li>
<li>对象被释放后，它的内存将进入可用内存池，如果调用发生在内存被复写之前，不会发生错误，所以之类bug有时会很难复现，所以在MRC中往往在调用release后会赋值nil。</li>
</ol>


<h3>Memory Management in Property Accessors</h3>

<ol>
<li>strong命名的property的setter方法，是新值retain，然后旧值release，然后赋值，这一顺序不能错，因为如果先release再retain，且正好两个对象是同一个，可能会导致对象提前释放，RC为0，成为野指针，再调用retain则会出错。想按照这个顺序来，必须判断新旧两值是否是同一对象。</li>
</ol>


<h3>Autorelease Pools</h3>

<ol>
<li>借助autorelease pool替代release操作的autorelease，常用于需要返回新建对象的方法，具体释放时间在下一次事件循环（Item34将讨论）。</li>
<li>在直接调用该方法时不用额外的内存空间，直接调用即可。</li>
<li>但是如果返回对象需要持有时，比如赋值给一个实例变量，它需要retain一次，然后使用完后手动release，所以可以将autorelease理解为延长对象的生命周期，可以至少保证到方法调用的边界。</li>
</ol>


<h3>Retain Cycles</h3>

<ol>
<li>循环引用一般是指两个或多个对象直接互相存在强引用，而导致RC都不能为0，所有对象都不能释放。</li>
<li>在垃圾回收机制下，retain cycle会被定义为孤岛，而直接被全部释放，而在RC机制下，只能通过定义weak引用或者依靠外部帮助来使其中某个对象交出对其他对象的引用。</li>
</ol>


<!--more-->


<h2>Item30 Use ARC to Make Reference Counting Easier</h2>

<ol>
<li>Clang编译器带来了一个静态分析器，可以定位出现RC问题的位置，例如没有添加release，除此之外，该分析器可以为你自动添加retain，release这些操作，这也就是ARC技术的基础。</li>
<li>在ARC机制下，retain、release、autorelease、dealloc这些操作都是不允许的，因为这回影响编译器判断添加语句的位置。</li>
<li>事实上，ARC并没有直接调用上述这些方法，而是调用了他们的C的替代方法，例如objc_retain，这么做的好处是，因为这些操作会频繁调用，使用C方法可以提高效率。这也是为什么不允许直接重写retain，release这些方法，因为这方法并不是直接调用的。</li>
</ol>


<h3>Method-Naming Rules Applied by ARC</h3>

<ol>
<li>内存管理指定方法名在OC里一直是惯例，而ARC将其加强了，含有以下名称的方法：<em>alloc、new、copy、mutableCopy</em>，所返回的对象的所有者为方法的调用者，而其他方法返回的对象为autorelease，会保持到方法调用边界。</li>
<li>而ARC会依据方法名的开头添加响应的语句，例如上述四个关键字开头的，会直接返回，而一般方法，ARC会在返回对象前加上autorelease。</li>
<li>而在调用这些方法时，第一类方法返回的对象，ARC会在方法结束前添加release方法，而第二类方法因为有autorelease，所以不会添加操作。</li>
<li>ARC通过命名规范来规范内存管理，再加上之前的命名空间，OC是少有的如此强调命名的语言之一。</li>
<li>ARC可以做一些无法手动完成的优化，比如，它将在编译期间取消多余的retain和release操作。</li>
<li>ARC在runtime也有进行优化，举例：EOCPerson的一般初始化方法返回的值（添加了autorelease），被赋值给一个对象的strong属性实例，按照之前的原则，需要在返回的对象加retain，这里的autorelease和retain看起来是多余的，ARC确实可以为了性能，直接去掉autorelease这个方法，所有返回的对象都为RC+1，但为了兼容MRC，ARC还是需要特殊处理。</li>
<li>ARC确实对这种现象做了处理，在返回对象之前它调用了<em>objc_autoreleaseReturnValue</em>，如果被发现该对象是需要retain的，则会添加一个flag，而不是调用autorelease。同样的，调用者也会调用<em>objc_retainAutoreleasedReturnValue</em>，而不是retain，该方法也会先检测flag，如果存在，则不会retain，这样提高了效率：</li>
</ol>


<p>```objectivec
//Within EOCPerson class
+(EOCPerson<em>)personWithName:(NSString</em>)name {</p>

<pre><code>EOCPerson *person = [[EOCPerson alloc] init];
person.name = name;
objc_autoreleaseReturnValue(person);
</code></pre>

<p>}
//Code using EOCPerson class
EOCPerson *tmp = [EOCPerson personWithName:@&ldquo;Matt&rdquo;];
_myPerson = objc_retainAutoreleasedReturnValue(tmp);</p>

<p>//objc_autoreleaseReturnValue
id objc_autoreleaseReturnValue(id object) {</p>

<pre><code>if(/*caller will retain object*/){
    set_flag(object);
    return object;//no autorelease
} else {
    return [object autorelease];
}
</code></pre>

<p>}</p>

<p>//objc_retainAutoreleasedReturnValue
id objc_retainAutoreleasedReturnValue(id object) {</p>

<pre><code>if(get_flag(object)){
    clear_flag(object);
    return object;//no retain
} else {
    return [object retain];
}
</code></pre>

<p>}
```</p>

<h3>Memory-Management Semantics of Variables</h3>

<ol>
<li>ARC也同时管理着本地变量和实例变量的内存，默认每个变量对于对象是strong引用。</li>
<li>在setter方法中，ARC中直接对旧值赋值即可，ARC会自动添加正确的代码。</li>
<li>声明实例变量时，也可以改变内存管理方式，<strong>strong（默认，赋值将被retain）、</strong>unsafe_retained（赋值同assign，但指针不会自动置空，可能出现野指针）、<strong>weak（赋值同assign，对象被释放时，指针会自动置为nil，所以是安全的，iOS5后可用）、</strong>autoreleasing（多用与方法的返回值）。</li>
<li>__weak用于本地变量时，常用于避免循环引用，比如在block中：</li>
</ol>


<p>```objectivec
NSURL <em>url = [NSURL URLWithString:@&ldquo;<a href="http://www.example.com/">http://www.example.com/</a>&rdquo;];
EOCNetworkRetcher </em>fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];
EOCNetworkFetcher * __weak weakFetcher = fetcher;
[fetcher startWithCompletion:^(BOOL success){</p>

<pre><code>NSLog(@"Finished fetching from %@", weakFetcher.url);
</code></pre>

<p>}];
```</p>

<h3>ARC Handling of Instance Variables</h3>

<ol>
<li>在ARC中，你一般不需要再重写dealloc方法，ARC借用Objective-C++的特性，Objective-C++对象在释放时会调用所有持有对象的析构方法，当编译器发现对象包含C++对象时，会生成<em>.cxx_destruct</em>方法，ARC借助这个方法，在其中执行清除内存的代码。</li>
<li>但有时你仍需要重写dealloc方法，像CoreFoundation对象和堆上开辟的内存（如malloc），以及KVO、的解除，都需要手动释放，但注意<em>在ARC中，不需要在dealloc中写[super dealloc]</em>，因为ARC在<em>.cxx_destruct</em>中已经调用了这一方法。</li>
</ol>


<h3>Overriding the Memory-Management Methods</h3>

<ol>
<li>在MRC中，重写内存相关方法是允许的，比如单例常常重写release方法为一个空操作，这样单例就不会被释放。</li>
<li>但在ARC中是不允许的，一是会导致ARC对对象周期的误判，二是ARC对内存管理做了深度的优化，当需要执行retain、release、autorelease时，ARC在OC的message dispatch做了优化处理，不能重写或调用这些方法则是该优化的前提。</li>
</ol>


<!--more-->


<h2>Item31 Release References and Clean Up Observation State Only in dealloc</h2>

<p>1.dealloc方法会在对象的引用计数为0时自动调用，但什么时候调用并不能保证，即使是在MRC中，手动控制release也一样，因为很多库会在你不知道的情况下修改对象，这会导致调用dealloc的时间发生变化。所以你千万不要手动去调用dealloc，runtime会在合适的时间调用。<br/>
2.那么在ARC下，重写dealloc的话，一是用于释放CoreFoundation的对象，二是取消NSNotificationCenter中注册该对象的监听或KVO。<br/>
3.如果你的类中使用到了文件描述集，sockets、或者开辟了大块儿内存，由于dealloc的调用时间不明，你可能在你不需要使用的时候即可释放这些内存，而不用等到dealloc触发，这样需要自定义一个清除方法，该方法必须在dealloc之前调用，不然就算异常了。<br/>
4.清除资源需要另一个方法的原因是创建的对象并不是都会被调用dealloc，因为一部分对象在应用退出后台时并不会释放，它们只有在应用彻底被系统回收后才会释放，这是一种优化措施，但也会导致大量的资源被无故占用，所以在-(void)applicationWillTerminate:(UIApplication*)application中调用一些对象的clean方法是必要的。<br/>
5.有时可以在dealloc中也可以去调用clean方法，这可以避免忘记调用clean，但最好还是手动去先执行clean，所以还是要提示下或者严重的话直接直接抛出异常：</p>

<p>```objectivec
&ndash;(void)close {</p>

<pre><code>/*clean up resources*/
_close = YES;
</code></pre>

<p>}</p>

<p>&ndash;(void)dealloc {</p>

<pre><code>if(!_closed) {
    NSLog(@"ERROR:close was not called before dealloc!");
    [self close];
}
</code></pre>

<p>}
```</p>

<p>6.除了上述特例，一般是不允许在dealloc中调用类的其他实例方法，因为有可能导致方法执行前，该对象可能已经释放了。而且，dealloc方法是在导致对象最终释放的线程上执行的，所以需要在特定线程执行的方法在此调用，不能保证线程正确，即使是通过代码强制在某线程执行，也是不安全的，因为对象处于释放状态。
7.另外dealloc中也不可调用property的setter、getter方法，尤其是被重写的accessor，也有可能触发KVO的回调，导致未知的错误。</p>

<!--more-->


<h2>Item32 Beware of Memory Management with Exception-Safe Code</h2>

<ol>
<li>Exception是OC和C++中用于处理严重异常的对象，但有时你也需要通过代码处理这些异常，例如去注销一个KVO，但之前并没有注册过的情况。</li>
<li>在try/catch中创建对象，并需要自己释放时，需要将释放代码写到finally中，这样才能保证无论是否异常都能保证对象释放。</li>
<li>但在ARC中可以自动添加额外的处理代码，使用<em>-fobjc-arc-exceptions</em>这个flag来控制，但默认是关闭的，因为exception出现时application直接crash，资源也会回收，所以没必要再做处理，而且会带来性能问题，只有编译器处于Objective-C++时才会开启，因为OC++添加代码带来性能损耗没有ARC添加时那么大，另外OC++中Exception是被大量使用的。</li>
<li>如果在ARC下需要单独处理exception，那么可以开启flag，但如果你有很多exception处理，那么你该考虑NSError了，如Item21所讲。</li>
</ol>


<!--more-->


<h2>Item33 Use Weak References to Avoid Retain Cycles</h2>

<ol>
<li>循环引用带来的问题主要是，引用环中的对象将不能再被调用，但也不能释放，从而导致内存泄露。</li>
<li>Java会有垃圾回收来解决这类问题，但iOS和Mac OS X 10.8之后是没有垃圾回收的，所以只能开发者自己去避免。</li>
<li>使用unsafe_unretained可以避免这一问题，它类似assign，但assign一般用于数值型，而unsafe_unretained用于对象，但如字面意思一样，它不会因为所指向的对象被释放而置为空值，所以调用unsafe_unretained的对象，可能会因为所指对象不存在而崩溃，所以是不安全的。</li>
<li>在ARC中我们常用的是weak字段，该字段与unsafe_unretained功能一致，但是它会在所指对象释放后自动指向nil，所以是安全的。</li>
<li>关于循环引用，总的原则就是，如果你不持有一个对象，那么你就不该retain它（数组，集合不直接持有包含的对象，但是会retain它们，是个例外）。一般场景有，controller的UI控件（一般weak属性），一个对象的delegate属性（一般为weak属性）。</li>
</ol>


<!--more-->


<h2>Item34 Use Autorelease Pool Blocks to Reduce High-Memory Waterline</h2>

<p>1.<em>@autoreleasepool{}</em>这是OC中建立autorelease pool的方法，但我们一般不必去手动创建。<br/>
2.main函数中的autorelease pool并不是必须的，只是UIApplicationMain()函数中需要autorelease的对象没有对应的pool，但它们在程序终止时时肯定会被释放的。<br/>
3.autorelease pool可以嵌套，autorelease的对象总是被添加最里面的pool中。<br/>
4.利用上述特性，我们可以对一些大量循环执行一个可能产生很多autorelease对象的方法做优化，如下EOCPerson的创建可能产生大量autorelease对象，这样产生的autorelease对象会在自己建的autorelease pool结束时释放，而不是长期存在于线程自己的autorelease pool，避免了出现应用内存陡升陡降这种“瀑布现象”：</p>

<p>```objectivec
NSArray <em>databaseRecords = /</em>&hellip;<em>/;
NSMutableArray </em>people = [NSMutableArray new];
for(NSDictionary *record in databaseRecords){</p>

<pre><code>@autoreleasepool{
    EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];
    [people addObject:person];
}
</code></pre>

<p>}
```</p>

<p>5.autorelease pool可以被理解为放入了一个栈中，新建的pool会在最顶端，当它释放后会被移出栈，当一个对象调用了autorelease，它将被添加到最顶端的autorelease pool。<br/>
6.使用autorelease pool来优化瀑布现象并不是必要的，这取决你的应用，如果确实导致了问题，那么去使用它，如果不必要使用，那么就不要添加多于的autorelease pool。<br/>
7.ARC之前使用autorelease pool是使用NSAutoreleasePool，因为它属于重量级对象，所以一般是隔段时间进行释放：</p>

<p>```objectivec
NSArray <em>databaseRecords = /</em>&hellip;<em>/;
NSMutableArray </em>people = [NSMutableArray new];
int i=0;
NSAutoreleasePool <em>pool = [[NSAutoreleasePool alloc] init];
for(NSDictionary </em>record in databaseRecords){</p>

<pre><code>EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];
[people addObject:person];
//Drain the pool only every 10 cycles
if(++i == 10){
    [pool drain];
}
</code></pre>

<p>}
//Also drain at the end in case the loop is not multiple of 10
[pool drain];
```</p>

<p>8.推荐使用新语法@autoreleasepool，更加轻量，而且一个重要特性，NSAutoreleasePool中创建的autoreleased对象在执行drain之后还能使用，这可能造成崩溃，且很多时候难以发现，而使用@autoreleasepool，这类代码不会被编过，也就及早避免了这一问题。</p>

<!--more-->


<h2>Item35 Use Zombies to Help Debug Memory-Management Problems</h2>

<p>1.内存问题一般很难处理，原因是被释放的那块内存不一定就很快被重写，或者正好被一个同类的对象重写，这样有时不会导致崩溃，有时却会，所以开发者有时会无从下手。<br/>
2.Cocoa的Zombies特性会帮助我们解决这一问题，当该模式启用，所有被释放的对象会转化为NSZombie对象，其占用过的内存也不会被重用，当该对象收到消息时，会抛出异常，告知开发者所收到的消息，原来的对象类型这些信息。</p>

<p>```objectivec
void PrintClassInfo(id obj){</p>

<pre><code>Class cls = object_getClass(obj);
Class superCls = class_getSuperclass(cls);
NSLog(@"===%s:%s===",class_getName(cls),class_getName(superCls));
</code></pre>

<p>}
int main(int argc, char *argv[]){</p>

<pre><code>EOCClass *obj = [[EOCClass alloc] init];
NSLog(@"Before release:");
printClassInfo(obj);
[obj release];
NSLog(@"After release");
PrintClassInfo(obj);
</code></pre>

<p>}
//result
//Before release:
//===EOCClass:NSObject===
//After release:
//===_NSZombie_EOCClass:nil===
```</p>

<p>3.通过上述手段我们得知obj在dealloc后变为了<em>NSZombie_EOCClass，但并没有它的父类，实际上，它是通过对原类型的类名修改，然后对</em>NSZombie<em>类型执行objc_duplicateClass()，完全拷贝zombie类并使用新类名（也可使用继承，但不如copy效率），制造出obj对应的zombie类，然后用objc_setClass()修改obj的isa指针，改变其类型，这一切都是利用runtime完成的（通过method swizzles对dealloc方法替换）。<br/>
4.由于</em>NSZombie<em>没有实现任何方法，所以向它或者它的copy类型发送任何消息，会直接进入forwarding mechanism，在寻求转发时如果发现类型名以</em>NSZombie_开头，那么直接抛出异常，并打印出message、原类型这些信息。</p>

<!--more-->


<h2>Item36 Avoid Using retainCount</h2>

<ol>
<li><em>retainCount</em>是NSObject Protocol的一个方法，用于返回对象目前的引用计数值，在ARC中已经弃用，但即使在MRC中，任然应该避免使用它。</li>
<li>原因一是<em>retainCount</em>返回的是实时的count值，也就是说像autorelease这样将要发生的count减少的情况，不会在该方法反映出来，所以依据该值去执行一些改变count的方法，往往会出问题。</li>
<li>有时retainCount会返回一个极大的值，这是NSString或NSNumber直接设置常量时，系统会将其作为一个单例的常量，而不是去创建一个对应的对象，这些对象的ratainCount是不会改变的，但只是对一些特例的优化。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记4]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/08/24/effective-objective-cdu-shu-bi-ji-4/"/>
    <updated>2015-08-24T11:35:10+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/08/24/effective-objective-cdu-shu-bi-ji-4</id>
    <content type="html"><![CDATA[<p>第四部分开始讨论OC的两大重要特性，Protocols和Categories。Protocols类似Java中的interfaces，弥补了OC没有多继承的缺点，常被用于实现OC委托模式，但还有很多其他方面的用途。Categories则是提供了不继承而向类添加拓展的方法，这要归功于OC动态语言特性，但同时了解它使用时的常见问题也非常重要。</p>

<!--more-->


<h2>Item23 Use Delegate and Data Source Protocols for Interobject Communication</h2>

<ol>
<li>Delegate是用于对象之间进行数据交互的设计模式，使用它的好处是可以让不同的业务逻辑解耦，实现代码模块化。而在OC中实现这一模式，主要依靠Protocols。</li>
<li>怎么使用Delegate不介绍了，注意点是：1）命名最好和你需要委托的类相关，例如UITableView,UITableViewDelegate；2）类的delegate property是weak属性，原因是接受委托的对象一般会持有需要委托的对象，如果delegate设置为strong，需要委托的对象也会持有接受委托的对象，这样就会出现retain cycle。</li>
<li>Delegate一般都定义为option，除非一些方法是一定要被委托者实现的，同时对于option的方法，委托者需要在调用之前使用<em>respondsToSelector:</em>来内省，确保被委托者实现了该方法。</li>
<li>Delegate中定义的方法一定要清楚，而且一定要包括被委托者自身作为其中一个参数，这样如果存在同类型多个实例对象时，委托者可以在同一个方法中区分这些实例变量。</li>
<li>Protocols还可以用于DataSource模式，与Delegate模式区别是，对于一个Class来说，Delegate的信息是流出Class的，而DataSource的信息是流入Class的，设计Protocols也可以参照这一原则。</li>
<li>对于option的方法要进行<em>respondsToSelector:</em>来检测，但是对于一些需要频繁调用的方法，采用这一方式非常影响性能，作者利用了C中的由多个1bit字段组成的结构体来标识被委托对象是否响应所有方法，这基于被委托对象一般不会动态改变对方法的响应：</li>
</ol>


<p>```objectivec
@interface EOCNetworkFetcher(){</p>

<pre><code>struc {
    unsigned int didReceiveData:1;
    unsigned int didFailWithError:1;
    unsigned int didUpdateProgressTo:1;
} _delegateFlags;
</code></pre>

<p>}
@end</p>

<p>@implementation EOCNetworkFetcher</p>

<p>&ndash;(void)setDelegate:(id<EOCNetworkFetcherDelegate>delegate) {</p>

<pre><code>_delegate = delegate;
_delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher: didReceiveData:)];
_delegateFlags.didFailWithError = [delegate respondsToSelector:@selector(networkFetcher: didFailWithError:)];
_delegateFlags.didUpdateProgressTo = [delegate respondsToSelector:@selector(networkFetcher: didUpdateProgressTo:)];
</code></pre>

<p>}</p>

<p>//调用委托时
/*
if(_delegateFlags.didUpdateProgressTo) {</p>

<pre><code>[_delegate networkFetcher:self didUpdateProgressTo:currentProgress];
</code></pre>

<p>}
*/</p>

<p>@end
```</p>

<!--more-->


<h2>Item24 Use Categories to Break Class Implementations into Manageable Segments</h2>

<ol>
<li>分类这一特性主要为了解决一个类在开发中无限膨胀的问题，将一个类的方法按照功能进行分类处理是常规做法。</li>
<li>第二种用途是为了对代码进行分割增加可读性，例如NSURLRequest想增加专门的HTTP请求，单纯继承不是一个很好的选择，原因是NSURLRequest封装了一组针对CFURLRequest的C方法，无法通过继承获得，而直接添加这些HTTP的方法则会导致一些代码理解错误，例如开发者使用FTP协议，去发现可以调用关于HTTP的方法，所以将HTTP部分的方法做成NSHTTPURLRequest的分类是最好的选择。</li>
<li>第三个用途是方便调试，原因是分类中的方法在日志里会显示为类似：<em>&ndash;[EOCPerson(Friendship) addFriend:]</em>，可以方便定位该方法。</li>
<li>另外，在做一个库时，把一些私有方法用名为Private的分类封装，这样这些方法不用暴露在外，而内部又可以随意调用，而且外部万一用到了，也可以在日志中看到private的标志，起到了文档的作用。</li>
</ol>


<!--more-->


<h2>Item25 Always Prefix Category Names on Third-Party Classes</h2>

<ol>
<li>为一个类添加分类后，运行时runtime会遍历category每个方法，顺便加入类的方法列表，如果这时category重写了类的某个方法，这将覆盖原有的方法，如果多个category都出现这个情况，那么最后被载入的那个分类的方法会被采用，这两种情况都将导致Bug，且难以定位。</li>
<li>解决这一问题的方法只能是添加namespace，规则参考Item15，最好就是公司+项目这样的方式，而且最好将分类的名字也加namespace，这样可以避免warning。</li>
<li>要记住添加到一个类的category中的方法，只要被添加，在所有类的示例都可以调用（这里还是需要导入这个category才可以），尤其在为Cocoa中的类添加分类时时刻注意添加命名空间，去刻意重写类中的方法是一个非常坏的习惯，它带来的问题可能比好处大得多。</li>
</ol>


<!--more-->


<h2>Item26 Avoid Properties in Categories</h2>

<ol>
<li>category默认是不支持添加property的（匿名分类除外），虽然这一做法可以在技术上实现，但是依然不推荐这么做。</li>
<li>category不支持property，主要是无法自动合成setter和getter方法，解决这一问题有两个方法：1）使用Item12的做法，用@dynamic声明，重写message-forwarding的方法，在runtime添加setter和getter方法；2）使用Item10，使用associated objects，自己在getter和setter进行关联。</li>
<li>上述两个方法均可行，但作者认为这两个方法都不完美，缺点有二：1）内存管理，你很容易忘记这个property的特殊性，而只去修改property的关键字，而忘记去修改setter方法；2）如果你想让自己的property对象在内部支持mutable，可以在内部声明一个，mutable拷贝，但是这又会出现一个进入源代码的混乱路径，所以在category中定义property的代价是很高的。</li>
<li>作者建议的方法是把所有的变量都放入原类中，而category只提供额外的方法。</li>
<li>但有时category中可以添加只读变量，而且也不涉及读写原类的变量，但是虽然不报错，还是推荐使用一个方法来完成，因为真的没必要这么做。</li>
</ol>


<!--more-->


<h2>Item27 Use the Class-Continuation Category to Hide Implementation Detail</h2>

<p>1.OC是没有真正的私有方法的，但我们还是不希望把不需要暴露的方法和变量暴露在外，所以匿名分类就是一种隐藏这些细节的手段。<br/>
2.你可以将实例变量声明在匿名变量或implementation中，可以完全不用暴露你要导入的头文件等一切信息，例如：</p>

<p>```objectivec
@interface EOCPerson(){</p>

<pre><code>NSString *_anInstanceVariable;
</code></pre>

<p>}
//Method declarations here
@end</p>

<p>@implemenation EOCPerson {</p>

<pre><code>int _anotherInstanceVariable;
</code></pre>

<p>}
//Method implemenations here</p>

<p>@end
```</p>

<p>3.一般OC代码中使用C++一般两种情况：一些游戏相关的后端代码需要用C++，使用的第三方库使用了C++，而你作为使用者除非特殊情况，一定要使用匿名分类来使用C++，这样其他类使用你的类时，不用再因为C++的原因，将.m文件命名为.mm，而使编译器将其编为Objective-C++。Cocoa的web browser framework和CoreAnimation使用了这一模式。<br/>
4.还有一种应用就是在外部声明readonly的property，然后在匿名分类中再将其声明为readwrite，这样可以实现外部只能通过方法设置值，而内部可以正常使用该变量，可能会出现外部在访问，内部同时在赋值同步的问题，将在Item41讨论。<br/>
5.接下来就是可以在匿名分类声明私有方法，虽然这不是必须的，而作者比较推荐先列好方法，理清思路，再开始实现，如果是比较大的项目，还是需要这么干的。<br/>
6.最后就是可以在匿名分类添加委托。</p>

<!--more-->


<h2>Item28 Use a Protocol to Provide Anonymous Objects</h2>

<ol>
<li>利用Protocol可以实现创建一些匿名对象，例如：id<EOCDelegate> delegate。</li>
<li>例子1：来自多个第三方类库的数据库管理对象对应不同数据库类型，现在需要提供一个统一的Manager，来返回这些不同的对象，依靠基类继承是不可能的，只能通过定义一组数据库通用的操作作为Protocol，然后分别继承这些类，而新类则遵从这一protocol，这样Manager只需返回id<Protocol>类型的对象即可，而使用者也只需要知道它们实现了这些方法也足够了。</li>
<li>例子2：已确定只有一个类型，但其是一个内部使用的数据类型，不需要将其所有细节暴露，只需要暴露其中一部分方法即可，那么将这些方法声明为Protocol，然后返回类型定义为id<Protocol>即可，其实就是实现了对对象的大部分封装。</li>
</ol>

]]></content>
  </entry>
  
</feed>
