<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 刘毅的技术博客]]></title>
  <link href="http://lucifer1988.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://lucifer1988.github.io/"/>
  <updated>2015-10-26T11:37:47+08:00</updated>
  <id>http://lucifer1988.github.io/</id>
  <author>
    <name><![CDATA[刘毅]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React Native初探1]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/20/react-nativechu-tan-1/"/>
    <updated>2015-10-20T17:29:08+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/20/react-nativechu-tan-1</id>
    <content type="html"><![CDATA[<p>React Native是Facebook最近推出的一个框架，让开发者通过JavaScript来完成iOS或Android的Native App，类似的方案好像几年前就出现过，比如PhoneGap，但经过市场检验，其App的用户体验，尤其是UI方面，始终较Native App相距甚远，那么这次Facebook带来的解决方案又有什么不同呢？</p>

<!--more-->


<h2>React Native特点</h2>

<ol>
<li>使用React Native后，你的App的逻辑部分是用JavaScript完成的，而UI则是完全native的，所以也不用担心H5带来的体验下降。</li>
<li>React Native还为用户界面构建带来了一种全新的函数式构建方案，App的UI会用与app的状态有关的函数来呈现。</li>
<li>React Native的核心思路是将响应式编程引入移动开发，这并不像之前PhoneGap倡导的<em>write-once,run-anywhere</em>，而是<em>learn-once,write-anywhere</em>。</li>
<li>Swift中Apple倡导使用函数式编程来完成算法和业务逻辑，但是构建UI仍然是基于UIKit，并没有实现函数式实现，而React则引入了UI层的函数式编程。</li>
</ol>


<h2>React Native环境搭建</h2>

<p>React Native的源码开源在<a href="https://github.com/facebook/react-native">GitHub</a>上，不过如果只是开发使用，则推荐使用commend line interface（CLI）来创建项目。<br/>
1.React Native使用Node.js，JavaScript的runtime，来创建JS代码。这里推荐使用Homebrew来安装Node.js。</p>

<p><code>ruby
brew install node
</code></p>

<p>2.然后安装watchman，一个Facebook开发的文件监听器，React Native通过它来监视代码的改动并适时编译，类似在Xcode中保存一次文件，便会执行一次build。</p>

<p><code>ruby
brew install watchman
</code></p>

<p>3.然后利用安装好的Node.js带的Node Package Manager来安装React Native CLI工具。</p>

<p><code>ruby
npm install -g react-native-cli
</code></p>

<p>4.这样环境就搭建完毕了，然后在目标文件夹，利用React Native的CLI创建新的项目。</p>

<p><code>ruby
react-native init YourAppFolderName
</code></p>

<h2>Hello Recact Native</h2>

<p>1.下面来创建一个“Hello World”的小程序，首先打开<strong>index.ios.js</strong>文件，删除测试代码，先添加以下代码，这段代码是开启了Strict Mode，主要为了提高JS的错误处理和禁用一些JS的语言特性。</p>

<p><code>javascript
'use strict'
</code></p>

<p>2.然后继续添加，这其实是导入了react-native模块，并将其赋值给了React，类似于#import或include。</p>

<p><code>javascript
var React = require("react-native")
</code></p>

<p>3.再添加一个样式，React Native使用了CSS来定义UI的样式，这和web开发是一致的。</p>

<p>```javascript
 var styles = React.StyleSheet.create({</p>

<pre><code>text:{
    color:'black',
    backgroundColor:'white',
    fontSize:30,
    margin:80
}
</code></pre>

<p> })
```</p>

<p>4.创建一个JS的类，Class是在ES6中引入的，但web开发为了兼容旧版浏览器，一般不会使用类，React Native是基于JavaScriptCore，可以放心使用JS的新特性，而不用担心浏览器兼容的问题。PropertyFinderApp扩展了React.Component，它是React UI的基本构建块，包含了不可变的Properties、可变的状态变量和用于渲染的方法，这里由于程序简单，只有一个渲染方法。</p>

<p>```javascript
class PropertyFinderApp extends React.Component{</p>

<pre><code>render(){
    return React.createElement(React.Text, {style:styles.text}, "Hello World!");
}
</code></pre>

<p>}
```</p>

<p>5.React.Component不是UIKit类，可以说是UIKit类的替代品，框架来负责将React components来转换为Native UI。最后再添加程序的入口，这里需要提供root component，也就是我们上面定义的PropertyFinderApp。</p>

<p><code>javascript
React.AppRegistry.registerComponent("RANTest", function(){return PropertyFinderApp});
</code></p>

<p>6.然后运行程序，你会发现JS代码已经转化为Native元素，完全没有网页元素出现。</p>

<h2>React Native运作原理</h2>

<p>1.先来看一下OC的程序加载后做了什么，一个类为RCTRootView的对象被创建，它负责加载JS程序和渲染视图，它通过*<a href="http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true*%E6%9D%A5%E5%8A%A0%E8%BD%BDJS%E3%80%82">http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true*%E6%9D%A5%E5%8A%A0%E8%BD%BDJS%E3%80%82</a></p>

<p>```objectivec
&ndash; (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{
  NSURL <em>jsCodeLocation;
  jsCodeLocation = [NSURL URLWithString:@&ldquo;<a href="http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true">http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true</a>&rdquo;];
  RCTRootView </em>rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</p>

<pre><code>                                                  moduleName:@"RANTest"
                                           initialProperties:nil
                                               launchOptions:launchOptions];
</code></pre>

<p>  self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
  UIViewController *rootViewController = [[UIViewController alloc] init];
  rootViewController.view = rootView;
  self.window.rootViewController = rootViewController;
  [self.window makeKeyAndVisible];
  return YES;
}
```</p>

<p>2.当你运行程序时，会打开一个终端窗口，就是为了开启一个packager和server来处理上述请求，在浏览器打开这一URL，也可以看到JS代码。<br/>
3.当app启动时，这些代码被载入，并被JavaScriptCore framework执行，将各个component载入，然后构建Native UIKit视图。</p>

<h2>Hello World JSX</h2>

<p>1.为了增加可读性和提高可维护性，可以使用HTML样式的JSX，也就是JavaScript syntax extension。</p>

<p><code>javascript
return &lt;React.Text style={styles.text}&gt;Hello World(Again)&lt;/React.Text&gt;;
</code></p>

<h2>A Search React Native App1</h2>

<h3>Adding Navigation</h3>

<p>1.这一节构建一个OC的NavgationController，将之前的PropertyFinderApp类改为HelloWorld，然后新定义一个PropertyFinderApp类，initialRoute定为HelloWorld，routing技术是web开发中定义导航结构，即哪个页面（或route）对应哪个URL。</p>

<p>```javascript
class PropertyFinderApp extends React.Component {
  render() {</p>

<pre><code>return (
  &lt;React.NavigatorIOS
    style={styles.container}
    initialRoute={ {
      title: 'Property Finder',
      component: HelloWorld,
    } }/&gt;
);
</code></pre>

<p>  }
}
```</p>

<p>2.然后添加container样式，这样，一个简单的导航控制器就完成了。</p>

<p>```javascript
var styles = React.StyleSheet.create({</p>

<pre><code>text:{
    color:'black',
    backgroundColor:'white',
    fontSize:30,
    margin:80
},
container:{
    flex:1
}
</code></pre>

<p>})
```</p>

<h3>Building the Search Page</h3>

<p>1.这一节介绍如何添加自定义一个Search页面，并在其他文件中进行引用。首先新建一个SearchPage.js文件，并在文件中添加代码。</p>

<p>```javascript
&lsquo;use strict&rsquo;
var React = require(&lsquo;react-native&rsquo;);
var {</p>

<pre><code>StyleSheet,
Text,
TextInput,
View,
TouchableHighlight,
ActivityIndicatorIOS,
Image,
Component
</code></pre>

<p>} = React;
```</p>

<p>2.这里使用了destructuring assignment，可以通过一行代码将多个对象属性一次性输出并将他们赋值给多个变量，这样你可以在之后的代码去掉React前缀，例如直接引用StyleSheet而不是React.StyleShet，这一技术在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">修改数组</a>时也经常用到，有点类似Swift的元组取值模式。</p>

<p><code>javascript
var foo = ["one", "two", "three"];
// without destructuring
var one   = foo[0];
var two   = foo[1];
var three = foo[2];
// with destructuring
var [one, two, three] = foo;
</code></p>

<p>3.然后创建CSS样式，并创建SearchPage component，语法依然使用了JSX的结构。</p>

<p>```javascript
var styles = StyleSheet.creat({</p>

<pre><code>description:{
    marginBottom:20,
    fontSize:18.
    textAlign:'center'.
    color:'#656565'
},
container:{
    padding:30,
    marginTop:65,
    alignItems:'center'
}
</code></pre>

<p>});
```</p>

<p>```javascript
class SearchPage extends Component {</p>

<pre><code>render() {
    return(
     &lt;View style={styles.container}&gt;
      &lt;Text style={styles.description}&gt;
       Search for houses to buy!
      &lt;/Text&gt;
      &lt;Text style={styles.description}&gt;
       Search by place-name, postcode or search near your location.
      &lt;/Text&gt;
     &lt;/View&gt;
    );
}
</code></pre>

<p>}
```</p>

<p>4.最后在文件结尾将SearchPage作为输出，并在index.ios.js中导入SearchPage，然后将之前render方法中的PropertyFinderApp类中的initialRoute更新。</p>

<p><code>javascript
module.exports = SearchPage;
</code></p>

<p><code>javascript
var SearchPage = require('./SearchPage');
</code></p>

<p><code>javascript
initialRoute={ {
  title: 'Property Finder',
  component: SearchPage,
} }
</code></p>

<h3>Styling with Flexbox</h3>

<p>1.flexbox是CSS最近加入的新特性，用于页面的布局（类似Autolayout），React Native使用了<a href="http://https://github.com/facebook/css-layout">css-layout</a>库，该库是Facebook自己开发的一个使用了flexbox标准的JS库，而这一标准对于C(iOS)和Java(Android)都是可接受的，这里有一篇专门讲解<a href="http://blog.scottlogic.com/2015/02/02/svg-layout-flexbox.html">flexbox layout to SVG</a>的文章，也是该作者写的。<br/>
2.在这个app中，container默认是列方向布局，也就是垂直方向布局（这与Android的布局方式是相同的），同时container也可以决定他的子视图的布局方向。</p>

<p>```javascript
<View style={styles.flowRight}>
  &lt;TextInput</p>

<pre><code>style={styles.searchInput}
placeholder='Search via name or postcode'/&gt;
</code></pre>

<p>  &lt;TouchableHighlight style={styles.button}</p>

<pre><code>  underlayColor='#99d9f4'&gt;
&lt;Text style={styles.buttonText}&gt;Go&lt;/Text&gt;
</code></pre>

<p>  </TouchableHighlight>
</View>
&lt;TouchableHighlight style={styles.button}</p>

<pre><code>underlayColor='#99d9f4'&gt;
</code></pre>

<p>  <Text style={styles.buttonText}>Location</Text>
</TouchableHighlight>
```</p>

<p>3.添加新的样式，记得在每个样式后要添加逗号分开，flex值是为了划分同一container下子视图的占位比，如这里的Go button和input view的flex分别为1和4，那么就按照1:4来划分，另外，这里的button是使用了TouchableHighlight。</p>

<p><code>javascript
flowRight: {
  flexDirection: 'row',
  alignItems: 'center',
  alignSelf: 'stretch'
},
buttonText: {
  fontSize: 18,
  color: 'white',
  alignSelf: 'center'
},
button: {
  height: 36,
  flex: 1,
  flexDirection: 'row',
  backgroundColor: '#48BBEC',
  borderColor: '#48BBEC',
  borderWidth: 1,
  borderRadius: 8,
  marginBottom: 10,
  alignSelf: 'stretch',
  justifyContent: 'center'
},
searchInput: {
  height: 36,
  padding: 4,
  marginRight: 5,
  flex: 4,
  fontSize: 18,
  borderWidth: 1,
  borderColor: '#48BBEC',
  borderRadius: 8,
  color: '#48BBEC'
}
</code></p>

<p>4.然后添加一张图片，图片资源依然要添加到Xcode的Images.xcassets，使用require(&lsquo;image!house&rsquo;)来加载图片，</p>

<p><code>javascript
&lt;Image source={require('image!house')} style={styles.image}/&gt;
</code></p>

<p><code>javascript
image: {
  width: 217,
  height: 138
}
</code></p>

<h2>A Search React Native App2</h2>

<h3>Adding Component State</h3>

<p>1.这一节，让我们来处理TextInput的输入，首先，我们来初始化SearchPage Component，下列代码添加到render()之前，这里有了新变量state以及searchString，并对TextInput赋该值。</p>

<p>```javascript
constructor(props) {
  super(props);
  this.state = {</p>

<pre><code>searchString: 'london'
</code></pre>

<p>  };
}
```</p>

<p><code>javascript
&lt;TextInput
  style={styles.searchInput}
  value={this.state.searchString}
  placeholder='Search via name or postcode'/&gt;
</code></p>

<p>2.然后在SearchPage Class添加一个方法，作为TextInput的回调，并将其与TextInput绑定，这一过程在OC中是以delegate的形式实现的，需要说明下的是这里的this是指向所在component的实例的指针。</p>

<p><code>javascript
onSearchTextChanged(event) {
  console.log('onSearchTextChanged');
  this.setState({ searchString: event.nativeEvent.text });
  console.log(this.state.searchString);
}
</code></p>

<p><code>javascript
&lt;TextInput
  style={styles.searchInput}
  value={this.state.searchString}
  onChange={this.onSearchTextChanged.bind(this)}
  placeholder='Search via name or postcode'/&gt;
</code></p>

<p>3.通过实验TextInput我们发现，每次TextIput的状态发生改变，整个component就会重新render一次，这一机制将渲染逻辑和与UI有关的状态改变彻底分开。在大部分UI框架中，一般都是开发者根据app状态改变来手动刷新UI（比如OC或Swift），或者使用隐式链接来绑定app的状态和UI刷新完成自动刷新（比如ReactiveCocoa），但是在React Native中，你不用再去手动处理这些逻辑，整个UI就是app状态的一个函数表示！这就是响应式编程的核心理念。<br/>
4.不过你可能会担心效率问题，频繁刷新整个UI当然是不明智的，React在每次刷新时，它会从render方法获取整个视图树，然后与现在的UIKit视图进行比较，比较的结果就是一个简单的更新表，React按照这个表去更新当前视图，所以只有需要更新的UI才会去更新。<br/>
5.这一理念的应用，将虚拟DOM和一致性引入了App开发，也是React的独特之处。</p>

<h3>Initiating a Search</h3>

<p>1.这一节为Search页面添加搜索功能，首先在state中加入isLoading变量，再在render中添加spinner变量告知用户搜索在进行，它依据isLoading变量来添加一个spinner或空视图，并将{spinner}加入return方法。</p>

<p><code>javascript
this.state = {
  searchString: 'london',
  isLoading: false
};
</code></p>

<p>```javascript
var spinner = this.state.isLoading ?
  ( &lt;ActivityIndicatorIOS</p>

<pre><code>  hidden='true'
  size='large'/&gt; ) :
</code></pre>

<p>  ( <View/>);
&hellip;
{spinner}
```</p>

<p>2.在Go Button绑定onPress事件回调，并添加回调方法，注意Javascript的类没有访问器，所以也没有私有方法，所以一般用<em>_</em>前缀来标识私有方法。</p>

<p><code>javascript
onPress={this.onSearchPressed.bind(this)}
</code></p>

<p><code>javascript
_executeQuery(query) {
  console.log(query);
  this.setState({ isLoading: true });
}
onSearchPressed() {
  var query = urlForQueryAndPage('place_name', this.state.searchString, 1);
  this._executeQuery(query);
}
</code></p>

<p>3.在SearchPage外单独定义urlForQueryAndPage()方法，这里做了URL的拼接，用到了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">JS的方法</a> 。</p>

<p>```javascript
function urlForQueryAndPage(key, value, pageNumber) {
  var data = {</p>

<pre><code>  country: 'uk',
  pretty: '1',
  encoding: 'json',
  listing_type: 'buy',
  action: 'search_listings',
  page: pageNumber
</code></pre>

<p>  };
  data[key] = value;</p>

<p>  var querystring = Object.keys(data)</p>

<pre><code>.map(key =&gt; key + '=' + encodeURIComponent(data[key]))
.join('&amp;');
</code></pre>

<p>  return &lsquo;<a href="http://api.nestoria.co.uk/api?">http://api.nestoria.co.uk/api?</a>&rsquo; + querystring;
};
```</p>

<p>4.=>是JS中对函数指针的缩写，可理解为OC中的block，这里先用map将其原字典的keys映射为新的数组，然后用&amp;相连，产生URL的参数String。</p>

<p><code>javascript
var a = [
  "Hydrogen",
  "Helium",
  "Lithium",
  "Beryl­lium"
];
var a2 = a.map(function(s){ return s.length });
var a3 = a.map( s =&gt; s.length );
</code></p>

<h3>Performing an API Request</h3>

<p>1.在state添加message变量，并在render添加Text，用以显示请求错误信息，并在_excuteQuery()中添加请求的代码。</p>

<p><code>javascript
this.state = {
  searchString: 'london',
  isLoading: false,
  message: ''
};
</code></p>

<p><code>javascript
&lt;Text style={styles.description}&gt;{this.state.message}&lt;/Text&gt;
</code></p>

<p>2.请求代码使用了fetch函数，这是<a href="https://fetch.spec.whatwg.org">Fetch API</a>中的函数，相比XMLHttpRequest，有很大提升，使用了promise规范。</p>

<p>```javascript
fetch(query)
  .then(response => response.json())
  .then(json => this._handleResponse(json.response))
  .catch(error =></p>

<pre><code> this.setState({
  isLoading: false,
  message: 'Something bad happened ' + error
</code></pre>

<p>   }));
```</p>

<p>3.success的回调处理，先对response code做了判断，然后打印出了listings的长度，可以看出JSON在JS开发中是直接使用的，而省去了转化为Model的步骤。</p>

<p>`&ldquo;javascript
_handleResponse(response) {
  this.setState({ isLoading: false , message: &rdquo; });
  if (response.application_response_code.substr(0, 1) === &lsquo;1&rsquo;) {</p>

<pre><code>console.log('Properties found: ' + response.listings.length);
</code></pre>

<p>  } else {</p>

<pre><code>this.setState({ message: 'Location not recognized; please try again.'});
</code></pre>

<p>  }
}
```</p>

<h3>Displaying the Results</h3>

<p>1.新建SearchResult.js，新建SearchResults component，代码中使用到了ListView，类似OC的UITableView，通过dataSource来提供数据源，renderRow来渲染每个cell。</p>

<p>```javascript
class SearchResults extends Component {</p>

<p>  constructor(props) {</p>

<pre><code>super(props);
var dataSource = new ListView.DataSource(
  {rowHasChanged: (r1, r2) =&gt; r1.guid !== r2.guid});
this.state = {
  dataSource: dataSource.cloneWithRows(this.props.listings)
};
</code></pre>

<p>  }</p>

<p>  renderRow(rowData, sectionID, rowID) {</p>

<pre><code>return (
  &lt;TouchableHighlight
      underlayColor='#dddddd'&gt;
    &lt;View&gt;
      &lt;Text&gt;{rowData.title}&lt;/Text&gt;
    &lt;/View&gt;
  &lt;/TouchableHighlight&gt;
);
</code></pre>

<p>  }</p>

<p>  render() {</p>

<pre><code>return (
  &lt;ListView
    dataSource={this.state.dataSource}
    renderRow={this.renderRow.bind(this)}/&gt;
);
</code></pre>

<p>  }
}
```</p>

<p>2.构建数据源时，提供了一个方法来比较row之间的id是否相同，ListView在更新时调用它，来确定数据源是否改变，本例中通过数据的guid来达到这个目的，然后在SearchPage的_handleResponse中添加导航方法。</p>

<p><code>javascript
this.props.navigator.push({
  title: 'Results',
  component: SearchResults,
  passProps: {listings: response.listings}
});
</code></p>

<h3>A Touch of Style</h3>

<p>1.添加样式，更新renderRow()方法，price为了去掉GBP后缀，做了字符串裁剪，同时这次的Image数据源为url，JS可直接赋值，而React Native会自动后台一步下载。</p>

<p>```javascript
var styles = StyleSheet.create({
  thumb: {</p>

<pre><code>width: 80,
height: 80,
marginRight: 10
</code></pre>

<p>  },
  textContainer: {</p>

<pre><code>flex: 1
</code></pre>

<p>  },
  separator: {</p>

<pre><code>height: 1,
backgroundColor: '#dddddd'
</code></pre>

<p>  },
  price: {</p>

<pre><code>fontSize: 25,
fontWeight: 'bold',
color: '#48BBEC'
</code></pre>

<p>  },
  title: {</p>

<pre><code>fontSize: 20,
color: '#656565'
</code></pre>

<p>  },
  rowContainer: {</p>

<pre><code>flexDirection: 'row',
padding: 10
</code></pre>

<p>  }
});
```</p>

<p>```javascript
renderRow(rowData, sectionID, rowID) {
  var price = rowData.price_formatted.split(&lsquo; &rsquo;)[0];</p>

<p>  return (</p>

<pre><code>&lt;TouchableHighlight onPress={() =&gt; this.rowPressed(rowData.guid)}
    underlayColor='#dddddd'&gt;
  &lt;View&gt;
    &lt;View style={styles.rowContainer}&gt;
      &lt;Image style={styles.thumb} source={ { uri: rowData.img_url } } /&gt;
      &lt;View  style={styles.textContainer}&gt;
        &lt;Text style={styles.price}&gt;£{price}&lt;/Text&gt;
        &lt;Text style={styles.title} 
              numberOfLines={1}&gt;{rowData.title}&lt;/Text&gt;
      &lt;/View&gt;
    &lt;/View&gt;
    &lt;View style={styles.separator}/&gt;
  &lt;/View&gt;
&lt;/TouchableHighlight&gt;
</code></pre>

<p>  );
}
```</p>

<p>2.然后添加点击cell的回调，可以看到数据源始终还是最原始的数据源，做了一步过滤操作（因为这里的cell没有index的概念，所以只能过滤，但是必须保证guid唯一才可以）。</p>

<p><code>javascript
rowPressed(propertyGuid) {
  var property = this.props.listings.filter(prop =&gt; prop.guid === propertyGuid)[0];
}
</code></p>

<h3>Property Details View</h3>

<p>1.添加详情页，PropertyView，首先对房屋的配置信息做了整理，然后就是常规的视图布局。</p>

<p>```javascript
class PropertyView extends Component {
  render() {</p>

<pre><code>var property = this.props.property;
var stats = property.bedroom_number + ' bed ' + property.property_type;
if (property.bathroom_number) {
  stats += ', ' + property.bathroom_number + ' ' + (property.bathroom_number &gt; 1 ? 'bathrooms' : 'bathroom');
}

var price = property.price_formatted.split(' ')[0];

return (
  &lt;View style={styles.container}&gt;
    &lt;Image style={styles.image} 
        source={ {uri: property.img_url} } /&gt;
    &lt;View style={styles.heading}&gt;
      &lt;Text style={styles.price}&gt;£{price}&lt;/Text&gt;
      &lt;Text style={styles.title}&gt;{property.title}&lt;/Text&gt;
      &lt;View style={styles.separator}/&gt;
    &lt;/View&gt;
    &lt;Text style={styles.description}&gt;{stats}&lt;/Text&gt;
    &lt;Text style={styles.description}&gt;{property.summary}&lt;/Text&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
}
```</p>

<p>2.最后从SearchResults，推入PropertyView。</p>

<p>```javascript
rowPressed(propertyGuid) {
  var property = this.props.listings.filter(prop => prop.guid === propertyGuid)[0];</p>

<p>  this.props.navigator.push({</p>

<pre><code>title: "Property",
component: PropertyView,
passProps: {property: property}
</code></pre>

<p>  });
}
```</p>

<h3>Geolocation Search</h3>

<p>1.增加自动定位并搜索周边房屋的功能，在SearchPage的Location按钮添加该功能，前提在Xcode的工程的Plist中添加NSLocationWhenInUseUsageDescription来添加请求允许定位的描述。</p>

<p><code>javascript
onPress={this.onLocationPressed.bind(this)}
</code></p>

<p>```javascript
onLocationPressed() {
  navigator.geolocation.getCurrentPosition(</p>

<pre><code>location =&gt; {
  var search = location.coords.latitude + ',' + location.coords.longitude;
  this.setState({ searchString: search });
  var query = urlForQueryAndPage('centre_point', search, 1);
  this._executeQuery(query);
},
error =&gt; {
  this.setState({
    message: 'There was a problem with obtaining your location: ' + error
  });
});
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Functions and Closures]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/20/swift-by-tutorials-functions-and-closures/"/>
    <updated>2015-10-20T17:28:15+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/20/swift-by-tutorials-functions-and-closures</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Generics]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/15/swift-by-tutorials-generics/"/>
    <updated>2015-10-15T11:05:56+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/15/swift-by-tutorials-generics</id>
    <content type="html"><![CDATA[<p>经过前三章，基本对Swift的基本语法有了较全面的介绍，接下来会分别就Swift比较重要的几个技术要点介绍，这一节将讨论一个比较流行的语言特性，generics，即泛型。对于类型安全的编程语言，希望代码可以在一个场景下运行，但又想要在其他场景中也可以是合法的，比如对于一个加法函数，Int和Float类型的函数形式是一样的，只是变量类型不同，在强调类型的语言中，你必须分开定义这两个方法。很多语言为这一问题提供了解决方案，C++是使用了模板，而Swift、Java、C#是使用了泛型，也就是这一章的主角，配合主题这一章将创建一个Flickr照片搜素App来实践这一技术。</p>

<!--more-->


<h2>Introducing generics</h2>

<p>1.泛型是什么？举例来说Array和Dictionary就是类型安全的泛型应用实例。在OC中Array和Dictionary是可以存放不同类型的对象的，当然这有时是提供了很多方便，但当你去使用一个Array或Dictionary时，你如何知道其中的类型？只能通过文档或其他代码，而且没有任何办法去控制在runtime中出现数据异常。<br/>
2.而Swift中对Array和Dictionary中类型是固定的，编译器会完成类型检查，而你的代码本身也对自己做了注释，比较下处理点击的方法在OC和Swift中的区别，在OC中调用这一方法，你一般是需要将set中的对象转化为UITouch类型，而Swift不仅省去你这一操作，代码可读性也更优。</p>

<p><code>objectivec
//in OC
-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;
//in Swift
func touchesBegan(touches: [UITouch]!, withEvent event: UIEvent!)
</code></p>

<p>2.所以说泛型就是类似Array这样，所有的Array运作方式都是一致的，都是将数据存在一张有序的表中，但泛型的Array将值的类型作为了参数，也就是不论Array中类型如何，都可以执行Array的方法。</p>

<!--more-->


<h2>Generics in action</h2>

<p>1.本章的实例项目是要从Flickr的搜索接口获取对应图片，并进行展示的一个App，其中网络访问部分大神已经写好了。</p>

<!--more-->


<h2>Ordered dictionaries</h2>

<p>1.第一个需求就是希望将用户最近搜索的图片放在前面，那么如果正常来讲，我们要用Array来存数据源，而不是Dictionary或Set，因为后两者是无序的，而这里为了应用泛型，打算自己创建一个有序的Dictionary，实际上就是想把key作为顺序。</p>

<h3>The initial data structure</h3>

<p>1.首先声明有序字典为Struct类型，并声明它的泛型类型参数，KeyType和ValueType并不是真实的类型，只是两个你用来替代类型的参数，一般用T来表示，如果单词表示的话用驼峰式大写首字母来表示。</p>

<p><code>objectivec
struct OrderedDictionary&lt;KeyType, ValueType&gt; {
}
</code></p>

<p>2.创建一个有序字典最简单的方法是，在内部同时维护一个Dictionary和Array，这里使用了typealias分别给[KeyType]和[KeyType: ValueType]做了类型名替代，这样下面声明Array和Dictionary就可以直接用替代类型名来定义，同理这个也可以用在替换函数类型和闭包等比较长的类型的替换。</p>

<p>```objectivec
typealias ArrayType = [KeyType]
typealias DictionaryType = [KeyType: ValueType]</p>

<p>var array = ArrayType()
var dictionary = DictionaryType()
```</p>

<p>3.对比Dictionary的定义，KeyType需要遵循Hashable协议，因为Dictionary需要对key做hash，所以在定义泛型那儿要加上遵循该协议。</p>

<p><code>objectivec
struct OrderedDictionary&lt;KeyType: Hashable, ValueType&gt;
</code></p>

<h3>Keys, values and all that jazz</h3>

<p>1.第一个要加入的方法是insert方法，因为是有序字典，所以有所不同。</p>

<p>```objectivec
mutating func insert(value: ValueType, forKey key: KeyType, atIndex index: Int) &ndash;> ValueType? {
  var adjustedIndex = index</p>

<p>  let existingValue = self.dictionary[key]
  if existingValue != nil {</p>

<pre><code>let existingIndex = self.array.indexOf(key)!
if existingIndex &lt; index {
  adjustedIndex--
}
self.array.removeAtIndex(existingIndex)
</code></pre>

<p>  }</p>

<p>  self.array.insert(key, atIndex:adjustedIndex)
  self.dictionary[key] = value</p>

<p>  return existingValue
}
```</p>

<p>2.有几点需要说明，首先，该方法前的mutating关键字，因为Struct默认是不可变的，也就是是说你不能在实例方法中修改struct的成员变量，加上mutating是为了告诉编译器该方法可以修改struct成员变量，使编译器在适当的时候对struct做copy操作(前面说过，实际上是copy-on-write)，同时也增加了可读性。<br/>
3.然后是remove方法，这里先对index是否越界做了判断，可以像OC中使用Assertions断言，也可以如下使用precondition，如果失败，会退出App。</p>

<p><code>objectivec
mutating func removeAtIndex(index: Int) -&gt; (KeyType, ValueType) {
  precondition(index &lt; self.array.count, "Index out-of-bounds")
  let key = self.array.removeAtIndex(index)
  let value = self.dictionary.removeValueForKey(key)!
  return (key, value)
}
</code></p>

<p>4.这里在结束后会返回一个元组类型的删除值，使之与Swift的Array和Dictionary的remove方法保持一致。</p>

<h3>Accessing values</h3>

<p>1.上一节为有序字典添加了写入的方法，接下来添加一些读取的方法，首先是获取count的方法，如下，使用了前面提到的computed property技术。</p>

<p><code>objectivec
var count: Int {
  return self.array.count
}
</code></p>

<p>2.在Swift中我们一般使用subscript来访问变量，类似dictionary[1]，一般是见于Array和Dictionary，不过我们计划在我们的有序字典也加入这一特性。</p>

<p>```objectivec
subscript(key: KeyType) &ndash;> ValueType? {
  get {</p>

<pre><code>return self.dictionary[key]
</code></pre>

<p>  }
  set {</p>

<pre><code>if let index = self.array.indexOf(key) {
} else {
  self.array.append(key)
}
self.dictionary[key] = newValue
</code></pre>

<p>  }
}
```</p>

<p>3.上述代码就是如何在自己的Struct中加入subscript行为，类似computed property，subscript有两个闭包，分别是getter和setter。<br/>
4.因为这是一个有序数组，我们打算让他支持通过index来访问，需要注意的是：一，无论setter，getter都需要判断index是否越界；二，setter中输入的值newValue是一个元组类型，所以需要用let (key, value) = newValue将键值取出来。</p>

<p>```objectivec
subscript(index: Int) &ndash;> (KeyType, ValueType) {
  get {</p>

<pre><code>precondition(index &lt; self.array.count, "Index out-of-bounds")
let key = self.array[index]
let value = self.dictionary[key]!
return (key, value)
</code></pre>

<p>  }
  set {</p>

<pre><code>precondition(index &lt; self.array.count, "Index out-of-bounds")
let (key, value) = newValue
let originalKey = self.array[index]
self.dictionary[originalKey] = nil
self.array[index] = key
self.dictionary[key] = value
</code></pre>

<p>  }
}
```</p>

<p>5.这里可能有个疑问，就是如果使用者使用Int作为KeyType呢？因为Int也遵循hashable，完全可以作为key，那么编译器如何判断该用哪组方法呢？遇到这种情况，setter方法当然没问题，因为赋值也不同，那么getter方法只能在取值时就声明返回值的类型，这样编译器会通过这个类型选择使用哪个方法。</p>

<p><code>objectivec
var dict = OrderedDictionary&lt;Int, String&gt;()
dict.insert("dog", forKey: 1, atIndex: 0)
dict.insert("cat", forKey: 2, atIndex: 1)
print(dict.array.description + " : " + dict.dictionary.description)
//"[1, 2] : [2: "cat", 1: "dog"]"
var byIndex: (Int, String) = dict[0]
print(byIndex)
//"(1, "dog")"
var byKey: String? = dict[2]
print(byKey)
//"Optional("cat")"
</code></p>

<p>6.在使用type interface时，编译器需要明确知道返回值的类型，如果出现上述相同方法，返回值类型不同的情况，必须caller指明类型，否则编译器是不会知道该返回那个值的。</p>

<!--more-->


<h2>Aside: Assertions &amp; preconditions</h2>

<p>1.assertions和precondition都是判断程序是否能继续执行时的判断条件，不同的是，assertion是不会在release build时编译的，而precondition可以；assertion是被用于在开发时获取bug，而precondition是用于当一个条件不满足时，抛出严重异常的。<br/>
2.assertion的一个使用场景是有多个创建view的方法共同来构建页面，但其中一些依赖于另一些完成，这时要使用assertion。</p>

<p>```objectivec
private func configureTableView() {</p>

<pre><code>self.tableView = UITableView(frame: CGRectZero) 
self.tableView.delegate = self 
self.tableView.dataSource = self 
self.view.addSubview(self.tableView)}private func configureHeader() {   assert(self.tableView != nil)   let headerView = UIView(frame: CGRectMake(0, 0, 320, 50))   headerView.backgroundColor = UIColor.clearColor()   let label = UILabel(frame: CGRectZero)  label.text = "My Table"     label.sizeToFit()   label.frame = CGRectMake(0, 0, label.bounds.size.width, label.bounds.size.height) headerView.addSubview(label)  self.tableView.tableHeaderView = headerView }
</code></pre>

<p>```</p>

<p>3.关于assertion一个有趣的现象是编译器允许在release build时假设assertion是true，有时也会导致一些bug，如下，输入0时，在debug下没问题，会触发断言；而在release中，编译器自动认为assertion是true，然后optimizer就会跳过if，直接进入>0的分支。</p>

<p>```objectivec
func foo(value: Int) {</p>

<pre><code>assert(value &gt; 0)   if value &gt; 0 {      print("Yes, it's greater than zero")    } else { 
    print("Nope")   } }
</code></pre>

<p>```</p>

<p>4.再来看下precondition，它和assertion做的是一样的工作，但是可以在release下运行，使用它是为了确保一些必要的条件，如下例，数组越界即使不加precondition，也会crash，但是通过precondition，可以获取到自定义的log信息，方便调试。</p>

<p>```objectivec
func fetchPeopleBetweenIndexes(start: Int, end: Int) &ndash;> [Person] {</p>

<pre><code>precondition(start &lt; end)   precondition(start &gt;= 0)    precondition(end &lt;= self.people.count)  return Array(self.people[start..&lt;end]) 
</code></pre>

<p>}
```</p>

<p>5.一般的经验是，在你release时可以跳过，但是希望在debug阶段获取失败信息时使用assertion；而在将会导致数据损坏或者其他严重问题前，使用precondition。同时在你开发一些第三方库时，在容易出现数据输入错误这些位置可以使用precondition来提示开发者。</p>

<!--more-->


<h2>Adding image search</h2>

<p>1.创建App的数据源，使用的就是之前自定义的有序字典，你可能注意到使用了Flickr.photo，Photo是一个定义在Flickr中的类，这样的机制非常有用，在保持类名尽量短的基础上实现了命名空间，在Flickr类中，可以单独使用Photo类。</p>

<p><code>objectivec
var searches = OrderedDictionary&lt;String, [Flickr.Photo]&gt;()
</code></p>

<p>2.然后实现tableView的委托和数据源协议。</p>

<p>```objectivec
func tableView(tableView: UITableView, numberOfRowsInSection section: Int) &ndash;> Int {
  return self.searches.count
}</p>

<p>func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) &ndash;> UITableViewCell {
  let cell = tableView.dequeueReusableCellWithIdentifier(&ldquo;Cell&rdquo;, forIndexPath: indexPath) as UITableViewCell
  let (term, photos) = self.searches[indexPath.row]
  cell.textLabel!.text = &ldquo;(term) ((photos.count))&rdquo;
  return cell
}
```</p>

<p>3.然后是UISearchBarDelegate，这里调用Flickr的search方法是使用了Trailing Closures技术，即如果closure作为一个方法最后一个变量，那么可以写到所调用方法的外面（后面），如下：</p>

<p>```objectivec
func searchBarSearchButtonClicked(searchBar: UISearchBar!) {
  searchBar.resignFirstResponder()
  let searchTerm = searchBar.text
  Flickr.search(searchTerm!) {</p>

<pre><code>switch ($0) {
case .Error:
  break
case .Results(let results):
  self.searches.insert(results, forKey: searchTerm!, atIndex: 0)
  self.tableView.reloadData()
}
</code></pre>

<p>  }
}
```</p>

<p>```objectivec
func someFunctionThatTakesAClosure(closure: () &ndash;> Void) {</p>

<pre><code>// function body goes here
</code></pre>

<p>}
// here&rsquo;s how you call this function without using a trailing closure:
someFunctionThatTakesAClosure({</p>

<pre><code>// closure's body goes here
</code></pre>

<p>})
// here&rsquo;s how you call this function with a trailing closure instead:
someFunctionThatTakesAClosure() {</p>

<pre><code>// trailing closure's body goes here
</code></pre>

<p>}
```</p>

<h3>Show me the photos!</h3>

<p>1.这一节来完成详情页，先是在prepareForSegue方法中设置DetailViewController。</p>

<p>```objectivec
override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
  if segue.identifier == &ldquo;showDetail&rdquo; {</p>

<pre><code>if let indexPath = self.tableView.indexPathForSelectedRow {
  let (_, photos) = self.searches[indexPath.row]
  (segue.destinationViewController as! DetailViewController).photos = photos
}
</code></pre>

<p>  }
}
```</p>

<h3>Deleting searches</h3>

<p>1.为搜索页添加滑动删除功能。</p>

<p><code>objectivec
self.navigationItem.leftBarButtonItem = self.editButtonItem()
</code></p>

<p><code>objectivec
override func setEditing(editing: Bool, animated: Bool)  {
  super.setEditing(editing, animated: animated)
  self.tableView.setEditing(editing, animated: animated)
}
</code></p>

<p><code>objectivec
func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -&gt; Bool {
  return true
}
</code></p>

<p>```objectivec
func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {
  if editingStyle == .Delete {</p>

<pre><code>self.searches.removeAtIndex(indexPath.row)
tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Fade)
</code></pre>

<p>  }
}
```</p>

<!--more-->


<h2>Generic functions and protocols</h2>

<p>1.这一节介绍泛型的函数和协议，之前一直使用的find方法就是一个泛型方法，这是一个全局方法，泛型参数C定义了domain参数，也间接定义了value参数的类型，且返回值也和C有关：</p>

<p><code>objectivec
func find&lt;C: Collection where C.GeneratorType.Element: Equatable&gt; (domain: C, value: C.GeneratorType.Element) -&gt; C.IndexType?
</code></p>

<p>2.我们之前定义的有序字典的insert方法中这么使用了find()，没有指出C，其实这又是type interface的体现，通过第一个参数推断出了C的类型。</p>

<p><code>objectivec
let existingIndex = find(self.array, key)!
</code></p>

<p>3.那么GeneratorType是什么？上述的Collection协议，同时也遵从于SequenceType协议，如下，要实现该协议，必须有个typealias名为Generator，且遵从于GeneratorType协议，同时实现generate()方法返回Generator类型。</p>

<p>```objectivec
protocol SequenceType { typealias Generator : GeneratorType</p>

<pre><code>public func generate() -&gt; Self.Generator}
</code></pre>

<p>```</p>

<p>4.那么在自定义的有序数组上实验下SeqenceType，首先定义typealias名为Generator，使用AnyGenerator这个泛型类。</p>

<p>```objectivec
extension OrderedDictionary: SequenceType {
  typealias Generator = AnyGenerator&lt;(KeyType, ValueType)>
  func generate() &ndash;> AnyGenerator&lt;(KeyType, ValueType)> {</p>

<pre><code>var index = 0
return anyGenerator {
  if index &lt; self.array.count {
    let key = self.array[index++]
    return (key, self.dictionary[key]!)
  } else {
    return nil
  }
}
</code></pre>

<p>  }
}
```</p>

<p>5.而在实现generate()方法中，通过调用了anyGenerator方法，该方法只有一个closure参数，所以使用了Trailing Closures技术，这个closure会在每次调用next()时调用，在closure中，你完成自己的遍历方法。</p>

<p><code>objectivec
public func anyGenerator&lt;Element&gt;(body: () -&gt; Element?) -&gt; AnyGenerator&lt;Element&gt;
</code></p>

<p>6.实现了SequenceType Protocol，你可以使用for-in来遍历字典，其实typealias Generator = AnyGenerator&lt;(KeyType, ValueType)>这句可以删除，因为Swift从func generate() &ndash;> AnyGenerator&lt;(KeyType, ValueType)>()返回值推断出了该类型。<br/>
7.实际上SequenceType Protocol就是一个泛型协议，只不过因为protocol不能使用&lt;>关键字，而像Java和C#是可以的，原因也很简单，Protocols本身就是定义给class或struct实现的，这本身就是带有泛型的性质，Swift的思想就是protocol定义接口，而class和struct定义类型、泛型或其他。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Classes and Structs]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/12/swift-by-tutorials-classes-and-structs/"/>
    <updated>2015-10-12T15:26:48+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/12/swift-by-tutorials-classes-and-structs</id>
    <content type="html"><![CDATA[<p>继上两章对Swift的基本类型的学习，这一章开始介绍Swift中的Class和Struct，Class对所有面向对象的语言都不陌生，而Struct可能用的比较少，因为大部分用于C中，但Swift中的Struct与C还有很多不同，这章会一一介绍，而且同时会讲到Class与Struct之间的不同与使用场景，以及它们的扩展，也是这一章的重点。</p>

<!--more-->


<h2>Getting started</h2>

<h3>The class concept</h3>

<p>1.类是通过总结一些对象的共同特点，定义基本类型，通过继承来创建具体使用的子类型，它拥有自己的数据和方法，可以视为数据的容器。</p>

<h2>My first class</h2>

<p>1.介绍示例项目的Class设计。</p>

<h3>Creating the class</h3>

<p>1.import语句用于导入Swift的库文件，记性好的话，之前Apple在OC中加入了@import来替代#import（如：@import Foundation;替代#import &lt;Foundation/Foundation.h>），其实Swift中的import是和这个一致的。<br/>
2.定义一个类如下即可，但是如果如下，有未初始化赋值的非optional变量，那么会提示你增加初始化方法。</p>

<p>```objectivec
class Treasure {</p>

<pre><code>let what: String
let latitude: Double
let longitude:Double
</code></pre>

<p>}
init(what: String, latitude: Double, longitude: Double) {</p>

<pre><code>self.what = waht
self.latitude = latitude
self.longitude = longitude
</code></pre>

<p>}
```</p>

<h3>A struct-ural improvement</h3>

<p>1.下一步的优化是把经纬度信息做成一个结构体，那么就涉及到了Swift中的Struct，Swift中Struct和Class一样，都可以存储数据和拥有自己的方法，但要记住Struct始终是一个数值型的容器，它的用途只是持有数据，不要让它承担更多的功能。</p>

<p>```objectivec
struct GeoLocation {</p>

<pre><code>var latitude: Double
var longitude: Double
</code></pre>

<p>}
```</p>

<p>2.在Swift中，在工程中的文件是相互自动import的，所以你不用再去手动导入，这一点在你开发library和framework也是一样的。</p>

<h3>Reference types vs. value types</h3>

<p>1.Swift中，Struct与Class的最大区别是，Class在本质上是指针引用类型，而Struct是值类型，在赋值过程中，Class传递的是指针，而Struct则会copy一份新值，从如下的例子即可看出。</p>

<p>```objectivec
struct MyStruct {</p>

<pre><code>var foo: Double = 0.0
</code></pre>

<p>}
class MyClass {</p>

<pre><code>var foo: Double = 0.0
</code></pre>

<p>}
var structA = MyStruct()
var structB = structA
structB.foo = 1.0
print(structA.foo)
//0.0
print(structB.foo)
//1.0
var classA = MyClass()
var classB = classA
classB.foo = 1.0
print(classA.foo)
//1.0
print(classB.foo)
//0.0
```</p>

<p>2.需要说明的一点，Swift在copy一个Struct时是很智能的，只会在确定必要的时候copy，也就是说structB = structA并不会创建出拷贝，只有你开始改变其中一个值时，runtime会开始执行copy。<br/>
3.另外关于let类型的Struct和Class还有一些细微的区别，对于二者的var实例，是没有区别的，都可以改变各自的属性或将自身赋值给其他实例，但对于let实例，Class依然可以修改自己的属性变量，但是不能将自己赋值给其他实例，而Struct既不能改变自己的属性变量，也不能将自己赋值给其他实例，这也是为什么Array和Dictionary是Struct而不是Class。</p>

<p>```objectivec
struct MyStruct {</p>

<pre><code>var foo: Double = 0.0
</code></pre>

<p>}
class MyClass {</p>

<pre><code>var foo: Double = 0.0
</code></pre>

<p>}
var classA = MyClass()
let classB = MyClass()
classA.foo = 1.0
classB.foo = 1.0
classB = classA
//error
var structA = MyStruct()
let structB = MyStruct()
structA.foo = 1.0
structB.foo = 1.0
//error
structB = structA
//error
```</p>

<h3>Convenience initializers</h3>

<p>1.在实例中其实还是不必要将GeoLocation暴露给使用者，可以直接给出更方便的初始化方法，这就用到了convenience initializer，在该初始化方法中跳转到了原初始化方法中，也称为designated initializer。</p>

<p>```objectivec
convenience init(what: String, latitude: Double, longitude: Double) {</p>

<pre><code>let location = GeoLocation(latitude: latitude, longitude: longitude)
self.init(what: what, location: location)
</code></pre>

<p>}
```</p>

<p>2.Struct不需要显式的初始化方法，Swift为你自动添加了，你只需要按Struct的属性顺序一一初始化就行了，这也是为什么上述方法中可以自动初始化GeoLocation。</p>

<h3>Class inheritance</h3>

<p>1.Swift中的继承是怎样的？如下例：</p>

<p>```objectivec
class HistoryTreasure: Treasure {</p>

<pre><code>let yaer: Int
init(what: String, year: Int, latitude: Double, longitude: Double) {
    self.year = year
    let location = GeoLocation(latitude: latitude, longitude: longitude)
    super.init(what: what, location: location)
}
</code></pre>

<p>}
```</p>

<p>2.子类如果有自己新的属性时，需要自己的designated initializer，而子类的designated initializer必须引用父类的一个designated initializer（注意不可以是convenience initializer），所以和上一节比较相当于做了重复工作。<br/>
3.这里有与OC不同的一点，在OC中子类的init()方法中，是先调用父类的init()，再进行子类属性的赋值，而在Swift中是最后调用父类的init()，因为在Swift中是initializer来初始化所有属性，最后交给父类来处理，父类的init()要放在最后，是因为它不知道子类中声明的新属性，必须在它之前把这些新属性初始化。</p>

<!--more-->


<h2>Swift and MapKit</h2>

<p>1.重写父类方法，Swift中需要在方法前加上override关键字，增加了可读性，同时如果你写的方法不存在于父类，那么编译器会报error通知你。</p>

<p>```objectivec
override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()
</code></pre>

<p>}
```</p>

<h3>Class extensions and computed properties</h3>

<p>1.示例中需要将Treasure类型的变量显示在MKMapView上，那么就要使Treasure遵循MKAnnotation协议，我们使用了extension来实现：</p>

<p>```objectivec
import MapKit
extension Treasure: MKAnnotation {</p>

<pre><code>var coordinate: CLLocationCoordinate2D {
    return self.location.coordinate
}
var title: String {
    return self.what
}
</code></pre>

<p>}
```</p>

<p>2.extension类似OC的category，都是扩展类的技术，但是优于category，因为extension不但可以添加方法，还可以添加新属性。<br/>
3.这里添加的两个property有些特别，它们是Swift中的computed properties，每次访问它们都会执行后面的方法，用法与普通的properties是一致的。</p>

<h3>Your first struct extension</h3>

<p>1.Struct也可以添加extension，下例中的extension起到了分割代码，增加可读性的作用，这是extension的习惯用法。</p>

<p>```objectivec
import MapKit
extension GeoLocation {</p>

<pre><code>var coordinate: CLLocationCoordinate2D {
    return CLLocationCoordinate2DMake(self.latitude, self.longitude)
}
var mapPoint: MKMapPoint {
    return MKMapPointForCoordinate(self.coordinate)
}
</code></pre>

<p>}
```</p>

<h3>Inheriting from NSObject</h3>

<p>1.类遵循MKAnnotation同时，也应该遵循NSObject协议，因为MKAnnotation继承自NSObject协议。</p>

<h3>Pinning the map</h3>

<p>1.在viewDidLoad()中添加以下代码，完成mapView上打点的工作。</p>

<p><code>objectivec
self.mapView.delegate = self
self.mapView.addAnnotations(self.treasures)
</code></p>

<p>2.然后添加viewController的extension，并实现MKMapViewDelegate的方法：</p>

<p>```objectivec
extension ViewController: MKMapViewDelegate {</p>

<pre><code>func mapView(mapView: MKMapView, viewForAnnotation annotation: MKAnnotation) -&gt; MKAnnotationView
{
    if let treasure = annotation as? Treasure {
        var view = mapView.dequeueReusableAnnotationViewWithIdentifier("pin") as! MKPinAnnotationView!
        if view = nil {
            view = MKPinAnnotationView(annotation: annotation, reuseIdentifier: "pin")
            view.canShowCallout = true
            view.animatesDrop = false
            view.calloutOffset = CGPoint(x: -5, y: 5)
            view.rightCalloutAccessoryView = UIButton(type: .DetailDisclosure) as UIView
        } else {
            view.annotation = annotation
        }
        return view
    }
    return nil
}
</code></pre>

<p>}
```</p>

<p>3.在实现的mapView:viewForAnnotation方法中，annotation参数类型为MKAnnotation!，是一个隐式拆解的optional类型，但是我们还是进行了if/let的检查，因为这个方法是OC的API，是没有optional的，所以为了兼容Swift只能声明为这个类型，所以还需要显式拆解。<br/>
4.同时除了检查是否为nil，我们还要注意传入的类型是否为Treasure类型，这儿用到了inline downcasting技术，也是Swift的一种简写语法，if let treasure = annotation as？ Treasure{}，如果annotation不是Treasure类型，那么也不会进入if，这是Swift中确保类型正确的一种技术。<br/>
5.获取MKPinAnnotationView利用了一贯的复用技术，另外此处又一次用到了downcast技术，只不过因为返回的类型肯定可以确定都是MKPinAnnotationView，所以用了非optional版本。</p>

<h3>The reduce algorithm</h3>

<p>1.这一节是为了解决app载入后不能直接定位到目标位置，而要先定位自己的位置这个bug。</p>

<p><code>objectivec
let rectToDisplay = self.treasures.reduce(MKMapRectNull) {
  (mapRect: MKMapRect, treasure: Treasure) -&gt; MKMapRect in
  let treasurePointRect = MKMapRect(origin: treasure.location.mapPoint, size: MKMapSize(width: 0, height: 0))
  return MKMapRectUnion(mapRect, treasurePointRect)
}
self.mapView.setVisibleMapRect(rectToDisplay, edgePadding: UIEdgeInsetsMake(74, 10, 10, 10), animated: false)
</code></p>

<p>2.为了达到这一优化，实际就是要获取可以展示全部treasures的最小地图范围，然后在地图绘制这一区域。而输入是一个数组，需要一个它们逐个计算的结果，这里使用了函数式编程中的Reduce函数，这是处理这一问题的最佳方案，下面是Swift中reduce的原型，需要一个初始值initial，这里对应的是MKMapRectNull，是一个空区域，然后combine的方法是(mapRect: MKMapRect, treasure: Treasure) &ndash;> MKMapRect类型的方法，mapRect是每次执行后的返回值，初始值就是initial，而treasure是array每个元素的遍历，最后可以得到一个MKMapRect类型的区域，包含了所有元素的最小区域，然后setVisibleMapRect()，并加了边距来适应其他页面元素，最终达到了目的，Swift中的函数式编程还会在第七章继续讲解。</p>

<p><code>objectivec
reduce(initial: U, combine: (U, T) -&gt; U) -&gt; U
</code></p>

<!--more-->


<h2>Polymorphism</h2>

<p>1.现在又有新需求了，需要不同类型的Treasure在地图上显示Annotation颜色不同，这可以通过多态来实现，首先在父类中添加方法，再在子类中重写该方法：</p>

<p><code>objectivec
//in parent class
func pinColor() -&gt; MKPinAnnotationColor  {
  return MKPinAnnotationColor.Red
}
//in subclass
override func pinColor() -&gt; MKPinAnnotationColor  {
  return MKPinAnnotationColor.Purple
}
</code></p>

<p>2.然后在绘制MKPinAnnotationView那儿调用该方法：</p>

<p><code>objectivec
view.pinColor = treasure.pinColor()
</code></p>

<h3>Dynamic dispatch and final classes</h3>

<p>1.对于上面的Treasure多态，runtime是怎么执行的呢？是靠dynamic dispatch实现的，这一技术其实在OC里用的很普遍，OC作为动态语言，可以在runtime修改所传递的消息，甚至消息的接收者，都是靠动态分发(详细过程可参照前一部的Effective Objective-C2.0的笔记)。<br/>
2.Dynamic dispatch在Swift中依然存在，就是为了实现多态这类特性，不同于OC的消息分发机制，Swift的分发更像C++，它通过virtual tables(简称vtables)来实现。<br/>
3.如上例，当编译器遇到pinColor()调用，因为Treasure有很多子类，它便会去使用vtable去查找，而如果是Treasure的子类调用pinColor()，编译器依然会去先去查找vtable，而不是直接去调用pinColor()方法，因为它并不知道有没有类继续在继承，虽然开发者知道它是没有子类的。<br/>
4.所以通过告知编译器某些类没有子类，会提高app的效率，缩短运行时间，我们可以通过在类型前加final关键字来告知编译器这一信息。</p>

<p><code>objectivec
final class HistoryTreasure: Treasure
</code></p>

<!--more-->


<h2>Adding annotations</h2>

<p>1.继续，新的需求是用户点击每个annotation时弹出一个alertView来告知用户一些信息。因为每个alert提示的信息不同，所以打算将生成alert的任务交给treasure，然后viewController负责显示，采用的是利用protocol技术。<br/>
2.首先在Treasure.swift文件中声明Alertable协议，然后Treasure的子类分别遵循并实现其中的方法。</p>

<p>```objectivec
@objc protocol Alertable {</p>

<pre><code>fun alert() -&gt; UIAlertController
</code></pre>

<p>}
```</p>

<p>```objectivec
extension HistoryTreasure: Alertable {<br/>
  func alert() &ndash;> UIAlertController {</p>

<pre><code>let alert = UIAlertController(title: "History", message: "From \(self.year):\n\(self.what)", preferredStyle: UIAlertControllerStyle.Alert)
return alert
</code></pre>

<p>  }
}
```</p>

<p>3.然后在viewController中实现MapView点击Annotation的委托方法。</p>

<p>```objectivec
func mapView(mapView: MKMapView, annotationView view: MKAnnotationView, calloutAccessoryControlTapped control: UIControl) {
  if let treasure = view.annotation as? Treasure {</p>

<pre><code>if let alertable = treasure as? Alertable {
  let alert = alertable.alert()
  alert.addAction(UIAlertAction(title: "OK", style: UIAlertActionStyle.Default, handler: nil))
  self.presentViewController(alert, animated: true, completion: nil)
}
</code></pre>

<p>  }
}
```</p>

<!--more-->


<h2>Sorting an array</h2>

<p>1.新需求，用户可以在找到第一个treasure后能有选项可以使其找到下一个最近的treasure。首先我们给GeoLocation添加一个计算点之间的方法。</p>

<p><code>objectivec
func distanceBetween(other: GeoLocation) -&gt; Double {
  let locationA = CLLocation(latitude: self.latitude, longitude: self.longitude)
  let locationB = CLLocation(latitude: other.latitude, longitude: other.longitude)
  return locationA.distanceFromLocation(locationB)
}
</code></p>

<p>2.该方法是直接定义在struct的定义中的，Swift中的Struct可以定义方法，这也是它与C的Struct的最大区别，C中的Struct只能定义变量，导致与之相关的方法只能定义为全局方法，而如何按照类型归纳这些方法就需要开发者手工将其写到一个头文件中，这显然费时也不合理，而Swift真正实现了Struct中可以真正拥有自己的方法。<br/>
3.像用户点击Annotation后弹出的alert再添加一个Find Nearest的选项，并实现找到离该点最近的Treasure。</p>

<p>```objectivec
alert.addAction(UIAlertAction(title: &ldquo;Find Nearest&rdquo;, style: UIAlertActionStyle.Default) { action in
  var sortedTreasures = self.treasures
  sortedTreasures.sortInPlace {</p>

<pre><code>let distanceA = treasure.location.distanceBetween($0.location)
let distanceB = treasure.location.distanceBetween($1.location)
return distanceA &lt; distanceB
</code></pre>

<p>  }
  mapView.deselectAnnotation(treasure, animated: true)
  mapView.selectAnnotation(sortedTreasures[1], animated: true)
  })
```</p>

<p>4.上述代码的核心是sortedTreasures的排序，利用了sort()方法(Swift中改为sortInPlace())，$1和$2分别代表了传入方法的第一和第二参数，是简写形式，分别计算出两点距离当前treasure的距离，然后返回Bool告知是否已按照小大顺序排好，最后数组排序后，展示第二个元素，来展示最近的treasure。</p>

<p><code>objectivec
public mutating func sortInPlace(@noescape isOrderedBefore: (Self.Generator.Element, Self.Generator.Element) -&gt; Bool)
</code></p>

<!--more-->


<h2>Equality and operator overload</h2>

<p>1.照例，新需求，需要标记用户发现treasure的路径并在用户在已发现的treasure上操作时提示用户。<br/>
2.创建已找到Treasure的数组和要绘制的地图线，并实现MKMapViewDelegate的一个方法。</p>

<p><code>objectivec
private var foundLocations: [GeoLocation] = []
private var polyline: MKPolyline!
</code></p>

<p>```objectivec
func mapView(mapView: MKMapView, rendererForOverlay overlay: MKOverlay) &ndash;> MKOverlayRenderer {
  if let polylineOverlay = overlay as? MKPolyline {</p>

<pre><code>let renderer = MKPolylineRenderer(polyline: polylineOverlay)
renderer.strokeColor = UIColor.blueColor()
return renderer
</code></pre>

<p>  }
  return nil
}
```</p>

<p>3.在上一节添加alert的位置再添加Found项，再创建markTreasureAsFound()方法来标记已找到的Treasure，并绘制新的MKPolyline。</p>

<p><code>objectivec
alert.addAction(UIAlertAction(title: "Found", style: UIAlertActionStyle.Default) { action in
  self.markTreasureAsFound(treasure)
  })
</code></p>

<p>```objectivec
private func markTreasureAsFound(treasure: Treasure) {
  if let index = self.foundLocations.indexOf(treasure.location) {</p>

<pre><code>let alert = UIAlertController(title: "Oops!", message: "You've already found this treasure (at step \(index + 1))! Try again!", preferredStyle: .Alert)
alert.addAction(UIAlertAction(title: "OK", style: .Default, handler: nil))
self.presentViewController(alert, animated: true, completion: nil)
</code></pre>

<p>  } else {</p>

<pre><code>self.foundLocations.append(treasure.location)
if self.polyline != nil {
  self.mapView.removeOverlay(self.polyline)
}
var coordinates = self.foundLocations.map { $0.coordinate }
self.polyline = MKPolyline(coordinates: &amp;coordinates, count: coordinates.count)
self.mapView.addOverlay(self.polyline)
</code></pre>

<p>  }
}
```</p>

<p>4.首先利用find()函数（Swift2.0已弃用，改为collection的indexOf()方法）来获取目前位置是否已在foundLocations中，返回值为optional类型，所以需要if/let判断，这里就体现了这一技术的便利。<br/>
5.在创建MKPolyline时，先对foundLocations使用了map方法，map如前面提到的reduce一样，也是函数式编程的一种，它的作用是从一个数组中获取另外一个数组，这里就是从foundLocations得到了由其中每一个location的coordinate组成的新数组，$0代表每一个location。<br/>
6.这里需要实现find()方法（实际在Swift2.0已弃用），需要在GeoLocation中遵循Equatable协议，，因为find()中比较每个元素是通过==来比较的（类似OC中的isEqual()），而Class和Struc默认是不能用==比较的。这里用到了Swift的又一新特性，operator overload，既可以直接重写==这样的操作符，但需要注意下面对==的重写，并没有包含在extension中，因为operation overload都必须在定义在全局中，因为它本身并不属于某个类，它只是与一个类有关，基于要比较的的两个参数是这个类的实例。</p>

<p><code>objectivec
protocol Equatable {    func ==(lhs: Self, rhs: Self) -&gt; Bool}
</code></p>

<p><code>objectivec
extension GeoLocation: Equatable {
}
func ==(lhs: GeoLocation, rhs: GeoLocation) -&gt; Bool {
  return lhs.latitude == rhs.latitude &amp;&amp; lhs.longitude == rhs.longitude
}
</code></p>

<!--more-->


<h2>Access Control</h2>

<p>1.目前为止所有变量和方法都是public的，但Swift提供了访问权限的关键字，包括：Public(所有代码均可访问)、Internal(只在该target(library或app)下的代码可以访问，是默认权限)、Private(只有该文件可以访问)。<br/>
2.例如有一些类中的帮助方法，你不希望暴露在外，因为他们可以改变着一些不该暴露的内部状态信息。<br/>
3.需要注意的是Unit test通常是另外一个Target，如果你的代码有部分需要单元测试，那么需要声明为public。<br/>
4.与OC相比，OC是没有绝对的私有方法的，因为即使没有暴露在在头文件中，也可以通过runtime注入来访问私有方法。</p>

<p><code>objectivec
private func markTreasureAsFound(treasure: Treasure)
</code></p>

<p><code>objectivec
private var treasures: [Treasure] = []private var foundLocations: [GeoLocation] = [] private var polyline: MKPolyline!
</code></p>

<p>5.internal一般是不会显式声明的，如果是一个library被多个app使用，你可能会将内部类声明为internal，这样就不会被其他app中的代码使用了。<br/>
6.访问控制标志是表达你代码意图的很好的方式，可以使代码更易维护，也会减少Bug，</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Language Basics II]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/10/swift-by-tutorials-language-basics-ii/"/>
    <updated>2015-10-10T14:41:12+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/10/swift-by-tutorials-language-basics-ii</id>
    <content type="html"><![CDATA[<p>继上一篇后，本章将继续介绍Swift的基础知识，但是相比第一章会有所提升，包括了Optional类型对象的用法、Swift中的Collection类型用法以及与OC的Collection的不同之处。</p>

<!--more-->


<h2>Optionals</h2>

<p>1.空指针是一个困扰着各类语言的常见问题，在Java中，调用了空指针会直接抛出异常，在OC中向nil指针发送消息会返回nil，也就是说空指针是安全的，但有很多时候你并不希望指针为空，一般会加判断对象是否为nil的断言判断，但在Swift中，针对这个问题，有了新的解决方案。<br/>
2.Swift在对没有初始化赋值的变量使用时，会直接报错，而且像String类型也不能初始化直接赋nil值，这也保证了空指针不会出现。但是如果我们真的需要一个空值的变量怎么办呢？可以使用optional机制，它是用来指明一个变量是可能有值的，相当于给变量一个nil的默认值，这也是空指针的问题所在，它是一个合法的指针，但没有指向一个合法的对象。</p>

<h3>Declaring optionals</h3>

<p>1.使用optional很简单，如下，不赋值的话str默认为nil，在这里你可以把String?理解为一个不同于String的类型，所以能给String?直接赋值String类型实际上是Swift在内部进行了封装，Swift将String的值封装到了一个String?类型的实例中，然后再赋值给了str。</p>

<p><code>objectivec
//no assignment
var str: String?
//an assignment
var str: String? = "Swift by Tutorials!"
</code></p>

<p>2.如果你现在对str使用uppercaseString方法，会报错，这也验证了上面所说String?已是另一个类型的说法，那么如何让str使用String的方法呢？如下即可，通过if语句对str进行解封，并将其赋值给一个let型的String，这就是optional和if在Swift中的经典配合，这么做的好处就是让开发者可以在必选确认指针不为空的时候强制去进行空指针的检查。</p>

<p>```objectivec
if let unwrappedStr = str {</p>

<pre><code>print("Unwrapped! \(unwrappedStr.uppercaseString)")
</code></pre>

<p>} else {</p>

<pre><code>print("Was nil")
</code></pre>

<p>}
```</p>

<h3>Forced unwrapping</h3>

<p>1.在你了解optional机制下，在一些optional中你确定有值的时候，你可以使用强制解封，如下：</p>

<p><code>objectivec
var str: String? = "Swift by Tutorials!"
print("Force unwrapped! \(str!.uppercaseString)")
</code></p>

<p>2.但是需要注意的是，如果optional类型中的是nil值，那么会出现runtime error，所以使用强制解封，<strong>一定要在你100%确定你的optional对象不是空值</strong>。</p>

<h3>Implicit unwrapping</h3>

<p>1.你也可以不用!或者let来进行optional解封，使用以下方法，可以直接对变量使用方法，这看起来和没使用optional差不多，但是它在实质上和上述两种解封方法是一致的，只是语法不通而已，如果不去初始化赋值，那么你会得到和强制解封一个nil的optional的值一样的error。</p>

<p><code>objectivec
var str: String! = "Swift by Tutorials!"
str = str.lowercaseString
print(str)
</code></p>

<p>2.你也可以通过if来检查隐式解封的optional值，但你会发现这和OC中的做法一样，只不过在OC中你拿nil作为一个false的判断条件，而在Swift中你将nil作为一个无值的状态来判断。</p>

<p>```objectivec
if str != nil {</p>

<pre><code>str = str.lowercaseString
print(str)
</code></pre>

<p>}
```</p>

<p>3.<strong>最后注意，你要将隐式解封和强制解封一样重视，因为除了声明的地方，它和普通变量是一样的，这很容易忽视。</strong></p>

<h3>Optional chaining</h3>

<p>1.最后要介绍的是Optional chaining，这是上述三个解封方式之外的另一种optional来执行方法的方式，它的设计参照了OC中常用的delegate模式，即在optional类型变量执行方法时会先判断它是否为nil，不是nil的话直接执行，而如果是nil的话，则直接返回nil，其实和OC中对nil发送消息的处理是一样的。</p>

<p><code>objectivec
var maybeString: String? = "Swift by Tutorials!"
let uppercase = maybeString?.uppercaseString
</code></p>

<p>2.由于在对象声明和方法执行时两次使用optional，所以形成了Optional chaining。</p>

<!--more-->


<h2>Collection</h2>

<p>1.任何语言都会有集合类型，OC中有NSArray、NSDictionary、NSSet，其中包含可变和不可变类型，而在Swift中只保留了Array和Dictionary两种类型。</p>

<h3>Arrays</h3>

<p>1.Swift的Array有着其他语言中共同的特性，如下：</p>

<p><code>objectivec
//initialize array
var array = [1, 2, 3, 4, 5]
print(array[2])
//add an element
array.append(6)
print(array)
</code></p>

<p>2.Swift中你可以通过添加一个序列来扩展一个Array，比如上一节提到的Range。</p>

<p><code>objectivec
//add 7,8,9,10
//Swift2.0中将extend()改为了appendContentsOf()
//array.extend(7...10)
array.appendContentsOf(7...10)
</code></p>

<p>3.在上述数组中试图添加一个String，会直接报错，这在OC中可能是很正常的需求，可以在一个数组中添加不同类型的对象，但在Swift中只能在一个数组中添加同一类型的对象，在上面的Array初始化中是使用了type interface，如果制定类型声明的话应该是<em>var array: Array<Int> = [1, 2, 3, 4, 5]</em>（会在第四章详细说明），不过更常见的写法是<em>var arrray: [Int] = [1, 2, 3, 4, 5]</em>，这是Apple的语法糖，用来简化语法。</p>

<p><code>objectivec
//Array Initializer
var array: Array&lt;Int&gt; = [1, 2, 3, 4, 5]
var arrray: [Int] = [1, 2, 3, 4, 5]
</code></p>

<p>4.当然也可以让Array像NSArray那样工作，可以将类型声明为Array<Any>，但是仍然不推荐这么做，因为这样Swift的很多Array方法会因为类型不一而不能使用，而且也会失去Swift的提供的安全性保护。</p>

<p><code>objectivec
//add multiple type instance
var array: Array&lt;Any&gt; = []
array.append(6)
array.append("Swift By Tutorials!")
</code></p>

<h3>Dictionaries</h3>

<p>1.Swift的Dictionary与OC的NSDicionary大致相同，只是语法上略有变化，但需要注意的是，Dictionary也存在只能添加固定类型的键值对的情况，与上述的Array相同。</p>

<p><code>objectivec
var dictionary = [1: "Dog", 2: "Cat"]
//Another Initializer
//var dictionary: Dictionary&lt;Int:String&gt; = [1: "Dog", 2: "Cat"]
//var dictionary: [Int:String] = [1: "Dog", 2: "Cat"]
print(dictionary[1])
dictionary[3] = "Mouse"
print(dictionary)
dictionary[3] = nil
print(dictionary)
</code></p>

<p>2.从Dictionary中通过key直接获取值时，该值是optional类型的，因为有可能是不存在该key对应的值的，所以推荐读取Dictionary时还是使用上一章中介绍的安全拆解的方法，这又是Swift强制开发者随时考虑安全问题的一个表现。</p>

<p>```objectivec
if let value = dictionary[1] {</p>

<pre><code>print("Value is \(value)")
</code></pre>

<p>}
```</p>

<h3>Reference and copies</h3>

<p>1.这一节讨论Dictionary和Array在Swift中与OC所不同的内存管理策略，如下，从结果发现，Swift中将一个Dictionary直接赋值给另外的变量或常量，都是执行copy操作的，即改变新变量，并不会影响原来的Dictionary。</p>

<p><code>objectivec
var dictionaryA = [1: 1, 2: 4, 3: 9, 4: 16]
var dictionaryB = dictionaryA
print(dictionaryA)
print(dictionaryB)
dictionaryB[4] = nil
print(dictionaryA)
print(dictionaryB)
</code></p>

<p>2.那么关于Array呢？答案是一样的，Array也是会执行copy操作，这与OC中的NSDictionary和NSArray的指针赋值是完全不同的，所以单独强调一下。</p>

<p><code>objectivec
var arrayA = [1, 2, 3, 4, 5]
var arrayB = arrayA
print(arrayA)
print(arrayB)
arrayB.removeAtIndex(0)
print(arrayA)
print(arrayB)
</code></p>

<h3>Constant collection</h3>

<p>1.上面都是定义的var类型的Dictionary和Array，那么如果定义为let的话，Dictionary和Array是不能进行任何修改操作的（其实就是OC中的不可变类型）。</p>

<p><code>objectivec
let constantArray = [1, 2, 3, 4, 5]
//error
constantArray.append(6)
constantArray.removeAtIndex(0)
</code></p>
]]></content>
  </entry>
  
</feed>
