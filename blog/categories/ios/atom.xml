<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 刘毅的技术博客]]></title>
  <link href="http://lucifer1988.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://lucifer1988.github.io/"/>
  <updated>2015-10-30T14:34:07+08:00</updated>
  <id>http://lucifer1988.github.io/</id>
  <author>
    <name><![CDATA[刘毅]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[回答Sunny的55道iOS面试题1]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1/"/>
    <updated>2015-10-28T15:32:57+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/28/hui-da-sunnyde-55dao-iosmian-shi-ti-1</id>
    <content type="html"><![CDATA[<p>百度知道的<a href="http://weibo.com/u/1364395395">微博@我就叫Sunny怎么了</a>出了55道iOS的面试题，很多题目是很有深度，现在自己尝试解一下这些题，并付上大神给出的答案。</p>

<!--more-->


<h3>1. 风格纠错题</h3>

<p><img src="http://i.imgur.com/O7Zev94.png" alt="enter image description here" /></p>

<p><strong>我的解答：</strong></p>

<p>```objectivec
typedef NS_ENUM(NSInteger, CCUserSex) {</p>

<pre><code>CCUserSexMan = 0,
CCUserSexWoman
</code></pre>

<p>}
@interface CCUser : NSObject
@property(nonatomic, copy)NSString <em>name;
@property(nonatomic, assign)NSUInteger age;
@property(nonatomic, assign)CCUserSex sex;
+(instancetype)userWithName:(NSString </em>)name age:(NSUInteger)age;
&ndash;(instancetype)initWithName:(NSString *)name age:(NSUInteger)age;</p>

<p>&ndash;(void)login;
```</p>

<p><strong>大神解答：</strong></p>

<p>```objectivec
// .h文件
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
// 修改完的代码，这是第一种修改方法，后面会给出第二种修改方法</p>

<p>typedef NS_ENUM(NSInteger, CYLSex) {</p>

<pre><code>CYLSexMan,
CYLSexWoman
</code></pre>

<p>};</p>

<p>@interface CYLUser : NSObject<NSCopying></p>

<p>@property (nonatomic, readonly, copy) NSString *name;
@property (nonatomic, readonly, assign) NSUInteger age;
@property (nonatomic, readonly, assign) CYLSex sex;</p>

<ul>
<li>(instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</li>
<li>(instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</li>
</ul>


<p>@end
```</p>

<p> 详解：</p>

<p> 1.enum建议使用NS_ENUM和NS_OPTIONS来定义，这是Apple推荐的枚举定义宏，主要是可以通过它来指定type的类型。<br/>
 2.数值型变量尽量使用Foundation的数据类型，而不要使用c的类型，主要是为了适配不同处理器而考虑的。<br/>
 3.大的工程必须在类前加前缀作为命名空间。<br/>
 4.命名习惯，通常情况下，即使有类似 withA:withB: 的命名需求，也通常是使用withA:andB: 这种命名，用来表示方法执行了两个相对独立的操作（从设计上来说，这时候也可以拆分成两个独立的方法），它不应该用作阐明有多个参数，比如下面的：</p>

<p><code>objectivec
 //错误，不要使用"and"来连接参数
- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;
//错误，不要使用"and"来阐明有多个参数
- (instancetype)initWithName:(CGFloat)name andAge:(CGFloat)age;
//正确，使用"and"来表示两个相对独立的操作
- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;
</code></p>

<p> 5.一些有可变类型的类型，如NSString、NSArray、NSDictionary，经常使用copy来命名property，为了避免将可变类型赋给当前对象，然后在外部改变数值，而对当前类型产生影响。<br/>
 6.OC有designated和secondary初始化方法的概念。 designated初始化方法是提供所有的参数，secondary初始化方法是一个或多个，并且提供一个或者更多的默认参数来调用designated初始化方法的初始化方法。子类在继承父类时，可以添加新的secondary初始化方法，但必须在内部调用父类的designated初始化方法，而且也必须重写父类暴露的secondary初始化方法。</p>

<h3>2. 什么情况使用 weak 关键字，相比 assign 有什么不同？</h3>

<p> <strong>我的解答：</strong><br/>
weak关键字一般用于xib导出的IBOutlet类型控件的变量声明，和delegate的声明，主要用于避免循环引用。相比assign，weak也是不会改变对象的retain count，但是weak只能用于object的property声明，而assign一般用于数值型变量的property声明。</p>

<p> <strong>大神解答：</strong></p>

<ol>
<li>在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性</li>
<li>自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。</li>
</ol>


<p>不同点：</p>

<ol>
<li><p><code>weak</code> 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，
然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。
而 <code>assign</code> 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或
NSlnteger 等)的简单赋值操作。</p></li>
<li><p>assigin 可以用非 OC 对象,而 weak 必须用于 OC 对象</p></li>
</ol>


<h3>3. 怎么用 copy 关键字？</h3>

<p><strong>我的解答：</strong></p>

<ol>
<li>copy一般用于property时是用于NSString、NSArray、NSDictionary这些有可变类型，原因为了避免将可变类型赋给当前对象，然后在外部改变数值，而对当前类型产生影响。</li>
<li>然后也经常适用于block类型的property赋值，原因是block声明时是被存放在栈中，如果不使用copy对其操作，将其拷贝到堆上，那么该block会在其声明的作用域失效时被释放。</li>
</ol>


<p><strong>大神解答：</strong></p>

<ol>
<li>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</li>
<li>block 也经常使用 copy 关键字，具体原因见<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12">官方文档：<strong><em>Objects Use Properties to Keep Track of Blocks</em></strong></a>：</li>
</ol>


<p>  block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。</p>

<p><img src="http://i.imgur.com/VlVKl8L.png" alt="enter image description here" /></p>

<p>下面做下解释：
 copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。
当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>

<blockquote><p>用 <code>@property</code> 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p></blockquote>

<h3>4. 这个写法会出什么问题： <code>@property (copy) NSMutableArray *array;</code></h3>

<p><strong>我的解答：</strong></p>

<p>对NSMutableArray执行copy操作，会返回NSArray类型的对象，那么给array赋值一个NSMutabeArray后，再对其经行修改操作，会出现错误。</p>

<p><strong>大神解答：</strong></p>

<p>两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；2、使用了 atomic 属性会严重影响性能 ；</p>

<p>比如下面的代码就会发生崩溃</p>

<p>```objectivec
// .h文件
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
// 下面的代码就会发生崩溃</p>

<p>@property (nonatomic, copy) NSMutableArray *mutableArray;
```</p>

<p>```objectivec
// .m文件
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
// 下面的代码就会发生崩溃</p>

<p>NSMutableArray *array = [NSMutableArray arrayWithObjects:@1,@2,nil];
self.mutableArray = array;
[self.mutableArray removeObjectAtIndex:0];
```</p>

<p>接下来就会崩溃：</p>

<p><code>objectivec
 -[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460
</code></p>

<p>第2条原因，如下：</p>

<blockquote><p>该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销。</p></blockquote>

<p>在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic))。</p>

<p>在iOS开发中，你会发现，几乎所有属性都声明为 nonatomic。</p>

<p>一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。</p>

<p>因此，开发iOS程序时一般都会使用 nonatomic 属性。但是在开发 Mac OS X 程序时，使用
 atomic 属性通常都不会有性能瓶颈。</p>

<h3>5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</h3>

<p><strong>我的解答：</strong></p>

<p>1.要让自己的类实现NSCopying协议的方法，也就是<strong>&ndash; (id)copyWithZone:(NSZone *)zone;</strong>方法。<br/>
2.重写copy的setter：</p>

<p>```objectivec
&ndash;(void)setCopyProperty:(id)copyProperty{</p>

<pre><code>_copyProperty = [copyProperty copy];
</code></pre>

<p>}
```</p>

<p><strong>大神解答：</strong></p>

<blockquote><p>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 <code>NSCopying</code> 与 <code>NSMutableCopying</code> 协议。</p></blockquote>

<p>具体步骤：</p>

<ol>
<li>需声明该类遵从 NSCopying 协议</li>
<li>实现 NSCopying 协议。该协议只有一个方法:</li>
</ol>


<p><code>objectivec
- (id)copyWithZone:(NSZone *)zone;
</code>
注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。</p>

<p>以第一题的代码为例：</p>

<p>```objectivec</p>

<pre><code>// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 修改完的代码

typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

@interface CYLUser : NSObject&lt;NSCopying&gt;

@property (nonatomic, readonly, copy) NSString *name;
@property (nonatomic, readonly, assign) NSUInteger age;
@property (nonatomic, readonly, assign) CYLSex sex;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;

@end
</code></pre>

<p>```</p>

<p>然后实现协议中规定的方法：</p>

<p>```objectivec
&ndash; (id)copyWithZone:(NSZone *)zone {</p>

<pre><code>CYLUser *copy = [[[self class] allocWithZone:zone] 
                 initWithName:_name
                              age:_age
                              sex:_sex];
return copy;
</code></pre>

<p>}
```
但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如 CYLUser 中含有一个数组，与其他 CYLUser 对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码:</p>

<p>```objectivec
// .h文件
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
// 以第一题《风格纠错题》里的代码为例</p>

<p>typedef NS_ENUM(NSInteger, CYLSex) {</p>

<pre><code>CYLSexMan,
CYLSexWoman
</code></pre>

<p>};</p>

<p>@interface CYLUser : NSObject<NSCopying></p>

<p>@property (nonatomic, readonly, copy) NSString *name;
@property (nonatomic, readonly, assign) NSUInteger age;
@property (nonatomic, readonly, assign) CYLSex sex;</p>

<ul>
<li>(instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</li>
<li>(instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</li>
<li>(void)addFriend:(CYLUser *)user;</li>
<li>(void)removeFriend:(CYLUser *)user;</li>
</ul>


<p>@end
```</p>

<p>// .m文件</p>

<p>```objectivec
// .m文件
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
//</p>

<p>@implementation CYLUser {</p>

<pre><code>NSMutableSet *_friends;
</code></pre>

<p>}</p>

<ul>
<li><p>(void)setName:(NSString *)name {
  _name = [name copy];
}</p></li>
<li><p>(instancetype)initWithName:(NSString *)name
                       age:(NSUInteger)age
                       sex:(CYLSex)sex {
  if(self = [super init]) {
      <em>name = [name copy];
      </em>age = age;
      <em>sex = sex;
      </em>friends = [[NSMutableSet alloc] init];
  }
  return self;
}</p></li>
<li><p>(void)addFriend:(CYLUser *)user {
  [_friends addObject:user];
}</p></li>
<li><p>(void)removeFriend:(CYLUser *)user {
  [_friends removeObject:person];
}</p></li>
<li><p>(id)copyWithZone:(NSZone <em>)zone {
  CYLUser </em>copy = [[[self class] allocWithZone:zone]
                   initWithName:<em>name
                   age:</em>age
                   sex:<em>sex];
  copy-></em>friends = [_friends mutableCopy];
  return copy;
}</p></li>
<li><p>(id)deepCopy {
  CYLUser *copy = [[[self class] allocWithZone:zone]
                   initWithName:<em>name
                   age:</em>age
                   sex:<em>sex];
  copy-></em>friends = [[NSMutableSet alloc] initWithSet:_friends
                                           copyItems:YES];
  return copy;
}</p></li>
</ul>


<p>@end</p>

<p>```</p>

<p>以上做法能满足基本的需求，但是也有缺陷：</p>

<blockquote><p>如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。</p></blockquote>

<p>【注：深浅拷贝的概念，在下文中有介绍，详见下文的：<strong><em>用@property声明的 NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？</em></strong>】</p>

<p>在例子中，存放朋友对象的 set 是用 “copyWithZone:” 方法来拷贝的，这种浅拷贝方式不会逐个复制 set 中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法:</p>

<p>```objectivec
&ndash; (id)deepCopy {</p>

<pre><code>CYLUser *copy = [[[self class] allocWithZone:zone]
                 initWithName:_name
                 age:_age
                 sex:_sex];
copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends
                                         copyItems:YES];
return copy;
</code></pre>

<p>}</p>

<p>```</p>

<p>至于<strong><em>如何重写带 copy 关键字的 setter</em></strong>这个问题，</p>

<p>如果抛开本例来回答的话，如下：</p>

<p>```objectivec
&ndash; (void)setName:(NSString *)name {</p>

<pre><code>//[_name release];
_name = [name copy];
</code></pre>

<p>}
```</p>

<p>不过也有争议，有人说“苹果如果像下面这样干，是不是效率会高一些？”</p>

<p>```objectivec
&ndash; (void)setName:(NSString *)name {</p>

<pre><code>if (_name != name) {
    //[_name release];//MRC
    _name = [name copy];
}
</code></pre>

<p>}
```</p>

<p>这样真得高效吗？不见得！这种写法“看上去很美、很合理”，但在实际开发中，它更像下图里的做法：</p>

<p><img src="http://i.imgur.com/UwV9oSn.jpeg" alt="enter image description here" /></p>

<p>克强总理这样评价你的代码风格：</p>

<p><img src="http://i.imgur.com/N77Lkic.png" alt="enter image description here" /></p>

<p>我和总理的意见基本一致：</p>

<blockquote><p>老百姓 copy 一下，咋就这么难？</p></blockquote>

<p>你可能会说：</p>

<p>之所以在这里做<code>if判断</code> 这个操作：是因为一个 if 可能避免一个耗时的copy，还是很划算的。
(在刚刚讲的：《如何让自己的类用 copy 修饰符？》里的那种复杂的copy，我们可以称之为 “耗时的copy”，但是对 NSString 的 copy 还称不上。)</p>

<p>但是你有没有考虑过代价：</p>

<blockquote><p>你每次调用 <code>setX:</code> 都会做 if 判断，这会让 <code>setX:</code> 变慢，如果你在 <code>setX:</code>写了一串复杂的 <code>if+elseif+elseif+...</code> 判断，将会更慢。</p></blockquote>

<p>要回答“哪个效率会高一些？”这个问题，不能脱离实际开发，就算 copy 操作十分耗时，if 判断也不见得一定会更快，除非你把一个“ @property他当前的值 ”赋给了他自己，代码看起来就像：</p>

<p><code>objectivec
[a setX:x1];
[a setX:x1];    //你确定你要这么干？与其在setter中判断，为什么不把代码写好？
</code></p>

<p>或者</p>

<p><code>objectivec
[a setX:[a x]];   //队友咆哮道：你在干嘛？！！
</code></p>

<blockquote><p>不要在 setter 里进行像 <code>if(_obj != newObj)</code> 这样的判断。（该观点参考链接：<a href="http://vgable.com/blog/tag/autorelease/"> <strong><em>How To Write Cocoa Object Setters： Principle 3: Only Optimize After You Measure</em></strong> </a>
）</p></blockquote>

<p>什么情况会在 copy setter 里做 if 判断？
例如，车速可能就有最高速的限制，车速也不可能出现负值，如果车子的最高速为300，则 setter 的方法就要改写成这样：</p>

<p>```objectivec
&ndash;(void)setSpeed:(int)_speed{</p>

<pre><code>if(_speed &lt; 0) speed = 0;
if(_speed &gt; 300) speed = 300;
_speed = speed;
</code></pre>

<p>}
```</p>

<p>回到这个题目，如果单单就上文的代码而言，我们不需要也不能重写 name 的 setter ：由于是 name 是只读属性，所以编译器不会为其创建对应的“设置方法”，用初始化方法设置好属性值之后，就不能再改变了。（ 在本例中，之所以还要声明属性的“内存管理语义”&mdash;copy，是因为：如果不写 copy，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而低效）。</p>

<p>那如何确保 name 被 copy？在初始化方法(initializer)中做：</p>

<p>```objectivec</p>

<pre><code>- (instancetype)initWithName:(NSString *)name 
                             age:(NSUInteger)age 
                             sex:(CYLSex)sex {
     if(self = [super init]) {
        _name = [name copy];
        _age = age;
        _sex = sex;
        _friends = [[NSMutableSet alloc] init];
     }
     return self;
}
</code></pre>

<p>```</p>

<h3>6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h3>

<p><strong>我的解答：</strong></p>

<ol>
<li>@property本质就是自动为变量创建对应的setter，getter的快捷语法。</li>
<li>额，不会。</li>
</ol>


<p><strong>大神解答：</strong></p>

<p><strong>@property 的本质是什么？</strong></p>

<blockquote><p>@property = ivar + getter + setter;</p></blockquote>

<p>下面解释下：</p>

<blockquote><p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p></blockquote>

<p>“属性” (property)作为 objectivec 的一项特性，主要的作用就在于封装对象中的数据。 objectivec 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 <code>objectivec 2.0</code> 的一部分。
而在正规的 objectivec 编码风格中，存取方法有着严格的命名规范。
正因为有了这种严格的命名规范，所以 objectivec 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p>

<blockquote><p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。
所以你也可以这么说：</p>

<p>@property = getter + setter;</p></blockquote>

<p>例如下面这个类：</p>

<p><code>objectivec
@interface Person : NSObject
@property NSString *firstName;
@property NSString *lastName;
@end
</code></p>

<p>上述代码写出来的类与下面这种写法等效：</p>

<p><code>objectivec
@interface Person : NSObject
- (NSString *)firstName;
- (void)setFirstName:(NSString *)firstName;
- (NSString *)lastName;
- (void)setLastName:(NSString *)lastName;
@end
</code></p>

<p><strong>ivar、getter、setter 是如何生成并添加到这个类中的?</strong></p>

<blockquote><p>“自动合成”( autosynthesis)</p></blockquote>

<p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译
器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为
 <code>_firstName</code> 与 <code>_lastName</code>。也可以在类的实现代码里通过
 <code>@synthesize</code> 语法来指定实例变量的名字.</p>

<p><code>objectivec
@implementation Person
@synthesize firstName = _myFirstName;
@synthesize lastName = _myLastName;
@end
</code></p>

<p>我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西</p>

<ol>
<li><code>OBJC_IVAR_$类名$属性名称</code> ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。</li>
<li>setter 与 getter 方法对应的实现函数</li>
<li><code>ivar_list</code> ：成员变量列表</li>
<li><code>method_list</code> ：方法列表</li>
<li><code>prop_list</code> ：属性列表</li>
</ol>


<p>也就是说我们每次在增加一个属性,系统都会在 <code>ivar_list</code> 中添加一个成员变量的描述,在 <code>method_list</code> 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</p>

<h3>7. @protocol 和 category 中如何使用 @property</h3>

<p><strong>我的解答：</strong></p>

<p>理论上说@protocol和category是不能使用@property，主要是声明property后，不能自动合成setter、getter方法，所以无法使用变量，不过确实存在需要时，可以使用associated objects技术为其绑定对象，作为实例变量的代替。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性</li>
<li><p>category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：</p></li>
<li><p> <code>objc_setAssociatedObject</code></p></li>
<li> <code>objc_getAssociatedObject</code></li>
</ol>


<h3>8. runtime 如何实现 weak 属性</h3>

<p><strong>我的解答：</strong></p>

<p>额，不会。</p>

<p><strong>大神解答：</strong></p>

<p>要实现 weak 属性，首先要搞清楚 weak 属性的特点：</p>

<blockquote><p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p></blockquote>

<p>那么 runtime 如何实现 weak 变量的自动置nil？</p>

<blockquote><p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p></blockquote>

<h3>9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</h3>

<p><strong>我的解答：</strong></p>

<p>有atomic、nonatomic、retain、assign、copy、strong（ARC）、weak（ARC）、readonly、readwrite，另外有指定setter和getter方法的关键字setter=setXXX、getter=xxx，最后一个在BOOL型对象时常用getter=isXXX来替代getter方法。</p>

<p><strong>大神解答：</strong></p>

<p>属性可以拥有的特质分为四类:</p>

<ol>
<li><p>原子性&mdash;&ndash; <code>nonatomic</code> 特质</p>

<p>在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。</p></li>
<li><p>读/写权限&mdash;&ndash;<code>readwrite(读写)</code>、<code>readonly (只读)</code></p></li>
<li>内存管理语义&mdash;&ndash;<code>assign</code>、<code>strong</code>、 <code>weak</code>、<code>unsafe_unretained</code>、<code>copy</code></li>
<li>方法名&mdash;&ndash;<code>getter=&lt;name&gt;</code> 、<code>setter=&lt;name&gt;</code></li>
</ol>


<p>  <code>getter=&lt;name&gt;</code>的样式：</p>

<p>```objectivec</p>

<pre><code>    @property (nonatomic, getter=isOn) BOOL on;
</code></pre>

<p><code>``
 &lt;p&gt;&lt;del&gt;（</code>setter=<name>`这种不常用，也不推荐使用。故不在这里给出写法。）
</del></p></p>

<p> <code>setter=&lt;name&gt;</code>一般用在特殊的情境下，比如：</p>

<p>在数据反序列化、转模型的过程中，服务器返回的字段如果以 <code>init</code> 开头，所以你需要定义一个 <code>init</code> 开头的属性，但默认生成的 <code>setter</code> 与 <code>getter</code> 方法也会以 <code>init</code> 开头，而编译器会把所有以 <code>init</code> 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。</p>

<p>这时你就可以使用下面的方式来避免编译器报错：</p>

<p>```objectivec
@property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:)NSString *initBy;</p>

<p>```</p>

<p>另外也可以用关键字进行特殊说明，来避免编译器报错：</p>

<p><code>objectivec
@property(nonatomic, readwrite, copy, null_resettable) NSString *initBy;
- (NSString *)initBy __attribute__((objc_method_family(none)));
</code></p>

<ol>
<li>不常用的：<code>nonnull</code>,<code>null_resettable</code>,<code>nullable</code></li>
</ol>


<h3>10. weak属性需要在dealloc中置nil么？</h3>

<p><strong>我的解答：</strong></p>

<p>不需要，weak属性的变量，在其所指向内存释放后，会自动指向nil，成为空指针。</p>

<p><strong>大神解答：</strong></p>

<p>不需要。</p>

<blockquote><p>在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理</p></blockquote>

<p>即便是编译器不帮我们做这些，weak也不需要在 dealloc 中置nil：</p>

<p>正如上文的：<strong><em>runtime 如何实现 weak 属性</em></strong> 中提到的：</p>

<p>我们模拟下 weak 的 setter 方法，应该如下：</p>

<p>```objectivec
&ndash; (void)setObject:(NSObject *)object
{</p>

<pre><code>objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);
[object cyl_runAtDealloc:^{
    _object = nil;
}];
</code></pre>

<p>}
```</p>

<p>也即:</p>

<blockquote><p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p></blockquote>

<h3>11. @synthesize和@dynamic分别有什么作用？</h3>

<p><strong>我的解答：</strong></p>

<p>@synthesize用于合成声明的property的实例变量和其setter、getter方法，并可以在其后面声明对应的内部变量，目前已不需要手写@synthesize操作，系统会对property执行autosynthesize操作。而@dynamic声明的变量，是告诉系统该变量没有显式的setter、getter方法，但是会在运行时为其添加setter/getter方法，常用于CoreData变量的声明，不是很常用。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是<code>@syntheszie var = _var;</code></li>
<li>@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。</li>
<li>@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 <code>instance.var = someVar</code>，由于缺 setter 方法会导致程序崩溃；或者当运行到 <code>someVar = var</code> 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</li>
</ol>


<h3>12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h3>

<p><strong>我的解答：</strong></p>

<p>默认添加的关键字有atomic，readwrite，assign。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>对应基本数据类型默认关键字是<br/>
atomic,readwrite,assign</li>
<li>对于普通的 objectivec 对象<br/>
atomic,readwrite,strong</li>
</ol>


<p>参考链接：</p>

<ol>
<li><p><a href="http://stackoverflow.com/a/15541801/3395008"> <strong><em>objectivec ARC: strong vs retain and weak vs assign</em></strong> </a></p></li>
<li><p><a href="http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html"> <strong><em>Variable property attributes or Modifiers in iOS</em></strong> </a></p></li>
</ol>


<h3>13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h3>

<p><strong>我的解答：</strong></p>

<p>上面答过。</p>

<p><strong>大神解答：</strong></p>

<ol>
<li>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.</li>
<li>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.</li>
</ol>


<p> copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。
当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>

<p>举例说明：</p>

<p>定义一个以 strong 修饰的 array：</p>

<p><code>objectivec
@property (nonatomic ,readwrite, strong) NSArray *array;
</code></p>

<p>然后进行下面的操作：</p>

<p>```objectivec</p>

<pre><code>NSMutableArray *mutableArray = [[NSMutableArray alloc] init];
NSArray *array = @[ @1, @2, @3, @4 ];
self.array = mutableArray;
[mutableArray removeAllObjects];;
NSLog(@"%@",self.array);

[mutableArray addObjectsFromArray:array];
self.array = [mutableArray copy];
[mutableArray removeAllObjects];;
NSLog(@"%@",self.array);
</code></pre>

<p>```</p>

<p>打印结果如下所示：</p>

<p>```objectivec
2015-09-27 19:10:32.523 CYLArrayCopyDmo[10681:713670] (
)
2015-09-27 19:10:32.524 CYLArrayCopyDmo[10681:713670] (</p>

<pre><code>1,
2,
3,
4
</code></pre>

<p>)
```</p>

<p>（详见仓库内附录的 Demo。）</p>

<p>为了理解这种做法，首先要知道，两种情况：</p>

<ol>
<li>对非集合类对象的 copy 与 mutableCopy 操作；</li>
<li>对集合类对象的 copy 与 mutableCopy 操作。</li>
</ol>


<h4>1. 对非集合类对象的copy操作：</h4>

<p>在非集合类对象中：对 immutable 对象进行 copy 操作，是指针复制，mutableCopy 操作时内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：</p>

<ul>
<li>[immutableObject copy] // 浅复制</li>
<li>[immutableObject mutableCopy] //深复制</li>
<li>[mutableObject copy] //深复制</li>
<li>[mutableObject mutableCopy] //深复制</li>
</ul>


<p>比如以下代码：</p>

<p><code>objectivec
NSMutableString *string = [NSMutableString stringWithString:@"origin"];//copy
NSString *stringCopy = [string copy];
</code></p>

<p>查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：</p>

<p><code>objectivec
[string appendString:@"origion!"]
</code></p>

<p>stringCopy 的值也不会因此改变，但是如果不使用 copy，stringCopy 的值就会被改变。
  集合类对象以此类推。
所以，</p>

<blockquote><p>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p></blockquote>

<h4>2、集合类对象的copy与mutableCopy</h4>

<p>集合类对象是指 NSArray、NSDictionary、NSSet &hellip; 之类的对象。下面先看集合类immutable对象使用 copy 和 mutableCopy 的一个例子：</p>

<p><code>objectivec
NSArray *array = @[@[@"a", @"b"], @[@"c", @"d"]];
NSArray *copyArray = [array copy];
NSMutableArray *mCopyArray = [array mutableCopy];
</code></p>

<p>查看内容，可以看到 copyArray 和 array 的地址是一样的，而 mCopyArray 和 array 的地址是不同的。说明 copy 操作进行了指针拷贝，mutableCopy 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 array 这个对象，array 集合内部的元素仍然是指针拷贝。这和上面的非集合 immutable 对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看 mutable 对象拷贝的例子：</p>

<p><code>objectivec
NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@"a"],@"b",@"c",nil];
NSArray *copyArray = [array copy];
NSMutableArray *mCopyArray = [array mutableCopy];
</code></p>

<p>查看内存，如我们所料，copyArray、mCopyArray和 array 的内存地址都不一样，说明 copyArray、mCopyArray 都对 array 进行了内容拷贝。同样，我们可以得出结论：</p>

<p>在集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：</p>

<p><code>objectivec
[immutableObject copy] // 浅复制
[immutableObject mutableCopy] //单层深复制
[mutableObject copy] //单层深复制
[mutableObject mutableCopy] //单层深复制
</code></p>

<p>这个代码结论和非集合类的非常相似。</p>

<p>参考链接：<a href="https://www.zybuluo.com/MicroCai/note/50592">iOS 集合的深复制与浅复制</a></p>

<h3>14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为<code>_foo</code>的实例变量，那么还会自动合成新变量么？</h3>

<p><strong>我的解答：</strong></p>

<p>额，规则不知道，感觉不会合成新变量。</p>

<p><strong>大神解答：</strong></p>

<p>在回答之前先说明下一个概念：</p>

<blockquote><p>实例变量 = 成员变量 ＝ ivar</p></blockquote>

<p>这些说法，笔者下文中，可能都会用到，指的是一个东西。</p>

<p>正如
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW6">Apple官方文档 <strong><em>You Can Customize Synthesized Instance Variable Names</em></strong></a> 所说：
<img src="http://i.imgur.com/D6d0zGJ.png" alt="enter image description here" /></p>

<p>如果使用了属性的话，那么编译器就会自动编写访问属性所需的方法，此过程叫做“自动合成”( auto synthesis)。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法” (synthesized method)的源代码。除了生成方法代码之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。</p>

<p><code>objectivec
@interface CYLPerson : NSObject
@property NSString *firstName;
@property NSString *lastName;
@end
</code></p>

<p>在上例中，会生成两个实例变量，其名称分别为
 <code>_firstName</code> 与 <code>_lastName</code>。也可以在类的实现代码里通过 <code>@synthesize</code> 语法来指定实例变量的名字:</p>

<p><code>objectivec
@implementation CYLPerson
@synthesize firstName = _myFirstName;
@synthesize lastName = _myLastName;
@end
</code></p>

<p>上述语法会将生成的实例变量命名为 <code>_myFirstName</code> 与 <code>_myLastName</code> ，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>

<p>总结下 @synthesize 合成实例变量的规则，有以下几点：</p>

<ol>
<li><p>如果指定了成员变量的名称,会生成一个指定的名称的成员变量,</p></li>
<li><p>如果这个成员已经存在了就不再生成了.</p></li>
<li>如果是 <code>@synthesize foo;</code> 还会生成一个名称为foo的成员变量，也就是说：</li>
</ol>


<blockquote><p>如果没有指定成员变量的名称会自动生成一个属性同名的成员变量,</p></blockquote>

<ol>
<li>如果是 <code>@synthesize foo = _foo;</code> 就不会生成成员变量了.</li>
</ol>


<p>假如 property 名为 foo，存在一个名为 <code>_foo</code> 的实例变量，那么还会自动合成新变量么？
不会。如下图：</p>

<p><img src="http://i.imgur.com/t28ge4W.png" alt="enter image description here" /></p>

<h3>15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h3>

<p><strong>我的解答：</strong></p>

<p>额，为了指定内部变量的名称会用到，其他呢？为啥就和@synthesize干上了？</p>

<p><strong>大神解答：</strong></p>

<p>回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？</p>

<ol>
<li>同时重写了 setter 和 getter 时</li>
<li>重写了只读属性的 getter 时</li>
<li>使用了 @dynamic 时</li>
<li>在 @protocol 中定义的所有属性</li>
<li>在 category 中定义的所有属性</li>
<li>重载的属性</li>
</ol>


<p>当你在子类中重载了父类中的属性，你必须 使用 <code>@synthesize</code> 来手动合成ivar。</p>

<p>除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理 @property 的所有内容时，你就会尝试通过实现 @property 的所有“存取方法”（the accessor methods）或者使用 <code>@dynamic</code> 来达到这个目的，这时编译器就会认为你打算手动管理 @property，于是编译器就禁用了 autosynthesis（自动合成）。</p>

<p>因为有了 autosynthesis（自动合成），大部分开发者已经习惯不去手动定义ivar，而是依赖于 autosynthesis（自动合成），但是一旦你需要使用ivar，而 autosynthesis（自动合成）又失效了，如果不去手动定义ivar，那么你就得借助 <code>@synthesize</code> 来手动合成 ivar。</p>

<p>其实，<code>@synthesize</code> 语法还有一个应用场景，但是不太建议大家使用：</p>

<p>可以在类的实现代码里通过 <code>@synthesize</code> 语法来指定实例变量的名字:</p>

<p><code>objectivec
@implementation CYLPerson
@synthesize firstName = _myFirstName;
@synthesize lastName = _myLastName;
@end
</code></p>

<p>上述语法会将生成的实例变量命名为 <code>_myFirstName</code> 与 <code>_myLastName</code>，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>

<p>举例说明：应用场景：</p>

<p>```objectivec</p>

<p>//
// .m文件
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a> (微博@iOS程序犭袁)
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
// 打开第14行和第17行中任意一行，就可编译成功</p>

<p>@import Foundation;</p>

<p>@interface CYLObject : NSObject
@property (nonatomic, copy) NSString *title;
@end</p>

<p>@implementation CYLObject {</p>

<pre><code>//    NSString *_title;
</code></pre>

<p>}</p>

<p>//@synthesize title = _title;</p>

<ul>
<li><p>(instancetype)init
{
  self = [super init];
  if (self) {
      _title = @&ldquo;微博@iOS程序犭袁&rdquo;;
  }
  return self;
}</p></li>
<li><p>(NSString *)title {
  return _title;
}</p></li>
<li><p>(void)setTitle:(NSString *)title {
  _title = [title copy];
}</p></li>
</ul>


<p>@end
```</p>

<p>结果编译器报错：
<img src="http://i.imgur.com/fAEGHIo.png" alt="enter image description here" /></p>

<p>当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择：</p>

<ol>
<li>要么如第14行：手动创建 ivar</li>
<li>要么如第17行：使用<code>@synthesize foo = _foo;</code> ，关联 @property 与 ivar。</li>
</ol>


<p>更多信息，请戳- 》<a href="http://stackoverflow.com/a/19821816/3395008"> <strong><em>When should I use @synthesize explicitly?</em></strong> </a></p>

<h3>16. objc中向一个nil对象发送消息将会发生什么？</h3>

<p><strong>我的解答：</strong></p>

<p>返回nil。</p>

<p><strong>大神解答：</strong></p>

<p>在 objectivec 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:</p>

<ol>
<li>如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如：</li>
</ol>


<p><code>objectivec
Person * motherInlaw = [[aPerson spouse] mother];
</code></p>

<p> 如果 spouse 对象为 nil，那么发送给 nil 的消息 mother 也将返回 nil。
 2. 如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量，发送给 nil 的消息将返回0。
 2. 如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。
 2. 如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。</p>

<p>具体原因如下：</p>

<blockquote><p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p></blockquote>

<p>那么，为了方便理解这个内容，还是贴一个objc的源代码：</p>

<p>```objectivec
// runtime.h（类在runtime中的定义）
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a></p>

<p>struct objc_class {
  Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object
  #if !<strong>OBJC2</strong>
  Class super_class OBJC2_UNAVAILABLE; // 父类
  const char <em>name OBJC2_UNAVAILABLE; // 类名
  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0
  long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识
  long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小
  struct objc_ivar_list </em>ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表
  struct objc_method_list <em><em>methodLists OBJC2_UNAVAILABLE; // 方法定义的链表
  struct objc_cache </em>cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。
  struct objc_protocol_list </em>protocols OBJC2_UNAVAILABLE; // 协议链表
  #endif
  } OBJC2_UNAVAILABLE;
```</p>

<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。
那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</p>

<h3>17. objc中向一个对象发送消息[obj foo]和<code>objc_msgSend()</code>函数之间有什么关系？</h3>

<p><strong>我的解答：</strong></p>

<p>编译期间[obj foo]会被编译为C代码，也就是objc_msgSend()方法，消息的接收者和消息名都会作为参数传到该方法中。</p>

<p><strong>大神解答：</strong></p>

<p>具体原因同上题：该方法编译之后就是<code>objc_msgSend()</code>函数调用.</p>

<p>我们用 clang 分析下，clang 提供一个命令，可以将objectivec的源码改写成C++语言，借此可以研究下[obj foo]和<code>objc_msgSend()</code>函数之间有什么关系。</p>

<p>以下面的代码为例，由于 clang 后的代码达到了10万多行，为了便于区分，添加了一个叫 iOSinit 方法，</p>

<p>```objectivec
//
//  main.m
//  <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
//  <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
//  Copyright &copy; 2015年 微博@iOS程序犭袁. All rights reserved.
//</p>

<h1>import &ldquo;CYLTest.h&rdquo;</h1>

<p>int main(int argc, char * argv[]) {</p>

<pre><code>@autoreleasepool {
    CYLTest *test = [[CYLTest alloc] init];
    [test performSelector:(@selector(iOSinit))];
    return 0;
}
</code></pre>

<p>}
```</p>

<p>在终端中输入</p>

<p><code>objectivec
clang -rewrite-objc main.m
</code>
就可以生成一个<code>main.cpp</code>的文件，在最低端（10万4千行左右）</p>

<p><img src="http://i.imgur.com/eAH5YWn.png" alt="enter image description here" /></p>

<p>我们可以看到大概是这样的：</p>

<p><code>objectivec
((void ()(id, SEL))(void )objc_msgSend)((id)obj, sel_registerName("foo"));
</code></p>

<p>也就是说：</p>

<blockquote><p> [obj foo];在objc动态编译时，会被转意为：<code>objc_msgSend(obj, @selector(foo));</code>。</p></blockquote>

<h3>18. 什么时候会报unrecognized selector的异常？</h3>

<p><strong>我的解答：</strong></p>

<p>当向对象发送消息时，对象无法响应该消息，且在系统的转发后也无法响应时，最后会报错unrecognized selector。</p>

<p><strong>大神解答：</strong></p>

<p>简单来说：</p>

<blockquote><p>当调用该对象上某个方法,而该对象上没有实现这个方法的时候，
可以通过“消息转发”进行解决。</p></blockquote>

<p>简单的流程如下，在上一题中也提到过：</p>

<blockquote><p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p></blockquote>

<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：</p>

<ol>
<li>Method resolution</li>
</ol>


<p> objc运行时会调用<code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。</p>

<ol>
<li>Fast forwarding</li>
</ol>


<p> 如果目标对象实现了<code>-forwardingTargetForSelector:</code>，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。
只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。
这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。
 3. Normal forwarding</p>

<p> 这一步是Runtime最后一次给你挽救的机会。首先它会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果<code>-methodSignatureForSelector:</code>返回nil，Runtime则会发出<code>-doesNotRecognizeSelector:</code>消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送<code>-forwardInvocation:</code>消息给目标对象。</p>

<p>为了能更清晰地理解这些方法的作用，git仓库里也给出了一个Demo，名称叫“ <code>_objc_msgForward_demo</code> ”,可运行起来看看。</p>

<h3>19. 一个objc对象如何进行内存布局？（考虑有父类的情况）</h3>

<p><strong>我的解答：</strong></p>

<p>额，不好描述。</p>

<p><strong>大神解答：</strong></p>

<ul>
<li>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.</li>
<li><p>每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的</p></li>
<li><p> 对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）</p></li>
<li> 成员变量的列表,</li>
<li> 属性列表,</li>
</ul>


<p> 它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。</p>

<p>每个 objectivec 对象都有相同的结构，如下图所示：</p>

<p> <img src="http://i.imgur.com/7mJlUj1.png" alt="enter image description here" /></p>

<p>翻译过来就是</p>

<table>
<thead>
<tr>
<th></th>
<th>  objectivec 对象的结构图 </th>
<th> </th>
</tr>
</thead>
<tbody>
<tr>
<td> ISA指针 </td>
<td></td>
<td></td>
</tr>
<tr>
<td> 根类的实例变量 </td>
<td></td>
<td></td>
</tr>
<tr>
<td> 倒数第二层父类的实例变量 </td>
<td></td>
<td></td>
</tr>
<tr>
<td> &hellip; </td>
<td></td>
<td></td>
</tr>
<tr>
<td> 父类的实例变量 </td>
<td></td>
<td></td>
</tr>
<tr>
<td> 类的实例变量 </td>
<td> </td>
<td></td>
</tr>
</tbody>
</table>


<ul>
<li><p>根对象就是NSobject，它的superclass指针指向nil</p></li>
<li><p>类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。</p></li>
</ul>


<p>如图:
<img src="http://i.imgur.com/w6tzFxz.png" alt="enter image description here" /></p>

<h3>20. 一个objc对象的isa的指针指向什么？有什么作用？</h3>

<p><strong>我的解答：</strong></p>

<p>isa指针指向objc所属的类型的结构体，用于找到该类的方法列表。</p>

<p><strong>大神解答：</strong></p>

<p>指向他的类对象,从而可以找到对象上的方法。</p>

<h3>21. 下面的代码输出什么？</h3>

<p>```objectivec</p>

<pre><code>@implementation Son : Father
- (id)init
{
    self = [super init];
    if (self) {
        NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@", NSStringFromClass([super class]));
    }
    return self;
}
@end
</code></pre>

<p>```</p>

<p><strong>我的解答：</strong></p>

<p>son，son</p>

<p><strong>大神解答：</strong></p>

<p>都输出 Son</p>

<pre><code>NSStringFromClass([self class]) = Son
NSStringFromClass([super class]) = Son
</code></pre>

<p>这个题目主要是考察关于 objectivec 中对 self 和 super 的理解。</p>

<p>我们都知道：self 是类的隐藏参数，指向当前调用方法的这个类的实例。那 super 呢？</p>

<p>很多人会想当然的认为“ super 和 self 类似，应该是指向父类的指针吧！”。这是很普遍的一个误区。其实 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者！他们两个的不同点在于：super 会告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。</p>

<p>上面的例子不管调用<code>[self class]</code>还是<code>[super class]</code>，接受消息的对象都是当前 <code>Son ＊xxx</code> 这个对象。</p>

<p>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。</p>

<p>这也就是为什么说“不推荐在 init 方法中使用点语法”，如果想访问实例变量 iVar 应该使用下划线（ <code>_iVar</code> ），而非点语法（ <code>self.iVar</code> ）。</p>

<p>点语法（ <code>self.iVar</code> ）的坏处就是子类有可能覆写 setter 。假设 Person 有一个子类叫 ChenPerson，这个子类专门表示那些姓“陈”的人。该子类可能会覆写 lastName 属性所对应的设置方法：</p>

<p>```objectivec
//
//  ChenPerson.m
//<br/>
//
//  Created by <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a> on 15/8/30.
//  Copyright &copy; 2015年 <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a> 微博@iOS程序犭袁. All rights reserved.
//</p>

<h1>import &ldquo;ChenPerson.h&rdquo;</h1>

<p>@implementation ChenPerson</p>

<p>@synthesize lastName = _lastName;</p>

<ul>
<li><p>(instancetype)init
{
  self = [super init];
  if (self) {
      NSLog(@&ldquo;🔴类名与方法名：%s（在第%d行），描述：%@&rdquo;, <strong>PRETTY_FUNCTION</strong>, <strong>LINE</strong>, NSStringFromClass([self class]));
      NSLog(@&ldquo;🔴类名与方法名：%s（在第%d行），描述：%@&rdquo;, <strong>PRETTY_FUNCTION</strong>, <strong>LINE</strong>, NSStringFromClass([super class]));
  }
  return self;
}</p></li>
<li><p>(void)setLastName:(NSString*)lastName
{
  //设置方法一：如果setter采用是这种方式，就可能引起崩溃
//    if (![lastName isEqualToString:@&ldquo;陈&rdquo;])
//    {
//        [NSException raise:NSInvalidArgumentException format:@&ldquo;姓不是陈&rdquo;];
//    }
//    _lastName = lastName;</p>

<p>  //设置方法二：如果setter采用是这种方式，就不会引起崩溃
  _lastName = @&ldquo;陈&rdquo;;
  NSLog(@&ldquo;🔴类名与方法名：%s（在第%d行），描述：%@&rdquo;, <strong>PRETTY_FUNCTION</strong>, <strong>LINE</strong>, @&ldquo;会调用这个方法,想一下为什么？&rdquo;);</p></li>
</ul>


<p>}</p>

<p>@end
```</p>

<p>在基类 Person 的默认初始化方法中，可能会将姓氏设为空字符串。此时若使用点语法（ <code>self.lastName</code> ）也即 setter 设置方法，那么调用将会是子类的设置方法，如果在刚刚的 setter 代码中采用设置方法一，那么就会抛出异常，</p>

<p>为了方便采用打印的方式展示，究竟发生了什么，我们使用设置方法二。</p>

<p>如果基类的代码是这样的：</p>

<p>```objectivec
//
//  Person.m
//  nil对象调用点语法
//
//  Created by <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a> on 15/8/29.
//  Copyright &copy; 2015年 <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a> 微博@iOS程序犭袁. All rights reserved.
//</p>

<h1>import &ldquo;Person.h&rdquo;</h1>

<p>@implementation Person</p>

<ul>
<li><p>(instancetype)init
{
  self = [super init];
  if (self) {
      self.lastName = @&ldquo;&rdquo;;
      //NSLog(@&ldquo;🔴类名与方法名：%s（在第%d行），描述：%@&rdquo;, <strong>PRETTY_FUNCTION</strong>, <strong>LINE</strong>, NSStringFromClass([self class]));
      //NSLog(@&ldquo;🔴类名与方法名：%s（在第%d行），描述：%@&rdquo;, <strong>PRETTY_FUNCTION</strong>, <strong>LINE</strong>, self.lastName);
  }
  return self;
}</p></li>
<li><p>(void)setLastName:(NSString*)lastName
{
  NSLog(@&ldquo;🔴类名与方法名：%s（在第%d行），描述：%@&rdquo;, <strong>PRETTY_FUNCTION</strong>, <strong>LINE</strong>, @&ldquo;根本不会调用这个方法&rdquo;);
  _lastName = @&ldquo;炎黄&rdquo;;
}</p></li>
</ul>


<p>@end
```</p>

<p>那么打印结果将会是这样的：</p>

<p><code>objectivec
 🔴类名与方法名：-[ChenPerson setLastName:]（在第36行），描述：会调用这个方法,想一下为什么？
 🔴类名与方法名：-[ChenPerson init]（在第19行），描述：ChenPerson
 🔴类名与方法名：-[ChenPerson init]（在第20行），描述：ChenPerson
</code></p>

<p>我在仓库里也给出了一个相应的 Demo（名字叫：Demo_21题_下面的代码输出什么）。有兴趣可以跑起来看一下，主要看下他是怎么打印的，思考下为什么这么打印。</p>

<p>接下来让我们利用 runtime 的相关知识来验证一下 super 关键字的本质，使用clang重写命令:</p>

<p>```objectivec</p>

<pre><code>$ clang -rewrite-objc test.m
</code></pre>

<p>```</p>

<p>将这道题目中给出的代码被转化为:</p>

<p>```objectivec</p>

<pre><code>NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName("class"))));

NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){ (id)self, (id)class_getSuperclass(objc_getClass("Son")) }, sel_registerName("class"))));
</code></pre>

<p>```</p>

<p>从上面的代码中，我们可以发现在调用 [self class] 时，会转化成 <code>objc_msgSend</code>函数。看下函数定义：</p>

<p>```objectivec</p>

<pre><code>id objc_msgSend(id self, SEL op, ...)
</code></pre>

<p>```
我们把 self 做为第一个参数传递进去。</p>

<p>而在调用 [super class]时，会转化成 <code>objc_msgSendSuper</code>函数。看下函数定义:</p>

<p>```objectivec</p>

<pre><code>id objc_msgSendSuper(struct objc_super *super, SEL op, ...)
</code></pre>

<p>```</p>

<p>第一个参数是 <code>objc_super</code> 这样一个结构体，其定义如下:</p>

<p>```objectivec
struct objc_super {</p>

<pre><code>   __unsafe_unretained id receiver;
   __unsafe_unretained Class super_class;
</code></pre>

<p>};
```</p>

<p>结构体有两个成员，第一个成员是 receiver, 类似于上面的 <code>objc_msgSend</code>函数第一个参数self 。第二个成员是记录当前类的父类是什么。</p>

<p>所以，当调用 ［self class] 时，实际先调用的是 <code>objc_msgSend</code>函数，第一个参数是 Son当前的这个实例，然后在 Son 这个类里面去找 &ndash; (Class)class这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 &ndash; (Class)class的实现就是返回self的类别，故上述输出结果为 Son。</p>

<p>objc Runtime开源代码对- (Class)class方法的实现:</p>

<p>```objectivec
&ndash; (Class)class {</p>

<pre><code>return object_getClass(self);
</code></pre>

<p>}
```</p>

<p>而当调用 <code>[super class]</code>时，会转换成<code>objc_msgSendSuper函数</code>。第一步先构造 <code>objc_super</code> 结构体，结构体第一个成员就是 <code>self</code> 。
第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code> , 实际该函数输出结果为 Father。</p>

<p>第二步是去 Father这个类里去找 <code>- (Class)class</code>，没有，然后去NSObject类去找，找到了。最后内部是使用 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>去调用，</p>

<p>此时已经和<code>[self class]</code>调用相同了，故上述输出结果仍然返回 Son。</p>

<p>参考链接：<a href="http://weibo.com/junbbcom">微博@Chun_iOS</a>的博文<a href="http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1">刨根问底objectivec Runtime（1）－ Self &amp; Super</a>%5Bnil%5D-self-and-super/)</p>

<h3>22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h3>

<p><strong>我的解答：</strong></p>

<p>从类型的结构体中找到对应的实例方法列表中按照selector的名称去查找对应的方法，而类方法列表存储在类型的类型，即meta class当中。</p>

<p><strong>大神解答：</strong></p>

<p>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</p>

<h3>23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h3>

<p><strong>我的解答：</strong></p>

<p>不需要，原因不清楚。</p>

<p><strong>大神解答：</strong></p>

<ul>
<li>在ARC下不需要。</li>
<li><p><del> 在MRC中,对于使用retain或copy策略的需要 。</del></p>在MRC下也不需要</li>
</ul>


<blockquote><p>无论在MRC下还是ARC下均不需要。</p></blockquote>

<p><a href="https://web.archive.org/web/20120818164935/http://developer.apple.com/library/ios/#/web/20120820002100/http://developer.apple.com/library/ios/documentation/cocoa/conceptual/objectivec/Chapters/ocAssociativeReferences.html"> <strong><em>2011年版本的Apple API 官方文档 &ndash; Associative References</em></strong>  </a> 一节中有一个MRC环境下的例子：</p>

<p>```objectivec
// 在MRC下，使用runtime Associate方法关联的对象，不需要在主对象dealloc的时候释放
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a> (微博@iOS程序犭袁)
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
// 摘自2011年版本的Apple API 官方文档 &ndash; Associative References</p>

<p>static char overviewKey;</p>

<p>NSArray *array =</p>

<pre><code>[[NSArray alloc] initWithObjects:@"One", @"Two", @"Three", nil];
</code></pre>

<p>// For the purposes of illustration, use initWithFormat: to ensure
// the string can be deallocated
NSString *overview =</p>

<pre><code>[[NSString alloc] initWithFormat:@"%@", @"First three numbers"];
</code></pre>

<p>objc_setAssociatedObject (</p>

<pre><code>array,
&amp;overviewKey,
overview,
OBJC_ASSOCIATION_RETAIN
</code></pre>

<p>);</p>

<p>[overview release];
// (1) overview valid
[array release];
// (2) overview invalid
```
文档指出</p>

<blockquote><p>At point 1, the string <code>overview</code> is still valid because the <code>OBJC_ASSOCIATION_RETAIN</code> policy specifies that the array retains the associated object. When the array is deallocated, however (at point 2), <code>overview</code> is released and so in this case also deallocated.</p></blockquote>

<p>我们可以看到，在<code>[array release];</code>之后，overview就会被release释放掉了。</p>

<p>既然会被销毁，那么具体在什么时间点？</p>

<blockquote><p>根据<a href="https://developer.apple.com/videos/wwdc/2011/#322-video"> <strong><em>WWDC 2011, Session 322 (第36分22秒)</em></strong> </a>中发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的 object_dispose() 方法中释放。</p></blockquote>

<p>对象的内存销毁时间表，分四个步骤：</p>

<pre><code>// 对象的内存销毁时间表
// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)
// https://github.com/ChenYilong
// 根据 WWDC 2011, Session 322 (36分22秒)中发布的内存销毁时间表 

 1. 调用 -release ：引用计数变为零
     * 对象正在被销毁，生命周期即将结束.
     * 不能再有新的 __weak 弱引用， 否则将指向 nil.
     * 调用 [self dealloc] 
 2. 父类 调用 -dealloc
     * 继承关系中最底层的父类 在调用 -dealloc
     * 如果是 MRC 代码 则会手动释放实例变量们（iVars）
     * 继承关系中每一层的父类 都在调用 -dealloc
 3. NSObject 调 -dealloc
     * 只做一件事：调用 objectivec runtime 中的 object_dispose() 方法
 4. 调用 object_dispose()
     * 为 C++ 的实例变量们（iVars）调用 destructors 
     * 为 ARC 状态下的 实例变量们（iVars） 调用 -release 
     * 解除所有使用 runtime Associate方法关联的对象
     * 解除所有 __weak 引用
     * 调用 free()
</code></pre>

<p>对象的内存销毁时间表：<a href="http://stackoverflow.com/a/10843510/3395008">参考链接</a>。</p>

<h3>24. objc中的类方法和实例方法有什么本质区别和联系？</h3>

<p><strong>我的解答：</strong></p>

<ol>
<li>类方法是类型调用的，而实例方法是类的实例来调用的。</li>
<li>类方法中不能使用实例方法和实例变量，而实例方法中可以使用类方法。</li>
</ol>


<p><strong>大神解答：</strong></p>

<p>类方法：</p>

<ol>
<li>类方法是属于类对象的</li>
<li>类方法只能通过类对象调用</li>
<li>类方法中的self是类对象</li>
<li>类方法可以调用其他的类方法</li>
<li>类方法中不能访问成员变量</li>
<li>类方法中不定直接调用对象方法</li>
</ol>


<p>实例方法：</p>

<ol>
<li>实例方法是属于实例对象的</li>
<li>实例方法只能通过实例对象调用</li>
<li>实例方法中的self是实例对象</li>
<li>实例方法中可以访问成员变量</li>
<li>实例方法中直接调用实例方法</li>
<li>实例方法中也可以调用类方法(通过类名)</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native初探1]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/20/react-nativechu-tan-1/"/>
    <updated>2015-10-20T17:29:08+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/20/react-nativechu-tan-1</id>
    <content type="html"><![CDATA[<p>React Native是Facebook最近推出的一个框架，让开发者通过JavaScript来完成iOS或Android的Native App，类似的方案好像几年前就出现过，比如PhoneGap，但经过市场检验，其App的用户体验，尤其是UI方面，始终较Native App相距甚远，那么这次Facebook带来的解决方案又有什么不同呢？</p>

<!--more-->


<h2>React Native特点</h2>

<ol>
<li>使用React Native后，你的App的逻辑部分是用JavaScript完成的，而UI则是完全native的，所以也不用担心H5带来的体验下降。</li>
<li>React Native还为用户界面构建带来了一种全新的函数式构建方案，App的UI会用与app的状态有关的函数来呈现。</li>
<li>React Native的核心思路是将响应式编程引入移动开发，这并不像之前PhoneGap倡导的<em>write-once,run-anywhere</em>，而是<em>learn-once,write-anywhere</em>。</li>
<li>Swift中Apple倡导使用函数式编程来完成算法和业务逻辑，但是构建UI仍然是基于UIKit，并没有实现函数式实现，而React则引入了UI层的函数式编程。</li>
</ol>


<h2>React Native环境搭建</h2>

<p>React Native的源码开源在<a href="https://github.com/facebook/react-native">GitHub</a>上，不过如果只是开发使用，则推荐使用commend line interface（CLI）来创建项目。<br/>
1.React Native使用Node.js，JavaScript的runtime，来创建JS代码。这里推荐使用Homebrew来安装Node.js。</p>

<p><code>ruby
brew install node
</code></p>

<p>2.然后安装watchman，一个Facebook开发的文件监听器，React Native通过它来监视代码的改动并适时编译，类似在Xcode中保存一次文件，便会执行一次build。</p>

<p><code>ruby
brew install watchman
</code></p>

<p>3.然后利用安装好的Node.js带的Node Package Manager来安装React Native CLI工具。</p>

<p><code>ruby
npm install -g react-native-cli
</code></p>

<p>4.这样环境就搭建完毕了，然后在目标文件夹，利用React Native的CLI创建新的项目。</p>

<p><code>ruby
react-native init YourAppFolderName
</code></p>

<h2>Hello Recact Native</h2>

<p>1.下面来创建一个“Hello World”的小程序，首先打开<strong>index.ios.js</strong>文件，删除测试代码，先添加以下代码，这段代码是开启了Strict Mode，主要为了提高JS的错误处理和禁用一些JS的语言特性。</p>

<p><code>javascript
'use strict'
</code></p>

<p>2.然后继续添加，这其实是导入了react-native模块，并将其赋值给了React，类似于#import或include。</p>

<p><code>javascript
var React = require("react-native")
</code></p>

<p>3.再添加一个样式，React Native使用了CSS来定义UI的样式，这和web开发是一致的。</p>

<p>```javascript
 var styles = React.StyleSheet.create({</p>

<pre><code>text:{
    color:'black',
    backgroundColor:'white',
    fontSize:30,
    margin:80
}
</code></pre>

<p> })
```</p>

<p>4.创建一个JS的类，Class是在ES6中引入的，但web开发为了兼容旧版浏览器，一般不会使用类，React Native是基于JavaScriptCore，可以放心使用JS的新特性，而不用担心浏览器兼容的问题。PropertyFinderApp扩展了React.Component，它是React UI的基本构建块，包含了不可变的Properties、可变的状态变量和用于渲染的方法，这里由于程序简单，只有一个渲染方法。</p>

<p>```javascript
class PropertyFinderApp extends React.Component{</p>

<pre><code>render(){
    return React.createElement(React.Text, {style:styles.text}, "Hello World!");
}
</code></pre>

<p>}
```</p>

<p>5.React.Component不是UIKit类，可以说是UIKit类的替代品，框架来负责将React components来转换为Native UI。最后再添加程序的入口，这里需要提供root component，也就是我们上面定义的PropertyFinderApp。</p>

<p><code>javascript
React.AppRegistry.registerComponent("RANTest", function(){return PropertyFinderApp});
</code></p>

<p>6.然后运行程序，你会发现JS代码已经转化为Native元素，完全没有网页元素出现。</p>

<h2>React Native运作原理</h2>

<p>1.先来看一下OC的程序加载后做了什么，一个类为RCTRootView的对象被创建，它负责加载JS程序和渲染视图，它通过*<a href="http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true*%E6%9D%A5%E5%8A%A0%E8%BD%BDJS%E3%80%82">http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true*%E6%9D%A5%E5%8A%A0%E8%BD%BDJS%E3%80%82</a></p>

<p>```objectivec
&ndash; (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{
  NSURL <em>jsCodeLocation;
  jsCodeLocation = [NSURL URLWithString:@&ldquo;<a href="http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true">http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true</a>&rdquo;];
  RCTRootView </em>rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</p>

<pre><code>                                                  moduleName:@"RANTest"
                                           initialProperties:nil
                                               launchOptions:launchOptions];
</code></pre>

<p>  self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
  UIViewController *rootViewController = [[UIViewController alloc] init];
  rootViewController.view = rootView;
  self.window.rootViewController = rootViewController;
  [self.window makeKeyAndVisible];
  return YES;
}
```</p>

<p>2.当你运行程序时，会打开一个终端窗口，就是为了开启一个packager和server来处理上述请求，在浏览器打开这一URL，也可以看到JS代码。<br/>
3.当app启动时，这些代码被载入，并被JavaScriptCore framework执行，将各个component载入，然后构建Native UIKit视图。</p>

<h2>Hello World JSX</h2>

<p>1.为了增加可读性和提高可维护性，可以使用HTML样式的JSX，也就是JavaScript syntax extension。</p>

<p><code>javascript
return &lt;React.Text style={styles.text}&gt;Hello World(Again)&lt;/React.Text&gt;;
</code></p>

<h2>A Search React Native App1</h2>

<h3>Adding Navigation</h3>

<p>1.这一节构建一个OC的NavgationController，将之前的PropertyFinderApp类改为HelloWorld，然后新定义一个PropertyFinderApp类，initialRoute定为HelloWorld，routing技术是web开发中定义导航结构，即哪个页面（或route）对应哪个URL。</p>

<p>```javascript
class PropertyFinderApp extends React.Component {
  render() {</p>

<pre><code>return (
  &lt;React.NavigatorIOS
    style={styles.container}
    initialRoute={ {
      title: 'Property Finder',
      component: HelloWorld,
    } }/&gt;
);
</code></pre>

<p>  }
}
```</p>

<p>2.然后添加container样式，这样，一个简单的导航控制器就完成了。</p>

<p>```javascript
var styles = React.StyleSheet.create({</p>

<pre><code>text:{
    color:'black',
    backgroundColor:'white',
    fontSize:30,
    margin:80
},
container:{
    flex:1
}
</code></pre>

<p>})
```</p>

<h3>Building the Search Page</h3>

<p>1.这一节介绍如何添加自定义一个Search页面，并在其他文件中进行引用。首先新建一个SearchPage.js文件，并在文件中添加代码。</p>

<p>```javascript
&lsquo;use strict&rsquo;
var React = require(&lsquo;react-native&rsquo;);
var {</p>

<pre><code>StyleSheet,
Text,
TextInput,
View,
TouchableHighlight,
ActivityIndicatorIOS,
Image,
Component
</code></pre>

<p>} = React;
```</p>

<p>2.这里使用了destructuring assignment，可以通过一行代码将多个对象属性一次性输出并将他们赋值给多个变量，这样你可以在之后的代码去掉React前缀，例如直接引用StyleSheet而不是React.StyleShet，这一技术在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">修改数组</a>时也经常用到，有点类似Swift的元组取值模式。</p>

<p><code>javascript
var foo = ["one", "two", "three"];
// without destructuring
var one   = foo[0];
var two   = foo[1];
var three = foo[2];
// with destructuring
var [one, two, three] = foo;
</code></p>

<p>3.然后创建CSS样式，并创建SearchPage component，语法依然使用了JSX的结构。</p>

<p>```javascript
var styles = StyleSheet.creat({</p>

<pre><code>description:{
    marginBottom:20,
    fontSize:18.
    textAlign:'center'.
    color:'#656565'
},
container:{
    padding:30,
    marginTop:65,
    alignItems:'center'
}
</code></pre>

<p>});
```</p>

<p>```javascript
class SearchPage extends Component {</p>

<pre><code>render() {
    return(
     &lt;View style={styles.container}&gt;
      &lt;Text style={styles.description}&gt;
       Search for houses to buy!
      &lt;/Text&gt;
      &lt;Text style={styles.description}&gt;
       Search by place-name, postcode or search near your location.
      &lt;/Text&gt;
     &lt;/View&gt;
    );
}
</code></pre>

<p>}
```</p>

<p>4.最后在文件结尾将SearchPage作为输出，并在index.ios.js中导入SearchPage，然后将之前render方法中的PropertyFinderApp类中的initialRoute更新。</p>

<p><code>javascript
module.exports = SearchPage;
</code></p>

<p><code>javascript
var SearchPage = require('./SearchPage');
</code></p>

<p><code>javascript
initialRoute={ {
  title: 'Property Finder',
  component: SearchPage,
} }
</code></p>

<h3>Styling with Flexbox</h3>

<p>1.flexbox是CSS最近加入的新特性，用于页面的布局（类似Autolayout），React Native使用了<a href="http://https://github.com/facebook/css-layout">css-layout</a>库，该库是Facebook自己开发的一个使用了flexbox标准的JS库，而这一标准对于C(iOS)和Java(Android)都是可接受的，这里有一篇专门讲解<a href="http://blog.scottlogic.com/2015/02/02/svg-layout-flexbox.html">flexbox layout to SVG</a>的文章，也是该作者写的。<br/>
2.在这个app中，container默认是列方向布局，也就是垂直方向布局（这与Android的布局方式是相同的），同时container也可以决定他的子视图的布局方向。</p>

<p>```javascript
<View style={styles.flowRight}>
  &lt;TextInput</p>

<pre><code>style={styles.searchInput}
placeholder='Search via name or postcode'/&gt;
</code></pre>

<p>  &lt;TouchableHighlight style={styles.button}</p>

<pre><code>  underlayColor='#99d9f4'&gt;
&lt;Text style={styles.buttonText}&gt;Go&lt;/Text&gt;
</code></pre>

<p>  </TouchableHighlight>
</View>
&lt;TouchableHighlight style={styles.button}</p>

<pre><code>underlayColor='#99d9f4'&gt;
</code></pre>

<p>  <Text style={styles.buttonText}>Location</Text>
</TouchableHighlight>
```</p>

<p>3.添加新的样式，记得在每个样式后要添加逗号分开，flex值是为了划分同一container下子视图的占位比，如这里的Go button和input view的flex分别为1和4，那么就按照1:4来划分，另外，这里的button是使用了TouchableHighlight。</p>

<p><code>javascript
flowRight: {
  flexDirection: 'row',
  alignItems: 'center',
  alignSelf: 'stretch'
},
buttonText: {
  fontSize: 18,
  color: 'white',
  alignSelf: 'center'
},
button: {
  height: 36,
  flex: 1,
  flexDirection: 'row',
  backgroundColor: '#48BBEC',
  borderColor: '#48BBEC',
  borderWidth: 1,
  borderRadius: 8,
  marginBottom: 10,
  alignSelf: 'stretch',
  justifyContent: 'center'
},
searchInput: {
  height: 36,
  padding: 4,
  marginRight: 5,
  flex: 4,
  fontSize: 18,
  borderWidth: 1,
  borderColor: '#48BBEC',
  borderRadius: 8,
  color: '#48BBEC'
}
</code></p>

<p>4.然后添加一张图片，图片资源依然要添加到Xcode的Images.xcassets，使用require(&lsquo;image!house&rsquo;)来加载图片，</p>

<p><code>javascript
&lt;Image source={require('image!house')} style={styles.image}/&gt;
</code></p>

<p><code>javascript
image: {
  width: 217,
  height: 138
}
</code></p>

<h2>A Search React Native App2</h2>

<h3>Adding Component State</h3>

<p>1.这一节，让我们来处理TextInput的输入，首先，我们来初始化SearchPage Component，下列代码添加到render()之前，这里有了新变量state以及searchString，并对TextInput赋该值。</p>

<p>```javascript
constructor(props) {
  super(props);
  this.state = {</p>

<pre><code>searchString: 'london'
</code></pre>

<p>  };
}
```</p>

<p><code>javascript
&lt;TextInput
  style={styles.searchInput}
  value={this.state.searchString}
  placeholder='Search via name or postcode'/&gt;
</code></p>

<p>2.然后在SearchPage Class添加一个方法，作为TextInput的回调，并将其与TextInput绑定，这一过程在OC中是以delegate的形式实现的，需要说明下的是这里的this是指向所在component的实例的指针。</p>

<p><code>javascript
onSearchTextChanged(event) {
  console.log('onSearchTextChanged');
  this.setState({ searchString: event.nativeEvent.text });
  console.log(this.state.searchString);
}
</code></p>

<p><code>javascript
&lt;TextInput
  style={styles.searchInput}
  value={this.state.searchString}
  onChange={this.onSearchTextChanged.bind(this)}
  placeholder='Search via name or postcode'/&gt;
</code></p>

<p>3.通过实验TextInput我们发现，每次TextIput的状态发生改变，整个component就会重新render一次，这一机制将渲染逻辑和与UI有关的状态改变彻底分开。在大部分UI框架中，一般都是开发者根据app状态改变来手动刷新UI（比如OC或Swift），或者使用隐式链接来绑定app的状态和UI刷新完成自动刷新（比如ReactiveCocoa），但是在React Native中，你不用再去手动处理这些逻辑，整个UI就是app状态的一个函数表示！这就是响应式编程的核心理念。<br/>
4.不过你可能会担心效率问题，频繁刷新整个UI当然是不明智的，React在每次刷新时，它会从render方法获取整个视图树，然后与现在的UIKit视图进行比较，比较的结果就是一个简单的更新表，React按照这个表去更新当前视图，所以只有需要更新的UI才会去更新。<br/>
5.这一理念的应用，将虚拟DOM和一致性引入了App开发，也是React的独特之处。</p>

<h3>Initiating a Search</h3>

<p>1.这一节为Search页面添加搜索功能，首先在state中加入isLoading变量，再在render中添加spinner变量告知用户搜索在进行，它依据isLoading变量来添加一个spinner或空视图，并将{spinner}加入return方法。</p>

<p><code>javascript
this.state = {
  searchString: 'london',
  isLoading: false
};
</code></p>

<p>```javascript
var spinner = this.state.isLoading ?
  ( &lt;ActivityIndicatorIOS</p>

<pre><code>  hidden='true'
  size='large'/&gt; ) :
</code></pre>

<p>  ( <View/>);
&hellip;
{spinner}
```</p>

<p>2.在Go Button绑定onPress事件回调，并添加回调方法，注意Javascript的类没有访问器，所以也没有私有方法，所以一般用<em>_</em>前缀来标识私有方法。</p>

<p><code>javascript
onPress={this.onSearchPressed.bind(this)}
</code></p>

<p><code>javascript
_executeQuery(query) {
  console.log(query);
  this.setState({ isLoading: true });
}
onSearchPressed() {
  var query = urlForQueryAndPage('place_name', this.state.searchString, 1);
  this._executeQuery(query);
}
</code></p>

<p>3.在SearchPage外单独定义urlForQueryAndPage()方法，这里做了URL的拼接，用到了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">JS的方法</a> 。</p>

<p>```javascript
function urlForQueryAndPage(key, value, pageNumber) {
  var data = {</p>

<pre><code>  country: 'uk',
  pretty: '1',
  encoding: 'json',
  listing_type: 'buy',
  action: 'search_listings',
  page: pageNumber
</code></pre>

<p>  };
  data[key] = value;</p>

<p>  var querystring = Object.keys(data)</p>

<pre><code>.map(key =&gt; key + '=' + encodeURIComponent(data[key]))
.join('&amp;');
</code></pre>

<p>  return &lsquo;<a href="http://api.nestoria.co.uk/api?">http://api.nestoria.co.uk/api?</a>&rsquo; + querystring;
};
```</p>

<p>4.=>是JS中对函数指针的缩写，可理解为OC中的block，这里先用map将其原字典的keys映射为新的数组，然后用&amp;相连，产生URL的参数String。</p>

<p><code>javascript
var a = [
  "Hydrogen",
  "Helium",
  "Lithium",
  "Beryl­lium"
];
var a2 = a.map(function(s){ return s.length });
var a3 = a.map( s =&gt; s.length );
</code></p>

<h3>Performing an API Request</h3>

<p>1.在state添加message变量，并在render添加Text，用以显示请求错误信息，并在_excuteQuery()中添加请求的代码。</p>

<p><code>javascript
this.state = {
  searchString: 'london',
  isLoading: false,
  message: ''
};
</code></p>

<p><code>javascript
&lt;Text style={styles.description}&gt;{this.state.message}&lt;/Text&gt;
</code></p>

<p>2.请求代码使用了fetch函数，这是<a href="https://fetch.spec.whatwg.org">Fetch API</a>中的函数，相比XMLHttpRequest，有很大提升，使用了promise规范。</p>

<p>```javascript
fetch(query)
  .then(response => response.json())
  .then(json => this._handleResponse(json.response))
  .catch(error =></p>

<pre><code> this.setState({
  isLoading: false,
  message: 'Something bad happened ' + error
</code></pre>

<p>   }));
```</p>

<p>3.success的回调处理，先对response code做了判断，然后打印出了listings的长度，可以看出JSON在JS开发中是直接使用的，而省去了转化为Model的步骤。</p>

<p>`&ldquo;javascript
_handleResponse(response) {
  this.setState({ isLoading: false , message: &rdquo; });
  if (response.application_response_code.substr(0, 1) === &lsquo;1&rsquo;) {</p>

<pre><code>console.log('Properties found: ' + response.listings.length);
</code></pre>

<p>  } else {</p>

<pre><code>this.setState({ message: 'Location not recognized; please try again.'});
</code></pre>

<p>  }
}
```</p>

<h3>Displaying the Results</h3>

<p>1.新建SearchResult.js，新建SearchResults component，代码中使用到了ListView，类似OC的UITableView，通过dataSource来提供数据源，renderRow来渲染每个cell。</p>

<p>```javascript
class SearchResults extends Component {</p>

<p>  constructor(props) {</p>

<pre><code>super(props);
var dataSource = new ListView.DataSource(
  {rowHasChanged: (r1, r2) =&gt; r1.guid !== r2.guid});
this.state = {
  dataSource: dataSource.cloneWithRows(this.props.listings)
};
</code></pre>

<p>  }</p>

<p>  renderRow(rowData, sectionID, rowID) {</p>

<pre><code>return (
  &lt;TouchableHighlight
      underlayColor='#dddddd'&gt;
    &lt;View&gt;
      &lt;Text&gt;{rowData.title}&lt;/Text&gt;
    &lt;/View&gt;
  &lt;/TouchableHighlight&gt;
);
</code></pre>

<p>  }</p>

<p>  render() {</p>

<pre><code>return (
  &lt;ListView
    dataSource={this.state.dataSource}
    renderRow={this.renderRow.bind(this)}/&gt;
);
</code></pre>

<p>  }
}
```</p>

<p>2.构建数据源时，提供了一个方法来比较row之间的id是否相同，ListView在更新时调用它，来确定数据源是否改变，本例中通过数据的guid来达到这个目的，然后在SearchPage的_handleResponse中添加导航方法。</p>

<p><code>javascript
this.props.navigator.push({
  title: 'Results',
  component: SearchResults,
  passProps: {listings: response.listings}
});
</code></p>

<h3>A Touch of Style</h3>

<p>1.添加样式，更新renderRow()方法，price为了去掉GBP后缀，做了字符串裁剪，同时这次的Image数据源为url，JS可直接赋值，而React Native会自动后台一步下载。</p>

<p>```javascript
var styles = StyleSheet.create({
  thumb: {</p>

<pre><code>width: 80,
height: 80,
marginRight: 10
</code></pre>

<p>  },
  textContainer: {</p>

<pre><code>flex: 1
</code></pre>

<p>  },
  separator: {</p>

<pre><code>height: 1,
backgroundColor: '#dddddd'
</code></pre>

<p>  },
  price: {</p>

<pre><code>fontSize: 25,
fontWeight: 'bold',
color: '#48BBEC'
</code></pre>

<p>  },
  title: {</p>

<pre><code>fontSize: 20,
color: '#656565'
</code></pre>

<p>  },
  rowContainer: {</p>

<pre><code>flexDirection: 'row',
padding: 10
</code></pre>

<p>  }
});
```</p>

<p>```javascript
renderRow(rowData, sectionID, rowID) {
  var price = rowData.price_formatted.split(&lsquo; &rsquo;)[0];</p>

<p>  return (</p>

<pre><code>&lt;TouchableHighlight onPress={() =&gt; this.rowPressed(rowData.guid)}
    underlayColor='#dddddd'&gt;
  &lt;View&gt;
    &lt;View style={styles.rowContainer}&gt;
      &lt;Image style={styles.thumb} source={ { uri: rowData.img_url } } /&gt;
      &lt;View  style={styles.textContainer}&gt;
        &lt;Text style={styles.price}&gt;£{price}&lt;/Text&gt;
        &lt;Text style={styles.title} 
              numberOfLines={1}&gt;{rowData.title}&lt;/Text&gt;
      &lt;/View&gt;
    &lt;/View&gt;
    &lt;View style={styles.separator}/&gt;
  &lt;/View&gt;
&lt;/TouchableHighlight&gt;
</code></pre>

<p>  );
}
```</p>

<p>2.然后添加点击cell的回调，可以看到数据源始终还是最原始的数据源，做了一步过滤操作（因为这里的cell没有index的概念，所以只能过滤，但是必须保证guid唯一才可以）。</p>

<p><code>javascript
rowPressed(propertyGuid) {
  var property = this.props.listings.filter(prop =&gt; prop.guid === propertyGuid)[0];
}
</code></p>

<h3>Property Details View</h3>

<p>1.添加详情页，PropertyView，首先对房屋的配置信息做了整理，然后就是常规的视图布局。</p>

<p>```javascript
class PropertyView extends Component {
  render() {</p>

<pre><code>var property = this.props.property;
var stats = property.bedroom_number + ' bed ' + property.property_type;
if (property.bathroom_number) {
  stats += ', ' + property.bathroom_number + ' ' + (property.bathroom_number &gt; 1 ? 'bathrooms' : 'bathroom');
}

var price = property.price_formatted.split(' ')[0];

return (
  &lt;View style={styles.container}&gt;
    &lt;Image style={styles.image} 
        source={ {uri: property.img_url} } /&gt;
    &lt;View style={styles.heading}&gt;
      &lt;Text style={styles.price}&gt;£{price}&lt;/Text&gt;
      &lt;Text style={styles.title}&gt;{property.title}&lt;/Text&gt;
      &lt;View style={styles.separator}/&gt;
    &lt;/View&gt;
    &lt;Text style={styles.description}&gt;{stats}&lt;/Text&gt;
    &lt;Text style={styles.description}&gt;{property.summary}&lt;/Text&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
}
```</p>

<p>2.最后从SearchResults，推入PropertyView。</p>

<p>```javascript
rowPressed(propertyGuid) {
  var property = this.props.listings.filter(prop => prop.guid === propertyGuid)[0];</p>

<p>  this.props.navigator.push({</p>

<pre><code>title: "Property",
component: PropertyView,
passProps: {property: property}
</code></pre>

<p>  });
}
```</p>

<h3>Geolocation Search</h3>

<p>1.增加自动定位并搜索周边房屋的功能，在SearchPage的Location按钮添加该功能，前提在Xcode的工程的Plist中添加NSLocationWhenInUseUsageDescription来添加请求允许定位的描述。</p>

<p><code>javascript
onPress={this.onLocationPressed.bind(this)}
</code></p>

<p>```javascript
onLocationPressed() {
  navigator.geolocation.getCurrentPosition(</p>

<pre><code>location =&gt; {
  var search = location.coords.latitude + ',' + location.coords.longitude;
  this.setState({ searchString: search });
  var query = urlForQueryAndPage('centre_point', search, 1);
  this._executeQuery(query);
},
error =&gt; {
  this.setState({
    message: 'There was a problem with obtaining your location: ' + error
  });
});
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Generics]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/15/swift-by-tutorials-generics/"/>
    <updated>2015-10-15T11:05:56+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/15/swift-by-tutorials-generics</id>
    <content type="html"><![CDATA[<p>经过前三章，基本对Swift的基本语法有了较全面的介绍，接下来会分别就Swift比较重要的几个技术要点介绍，这一节将讨论一个比较流行的语言特性，generics，即泛型。对于类型安全的编程语言，希望代码可以在一个场景下运行，但又想要在其他场景中也可以是合法的，比如对于一个加法函数，Int和Float类型的函数形式是一样的，只是变量类型不同，在强调类型的语言中，你必须分开定义这两个方法。很多语言为这一问题提供了解决方案，C++是使用了模板，而Swift、Java、C#是使用了泛型，也就是这一章的主角，配合主题这一章将创建一个Flickr照片搜素App来实践这一技术。</p>

<!--more-->


<h2>Introducing generics</h2>

<p>1.泛型是什么？举例来说Array和Dictionary就是类型安全的泛型应用实例。在OC中Array和Dictionary是可以存放不同类型的对象的，当然这有时是提供了很多方便，但当你去使用一个Array或Dictionary时，你如何知道其中的类型？只能通过文档或其他代码，而且没有任何办法去控制在runtime中出现数据异常。<br/>
2.而Swift中对Array和Dictionary中类型是固定的，编译器会完成类型检查，而你的代码本身也对自己做了注释，比较下处理点击的方法在OC和Swift中的区别，在OC中调用这一方法，你一般是需要将set中的对象转化为UITouch类型，而Swift不仅省去你这一操作，代码可读性也更优。</p>

<p><code>objectivec
//in OC
-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;
//in Swift
func touchesBegan(touches: [UITouch]!, withEvent event: UIEvent!)
</code></p>

<p>2.所以说泛型就是类似Array这样，所有的Array运作方式都是一致的，都是将数据存在一张有序的表中，但泛型的Array将值的类型作为了参数，也就是不论Array中类型如何，都可以执行Array的方法。</p>

<!--more-->


<h2>Generics in action</h2>

<p>1.本章的实例项目是要从Flickr的搜索接口获取对应图片，并进行展示的一个App，其中网络访问部分大神已经写好了。</p>

<!--more-->


<h2>Ordered dictionaries</h2>

<p>1.第一个需求就是希望将用户最近搜索的图片放在前面，那么如果正常来讲，我们要用Array来存数据源，而不是Dictionary或Set，因为后两者是无序的，而这里为了应用泛型，打算自己创建一个有序的Dictionary，实际上就是想把key作为顺序。</p>

<h3>The initial data structure</h3>

<p>1.首先声明有序字典为Struct类型，并声明它的泛型类型参数，KeyType和ValueType并不是真实的类型，只是两个你用来替代类型的参数，一般用T来表示，如果单词表示的话用驼峰式大写首字母来表示。</p>

<p><code>objectivec
struct OrderedDictionary&lt;KeyType, ValueType&gt; {
}
</code></p>

<p>2.创建一个有序字典最简单的方法是，在内部同时维护一个Dictionary和Array，这里使用了typealias分别给[KeyType]和[KeyType: ValueType]做了类型名替代，这样下面声明Array和Dictionary就可以直接用替代类型名来定义，同理这个也可以用在替换函数类型和闭包等比较长的类型的替换。</p>

<p>```objectivec
typealias ArrayType = [KeyType]
typealias DictionaryType = [KeyType: ValueType]</p>

<p>var array = ArrayType()
var dictionary = DictionaryType()
```</p>

<p>3.对比Dictionary的定义，KeyType需要遵循Hashable协议，因为Dictionary需要对key做hash，所以在定义泛型那儿要加上遵循该协议。</p>

<p><code>objectivec
struct OrderedDictionary&lt;KeyType: Hashable, ValueType&gt;
</code></p>

<h3>Keys, values and all that jazz</h3>

<p>1.第一个要加入的方法是insert方法，因为是有序字典，所以有所不同。</p>

<p>```objectivec
mutating func insert(value: ValueType, forKey key: KeyType, atIndex index: Int) &ndash;> ValueType? {
  var adjustedIndex = index</p>

<p>  let existingValue = self.dictionary[key]
  if existingValue != nil {</p>

<pre><code>let existingIndex = self.array.indexOf(key)!
if existingIndex &lt; index {
  adjustedIndex--
}
self.array.removeAtIndex(existingIndex)
</code></pre>

<p>  }</p>

<p>  self.array.insert(key, atIndex:adjustedIndex)
  self.dictionary[key] = value</p>

<p>  return existingValue
}
```</p>

<p>2.有几点需要说明，首先，该方法前的mutating关键字，因为Struct默认是不可变的，也就是是说你不能在实例方法中修改struct的成员变量，加上mutating是为了告诉编译器该方法可以修改struct成员变量，使编译器在适当的时候对struct做copy操作(前面说过，实际上是copy-on-write)，同时也增加了可读性。<br/>
3.然后是remove方法，这里先对index是否越界做了判断，可以像OC中使用Assertions断言，也可以如下使用precondition，如果失败，会退出App。</p>

<p><code>objectivec
mutating func removeAtIndex(index: Int) -&gt; (KeyType, ValueType) {
  precondition(index &lt; self.array.count, "Index out-of-bounds")
  let key = self.array.removeAtIndex(index)
  let value = self.dictionary.removeValueForKey(key)!
  return (key, value)
}
</code></p>

<p>4.这里在结束后会返回一个元组类型的删除值，使之与Swift的Array和Dictionary的remove方法保持一致。</p>

<h3>Accessing values</h3>

<p>1.上一节为有序字典添加了写入的方法，接下来添加一些读取的方法，首先是获取count的方法，如下，使用了前面提到的computed property技术。</p>

<p><code>objectivec
var count: Int {
  return self.array.count
}
</code></p>

<p>2.在Swift中我们一般使用subscript来访问变量，类似dictionary[1]，一般是见于Array和Dictionary，不过我们计划在我们的有序字典也加入这一特性。</p>

<p>```objectivec
subscript(key: KeyType) &ndash;> ValueType? {
  get {</p>

<pre><code>return self.dictionary[key]
</code></pre>

<p>  }
  set {</p>

<pre><code>if let index = self.array.indexOf(key) {
} else {
  self.array.append(key)
}
self.dictionary[key] = newValue
</code></pre>

<p>  }
}
```</p>

<p>3.上述代码就是如何在自己的Struct中加入subscript行为，类似computed property，subscript有两个闭包，分别是getter和setter。<br/>
4.因为这是一个有序数组，我们打算让他支持通过index来访问，需要注意的是：一，无论setter，getter都需要判断index是否越界；二，setter中输入的值newValue是一个元组类型，所以需要用let (key, value) = newValue将键值取出来。</p>

<p>```objectivec
subscript(index: Int) &ndash;> (KeyType, ValueType) {
  get {</p>

<pre><code>precondition(index &lt; self.array.count, "Index out-of-bounds")
let key = self.array[index]
let value = self.dictionary[key]!
return (key, value)
</code></pre>

<p>  }
  set {</p>

<pre><code>precondition(index &lt; self.array.count, "Index out-of-bounds")
let (key, value) = newValue
let originalKey = self.array[index]
self.dictionary[originalKey] = nil
self.array[index] = key
self.dictionary[key] = value
</code></pre>

<p>  }
}
```</p>

<p>5.这里可能有个疑问，就是如果使用者使用Int作为KeyType呢？因为Int也遵循hashable，完全可以作为key，那么编译器如何判断该用哪组方法呢？遇到这种情况，setter方法当然没问题，因为赋值也不同，那么getter方法只能在取值时就声明返回值的类型，这样编译器会通过这个类型选择使用哪个方法。</p>

<p><code>objectivec
var dict = OrderedDictionary&lt;Int, String&gt;()
dict.insert("dog", forKey: 1, atIndex: 0)
dict.insert("cat", forKey: 2, atIndex: 1)
print(dict.array.description + " : " + dict.dictionary.description)
//"[1, 2] : [2: "cat", 1: "dog"]"
var byIndex: (Int, String) = dict[0]
print(byIndex)
//"(1, "dog")"
var byKey: String? = dict[2]
print(byKey)
//"Optional("cat")"
</code></p>

<p>6.在使用type interface时，编译器需要明确知道返回值的类型，如果出现上述相同方法，返回值类型不同的情况，必须caller指明类型，否则编译器是不会知道该返回那个值的。</p>

<!--more-->


<h2>Aside: Assertions &amp; preconditions</h2>

<p>1.assertions和precondition都是判断程序是否能继续执行时的判断条件，不同的是，assertion是不会在release build时编译的，而precondition可以；assertion是被用于在开发时获取bug，而precondition是用于当一个条件不满足时，抛出严重异常的。<br/>
2.assertion的一个使用场景是有多个创建view的方法共同来构建页面，但其中一些依赖于另一些完成，这时要使用assertion。</p>

<p>```objectivec
private func configureTableView() {</p>

<pre><code>self.tableView = UITableView(frame: CGRectZero) 
self.tableView.delegate = self 
self.tableView.dataSource = self 
self.view.addSubview(self.tableView)}private func configureHeader() {   assert(self.tableView != nil)   let headerView = UIView(frame: CGRectMake(0, 0, 320, 50))   headerView.backgroundColor = UIColor.clearColor()   let label = UILabel(frame: CGRectZero)  label.text = "My Table"     label.sizeToFit()   label.frame = CGRectMake(0, 0, label.bounds.size.width, label.bounds.size.height) headerView.addSubview(label)  self.tableView.tableHeaderView = headerView }
</code></pre>

<p>```</p>

<p>3.关于assertion一个有趣的现象是编译器允许在release build时假设assertion是true，有时也会导致一些bug，如下，输入0时，在debug下没问题，会触发断言；而在release中，编译器自动认为assertion是true，然后optimizer就会跳过if，直接进入>0的分支。</p>

<p>```objectivec
func foo(value: Int) {</p>

<pre><code>assert(value &gt; 0)   if value &gt; 0 {      print("Yes, it's greater than zero")    } else { 
    print("Nope")   } }
</code></pre>

<p>```</p>

<p>4.再来看下precondition，它和assertion做的是一样的工作，但是可以在release下运行，使用它是为了确保一些必要的条件，如下例，数组越界即使不加precondition，也会crash，但是通过precondition，可以获取到自定义的log信息，方便调试。</p>

<p>```objectivec
func fetchPeopleBetweenIndexes(start: Int, end: Int) &ndash;> [Person] {</p>

<pre><code>precondition(start &lt; end)   precondition(start &gt;= 0)    precondition(end &lt;= self.people.count)  return Array(self.people[start..&lt;end]) 
</code></pre>

<p>}
```</p>

<p>5.一般的经验是，在你release时可以跳过，但是希望在debug阶段获取失败信息时使用assertion；而在将会导致数据损坏或者其他严重问题前，使用precondition。同时在你开发一些第三方库时，在容易出现数据输入错误这些位置可以使用precondition来提示开发者。</p>

<!--more-->


<h2>Adding image search</h2>

<p>1.创建App的数据源，使用的就是之前自定义的有序字典，你可能注意到使用了Flickr.photo，Photo是一个定义在Flickr中的类，这样的机制非常有用，在保持类名尽量短的基础上实现了命名空间，在Flickr类中，可以单独使用Photo类。</p>

<p><code>objectivec
var searches = OrderedDictionary&lt;String, [Flickr.Photo]&gt;()
</code></p>

<p>2.然后实现tableView的委托和数据源协议。</p>

<p>```objectivec
func tableView(tableView: UITableView, numberOfRowsInSection section: Int) &ndash;> Int {
  return self.searches.count
}</p>

<p>func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) &ndash;> UITableViewCell {
  let cell = tableView.dequeueReusableCellWithIdentifier(&ldquo;Cell&rdquo;, forIndexPath: indexPath) as UITableViewCell
  let (term, photos) = self.searches[indexPath.row]
  cell.textLabel!.text = &ldquo;(term) ((photos.count))&rdquo;
  return cell
}
```</p>

<p>3.然后是UISearchBarDelegate，这里调用Flickr的search方法是使用了Trailing Closures技术，即如果closure作为一个方法最后一个变量，那么可以写到所调用方法的外面（后面），如下：</p>

<p>```objectivec
func searchBarSearchButtonClicked(searchBar: UISearchBar!) {
  searchBar.resignFirstResponder()
  let searchTerm = searchBar.text
  Flickr.search(searchTerm!) {</p>

<pre><code>switch ($0) {
case .Error:
  break
case .Results(let results):
  self.searches.insert(results, forKey: searchTerm!, atIndex: 0)
  self.tableView.reloadData()
}
</code></pre>

<p>  }
}
```</p>

<p>```objectivec
func someFunctionThatTakesAClosure(closure: () &ndash;> Void) {</p>

<pre><code>// function body goes here
</code></pre>

<p>}
// here&rsquo;s how you call this function without using a trailing closure:
someFunctionThatTakesAClosure({</p>

<pre><code>// closure's body goes here
</code></pre>

<p>})
// here&rsquo;s how you call this function with a trailing closure instead:
someFunctionThatTakesAClosure() {</p>

<pre><code>// trailing closure's body goes here
</code></pre>

<p>}
```</p>

<h3>Show me the photos!</h3>

<p>1.这一节来完成详情页，先是在prepareForSegue方法中设置DetailViewController。</p>

<p>```objectivec
override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
  if segue.identifier == &ldquo;showDetail&rdquo; {</p>

<pre><code>if let indexPath = self.tableView.indexPathForSelectedRow {
  let (_, photos) = self.searches[indexPath.row]
  (segue.destinationViewController as! DetailViewController).photos = photos
}
</code></pre>

<p>  }
}
```</p>

<h3>Deleting searches</h3>

<p>1.为搜索页添加滑动删除功能。</p>

<p><code>objectivec
self.navigationItem.leftBarButtonItem = self.editButtonItem()
</code></p>

<p><code>objectivec
override func setEditing(editing: Bool, animated: Bool)  {
  super.setEditing(editing, animated: animated)
  self.tableView.setEditing(editing, animated: animated)
}
</code></p>

<p><code>objectivec
func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -&gt; Bool {
  return true
}
</code></p>

<p>```objectivec
func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {
  if editingStyle == .Delete {</p>

<pre><code>self.searches.removeAtIndex(indexPath.row)
tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Fade)
</code></pre>

<p>  }
}
```</p>

<!--more-->


<h2>Generic functions and protocols</h2>

<p>1.这一节介绍泛型的函数和协议，之前一直使用的find方法就是一个泛型方法，这是一个全局方法，泛型参数C定义了domain参数，也间接定义了value参数的类型，且返回值也和C有关：</p>

<p><code>objectivec
func find&lt;C: Collection where C.GeneratorType.Element: Equatable&gt; (domain: C, value: C.GeneratorType.Element) -&gt; C.IndexType?
</code></p>

<p>2.我们之前定义的有序字典的insert方法中这么使用了find()，没有指出C，其实这又是type interface的体现，通过第一个参数推断出了C的类型。</p>

<p><code>objectivec
let existingIndex = find(self.array, key)!
</code></p>

<p>3.那么GeneratorType是什么？上述的Collection协议，同时也遵从于SequenceType协议，如下，要实现该协议，必须有个typealias名为Generator，且遵从于GeneratorType协议，同时实现generate()方法返回Generator类型。</p>

<p>```objectivec
protocol SequenceType { typealias Generator : GeneratorType</p>

<pre><code>public func generate() -&gt; Self.Generator}
</code></pre>

<p>```</p>

<p>4.那么在自定义的有序数组上实验下SeqenceType，首先定义typealias名为Generator，使用AnyGenerator这个泛型类。</p>

<p>```objectivec
extension OrderedDictionary: SequenceType {
  typealias Generator = AnyGenerator&lt;(KeyType, ValueType)>
  func generate() &ndash;> AnyGenerator&lt;(KeyType, ValueType)> {</p>

<pre><code>var index = 0
return anyGenerator {
  if index &lt; self.array.count {
    let key = self.array[index++]
    return (key, self.dictionary[key]!)
  } else {
    return nil
  }
}
</code></pre>

<p>  }
}
```</p>

<p>5.而在实现generate()方法中，通过调用了anyGenerator方法，该方法只有一个closure参数，所以使用了Trailing Closures技术，这个closure会在每次调用next()时调用，在closure中，你完成自己的遍历方法。</p>

<p><code>objectivec
public func anyGenerator&lt;Element&gt;(body: () -&gt; Element?) -&gt; AnyGenerator&lt;Element&gt;
</code></p>

<p>6.实现了SequenceType Protocol，你可以使用for-in来遍历字典，其实typealias Generator = AnyGenerator&lt;(KeyType, ValueType)>这句可以删除，因为Swift从func generate() &ndash;> AnyGenerator&lt;(KeyType, ValueType)>()返回值推断出了该类型。<br/>
7.实际上SequenceType Protocol就是一个泛型协议，只不过因为protocol不能使用&lt;>关键字，而像Java和C#是可以的，原因也很简单，Protocols本身就是定义给class或struct实现的，这本身就是带有泛型的性质，Swift的思想就是protocol定义接口，而class和struct定义类型、泛型或其他。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Classes and Structs]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/12/swift-by-tutorials-classes-and-structs/"/>
    <updated>2015-10-12T15:26:48+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/12/swift-by-tutorials-classes-and-structs</id>
    <content type="html"><![CDATA[<p>继上两章对Swift的基本类型的学习，这一章开始介绍Swift中的Class和Struct，Class对所有面向对象的语言都不陌生，而Struct可能用的比较少，因为大部分用于C中，但Swift中的Struct与C还有很多不同，这章会一一介绍，而且同时会讲到Class与Struct之间的不同与使用场景，以及它们的扩展，也是这一章的重点。</p>

<!--more-->


<h2>Getting started</h2>

<h3>The class concept</h3>

<p>1.类是通过总结一些对象的共同特点，定义基本类型，通过继承来创建具体使用的子类型，它拥有自己的数据和方法，可以视为数据的容器。</p>

<h2>My first class</h2>

<p>1.介绍示例项目的Class设计。</p>

<h3>Creating the class</h3>

<p>1.import语句用于导入Swift的库文件，记性好的话，之前Apple在OC中加入了@import来替代#import（如：@import Foundation;替代#import &lt;Foundation/Foundation.h>），其实Swift中的import是和这个一致的。<br/>
2.定义一个类如下即可，但是如果如下，有未初始化赋值的非optional变量，那么会提示你增加初始化方法。</p>

<p>```objectivec
class Treasure {</p>

<pre><code>let what: String
let latitude: Double
let longitude:Double
</code></pre>

<p>}
init(what: String, latitude: Double, longitude: Double) {</p>

<pre><code>self.what = waht
self.latitude = latitude
self.longitude = longitude
</code></pre>

<p>}
```</p>

<h3>A struct-ural improvement</h3>

<p>1.下一步的优化是把经纬度信息做成一个结构体，那么就涉及到了Swift中的Struct，Swift中Struct和Class一样，都可以存储数据和拥有自己的方法，但要记住Struct始终是一个数值型的容器，它的用途只是持有数据，不要让它承担更多的功能。</p>

<p>```objectivec
struct GeoLocation {</p>

<pre><code>var latitude: Double
var longitude: Double
</code></pre>

<p>}
```</p>

<p>2.在Swift中，在工程中的文件是相互自动import的，所以你不用再去手动导入，这一点在你开发library和framework也是一样的。</p>

<h3>Reference types vs. value types</h3>

<p>1.Swift中，Struct与Class的最大区别是，Class在本质上是指针引用类型，而Struct是值类型，在赋值过程中，Class传递的是指针，而Struct则会copy一份新值，从如下的例子即可看出。</p>

<p>```objectivec
struct MyStruct {</p>

<pre><code>var foo: Double = 0.0
</code></pre>

<p>}
class MyClass {</p>

<pre><code>var foo: Double = 0.0
</code></pre>

<p>}
var structA = MyStruct()
var structB = structA
structB.foo = 1.0
print(structA.foo)
//0.0
print(structB.foo)
//1.0
var classA = MyClass()
var classB = classA
classB.foo = 1.0
print(classA.foo)
//1.0
print(classB.foo)
//0.0
```</p>

<p>2.需要说明的一点，Swift在copy一个Struct时是很智能的，只会在确定必要的时候copy，也就是说structB = structA并不会创建出拷贝，只有你开始改变其中一个值时，runtime会开始执行copy。<br/>
3.另外关于let类型的Struct和Class还有一些细微的区别，对于二者的var实例，是没有区别的，都可以改变各自的属性或将自身赋值给其他实例，但对于let实例，Class依然可以修改自己的属性变量，但是不能将自己赋值给其他实例，而Struct既不能改变自己的属性变量，也不能将自己赋值给其他实例，这也是为什么Array和Dictionary是Struct而不是Class。</p>

<p>```objectivec
struct MyStruct {</p>

<pre><code>var foo: Double = 0.0
</code></pre>

<p>}
class MyClass {</p>

<pre><code>var foo: Double = 0.0
</code></pre>

<p>}
var classA = MyClass()
let classB = MyClass()
classA.foo = 1.0
classB.foo = 1.0
classB = classA
//error
var structA = MyStruct()
let structB = MyStruct()
structA.foo = 1.0
structB.foo = 1.0
//error
structB = structA
//error
```</p>

<h3>Convenience initializers</h3>

<p>1.在实例中其实还是不必要将GeoLocation暴露给使用者，可以直接给出更方便的初始化方法，这就用到了convenience initializer，在该初始化方法中跳转到了原初始化方法中，也称为designated initializer。</p>

<p>```objectivec
convenience init(what: String, latitude: Double, longitude: Double) {</p>

<pre><code>let location = GeoLocation(latitude: latitude, longitude: longitude)
self.init(what: what, location: location)
</code></pre>

<p>}
```</p>

<p>2.Struct不需要显式的初始化方法，Swift为你自动添加了，你只需要按Struct的属性顺序一一初始化就行了，这也是为什么上述方法中可以自动初始化GeoLocation。</p>

<h3>Class inheritance</h3>

<p>1.Swift中的继承是怎样的？如下例：</p>

<p>```objectivec
class HistoryTreasure: Treasure {</p>

<pre><code>let yaer: Int
init(what: String, year: Int, latitude: Double, longitude: Double) {
    self.year = year
    let location = GeoLocation(latitude: latitude, longitude: longitude)
    super.init(what: what, location: location)
}
</code></pre>

<p>}
```</p>

<p>2.子类如果有自己新的属性时，需要自己的designated initializer，而子类的designated initializer必须引用父类的一个designated initializer（注意不可以是convenience initializer），所以和上一节比较相当于做了重复工作。<br/>
3.这里有与OC不同的一点，在OC中子类的init()方法中，是先调用父类的init()，再进行子类属性的赋值，而在Swift中是最后调用父类的init()，因为在Swift中是initializer来初始化所有属性，最后交给父类来处理，父类的init()要放在最后，是因为它不知道子类中声明的新属性，必须在它之前把这些新属性初始化。</p>

<!--more-->


<h2>Swift and MapKit</h2>

<p>1.重写父类方法，Swift中需要在方法前加上override关键字，增加了可读性，同时如果你写的方法不存在于父类，那么编译器会报error通知你。</p>

<p>```objectivec
override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()
</code></pre>

<p>}
```</p>

<h3>Class extensions and computed properties</h3>

<p>1.示例中需要将Treasure类型的变量显示在MKMapView上，那么就要使Treasure遵循MKAnnotation协议，我们使用了extension来实现：</p>

<p>```objectivec
import MapKit
extension Treasure: MKAnnotation {</p>

<pre><code>var coordinate: CLLocationCoordinate2D {
    return self.location.coordinate
}
var title: String {
    return self.what
}
</code></pre>

<p>}
```</p>

<p>2.extension类似OC的category，都是扩展类的技术，但是优于category，因为extension不但可以添加方法，还可以添加新属性。<br/>
3.这里添加的两个property有些特别，它们是Swift中的computed properties，每次访问它们都会执行后面的方法，用法与普通的properties是一致的。</p>

<h3>Your first struct extension</h3>

<p>1.Struct也可以添加extension，下例中的extension起到了分割代码，增加可读性的作用，这是extension的习惯用法。</p>

<p>```objectivec
import MapKit
extension GeoLocation {</p>

<pre><code>var coordinate: CLLocationCoordinate2D {
    return CLLocationCoordinate2DMake(self.latitude, self.longitude)
}
var mapPoint: MKMapPoint {
    return MKMapPointForCoordinate(self.coordinate)
}
</code></pre>

<p>}
```</p>

<h3>Inheriting from NSObject</h3>

<p>1.类遵循MKAnnotation同时，也应该遵循NSObject协议，因为MKAnnotation继承自NSObject协议。</p>

<h3>Pinning the map</h3>

<p>1.在viewDidLoad()中添加以下代码，完成mapView上打点的工作。</p>

<p><code>objectivec
self.mapView.delegate = self
self.mapView.addAnnotations(self.treasures)
</code></p>

<p>2.然后添加viewController的extension，并实现MKMapViewDelegate的方法：</p>

<p>```objectivec
extension ViewController: MKMapViewDelegate {</p>

<pre><code>func mapView(mapView: MKMapView, viewForAnnotation annotation: MKAnnotation) -&gt; MKAnnotationView
{
    if let treasure = annotation as? Treasure {
        var view = mapView.dequeueReusableAnnotationViewWithIdentifier("pin") as! MKPinAnnotationView!
        if view = nil {
            view = MKPinAnnotationView(annotation: annotation, reuseIdentifier: "pin")
            view.canShowCallout = true
            view.animatesDrop = false
            view.calloutOffset = CGPoint(x: -5, y: 5)
            view.rightCalloutAccessoryView = UIButton(type: .DetailDisclosure) as UIView
        } else {
            view.annotation = annotation
        }
        return view
    }
    return nil
}
</code></pre>

<p>}
```</p>

<p>3.在实现的mapView:viewForAnnotation方法中，annotation参数类型为MKAnnotation!，是一个隐式拆解的optional类型，但是我们还是进行了if/let的检查，因为这个方法是OC的API，是没有optional的，所以为了兼容Swift只能声明为这个类型，所以还需要显式拆解。<br/>
4.同时除了检查是否为nil，我们还要注意传入的类型是否为Treasure类型，这儿用到了inline downcasting技术，也是Swift的一种简写语法，if let treasure = annotation as？ Treasure{}，如果annotation不是Treasure类型，那么也不会进入if，这是Swift中确保类型正确的一种技术。<br/>
5.获取MKPinAnnotationView利用了一贯的复用技术，另外此处又一次用到了downcast技术，只不过因为返回的类型肯定可以确定都是MKPinAnnotationView，所以用了非optional版本。</p>

<h3>The reduce algorithm</h3>

<p>1.这一节是为了解决app载入后不能直接定位到目标位置，而要先定位自己的位置这个bug。</p>

<p><code>objectivec
let rectToDisplay = self.treasures.reduce(MKMapRectNull) {
  (mapRect: MKMapRect, treasure: Treasure) -&gt; MKMapRect in
  let treasurePointRect = MKMapRect(origin: treasure.location.mapPoint, size: MKMapSize(width: 0, height: 0))
  return MKMapRectUnion(mapRect, treasurePointRect)
}
self.mapView.setVisibleMapRect(rectToDisplay, edgePadding: UIEdgeInsetsMake(74, 10, 10, 10), animated: false)
</code></p>

<p>2.为了达到这一优化，实际就是要获取可以展示全部treasures的最小地图范围，然后在地图绘制这一区域。而输入是一个数组，需要一个它们逐个计算的结果，这里使用了函数式编程中的Reduce函数，这是处理这一问题的最佳方案，下面是Swift中reduce的原型，需要一个初始值initial，这里对应的是MKMapRectNull，是一个空区域，然后combine的方法是(mapRect: MKMapRect, treasure: Treasure) &ndash;> MKMapRect类型的方法，mapRect是每次执行后的返回值，初始值就是initial，而treasure是array每个元素的遍历，最后可以得到一个MKMapRect类型的区域，包含了所有元素的最小区域，然后setVisibleMapRect()，并加了边距来适应其他页面元素，最终达到了目的，Swift中的函数式编程还会在第七章继续讲解。</p>

<p><code>objectivec
reduce(initial: U, combine: (U, T) -&gt; U) -&gt; U
</code></p>

<!--more-->


<h2>Polymorphism</h2>

<p>1.现在又有新需求了，需要不同类型的Treasure在地图上显示Annotation颜色不同，这可以通过多态来实现，首先在父类中添加方法，再在子类中重写该方法：</p>

<p><code>objectivec
//in parent class
func pinColor() -&gt; MKPinAnnotationColor  {
  return MKPinAnnotationColor.Red
}
//in subclass
override func pinColor() -&gt; MKPinAnnotationColor  {
  return MKPinAnnotationColor.Purple
}
</code></p>

<p>2.然后在绘制MKPinAnnotationView那儿调用该方法：</p>

<p><code>objectivec
view.pinColor = treasure.pinColor()
</code></p>

<h3>Dynamic dispatch and final classes</h3>

<p>1.对于上面的Treasure多态，runtime是怎么执行的呢？是靠dynamic dispatch实现的，这一技术其实在OC里用的很普遍，OC作为动态语言，可以在runtime修改所传递的消息，甚至消息的接收者，都是靠动态分发(详细过程可参照前一部的Effective Objective-C2.0的笔记)。<br/>
2.Dynamic dispatch在Swift中依然存在，就是为了实现多态这类特性，不同于OC的消息分发机制，Swift的分发更像C++，它通过virtual tables(简称vtables)来实现。<br/>
3.如上例，当编译器遇到pinColor()调用，因为Treasure有很多子类，它便会去使用vtable去查找，而如果是Treasure的子类调用pinColor()，编译器依然会去先去查找vtable，而不是直接去调用pinColor()方法，因为它并不知道有没有类继续在继承，虽然开发者知道它是没有子类的。<br/>
4.所以通过告知编译器某些类没有子类，会提高app的效率，缩短运行时间，我们可以通过在类型前加final关键字来告知编译器这一信息。</p>

<p><code>objectivec
final class HistoryTreasure: Treasure
</code></p>

<!--more-->


<h2>Adding annotations</h2>

<p>1.继续，新的需求是用户点击每个annotation时弹出一个alertView来告知用户一些信息。因为每个alert提示的信息不同，所以打算将生成alert的任务交给treasure，然后viewController负责显示，采用的是利用protocol技术。<br/>
2.首先在Treasure.swift文件中声明Alertable协议，然后Treasure的子类分别遵循并实现其中的方法。</p>

<p>```objectivec
@objc protocol Alertable {</p>

<pre><code>fun alert() -&gt; UIAlertController
</code></pre>

<p>}
```</p>

<p>```objectivec
extension HistoryTreasure: Alertable {<br/>
  func alert() &ndash;> UIAlertController {</p>

<pre><code>let alert = UIAlertController(title: "History", message: "From \(self.year):\n\(self.what)", preferredStyle: UIAlertControllerStyle.Alert)
return alert
</code></pre>

<p>  }
}
```</p>

<p>3.然后在viewController中实现MapView点击Annotation的委托方法。</p>

<p>```objectivec
func mapView(mapView: MKMapView, annotationView view: MKAnnotationView, calloutAccessoryControlTapped control: UIControl) {
  if let treasure = view.annotation as? Treasure {</p>

<pre><code>if let alertable = treasure as? Alertable {
  let alert = alertable.alert()
  alert.addAction(UIAlertAction(title: "OK", style: UIAlertActionStyle.Default, handler: nil))
  self.presentViewController(alert, animated: true, completion: nil)
}
</code></pre>

<p>  }
}
```</p>

<!--more-->


<h2>Sorting an array</h2>

<p>1.新需求，用户可以在找到第一个treasure后能有选项可以使其找到下一个最近的treasure。首先我们给GeoLocation添加一个计算点之间的方法。</p>

<p><code>objectivec
func distanceBetween(other: GeoLocation) -&gt; Double {
  let locationA = CLLocation(latitude: self.latitude, longitude: self.longitude)
  let locationB = CLLocation(latitude: other.latitude, longitude: other.longitude)
  return locationA.distanceFromLocation(locationB)
}
</code></p>

<p>2.该方法是直接定义在struct的定义中的，Swift中的Struct可以定义方法，这也是它与C的Struct的最大区别，C中的Struct只能定义变量，导致与之相关的方法只能定义为全局方法，而如何按照类型归纳这些方法就需要开发者手工将其写到一个头文件中，这显然费时也不合理，而Swift真正实现了Struct中可以真正拥有自己的方法。<br/>
3.像用户点击Annotation后弹出的alert再添加一个Find Nearest的选项，并实现找到离该点最近的Treasure。</p>

<p>```objectivec
alert.addAction(UIAlertAction(title: &ldquo;Find Nearest&rdquo;, style: UIAlertActionStyle.Default) { action in
  var sortedTreasures = self.treasures
  sortedTreasures.sortInPlace {</p>

<pre><code>let distanceA = treasure.location.distanceBetween($0.location)
let distanceB = treasure.location.distanceBetween($1.location)
return distanceA &lt; distanceB
</code></pre>

<p>  }
  mapView.deselectAnnotation(treasure, animated: true)
  mapView.selectAnnotation(sortedTreasures[1], animated: true)
  })
```</p>

<p>4.上述代码的核心是sortedTreasures的排序，利用了sort()方法(Swift中改为sortInPlace())，$1和$2分别代表了传入方法的第一和第二参数，是简写形式，分别计算出两点距离当前treasure的距离，然后返回Bool告知是否已按照小大顺序排好，最后数组排序后，展示第二个元素，来展示最近的treasure。</p>

<p><code>objectivec
public mutating func sortInPlace(@noescape isOrderedBefore: (Self.Generator.Element, Self.Generator.Element) -&gt; Bool)
</code></p>

<!--more-->


<h2>Equality and operator overload</h2>

<p>1.照例，新需求，需要标记用户发现treasure的路径并在用户在已发现的treasure上操作时提示用户。<br/>
2.创建已找到Treasure的数组和要绘制的地图线，并实现MKMapViewDelegate的一个方法。</p>

<p><code>objectivec
private var foundLocations: [GeoLocation] = []
private var polyline: MKPolyline!
</code></p>

<p>```objectivec
func mapView(mapView: MKMapView, rendererForOverlay overlay: MKOverlay) &ndash;> MKOverlayRenderer {
  if let polylineOverlay = overlay as? MKPolyline {</p>

<pre><code>let renderer = MKPolylineRenderer(polyline: polylineOverlay)
renderer.strokeColor = UIColor.blueColor()
return renderer
</code></pre>

<p>  }
  return nil
}
```</p>

<p>3.在上一节添加alert的位置再添加Found项，再创建markTreasureAsFound()方法来标记已找到的Treasure，并绘制新的MKPolyline。</p>

<p><code>objectivec
alert.addAction(UIAlertAction(title: "Found", style: UIAlertActionStyle.Default) { action in
  self.markTreasureAsFound(treasure)
  })
</code></p>

<p>```objectivec
private func markTreasureAsFound(treasure: Treasure) {
  if let index = self.foundLocations.indexOf(treasure.location) {</p>

<pre><code>let alert = UIAlertController(title: "Oops!", message: "You've already found this treasure (at step \(index + 1))! Try again!", preferredStyle: .Alert)
alert.addAction(UIAlertAction(title: "OK", style: .Default, handler: nil))
self.presentViewController(alert, animated: true, completion: nil)
</code></pre>

<p>  } else {</p>

<pre><code>self.foundLocations.append(treasure.location)
if self.polyline != nil {
  self.mapView.removeOverlay(self.polyline)
}
var coordinates = self.foundLocations.map { $0.coordinate }
self.polyline = MKPolyline(coordinates: &amp;coordinates, count: coordinates.count)
self.mapView.addOverlay(self.polyline)
</code></pre>

<p>  }
}
```</p>

<p>4.首先利用find()函数（Swift2.0已弃用，改为collection的indexOf()方法）来获取目前位置是否已在foundLocations中，返回值为optional类型，所以需要if/let判断，这里就体现了这一技术的便利。<br/>
5.在创建MKPolyline时，先对foundLocations使用了map方法，map如前面提到的reduce一样，也是函数式编程的一种，它的作用是从一个数组中获取另外一个数组，这里就是从foundLocations得到了由其中每一个location的coordinate组成的新数组，$0代表每一个location。<br/>
6.这里需要实现find()方法（实际在Swift2.0已弃用），需要在GeoLocation中遵循Equatable协议，，因为find()中比较每个元素是通过==来比较的（类似OC中的isEqual()），而Class和Struc默认是不能用==比较的。这里用到了Swift的又一新特性，operator overload，既可以直接重写==这样的操作符，但需要注意下面对==的重写，并没有包含在extension中，因为operation overload都必须在定义在全局中，因为它本身并不属于某个类，它只是与一个类有关，基于要比较的的两个参数是这个类的实例。</p>

<p><code>objectivec
protocol Equatable {    func ==(lhs: Self, rhs: Self) -&gt; Bool}
</code></p>

<p><code>objectivec
extension GeoLocation: Equatable {
}
func ==(lhs: GeoLocation, rhs: GeoLocation) -&gt; Bool {
  return lhs.latitude == rhs.latitude &amp;&amp; lhs.longitude == rhs.longitude
}
</code></p>

<!--more-->


<h2>Access Control</h2>

<p>1.目前为止所有变量和方法都是public的，但Swift提供了访问权限的关键字，包括：Public(所有代码均可访问)、Internal(只在该target(library或app)下的代码可以访问，是默认权限)、Private(只有该文件可以访问)。<br/>
2.例如有一些类中的帮助方法，你不希望暴露在外，因为他们可以改变着一些不该暴露的内部状态信息。<br/>
3.需要注意的是Unit test通常是另外一个Target，如果你的代码有部分需要单元测试，那么需要声明为public。<br/>
4.与OC相比，OC是没有绝对的私有方法的，因为即使没有暴露在在头文件中，也可以通过runtime注入来访问私有方法。</p>

<p><code>objectivec
private func markTreasureAsFound(treasure: Treasure)
</code></p>

<p><code>objectivec
private var treasures: [Treasure] = []private var foundLocations: [GeoLocation] = [] private var polyline: MKPolyline!
</code></p>

<p>5.internal一般是不会显式声明的，如果是一个library被多个app使用，你可能会将内部类声明为internal，这样就不会被其他app中的代码使用了。<br/>
6.访问控制标志是表达你代码意图的很好的方式，可以使代码更易维护，也会减少Bug，</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Language Basics II]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/10/swift-by-tutorials-language-basics-ii/"/>
    <updated>2015-10-10T14:41:12+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/10/swift-by-tutorials-language-basics-ii</id>
    <content type="html"><![CDATA[<p>继上一篇后，本章将继续介绍Swift的基础知识，但是相比第一章会有所提升，包括了Optional类型对象的用法、Swift中的Collection类型用法以及与OC的Collection的不同之处。</p>

<!--more-->


<h2>Optionals</h2>

<p>1.空指针是一个困扰着各类语言的常见问题，在Java中，调用了空指针会直接抛出异常，在OC中向nil指针发送消息会返回nil，也就是说空指针是安全的，但有很多时候你并不希望指针为空，一般会加判断对象是否为nil的断言判断，但在Swift中，针对这个问题，有了新的解决方案。<br/>
2.Swift在对没有初始化赋值的变量使用时，会直接报错，而且像String类型也不能初始化直接赋nil值，这也保证了空指针不会出现。但是如果我们真的需要一个空值的变量怎么办呢？可以使用optional机制，它是用来指明一个变量是可能有值的，相当于给变量一个nil的默认值，这也是空指针的问题所在，它是一个合法的指针，但没有指向一个合法的对象。</p>

<h3>Declaring optionals</h3>

<p>1.使用optional很简单，如下，不赋值的话str默认为nil，在这里你可以把String?理解为一个不同于String的类型，所以能给String?直接赋值String类型实际上是Swift在内部进行了封装，Swift将String的值封装到了一个String?类型的实例中，然后再赋值给了str。</p>

<p><code>objectivec
//no assignment
var str: String?
//an assignment
var str: String? = "Swift by Tutorials!"
</code></p>

<p>2.如果你现在对str使用uppercaseString方法，会报错，这也验证了上面所说String?已是另一个类型的说法，那么如何让str使用String的方法呢？如下即可，通过if语句对str进行解封，并将其赋值给一个let型的String，这就是optional和if在Swift中的经典配合，这么做的好处就是让开发者可以在必选确认指针不为空的时候强制去进行空指针的检查。</p>

<p>```objectivec
if let unwrappedStr = str {</p>

<pre><code>print("Unwrapped! \(unwrappedStr.uppercaseString)")
</code></pre>

<p>} else {</p>

<pre><code>print("Was nil")
</code></pre>

<p>}
```</p>

<h3>Forced unwrapping</h3>

<p>1.在你了解optional机制下，在一些optional中你确定有值的时候，你可以使用强制解封，如下：</p>

<p><code>objectivec
var str: String? = "Swift by Tutorials!"
print("Force unwrapped! \(str!.uppercaseString)")
</code></p>

<p>2.但是需要注意的是，如果optional类型中的是nil值，那么会出现runtime error，所以使用强制解封，<strong>一定要在你100%确定你的optional对象不是空值</strong>。</p>

<h3>Implicit unwrapping</h3>

<p>1.你也可以不用!或者let来进行optional解封，使用以下方法，可以直接对变量使用方法，这看起来和没使用optional差不多，但是它在实质上和上述两种解封方法是一致的，只是语法不通而已，如果不去初始化赋值，那么你会得到和强制解封一个nil的optional的值一样的error。</p>

<p><code>objectivec
var str: String! = "Swift by Tutorials!"
str = str.lowercaseString
print(str)
</code></p>

<p>2.你也可以通过if来检查隐式解封的optional值，但你会发现这和OC中的做法一样，只不过在OC中你拿nil作为一个false的判断条件，而在Swift中你将nil作为一个无值的状态来判断。</p>

<p>```objectivec
if str != nil {</p>

<pre><code>str = str.lowercaseString
print(str)
</code></pre>

<p>}
```</p>

<p>3.<strong>最后注意，你要将隐式解封和强制解封一样重视，因为除了声明的地方，它和普通变量是一样的，这很容易忽视。</strong></p>

<h3>Optional chaining</h3>

<p>1.最后要介绍的是Optional chaining，这是上述三个解封方式之外的另一种optional来执行方法的方式，它的设计参照了OC中常用的delegate模式，即在optional类型变量执行方法时会先判断它是否为nil，不是nil的话直接执行，而如果是nil的话，则直接返回nil，其实和OC中对nil发送消息的处理是一样的。</p>

<p><code>objectivec
var maybeString: String? = "Swift by Tutorials!"
let uppercase = maybeString?.uppercaseString
</code></p>

<p>2.由于在对象声明和方法执行时两次使用optional，所以形成了Optional chaining。</p>

<!--more-->


<h2>Collection</h2>

<p>1.任何语言都会有集合类型，OC中有NSArray、NSDictionary、NSSet，其中包含可变和不可变类型，而在Swift中只保留了Array和Dictionary两种类型。</p>

<h3>Arrays</h3>

<p>1.Swift的Array有着其他语言中共同的特性，如下：</p>

<p><code>objectivec
//initialize array
var array = [1, 2, 3, 4, 5]
print(array[2])
//add an element
array.append(6)
print(array)
</code></p>

<p>2.Swift中你可以通过添加一个序列来扩展一个Array，比如上一节提到的Range。</p>

<p><code>objectivec
//add 7,8,9,10
//Swift2.0中将extend()改为了appendContentsOf()
//array.extend(7...10)
array.appendContentsOf(7...10)
</code></p>

<p>3.在上述数组中试图添加一个String，会直接报错，这在OC中可能是很正常的需求，可以在一个数组中添加不同类型的对象，但在Swift中只能在一个数组中添加同一类型的对象，在上面的Array初始化中是使用了type interface，如果制定类型声明的话应该是<em>var array: Array<Int> = [1, 2, 3, 4, 5]</em>（会在第四章详细说明），不过更常见的写法是<em>var arrray: [Int] = [1, 2, 3, 4, 5]</em>，这是Apple的语法糖，用来简化语法。</p>

<p><code>objectivec
//Array Initializer
var array: Array&lt;Int&gt; = [1, 2, 3, 4, 5]
var arrray: [Int] = [1, 2, 3, 4, 5]
</code></p>

<p>4.当然也可以让Array像NSArray那样工作，可以将类型声明为Array<Any>，但是仍然不推荐这么做，因为这样Swift的很多Array方法会因为类型不一而不能使用，而且也会失去Swift的提供的安全性保护。</p>

<p><code>objectivec
//add multiple type instance
var array: Array&lt;Any&gt; = []
array.append(6)
array.append("Swift By Tutorials!")
</code></p>

<h3>Dictionaries</h3>

<p>1.Swift的Dictionary与OC的NSDicionary大致相同，只是语法上略有变化，但需要注意的是，Dictionary也存在只能添加固定类型的键值对的情况，与上述的Array相同。</p>

<p><code>objectivec
var dictionary = [1: "Dog", 2: "Cat"]
//Another Initializer
//var dictionary: Dictionary&lt;Int:String&gt; = [1: "Dog", 2: "Cat"]
//var dictionary: [Int:String] = [1: "Dog", 2: "Cat"]
print(dictionary[1])
dictionary[3] = "Mouse"
print(dictionary)
dictionary[3] = nil
print(dictionary)
</code></p>

<p>2.从Dictionary中通过key直接获取值时，该值是optional类型的，因为有可能是不存在该key对应的值的，所以推荐读取Dictionary时还是使用上一章中介绍的安全拆解的方法，这又是Swift强制开发者随时考虑安全问题的一个表现。</p>

<p>```objectivec
if let value = dictionary[1] {</p>

<pre><code>print("Value is \(value)")
</code></pre>

<p>}
```</p>

<h3>Reference and copies</h3>

<p>1.这一节讨论Dictionary和Array在Swift中与OC所不同的内存管理策略，如下，从结果发现，Swift中将一个Dictionary直接赋值给另外的变量或常量，都是执行copy操作的，即改变新变量，并不会影响原来的Dictionary。</p>

<p><code>objectivec
var dictionaryA = [1: 1, 2: 4, 3: 9, 4: 16]
var dictionaryB = dictionaryA
print(dictionaryA)
print(dictionaryB)
dictionaryB[4] = nil
print(dictionaryA)
print(dictionaryB)
</code></p>

<p>2.那么关于Array呢？答案是一样的，Array也是会执行copy操作，这与OC中的NSDictionary和NSArray的指针赋值是完全不同的，所以单独强调一下。</p>

<p><code>objectivec
var arrayA = [1, 2, 3, 4, 5]
var arrayB = arrayA
print(arrayA)
print(arrayB)
arrayB.removeAtIndex(0)
print(arrayA)
print(arrayB)
</code></p>

<h3>Constant collection</h3>

<p>1.上面都是定义的var类型的Dictionary和Array，那么如果定义为let的话，Dictionary和Array是不能进行任何修改操作的（其实就是OC中的不可变类型）。</p>

<p><code>objectivec
let constantArray = [1, 2, 3, 4, 5]
//error
constantArray.append(6)
constantArray.removeAtIndex(0)
</code></p>
]]></content>
  </entry>
  
</feed>
