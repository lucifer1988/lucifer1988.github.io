<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 刘毅的技术博客]]></title>
  <link href="http://lucifer1988.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://lucifer1988.github.io/"/>
  <updated>2015-11-26T16:56:08+08:00</updated>
  <id>http://lucifer1988.github.io/</id>
  <author>
    <name><![CDATA[刘毅]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Swift and Cocoa]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/25/swift-by-tutorials-swift-and-cocoa/"/>
    <updated>2015-11-25T11:20:10+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/25/swift-by-tutorials-swift-and-cocoa</id>
    <content type="html"><![CDATA[<p>Swift是一门新推出的语言，但是核心框架还是Cocoa，这与OC是一致的，Cocoa的Foundation和UIKit框架对于开发应用仍是最重要的。这一章将创建一个应用，主要介绍Swift一Cocoa直接的交互，同时了解Cocoa的设计模式如何在Swift中体现出来。</p>

<!--more-->


<h2>Getting started</h2>

<p>作者提供了一个starter project，添加了一个viewcontroller和之前介绍的JSON.swift（帮助解析JSON的工具类），另外还有facebook的SDK，所以接下来会介绍如何在Swift中混用OC代码。</p>

<h2>Bridging Swift and Objectivec-C</h2>

<p>通过<strong>bridging</strong>技术，可以让我们在Swift和OC间相互调用。</p>

<h3>Swift bridging header</h3>

<p>新建一个OC的.h文件，如：CafeHunter-ObjCBridging.h，然后在<strong>Build Settings</strong>中找到<strong>Objective-C Bridging Header</strong>，填写该头文件的路径，如：CafeHunter/CafeHunter-ObjCBridging.h，然后可以在该头文件中添加所需的OC头文件，如下，这样就可以在Swift中使用OC的类和方法了。</p>

<p>```objectivec</p>

<h1>import &lt;FacebookSDK/FacebookSDK.h></h1>

<p>```</p>

<p><code>objectivec
FBSettings.setDefaultAppID("INSERT_YOUR_FB_APP_ID")
</code></p>

<h3>Objective-C compatibility header</h3>

<p>那么如何在OC中使用Swift代码呢？还记得刚才在<strong>Build Settings</strong>中找到的<strong>Objective-C Bridging Header</strong>上面的<strong>Install Objective-C Compatibility Header</strong>吗？该项就是控制Swift向OC转换的开关，默认是打开的。</p>

<p>在report navigation的Build，中可以找到<strong> Copy CafeHunter-Swift.h</strong>的信息，可以双击打开该文件，你会发现你用Swift中创建的继承于OC的类和方法都在这里有对应的OC代码，而且实际上还有用@objec标记的代码，也有对应的转化。需要注意的两点是：</p>

<ol>
<li>Swift中的私有方法是没有转化的，因为理论上外部不可能使用私有方法，但私有方法仍会注册在runtime中。</li>
<li>转化的代码每个类之前会有一行类似<strong>SWIFT_CLASS(&ldquo;_TtC10CafeHunter11AppDelegate&rdquo;)</strong>的代码，实际上是Swift的压缩命名，为每个类添加了命名空间，也是该类在runtime中实际的名字，即使不同库中有相同名类，编译器也会通过该类名，准确找到对应的类。</li>
</ol>


<h2>Adding the UI</h2>

<p>添加一个FaceBook的登录View和MKMapView到Storybiard，然后关联到代码，如下。</p>

<p><code>objectivec
@IBOutlet weak var mapView: MKMapView!
@IBOutlet weak var loginView: FBLoginView!
</code></p>

<p>有几点说明：</p>

<ol>
<li>outlet的类型是optional的，而且是隐式拆解的，这是因为如果不这么设置，编译器会发现这些变量没有在初始化中赋值，从而报错，所以这是为了避免编译器报错的手段，但我们知道它会在IB中初始化，所以采用了隐式拆解。使用outlet时不用再去拆解，但同时需要注意在view加载之前调用它们会导致崩溃，这点需要谨记。</li>
<li>outlet被加了weak关键字，这和OC中是一致的，是因为viewController的view对outlet是有强引用的，所以不必再添加额外的强引用。</li>
</ol>


<h3>Showing the user&rsquo;s location</h3>

<p>在Swift中长把协议的实现放在单独的extension中，这样可以将代码分组，但依然可以访问原类的变量和方法。</p>

<p>```objectivec
extension ViewController: MKMapViewDelegate {</p>

<p>  func mapView(mapView: MKMapView, didFailToLocateUserWithError error: NSError) {</p>

<pre><code>print(error)
let alert = UIAlertController(title: "Error", message: "Failed to obtain location!", preferredStyle: .Alert)
alert.addAction(UIAlertAction(title: "OK", style: .Default, handler: nil))
self.presentViewController(alert, animated: true, completion: nil)
</code></pre>

<p>  }</p>

<p>  func mapView(mapView: MKMapView, didUpdateUserLocation userLocation: MKUserLocation) {</p>

<pre><code>let newLocation = userLocation.location!
let distance = self.lastLoction?.distanceFromLocation(newLocation)
if distance == nil || distance &gt; searchDistance {
  self.lastLoction = newLocation
  self.centerMapOnLocation(newLocation)
  self.fetchCafesAroundLocation(newLocation)
}
</code></pre>

<p>  }
}
```</p>

<p>本节其他部分都是一些业务逻辑方面的内容，数不赘述。</p>

<h2>Fetching data</h2>

<p>前面的开发进行到了最后一步，就是将用户位置附近的咖啡馆找出来，并在地图上展示，这依赖于一个FaceBook的接口访问，同时本地需要定义咖啡馆的模型。</p>

<h3>Building the data model</h3>

<p>先定义Cafe的model，首先你会想到Cafe在这里是一个纯数据类型，你可能会使用struct，因为Swift中struct也是model的选择之一。</p>

<p>但同时，你希望Cafe可以直接被显示到地图上，那么它就必须遵循MKAnnotation协议，这时，编译器便会报错，因为MKAnnotation是OC的协议，Cafe遵循该协议，必须可以被转化为OC代码，但struct在OC中只是一个C的数据类型，无法转化，所以这里必须声明Cafe为class，且必须继承自NSObject，因为MKAnnotation也遵循NSObject协议。最后，别忘了在init()结尾，添加<strong>super.init()</strong>，这样才能调到NSObject的初始化方法。</p>

<p>```objectivec
import Foundation
import MapKit</p>

<p>class Cafe: NSObject {
  let fbid: String
  let name: String
  let location: CLLocationCoordinate2D
  let street: String
  let city: String
  let zip: String</p>

<p>  init(fbid: String, name: String, location: CLLocationCoordinate2D, street: String, city: String, zip: String) {    self.fbid = fbid</p>

<pre><code>self.name = name
self.location = location
self.street = street
self.city = city
self.zip = zip
super.init()  }
</code></pre>

<p>}</p>

<p>extension Cafe: MKAnnotation {
  var title: String? {</p>

<pre><code>return name
</code></pre>

<p>  }
  var coordinate: CLLocationCoordinate2D {</p>

<pre><code>  return location
</code></pre>

<p>  }
}
```</p>

<h3>Fetching from Facebook</h3>

<p>下面将从Facebook的接口获取数据。</p>

<p>```objectivec
var urlString = &ldquo;<a href="https://graph.facebook.com/v2.0/search/">https://graph.facebook.com/v2.0/search/</a>&rdquo;
urlString += &ldquo;?access_token=&rdquo;
urlString += &ldquo;(FBSession.activeSession().accessTokenData.accessToken)&rdquo;
urlString += &ldquo;&amp;type=place&rdquo;
urlString += &ldquo;&amp;q=cafe&rdquo;
urlString += &ldquo;&amp;center=(location.coordinate.latitude),&rdquo;
urlString += &ldquo;(location.coordinate.longitude)&rdquo;
urlString += &ldquo;&amp;distance=(Int(searchDistance))&rdquo;</p>

<p>let url = NSURL(string: urlString)!
print(&ldquo;Request URL: (url)&rdquo;)</p>

<p>let request = NSURLRequest(URL: url)
NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.mainQueue()) { (response: NSURLResponse?, data: NSData?, error: NSError?) &ndash;> Void in</p>

<pre><code>if error != nil {
  let alert = UIAlertController(title: "Oops!", message: "An error occured", preferredStyle: .Alert)
  alert.addAction(UIAlertAction( title: "OK", style: .Default, handler: nil))
  self.presentViewController(alert, animated: true, completion: nil)
  return
}

let jsonObject: AnyObject! = try? NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions(rawValue: 0))

if let jsonObject = jsonObject as? [String:AnyObject] {
    if let data = JSONValue.fromObject(jsonObject)?["data"]?.array {
        var cafes: [Cafe] = []
        for cafeJSON in data {
        if let cafeJSON = cafeJSON.object {
            if let cafe = Cafe.fromJSON(cafeJSON) {
                cafes.append(cafe)
            }
        }
    }

    self.mapView.removeAnnotations(self.cafes)
    self.cafes = cafes
    self.mapView.addAnnotations(cafes)
    }
}
</code></pre>

<p>}
```</p>

<ol>
<li>首先拼接要访问的URL，采用了String拼接，而不是stringWithFormat:，这样代码比较清晰</li>
<li>然后将string转化为NSURL，虽然NSURL的参数需要NSString，但是使用String也没问题，这是因为Swift对它们进行了无缝的桥接。</li>
<li>使用了NSURLConnection的异步请求，使用closure处理回调。</li>
<li>JSON的反序列化，目前Swift2.0采用了try/catch这样的写法，而弃用了之前OC的传入NSError**参数的做法，代码更简洁。</li>
<li>NSJSONSerialization的JSONObjectWithData()方法实际返回的是NSDictionary，但是我们使用时是转化成[NSObject:AnyObject]，这也是Swift的隐式转换，还有NSArray和[AnyObject]。</li>
<li>具体的JSON对象的解析，使用了JSON.swift库，关于这个库的原理在之前讲过，主要是利用enum的新特性，为每一种JSON元素类型提供了type。</li>
</ol>


<h3>Parsing the JSON data</h3>

<p>让我们在Cafe类中添加一个直接从JSON初始化的方法，在取JSON每一个元素时，一定要注意使用optional类型，这样可以保证不会因为某个值不存在而崩溃。</p>

<p>```objectivec
class func fromJSON(json: [String:JSONValue]) &ndash;> Cafe? {
   let fbid = json[&ldquo;id&rdquo;]?.string
   let name = json[&ldquo;name&rdquo;]?.string
   let latitude = json[&ldquo;location&rdquo;]?[&ldquo;latitude&rdquo;]?.double
   let longitude = json[&ldquo;location&rdquo;]?[&ldquo;longitude&rdquo;]?.double</p>

<p>   if fbid != nil &amp;&amp; name != nil &amp;&amp; latitude != nil &amp;&amp; longitude != nil {</p>

<pre><code>   var street: String
   if let maybeStreet = json["location"]?["street"]?.string {
       street = maybeStreet
   } else {
       street = ""
   }

   var city: String
   if let maybeCity = json["location"]?["city"]?.string {
       city = maybeCity
   } else {
       city = ""
   }

   var zip: String
   if let maybeZip = json["location"]?["zip"]?.string {
       zip = maybeZip
   } else {
       zip = ""
   }

   let location = CLLocationCoordinate2D(latitude: latitude!, longitude: longitude!)
   return Cafe(fbid: fbid!, name: name!, location: location, street: street, city: city, zip: zip)
</code></pre>

<p>   }
   return nil
}
```</p>

<p>从OC的角度考虑，我们可能会问，为什么不写一个secondary初始化方法？这是由于Swift决定的，某个类初始化方法是不能返回nil值的，如果可以，那么所有的Swift类型都是optional类型了，那么区分optional就没有意义，所以我们一定要注意，像构建这类可能返回nil的初始化方法，最好采用该类型的工厂方法来实现。</p>

<h2>Selectors</h2>

<p>这一小节想给app加一个刷新按钮，引出OC中的target/selector模式在Swift中如何使用的问题。</p>

<p>OC中的方法调用是动态分发的，即方法的调用者（target）和方法名（SEL）都是可以在runtime动态分发的，而且你可以在runtime中修改这些值，而编译器不会在意该方法有没有实现。而在Swift中，所有的方法调用在编译期间就会决定，不再采用动态分发。那么如何解决Swift中调用原OC中需要target/SEL的方法，就需要得到解决。</p>

<p>Swift给出的方案是使用一个结构体Selector，Selector遵循了StringLiteralConvertible协议，其内部使用时可以直接从String转换，而使用者只需传入一个String即可。</p>

<p><code>objectivec
self.navigationItem.leftBarButtonItem = UIBarButtonItem(barButtonSystemItem: .Refresh, target: self, action: "refresh:")
</code></p>

<p><code>objectivec
public convenience init(barButtonSystemItem systemItem: UIBarButtonSystemItem, target: AnyObject?, action: Selector)
</code></p>

<p>你可以尝试不去实现refresh:方法，而编译器也不会报错，而在执行时才会报错，这就是因为它的真正实现还是使用了OC的动态分发，只是做了Swift的桥接。</p>

<h2>Protocols and delegates</h2>

<p>接下来会为每个cafe创建一个detail view，并定义一个protocol，使用委托模式，并确保可以桥接到OC。</p>

<h3>Creating the detail view</h3>

<p>创建对应的viewController，并在storyboard上定义好xib。</p>

<p>这里声明了一个Cafe变量作为数据源，如下，与以往不同的是，添加了didSet()方法，该方法会在cafe被赋值之后会调用，类似OC中的KVO，你可以为实现变量的didSet和willSet，分别在赋值前和复制后调用。</p>

<p>```objectivec
var cafe: Cafe? {
  didSet {</p>

<pre><code>self.setupWithCafe()
</code></pre>

<p>  }
}
```</p>

<p>在Cafe类添加一个pictureURL变量，是一个computed property，提供了返回值。</p>

<p><code>objectivec
var pictureURL: NSURL {
return NSURL(string: "http://graph.facebook.com/place/picture?id=\(self.fbid)&amp;type=large")!
}
</code></p>

<p>接下来是setupWithCafe()方法，由于该方法放在了cafe的didSet中调用了，而且存在很多outlet存在，需要判断这些outlet是否加载完成，所以先进行了self.isViewLoaded()判断。</p>

<p>```objectivec
private func setupWithCafe() {
  if !self.isViewLoaded() {</p>

<pre><code>return
</code></pre>

<p>  }</p>

<p>  if let cafe = self.cafe {</p>

<pre><code>self.title = cafe.name

self.nameLabel.text = cafe.name
self.streetLabel.text = cafe.street
self.cityLabel.text = cafe.city
self.zipLabel.text = cafe.zip

let request = NSURLRequest(URL: cafe.pictureURL)
NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.mainQueue()) {
  (response: NSURLResponse?, data: NSData?, error: NSError?) -&gt; Void in
  let image = UIImage(data: data!)
  self.imageView.image = image
}
</code></pre>

<p>  }
}
```</p>

<h3>Wiring up the detail view</h3>

<p>在ViewController中，通过实现mapView(mapView: MKMapView!, viewForAnnotation annotation: MKAnnotation!) &ndash;> MKAnnotationView!和mapView(mapView: MKMapView!, annotationView view: MKAnnotationView!, calloutAccessoryControlTapped control: UIControl!)两个MKMapViewDelegate的方法，完成了通过点击大头针，弹出详情按钮，再进入详情页的功能。</p>

<p>这里还想将ViewController作为CafeViewController的委托，在CafeViewController点击返回时调用。</p>

<p><code>objectivec
@objc protocol CafeViewControllerDelegate {
  optional func cafeViewControllerDidFinish(viewController: CafeViewController)
}
</code></p>

<p>这里在声明protocol前加了<strong>@objc</strong>关键字是因为该protocol有optional方法，因为这样可以使Swift添加多个runtime检测，来检测protocol的一致性和是否实现了optional类型的方法。同时这也限制了，protocol的实现者必须是class类型，因为runtime对@obj的检测需要对象为class。而你也可以通过在protocol后加限制来实现。</p>

<p><code>objectivec
@objc protocol CafeViewControllerDelegate: class {
  optional func cafeViewControllerDidFinish(viewController: CafeViewController)
}
</code></p>

<p>然后在CafeViewController添加delegate变量，与OC一样，使用weak属性，需要注意的是声明为optional类型，因为不是一定有委托对象的。</p>

<p><code>objectivec
weak var delegate: CafeViewControllerDelegate?
</code></p>

<p>然后是delegate的调用，这里使用了optional chain，delegate的存在与cafeViewControllerDidFinish()方法的实现与否都是不确定的。</p>

<p>```objectivec
@IBAction private func back(sender: AnyObject) {</p>

<pre><code>self.delegate?.cafeViewControllerDidFinish?(self)}
</code></pre>

<p>```</p>

<p>最后，是在ViewController中的delegate实现。</p>

<p>```objectivec
extension ViewController: CafeViewControllerDelegate {
  func cafeViewControllerDidFinish(viewController: CafeViewController) {</p>

<pre><code>self.dismissViewControllerAnimated(true, completion: nil)
</code></pre>

<p>  }
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Functional Programming]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/23/swift-by-tutorials-functional-programming/"/>
    <updated>2015-11-23T14:09:04+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/23/swift-by-tutorials-functional-programming</id>
    <content type="html"><![CDATA[<p>前几篇分别介绍了泛型、类、枚举、范围运算符这些Swift的语言新特性，当然有一部分是对已有技术的改进，但这已经表明Swift是比OC更具表现力和更简洁的语言。而Swift不仅仅是提供了更好的语法，在Swift中，函数式编程会成为编程中可行的并且非常重要的编程工具。函数式编程，简而言之，就是一种通过数学式的函数概括计算的编程范式，不可变且具表现力，同时使用最少的变量和状态值。函数式编程对于测试是非常友好的。随着多核设备的普及，并行和并发处理显得非常重要，而函数式编程就是可以很好处理并行和并发处理的，这也是它日趋重要的原因之一。</p>

<!--more-->


<h2>Simple array filtering</h2>

<p>这个简单的例子要求我们在1到10之间找到所有的偶数的数字，看起来是一个简单的工作，但是是介绍函数式编程的一大步。</p>

<h3>Filtering the old way</h3>

<p>```objectivec
var evens = <a href="">Int</a>
for i in 1&hellip;10 {</p>

<pre><code>if i % 2 == 0 {
evens.append(i)
}
</code></pre>

<p>}
print(evens)
```</p>

<p>这是一个很简单的小程序，而且运行也没问题，但是最核心的逻辑，检测一个数是否偶数，被隐藏在了for循环中。另外，添加数字到数组的逻辑在判断条件中，如果你想要打印每个偶数，那么除了复制粘贴，没法儿复用这部分代码。</p>

<h3>Functional filtering</h3>

<p>让我们来看看函数式的解决方案，其中filter是核心，通过传递isEven给filter，直接返回了我们需要的新数组。</p>

<p>```objectivec
func isEven(number: Int) &ndash;> Bool {</p>

<pre><code>return number%2 == 0
</code></pre>

<p>}
evens = Array(1&hellip;10).filter(isEven)
print(evens)
```</p>

<p>通过上一章我们知道函数只是有名字的闭包，按照之前的介绍，利用type inference我们可以对该方案进一步简化。</p>

<p><code>objectivec
evens = Array(1...10).filter { number in number % 2 == 0 }
println(evens)
</code></p>

<p>或者最简化的使用参数简化符号。</p>

<p><code>objectivec
evens = Array(1...10).filter{ $0%2 == 0 }
print(evens)
</code></p>

<p>对于简化符号的使用，作者表示，对于比较简单的逻辑（如上例）推荐使用简化符号，而对于复杂的逻辑，则不推荐使用，因为即使减少了代码量，但牺牲了可读性，还是不太划算。</p>

<p>上面的函数式编程较上一节的方案，更为简洁，而同时它也反映了，函数式编程三个共同的特点。</p>

<ol>
<li>Higher-order functons：你需要将这些函数当做参数传入其他函数，该例中isEven即是Higher-order functons。</li>
<li>First-class function：这也是我们多次强调的一点，函数作为第一类对象，可以作为参数或者返回结果，这也是函数式编程的基础，Swift全面支持这一点。</li>
<li>Closures：闭包，可以使代码更简洁，相当于匿名函数。</li>
</ol>


<p>你可能觉得OC的block也具有类似的特点，但Swift较之更胜一筹，主要是因为它拥有很多内建的函数式语法，比如该例中的filter就是。</p>

<h3>The magic behind filter</h3>

<p>通过自定义一个myFilter方法，让我们来看一下filter的背后实现。</p>

<p>```objectivec
func myFilter<T>(source: [T], predicate:(T) &ndash;> Bool) &ndash;> [T] {</p>

<pre><code>var result = [T]()
for i in source {
    if predicate(i) {
        result.append(i)
    }
}
return result
</code></pre>

<p>}
```</p>

<p>从上面发现，实际上的实现和我们在第一节的逻辑是相同的，只不过通过泛型和函数作为参数完成了filter这一过程的抽象，这也是函数式编程的本质。</p>

<p>原文还提出一个将myFilter()作为Array的一个方法，而不是函数，其实只需要添加一个Array的扩展，将泛型改为Array自身的元素就行，下面给出自己的解答。</p>

<p>```objectivec
extension Array {</p>

<pre><code>func myFilter&lt;T&gt;(predicate:(T) -&gt; Bool) -&gt; [T] {
    var result = [T]()
    for i in self {
        if predicate(i as! T) {
            result.append(i as! T)
        }
    }
    return result
}
</code></pre>

<p>}
evens = Array(1&hellip;10).myFilter{$0%2 == 0}
```</p>

<h2>Reducing</h2>

<p>这一节将介绍Swift中内建的，比较复杂的reduce函数，进一步了解函数式编程。</p>

<h3>Manual reduction</h3>

<p>reduce的效果是输入一个数组，但最终得到一个结果，例子是要求我们找出1到10的所有偶数，并计算出他们的和，先看下常规控制流的实现。</p>

<p>```objectivec
var evens = <a href="">Int</a>
for i in 1&hellip;10 {</p>

<pre><code>if i % 2 == 0 {
    evens.append(i)
}
</code></pre>

<p>}
var evenSum = 0
for i in evens {</p>

<pre><code>evenSum += i
</code></pre>

<p>}
print(evenSum)
```</p>

<h3>Functional reduce</h3>

<p>下面是reduce的函数式实现，这里采用的是全简写符号。</p>

<p><code>objectivec
let evenSum = Array(1...10).filter{$0%2 == 0}.reduce(0){$0+$1}
print(evenSum)
</code></p>

<p>reduce的函数原型如下，有两个参数，initial和combine，initial为U类型，最终的返回值也是U类型，而combine的参数是U和T类型，返回值也是U类型，每次执行完后，返回值都会成为combine新的参数，所以实现了上述的累加效果。</p>

<p><code>objectivec
func reduce&lt;U&gt;(initial: U, combine: (U, T) -&gt; U) -&gt; U
</code></p>

<p>这里还有一个寻找数组中最大值的例子。</p>

<p><code>objectivec
let maxNumber = Array(1...10).reduce(0){total, number in max(total, number)}
print(maxNumber)
</code></p>

<p>我们发现，输入值T和最终返回值U可以是不同的类型，所以可以有更多的应用，比如下面的字符串输出。</p>

<p><code>objectivec
let numbers = Array(1...10).reduce("numbers:"){$0+"\($1)"}
print(numbers)
</code></p>

<p>这里又有一个附加问题，要求输入一个[&ldquo;3&rdquo;, &ldquo;1&rdquo;, &ldquo;4&rdquo;, &ldquo;1&rdquo;]数组，而输出Int值3141，我的思路是先拼接字符串，然后转为Int。</p>

<p><code>objectivec
let digits = Int(["3", "1", "4", "1"].reduce(""){$0+$1})
print(digits)
</code></p>

<h3>The magic behind reduce</h3>

<p>下面我们自己为Array添加一个自定义的reduce方法，实现方法与我们在之前的实现是一致的，还是做了一步抽象。</p>

<p>```objectivec
extension Array {</p>

<pre><code>func myReduce&lt;T, U&gt;(seed:U, combiner:(U, T) -&gt; U) -&gt; U {
    var result = seed;
    for i in self {
        result = combiner(result, i as! T)
    }
    return result
}
</code></pre>

<p>}
```</p>

<h2>Building an index</h2>

<p>接下来，我们将实践一次函数式编程，题目是将下面的String数组，按照首字母进行分组。</p>

<p><code>objectivec
let words = ["Cat", "Chicken", "fish", "Dog", "Mouse", "Guinea Pig", "monkey"]
</code></p>

<p>首先现有一个大致的思路，建立一个元组，包含首字母和其对应的String数组，最后通过一个函数返回一个该元组的数组，然后就完成了任务。</p>

<p>```objectivec
typealias Entry = (Character, [String])</p>

<p>func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>return [Entry]()
</code></pre>

<p>}
```</p>

<h3>Building an index imperatively</h3>

<p>下面是常规控制流实现，使用了两个for循环，一个用于记录所有的首字母key，第二个用于将原数组添加到对应的元组中。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {
  var result = <a href="">Entry</a>
  var letters = <a href="">Character</a>
  for word in words {</p>

<pre><code>let firstLetter = Character(word.substringToIndex(
  advance(word.startIndex, 1)).uppercaseString)
if !contains(letters, firstLetter) {
  letters.append(firstLetter)
}
</code></pre>

<p>  }
  for letter in letters {</p>

<pre><code>var wordsForLetter = [String]()
for word in words {
  let firstLetter = Character(word.substringToIndex(
    advance(word.startIndex, 1)).uppercaseString)
  if firstLetter == letter {
    wordsForLetter.append(word)
  }
}
result.append((letter, wordsForLetter))
</code></pre>

<p>  }
  return result
}
```</p>

<h3>Building an index the functional way</h3>

<p>下面是该问题的函数式解决方案，首先我们利用Array的map函数，得到words对应的首字母数组。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>let letters = words.map { word -&gt; Character in
Character(word.substringToIndex(word.startIndex.advancedBy(1)).uppercaseString)
}
return [Entry]()
</code></pre>

<p>}
```</p>

<p>map与前面的filter，reduce一样都是Array的内建函数，它的作用是输出一个与原数组对应的相关数组。而且数组元素可以与原数组不同，这里通过map得到了words对应的首字母数组，但是不足的是重复字母并没有过滤。我们可以像之前一样自定义一个过滤相同字母的函数。</p>

<p>```objectivec
func distinct&lt;T: Equatable> (source: [T]) &ndash;> [T] {</p>

<pre><code>var unique = [T]()
for item in source {
    if !unique.contains(item) {
        unique.append(item)
    }
}
return unique
</code></pre>

<p>}
```</p>

<p>利用这一函数，过滤重复字母。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>let letters = words.map { word -&gt; Character in 
Character(word.substringToIndex(word.startIndex.advancedBy(1)).uppercaseString)
}
let distinctLetters = distinct(letters)
print(distinctLetters)
return [Entry]()
</code></pre>

<p>}
```</p>

<p>最后，我们利用map和filter的嵌套使用，完成最终的结果数组。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>let letters = words.map { word -&gt; Character in 
Character(word.substringToIndex(word.startIndex.advancedBy(1)).uppercaseString)
}
let distinctLetters = distinct(letters)

return distinctLetters.map { letter -&gt; Entry in
    return (letter, words.filter { word -&gt; Bool in 
    Character(word.substringToIndex(word.startIndex.advancedBy(1)).uppercaseString) == letter
        })
}
</code></pre>

<p>}
```</p>

<p>在完成基础上我们可以进一步重构，我们在buildIndex()函数中声明了一个新的函数firstLetter()，该函数的作用范围只在外围函数中，这得益于Swift中function作为第一类对象，所以可以被视作本地变量，也有作用范围。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>func firstLetter(str: String) -&gt; Character {
    return Character(str.substringToIndex(str.startIndex.advancedBy(1)).uppercaseString)
}

let letters = words.map { word -&gt; Character in
    return firstLetter(word)
}
let distinctLetters = distinct(letters)
print(distinctLetters)

return distinctLetters.map { letter -&gt; Entry in
    return (letter, words.filter { word -&gt; Bool in
        firstLetter(word) == letter
        })
}
</code></pre>

<p>}
```</p>

<p>然而，这还不是最简形式，追求最简形式，可以将所有函数连续调用，这是没问题的，以下是最终结果。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>func firstLetter(str: String) -&gt; Character {
    return Character(str.substringToIndex(str.startIndex.advancedBy(1)).uppercaseString)
}

return distinct(words.map(firstLetter))
    .map {
      letter -&gt; Entry in
      return (letter, words.filter {
        word -&gt; Bool in
        firstLetter(word) == letter
      })
    }
</code></pre>

<p>}
```</p>

<p>通过比较，你会发现，在常规做法中，你会声明很多临时变量，而在函数式编程中，你会使用对应的常量替代，这就意味着是不可变的，而不可变的类型更容易测试和协助并发，函数式编程与不可变类型是一体的，而且会导致你的代码更简洁，错误更少。</p>

<p>这节的挑战任务是需要输出的结果按字母排序，我们可以添加之前介绍过的最简的sort()方法，在distinct()之后进行调用。</p>

<p>```objectivec
func buildIndex(words: [String]) &ndash;> [Entry] {</p>

<pre><code>func firstLetter(str: String) -&gt; Character {
    return Character(str.substringToIndex(str.startIndex.advancedBy(1)).uppercaseString)
}

return distinct(words.map(firstLetter)).sort(&lt;)
    .map {
      letter -&gt; Entry in
      return (letter, words.filter {
        word -&gt; Bool in
        firstLetter(word) == letter
      })
    }
</code></pre>

<p>}
```</p>

<h2>Partial application and currying</h2>

<p>前面几节围绕Array的三个方法，map，reduce，filter来介绍函数式编程。这一节将进一步介绍函数式编程的Partial application和currying。这里有一篇<a href="http://segmentfault.com/a/1190000000765247">博客</a>也进行了简单的介绍。</p>

<h3>Partial application</h3>

<p>为了说明Partial application，先提出一个问题，切割字符串为数组，我们的常用解决方案就是就是直接调用NSString的componentsSeparatedByString()方法。</p>

<p><code>objectivec
import Foundation
let data = "5,7;3,4;55,6"
print(data.componentsSeparatedByString(";"))
print(data.componentsSeparatedByString(","))
</code></p>

<p>这么调用也没问题，但是如果有场景需要我们多次用分号，或者逗号切割字符串，这样处理会出现许多重复代码，那么partical application就是这类问题的解决方案。</p>

<p>```objectivec
func creatSplitter(separator: String) &ndash;> (String &ndash;> [String]) {</p>

<pre><code>func split(source: String) -&gt; [String] {
    return source.componentsSeparatedByString(separator)
}
return split
</code></pre>

<p>}</p>

<p>let commaSplitter = creatSplitter(&ldquo;,&rdquo;)
print(commaSplitter(data))</p>

<p>let semiColonSplitter = creatSplitter(&ldquo;;&rdquo;)
print(semiColonSplitter(data))
```</p>

<p>我们创建了一个产生分割字符串方法的工厂方法，输入分隔符号，返回一个该符号的分割方法，也就是我们先实现了函数的一部分，将函数从二元降为了一元，最主要的是，我们可以反复使用这一得到的方法，可能在该例中优点体现不太明显，但是如果逻辑更复杂，参数更多后，partical application带来的效率提高就非常可观了。</p>

<h3>A mild curry</h3>

<p>使用curry也可以实现上例中的结果，如下，但是调用和工厂方法的写法都会改变。</p>

<p>```objectivec
func createSplitter(separator: String)(source: String) &ndash;> [String] {</p>

<pre><code>return source.componentsSeparatedByString(separator)
</code></pre>

<p>}</p>

<p>let commaSplitter = createSplitter(&ldquo;,&rdquo;)
print(commaSplitter(source: data))</p>

<p>let semiColonSplitter = createSplitter(&ldquo;;&rdquo;)
print(semiColonSplitter(source: data))
```</p>

<p>curry实现了相同的目的，但是它创建的方法包含了两组“分开的”参数，而当你输入第一个参数时，会返回一个函数，你可以继续输入第二个参数（第二个参数需要使用外部参数名，与一般函数一致）。</p>

<h3>A hotter curry</h3>

<p>让我们进一步了解curry，将下面的三元函数进行curry化。</p>

<p>```objectivec
func addNumbers(one:Int, two:Int, three:Int) &ndash;> Int {</p>

<pre><code>return one + two + three
</code></pre>

<p>}
let sum = addNumbers(2, two: 5, three: 4)
print(sum)
```</p>

<p>```objectivec
func curryAddNumbers(one:Int)(two:Int)(three:Int) &ndash;> Int {</p>

<pre><code>return one+two+three
</code></pre>

<p>}
```</p>

<p>接着让我们分部对curry函数进行调用，每一步都会返回一个函数，最后一步返回最终结果。</p>

<p><code>objectivec
let stepOne = curryAddNumbers(2)
let stepTwo = stepOne(two: 5)
let result = stepTwo(three: 4)
</code></p>

<p>也可以像一般函数一样，一次性直接调用。</p>

<p><code>objectivec
let result2 = curryAddNumbers(2)(two: 5)(three: 4)
</code></p>

<p>当然，也可以在每一步添加多个参数。</p>

<p>```objectivec
func curryAddNumbers2(one:Int, two: Int)(three: Int) &ndash;> Int {</p>

<pre><code>return one+two+three
</code></pre>

<p>}
let result3 = curryAddNumbers2(2, two: 5)(three: 4)
```</p>

<h3>Practical curring</h3>

<p>上面两例主要为了说明curry的使用，这里看下它在实际开发中的用法。</p>

<p><code>objectivec
let text = "Swift"let paddedText = text.stringByPaddingToLength(10, withString: ".", startingAtIndex: 0)print(paddedText)
</code></p>

<p>这是一个调用了NSString的填充字符串的方法（额外注意一点startingAtIndex:是指明要填充的字符串从哪位开始填充，所以不能超过withString:参数的长度）。我们在他基础之上要封装一个四元的curry函数。</p>

<p>```objectivec
func curriedPadding(startingAtIndex: Int, withString: String)
  (source: String, length: Int) &ndash;> String {</p>

<pre><code>return source.stringByPaddingToLength(length,
  withString: withString, startingAtIndex: startingAtIndex);
</code></pre>

<p>}
```</p>

<p>然后在它基础上创建一个只用点填充字符串的方法。</p>

<p><code>objectivec
let dotPadding = curriedPadding(0, withString: ".")
let dotPadded = dotPadding(source: "Curry!", length: 10)
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Enums and Switch Statements]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/20/swift-by-tutorials-enums-and-switch-statements/"/>
    <updated>2015-11-20T10:11:34+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/20/swift-by-tutorials-enums-and-switch-statements</id>
    <content type="html"><![CDATA[<p>enum枚举类型是很多编程语言的基本特性，一般是用来存储一组表示不同type的值，比如UILabel使用的NSTextAlignment，会有.Center，.Left多个type。而在Swift中，enum除了原始的用法，它的用法更像class或struct，enum可以拥有自己的方法，甚至是构造方法，然后通过配合Switch，可以实现更灵活的代码流控制，所以才会专门拿出来讲解，足见enum+switch在Swift的重要性。</p>

<!--more-->


<h2>Basic enumerations</h2>

<p>先看一个Swift中定义的简单enum，如下：</p>

<p>```objectivec
enum Shape {</p>

<pre><code>case Rectangle
case Square
case Triangle
case Circle
</code></pre>

<p>}
```</p>

<p>而使用时，可以按照下面两种方式赋值，如果事先定义了类型，那么可以不用在后面写类型，这还是Swift type inference的表现。</p>

<p><code>objectivec
var aShape = Shape.Triangle
var bShape: Shape = .Triangle
</code></p>

<p>而在之后的再次赋值中，都不用再指定类型。</p>

<p><code>objectivec
aShape = .Square
</code></p>

<h3>Raw values</h3>

<p>在OC中，我们一般使用NS_ENUM()来定义枚举，并可以指定值的类型，也可以单独指定某个type的值。而在Swift中，也可以做到，而且更简单。</p>

<p>```objectivec
enum Shape: Int {</p>

<pre><code>case Rectangle
case Square
case Triangle
case Circle
</code></pre>

<p>}
```</p>

<p>使用上述代码就指定了enum的原始值类型为Int，同时该enum获得了一个property，<strong>rawValue</strong>，用于读取当前枚举值的raw value，和一个新的初始化方法，<strong>init(rawValue:)</strong>，用raw value来初始化enum。</p>

<p><code>objectivec
var triangle = Shape.Triangle
triangle.rawValue
var square = Shape(rawValue: 1)
</code></p>

<p>有一点需要注意，就是通过<strong>init(rawValue:)</strong>生成的enum值，是Optional类型的，因为可能会出现输入的raw value没有对应的enum，如下，会返回nil。</p>

<p><code>objectivec
var notAShape = Shape(rawValue: 100)
</code></p>

<p>enum可以直接给某个type赋值，然后其他未赋值的type会自动加1。</p>

<p>```objectivec
enum Shape: Int {</p>

<pre><code>case Rectangle = 10
case Square
case Triangle
case Circle
</code></pre>

<p>}
```</p>

<p>此外，enum可以使用其他类型的raw value，比如Double，Float，String，但是需要为所有type指定对应的raw value，因为除了Int，其他类型的enum是不会对没赋值的enum自动加1的。</p>

<p>```objectivec
enum Shape: String {</p>

<pre><code>case Rectangle = "Rectangle"
case Square = "Square"
case Triangle = "Triangle"
case Circle = "Circle"
</code></pre>

<p>}
```</p>

<h2>Switch statements</h2>

<p>switch与enum的配合在很多语言都是常见的用法，Swift中一样可以，而且有很多实用的改进。</p>

<p>```objectivec
enum Shape {</p>

<pre><code>case Rectangle
case Square
case Triangle
case Circle
</code></pre>

<p>}</p>

<p>var aShape = Shape.Rectangle</p>

<p>switch(aShape) {
case .Rectangle:</p>

<pre><code>print("a rectangle")
</code></pre>

<p>case .Square:</p>

<pre><code>print("a square")
</code></pre>

<p>default:</p>

<pre><code>print("other shape")
</code></pre>

<p>}
```</p>

<p>之前在控制流的章节我们介绍过Swift中的switch，它是需要所有case全部覆盖的，如果你实现了全部case的覆盖，则不用添加default，反之，一定要添加defaut处理。而且，你不需要在每个case后添加break，系统会自动为你添加。</p>

<p>```objectivec
switch(aShape) {
case .Rectangle, .Square:</p>

<pre><code>print("a quadrilateral")
</code></pre>

<p>case .Circle:</p>

<pre><code>print("a circle")
</code></pre>

<p>default:</p>

<pre><code>break
</code></pre>

<p>}
```</p>

<p>一个case处理多个值也很简单，只需要逗号隔开多个值即可，并不需要其他语言中，用不加break的多行处理。</p>

<h2>Associated values</h2>

<p>Associated values是Swift与其他语言的enum类型最大的不同之处，你可以向每个type添加一个类似元组类型的附加值，来作为二级判断条件，下面是有附带值的enum声明，可以为参数添加参数名。</p>

<p>```objectivec
enum Shape {</p>

<pre><code>case Rectangle(width: Float, height: Float)
case Square(side: Float)
case Triangle(base: Float, height: Float)
case Circle(radius: Float)
</code></pre>

<p>}
```</p>

<p>使用时，可以像类或结构体初始化一样赋值，但记住不能像两者一样用<strong>.</strong>来访问。</p>

<p><code>objectivec
var rectangle = Shape.Rectangle(width: 5, height: 10)
</code></p>

<p>你可以使用这些associated values的场景只能是在switch语句中，同时你还可以使用where关键字，为case添加二级条件。</p>

<p>```objectivec
switch (rectangle) {
case .Rectangle(let width, let height) where width &lt;= 10:</p>

<pre><code>print("Narrow rectangle:\(width)*\(height)")
</code></pre>

<p>case .Rectangle(let width, let height):</p>

<pre><code>print("Wide rectangle:\(width)*\(height)")
</code></pre>

<p>default:</p>

<pre><code>print("other shape")
</code></pre>

<p>}
```</p>

<p>需要注意的是，判断条件越来越复杂，便会出现符合多个case的情况，但像前面所说，系统会自动在case后添加break，所以也只会执行最先符合的case，这需要注意。</p>

<h2>Eunms as types</h2>

<p>Swift中的enum还有另外一个重要特性，就是可以添加方法，配合associated value，可以封转一些方便的方法，比如为上面的Shape添加一个计算面积的方法。</p>

<p>```objectivec
func area() &ndash;> Float {</p>

<pre><code>switch(self) {
case .Rectangle(let width, let height):
    return width * height
case .Square(let side):
    return side * side
case .Triangle(let base, let height):
    return 0.5 * base * height
case .Circle(let radius):
    return Float(M_PI) * powf(radius, 2)
}
</code></pre>

<p>}
```</p>

<p>然后申明一个Shape的变量，就可以直接调用该方法计算面积了。</p>

<p><code>objectivec
var circle = Shape.Circle(radius: 5)
circle.area()
</code></p>

<p>除此之外，可以添加新的构建方法，这是Shape实例的构造方法，所以切记一定要给self赋值，否则self没有值是无法返回对象的。</p>

<p>```objectivec
init(_ rect: CGRect) {</p>

<pre><code>let width = Float(CGRectGetWidth(rect))
let height = Float(CGRectGetHeight(rect))
if width == height {
    self = Square(side: width)
} else {
    self = Rectangle(width: width, height: height)
}
</code></pre>

<p>}
```</p>

<p><code>objectivec
var shape = Shape(CGRectMake(0, 0, 5, 10))
</code></p>

<p>所以如下这个构建方法是不合法的，因为会存在无法给self赋值的情况。</p>

<p>```objectivec
init(_ string: String) {</p>

<pre><code>switch(string) {
case "rectangle":
    self = Rectangle(width: 5, height: 10)
case "square":
    self = Square(side: 5)
case "triangle":
    self = Triangle(base: 5, height: 10)
case "circle":
    self = Circle(radius: 5)
default:
    break
}
</code></pre>

<p>}
```</p>

<p>但是想通过这种思路来初始化Shape，也可以实现，就是构建一个static的工厂方法，这样就不存在一定要有值的限制了，可以返回Optional类型。</p>

<p>```objectivec
static func fromString(string: String) &ndash;> Shape? {
switch(string) {</p>

<pre><code>case "rectangle":
    return Rectangle(width: 5, height: 10)
case "square":
    return Square(side: 5)
case "triangle":
    return Triangle(base: 5, height: 10)
case "circle":
    return Circle(radius: 5)
default:
    return nil
}
</code></pre>

<p>}
```</p>

<p>对应的，使用时也要用if来拆包。</p>

<p>```objectivec
if let anotherShape = Shape.fromString(&ldquo;rectangle&rdquo;) {</p>

<pre><code>anotherShape.area()
</code></pre>

<p>}
```</p>

<h3>Optionals are enums</h3>

<p>Swift的Optional类型是enum类型，下面是部分实现：</p>

<p><code>objectivec
enum Optional&lt;T&gt; : NilLiteralConvertible {
  case None  case Some(T)  init()  init(_ some: T)  static func convertFromNilLiteral() -&gt; T?
}
</code></p>

<p>这里使用了泛型，并将该类型作为Some的associated value，可以使Optional持有任何类型的值。</p>

<p>同时enum可以实现协议，NilLiteralConvertible协议使你可以用nil来替代optional，编译器自动会将赋值nil时去调用<strong>convertFromNilLiteral</strong>，最终转化为.None。正是因为实现了这个协议，才可以对optional类型赋nil值，不然会报错。</p>

<h2>JSON parsing using enums</h2>

<p>本节用解析JSON这一常见用例，来实践enum在Swift中的使用。</p>

<h3>Parsing JSON the hard way</h3>

<p>这是常规的解析方法，看起来确实比较繁琐（但相比OC是还是简单多了）。</p>

<p>```objectivec
let json = &ldquo;{\"success\&rdquo;:true,\&ldquo;data\&rdquo;:{\&ldquo;numbers\&rdquo;:[1,2,3,4,5],\&ldquo;animal\&rdquo;:\&ldquo;dog\&rdquo;}}"</p>

<p>if let jsonData = (json as NSString).dataUsingEncoding(NSUTF8StringEncoding) {
  let parsed: AnyObject? = NSJSONSerialization.JSONObjectWithData(jsonData, options: NSJSONReadingOptions(0), error: nil)</p>

<p>  // Actual JSON parsing section
  if let parsed = parsed as? [String:AnyObject] {</p>

<pre><code>if let success = parsed["success"] as? NSNumber {
  if success.boolValue == true {
    if let data = parsed["data"] as? NSDictionary {
      if let numbers = data["numbers"] as? NSArray {
        print(numbers)
      }
      if let animal = data["animal"] as? NSString {
        print(animal)
      }
    }
  }
}
</code></pre>

<p>  }
}
```</p>

<h3>Introducing JSON.swift</h3>

<p>这个文件之前在第四章解析JSON时用过，下面来分析下它的结构，首先是一个enum定义，因为JSON文件就是一些基本元素和dictionary或array的组合，所以使用enum和associated value来定义JSON的基本对象，这是这一解决方案的核心思想。</p>

<p><code>objectivec
enum JSONValue {    case JSONObject([String:JSONValue])     case JSONArray([JSONValue]) case JSONString(String) case JSONNumber(NSNumber)   case JSONBool(Bool) case JSONNull}
</code></p>

<p>接下来为了获取.JSONObject和.JSONArray，我们利用Swift中方便添加角标访问的方式，使用subscript技术。</p>

<p>```objectivec
subscript(i: Int) &ndash;> JSONValue? {
  get {</p>

<pre><code>switch self {
case .JSONArray(let value):
  return value[i]
default:
  return nil
}
</code></pre>

<p>  }
}</p>

<p>subscript(key: String) &ndash;> JSONValue? {
  get {</p>

<pre><code>switch self {
case .JSONObject(let value):
  return value[key]
default:
  return nil
}
</code></pre>

<p>  }
}
```</p>

<p>那么访问一般元素时呢？我们采用了computed properties来访问。</p>

<p>```objectivec
var object: [String:JSONValue]? {
  switch self {
  case .JSONObject(let value):</p>

<pre><code>return value
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}</p>

<p>var array: [JSONValue]? {
  switch self {
  case .JSONArray(let value):</p>

<pre><code>return value
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}</p>

<p>var string: String? {
  switch self {
  case .JSONString(let value):</p>

<pre><code>return value
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}</p>

<p>var integer: Int? {
  switch self {
  case .JSONNumber(let value):</p>

<pre><code>return value.integerValue
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}</p>

<p>var double: Double? {
  switch self {
  case .JSONNumber(let value):</p>

<pre><code>return value.doubleValue
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}</p>

<p>var bool: Bool? {
  switch self {
  case .JSONBool(let value):</p>

<pre><code>return value
</code></pre>

<p>  case .JSONNumber(let value):</p>

<pre><code>return value.boolValue
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}
```</p>

<p>最后将对象转化为JSONValue也需要一个方法，而且是递归调用的，</p>

<p>```objectivec
static func fromObject(object: AnyObject) &ndash;> JSONValue? {
  switch object {
  case let value as NSString:</p>

<pre><code>return JSONValue.JSONString(value)
</code></pre>

<p>  case let value as NSNumber:</p>

<pre><code>return JSONValue.JSONNumber(value)
</code></pre>

<p>  case let value as NSNull:</p>

<pre><code>return JSONValue.JSONNull
</code></pre>

<p>  case let value as NSDictionary:</p>

<pre><code>var jsonObject: [String:JSONValue] = [:]
for (k: AnyObject, v: AnyObject) in value {
  if let k = k as? NSString {
    if let v = JSONValue.fromObject(v) {
      jsonObject[k] = v
    } else {
      return nil
    }
  }
}
return JSONValue.JSONObject(jsonObject)
</code></pre>

<p>  case let value as NSArray:</p>

<pre><code>var jsonArray: [JSONValue] = []
for v in value {
  if let v = JSONValue.fromObject(v) {
    jsonArray.append(v)
  } else {
    return nil
  }
}
return JSONValue.JSONArray(jsonArray)
</code></pre>

<p>  default:</p>

<pre><code>return nil
</code></pre>

<p>  }
}
```</p>

<h3>Putting it into practice</h3>

<p>现在让我们使用JSON.swift来完成JSON的解析，进过比较，现在只需要两层嵌套就完成了原来五层的嵌套解析，而且由于使用了Optional类型，也增加了安全性。所以在Swift中一定要注重利用enum这些新特性，它非常适用于可以预定义为一组不同的子类型的类型，就像JSON。</p>

<p>```objectivec
let json = &ldquo;{\"success\&rdquo;:true,\&ldquo;data\&rdquo;:{\&ldquo;numbers\&rdquo;:[1,2,3,4,5],\&ldquo;animal\&rdquo;:\&ldquo;dog\&rdquo;}}"</p>

<p>if let jsonData = (json as NSString).dataUsingEncoding(NSUTF8StringEncoding) {
  if let parsed: AnyObject = NSJSONSerialization.JSONObjectWithData(jsonData, options: NSJSONReadingOptions(0), error: nil) {</p>

<pre><code>if let jsonParsed = JSONValue.fromObject(parsed) {

  // Actual JSON parsing section
  if jsonParsed["success"]?.bool == true {
    if let numbers = jsonParsed["data"]?["numbers"]?.array {
      print(numbers)
    }
    if let animal = jsonParsed["data"]?["animal"]?.string {
      print(animal)
    }
  }
}
</code></pre>

<p>  }
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CALayer&amp;CoreAnimation]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/09/calayer-and-coreanimation/"/>
    <updated>2015-11-09T10:18:03+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/09/calayer-and-coreanimation</id>
    <content type="html"><![CDATA[<p>这两天打算系统的整理一下CALayer和CoreAnimation相关的知识，之前开发中只是在具体场景中使用时才会去找相应的解决方法，而没有系统的进行整理，所以打算开一篇专门介绍。这一篇<a href="http://www.cnblogs.com/kenshincui/p/3972100.html">博客</a>也做了详尽的介绍，本文的思路也与其基本一致，另外会记录自己的一些理解。</p>

<!--more-->


<h2>CALayer相关</h2>

<p>CALayer包含在QuartzCore框架中。它与UIView的区别是，UIView是UIResponder的子类，是可以接受事件并做出响应的，而CALayer是NSObject的子类，它只是用来展示内容的类。而UIView有一个layer属性就是用来绘制其图像的，而复杂的图层结构在CALayer中是以树的形式存储的，而CoreAnimation中的动画都是在CALayer上进行操作的，可能我们在开发中大部分是直接在UIView组织动画，而这些其实是CoreAnimation在UIView层的封装，本质还是对其layer属性进行操作。</p>

<p><img src="http://lucifer1988.github.io/images/CALayerTree.png"></p>

<h3>CALayer属性</h3>

<p>下表列出了CALayer常用的一些属性：</p>

<table>
<thead>
<tr>
<th></th>
<th> 属性 </th>
<th> 说明 </th>
<th align="center"> 是否支持隐式动画 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> anchorPoint </td>
<td> 锚点，CGPoint类型，默认为(0.5,0.5)，可以理解为layer的重心，始终与position位置重合 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> backgroundColor </td>
<td> 背景色  </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> borderColor </td>
<td> 边框颜色  </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> borderWidth </td>
<td> 边框宽度  </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> bounds </td>
<td> 范围大小  </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> contents </td>
<td> id类型，layer显示内容，通常是CGImageRef类型 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> contentsRect </td>
<td> layer内容的位置和范围  </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> cornerRadius </td>
<td> 圆角半径 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> doubleSided </td>
<td> 图层背面是否显示，默认YES  </td>
<td align="center"> 否 </td>
</tr>
<tr>
<td></td>
<td> frame </td>
<td> layer的位置和范围，由于不支持隐式动画，所以改变layer的位置和大小，通常使用修改bounds和position来替代 </td>
<td align="center"> 否 </td>
</tr>
<tr>
<td></td>
<td> hidden </td>
<td> 是否隐藏 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> mask </td>
<td> 图层蒙版 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> maskToBounds </td>
<td> 子图层是否剪切图层边界，默认NO </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> opacity </td>
<td> 透明度，类似UIView的alpha </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> position </td>
<td> layer中心位置，类似UIView的center </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> shadowColor </td>
<td> 阴影颜色 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> shadowOffset </td>
<td> 阴影偏移量 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> shadowOpacity </td>
<td> 阴影透明度，默认为0，所以设置阴影时必须设置此值 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> shadowPath</td>
<td> 阴影形状 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> shadowRadius </td>
<td> 阴影模糊半径 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> sublayers </td>
<td> 子图层数组 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> sublayerTransform </td>
<td> 子图层形变 </td>
<td align="center"> 是 </td>
</tr>
<tr>
<td></td>
<td> transform </td>
<td> 图层形变 </td>
<td align="center"> 是 </td>
</tr>
</tbody>
</table>


<h3>隐式动画</h3>

<p>CALayer很多属性在修改时就能形成动画，被称为隐式动画，但是需要注意UIView的根视图layer的属性修改并不会形成动画，因为根图层一般是作为容器来使用，修改它的属性可能会直接影响子图层。另外，UIView的根图层是由系统创建的，而无法重新创建，但可以添加子图层。</p>

<p>隐式动画的本质是这些属性的变化默认实现了CABasicAnimation，具体见<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/AnimatableProperties/AnimatableProperties.html#//apple_ref/doc/uid/TP40004514-CH11-SW2">Apple文档</a>，具体示例见<a href="https://github.com/lucifer1988/AnimationCase">AnimationCase</a>中的AnimatablePropertiesTest。</p>

<p>```objectivec
@interface ACAnimatablePropertiesViewController () {</p>

<pre><code>CALayer *layer;
</code></pre>

<p>}</p>

<p>@end</p>

<p>static CGFloat width = 150.0;</p>

<p>@implementation ACAnimatablePropertiesViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  layer = [[CALayer alloc] init];
  layer.bounds = CGRectMake(0, 0, width, width);
  layer.position = self.view.center;
  layer.backgroundColor = [UIColor blueColor].CGColor;
  layer.cornerRadius = width/2;</p>

<p>  layer.shadowColor = [UIColor grayColor].CGColor;
  layer.shadowOffset = CGSizeMake(2, 3);
  layer.shadowOpacity = 0.9;</p>

<p>  layer.borderWidth = 2.0;
  layer.borderColor = [UIColor greenColor].CGColor;</p>

<p>  [self.view.layer addSublayer:layer];
}</p></li>
<li><p>(void)touchesEnded:(NSSet<UITouch *> <em>)touches withEvent:(UIEvent </em>)event {
  UITouch *touch = [touches anyObject];
  CGFloat randWidth = arc4random()%200+100;
  layer.bounds = CGRectMake(0, 0, randWidth, randWidth);
  layer.cornerRadius = randWidth/2;
  layer.position = [touch locationInView:self.view];
  layer.backgroundColor = [UIColor colorWithRed:arc4random()%225/225.0 green:arc4random()%225/225.0 blue:arc4random()%225/225.0 alpha:1.0].CGColor;
  layer.borderColor = [UIColor colorWithRed:arc4random()%225/225.0 green:arc4random()%225/225.0 blue:arc4random()%225/225.0 alpha:1.0].CGColor;
}</p></li>
</ul>


<p>@end
```</p>

<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Reference/CALayer_class/index.html#//apple_ref/occ/instp/CALayer/anchorPoint">AnchorPoint</a>的作用：图层的锚点，范围在（0~1,0~1）表示在x、y轴的比例，这个点永远可以同position重合，当图层中心点固定后，调整anchorPoint即可达到调整图层显示位置的作用（因为它永远和position重合），类似旋转动画中，改变anchorPoint的值可以改变旋转的中心位置，详见<a href="https://github.com/lucifer1988/AnimationCase">AnimationCase</a>中的AnchorPointTest。</p>

<p>```objectivec
@interface ACAnchorPointViewController () <UITextFieldDelegate> {</p>

<pre><code>CALayer *layer;
</code></pre>

<p>}</p>

<p>@property (weak, nonatomic) IBOutlet UITextField <em>xField;
@property (weak, nonatomic) IBOutlet UITextField </em>yField;</p>

<p>@end</p>

<p>@implementation ACAnchorPointViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  layer = [[CALayer alloc] init];
  layer.backgroundColor = [UIColor lightGrayColor].CGColor;
  layer.position = self.view.center;
  layer.bounds = CGRectMake(0, 0, 150.0, 150.0);</p>

<p>  CABasicAnimation <em>rotationAnimation = [CABasicAnimation animationWithKeyPath:@&ldquo;transform.rotation.z&rdquo;];
  rotationAnimation.duration = 2;
  rotationAnimation.repeatCount = HUGE_VALF;
  rotationAnimation.removedOnCompletion = NO;
  rotationAnimation.fromValue = [NSNumber numberWithFloat:0];
  rotationAnimation.toValue = [NSNumber numberWithFloat:3.1415926</em>2];
  [layer addAnimation:rotationAnimation forKey:@&ldquo;rotationTransform&rdquo;];</p>

<p>  [self.view.layer addSublayer:layer];
}</p></li>
</ul>


<h1>pragma mark &ndash; UITextFieldDelegate</h1>

<ul>
<li>(BOOL)textFieldShouldReturn:(UITextField <em>)textField {
  double value = textField.text.length ? textField.text.doubleValue : 0.5;
  if (value &lt; 0 || value > 1) {
      UIAlertController </em>alert = [UIAlertController alertControllerWithTitle:@&ldquo;输入值必须介于0到1&rdquo; message:nil preferredStyle:UIAlertControllerStyleAlert];
      [alert addAction:[UIAlertAction actionWithTitle:@&ldquo;我知道了&rdquo; style:UIAlertActionStyleCancel handler:nil]];
      [self presentViewController:alert animated:YES completion:nil];
      return NO;
  }
  if (textField == self.xField) {
      CGPoint point = layer.anchorPoint;
      point.x = value;
      layer.anchorPoint = point;
  } else {
      CGPoint point = layer.anchorPoint;
      point.y = value;
      layer.anchorPoint = point;
  }
  [textField resignFirstResponder];
  return YES;
}</li>
</ul>


<p>@end
```</p>

<h3>CALayer绘图</h3>

<p>CALayer的绘图方法主要有两种，不过都需要调用layer的setNeedDisplay方法（需要注意的是必须是layer调用，而不是UIView，因为UIView也有一个setNeedDisplay方法）。</p>

<ul>
<li>通过实现代理方法<strong>drawLayer:inContext:</strong>来绘制</li>
<li>通过自定义图层<strong>drawInContext:</strong>来绘制</li>
</ul>


<h4>实现代理方法绘制layer</h4>

<p>通过代理方法进行图层绘图只要指定图层的代理，然后在代理对象中重写-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx方法即可。需要注意这个方法虽然是代理方法但是不用手动实现CALayerDelegate，因为CALayer定义中给NSObject做了分类扩展，所有的NSObject都包含这个方法。另外设置完代理后必须要调用图层的setNeedDisplay方法，否则绘制的内容无法显示。</p>

<p>使用代理方法绘制图形、图像时在drawLayer:inContext:方法中可以通过事件参数获得绘制的图层和图形上下文。在这个方法中绘图时所有的位置都是相对于图层而言的，图形上下文指的也是当前图层的图形上下文，详见<a href="https://github.com/lucifer1988/AnimationCase">AnimationCase</a>中的DrawLayerByDelegateTest。</p>

<p>```objectivec
@interface ACDrawLayerByDelegateViewController () {</p>

<pre><code>CALayer *layer;
</code></pre>

<p>}</p>

<p>@end</p>

<p>static CGFloat width = 150.0;</p>

<p>@implementation ACDrawLayerByDelegateViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  layer = [[CALayer alloc] init];
  layer.bounds = CGRectMake(0, 0, width, width);
  layer.position = self.view.center;
  layer.backgroundColor = [UIColor blueColor].CGColor;
  layer.cornerRadius = width/2;
  layer.masksToBounds = YES;</p>

<p>  layer.borderWidth = 2.0;
  layer.borderColor = [UIColor grayColor].CGColor;</p>

<p>  layer.delegate = self;</p>

<p>  [self.view.layer addSublayer:layer];</p>

<p>  [layer setNeedsDisplay];
}</p></li>
<li><p>(void)dealloc {
  layer.delegate = nil;
}</p></li>
</ul>


<h1>pragma mark &ndash; layer delegate</h1>

<ul>
<li><p>(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx {
  CGContextSaveGState(ctx);</p>

<p>  CGContextScaleCTM(ctx, 1, -1);
  CGContextTranslateCTM(ctx, 0, -width);</p>

<p>  UIImage *image = [UIImage imageNamed:@&ldquo;avatar.png&rdquo;];
  CGContextDrawImage(ctx, CGRectMake(0, 0, width, width), image.CGImage);</p>

<p>  CGContextRestoreGState(ctx);
}</p></li>
</ul>


<p>@end
```</p>

<p>另外需要注意的是上面代码中绘制图片圆形裁切效果时如果不设置masksToBounds是无法显示圆形，但是对于其他图形却没有这个限制。原因就是当绘制一张图片到图层上的时候会重新创建一个图层添加到当前图层，这样一来如果设置了圆角之后虽然底图层有圆角效果，但是子图层还是矩形，只有设置了masksToBounds为YES让子图层按底图层剪切才能显示圆角效果。同样的，有些朋友经常在网上提问说为什么使用UIImageView的layer设置圆角后图片无法显示圆角，只有设置masksToBounds才能出现效果，也是类似的问题。</p>

<h4>自定义layer来绘制</h4>

<p>在自定义图层中绘图时只要自己编写一个类继承于CALayer然后在drawInContext:中绘图即可。同前面在代理方法绘图一样，要显示图层中绘制的内容也要调用图层的setNeedDisplay方法，否则drawInContext方法将不会调用，详见<a href="https://github.com/lucifer1988/AnimationCase">AnimationCase</a>中的DrawLayerByCustomTest。</p>

<p>```objectivec
@implementation ACCustomLayer</p>

<ul>
<li><p>(void)drawInContext:(CGContextRef)ctx {
  CGContextSetRGBFillColor(ctx, 135.0/255.0, 232.0/255.0, 84.0/255.0, 1);
  CGContextSetRGBStrokeColor(ctx, 135.0/255.0, 232.0/255.0, 84.0/255.0, 1);
  CGPoint center = CGPointMake(width/2, width/2);
  CGContextMoveToPoint(ctx, center.x, center.y &ndash; 60.0);
  for(int i = 1; i &lt; 5; ++i) {
      CGFloat x = 60.0 * sinf(i * 4.0 * M_PI / 5.0);
      CGFloat y = 60.0 * cosf(i * 4.0 * M_PI / 5.0);
      CGContextAddLineToPoint(ctx, center.x &ndash; x, center.y &ndash; y);
      NSLog(@&ldquo;x:%f, y:%f&rdquo;, center.x &ndash; x, center.y &ndash; y);
  }</p>

<p>  CGContextClosePath(ctx);</p>

<p>  CGContextDrawPath(ctx, kCGPathFillStroke);
}</p></li>
</ul>


<p>@end
```</p>

<p>```objectivec
@interface ACDrawLayerCustomViewController ()</p>

<p>@end</p>

<p>@implementation ACDrawLayerCustomViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  ACCustomLayer *layer = [[ACCustomLayer alloc] init];
  layer.bounds = CGRectMake(0, 0, width, width);
  layer.position = self.view.center;
  layer.backgroundColor = [UIColor blueColor].CGColor;</p>

<p>  [self.view.layer addSublayer:layer];
  [layer setNeedsDisplay];
}</p></li>
</ul>


<p>@end
```</p>

<h3>带阴影效果的圆形图片裁切</h3>

<p>如果设置了masksToBounds=YES之后确实可以显示图片圆角效果，但遗憾的是设置了这个属性之后就无法设置阴影效果。因为masksToBounds=YES就意味着外边框不能显示，而阴影恰恰作为外边框绘制的，这样两个设置就产生了矛盾。要解决这个问题不妨换个思路:使用两个大小一样的图层，下面的图层负责绘制阴影，上面的图层用来显示图片。</p>

<p>```objectivec
@interface ACCircleAvatarWithShadowViewController () {</p>

<pre><code>CALayer *layer;
</code></pre>

<p>}</p>

<p>@end</p>

<p>static CGFloat width = 150.0;</p>

<p>@implementation ACCircleAvatarWithShadowViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  CALayer *shadowLayer = [[CALayer alloc] init];
  shadowLayer.bounds = CGRectMake(0, 0, width, width);
  shadowLayer.position = self.view.center;
  shadowLayer.backgroundColor = [UIColor whiteColor].CGColor;
  shadowLayer.cornerRadius = width/2;
  shadowLayer.shadowOffset = CGSizeMake(2, 2);
  shadowLayer.shadowColor = [UIColor grayColor].CGColor;
  shadowLayer.shadowOpacity = 1.0;</p>

<p>  [self.view.layer addSublayer:shadowLayer];</p>

<p>  layer = [[CALayer alloc] init];
  layer.bounds = CGRectMake(0, 0, width, width);
  layer.position = self.view.center;
  layer.backgroundColor = [UIColor blueColor].CGColor;
  layer.cornerRadius = width/2;
  layer.masksToBounds = YES;</p>

<p>  layer.borderWidth = 2.0;
  layer.borderColor = [UIColor grayColor].CGColor;</p>

<p>  layer.delegate = self;</p>

<p>  [self.view.layer addSublayer:layer];</p>

<p>  [layer setNeedsDisplay];
}</p></li>
<li><p>(void)dealloc
{
  layer.delegate = nil;
}</p></li>
</ul>


<h1>pragma mark &ndash; layer delegate</h1>

<ul>
<li><p>(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx {
  CGContextSaveGState(ctx);</p>

<p>  CGContextScaleCTM(ctx, 1, -1);
  CGContextTranslateCTM(ctx, 0, -width);</p>

<p>  UIImage *image = [UIImage imageNamed:@&ldquo;avatar.png&rdquo;];
  CGContextDrawImage(ctx, CGRectMake(0, 0, width, width), image.CGImage);</p>

<p>  CGContextRestoreGState(ctx);
}</p></li>
</ul>


<p>@end
```</p>

<h3>CALayer形变</h3>

<p>从上面代码中大家不难发现使用Core Graphics绘制图片时会倒立显示，对图层的图形上下文进行了反转。可以控制图层直接旋转而不用借助于图形上下文的形变操作。对于上面的程序，只需要设置图层的transform属性即可。需要注意的是transform是CATransform3D类型，形变可以在三个维度上进行，而且都有对应的形变设置方法（如：CATransform3DMakeTranslation()、CATransform3DMakeScale()、CATransform3DMakeRotation()）。</p>

<p>事实上如果仅仅就显示一张图片在图层中当然没有必要那么麻烦，直接设置图层contents就可以了，不牵涉到绘图也就没有倒立的问题了。</p>

<p>```objectivec
//Plan B
CALayer <em>anotherlayer = [[CALayer alloc] init];
anotherlayer.bounds = CGRectMake(0, 0, width, width);
center = self.view.center;
center.y += width;
anotherlayer.position = center;
anotherlayer.backgroundColor = [UIColor blueColor].CGColor;
anotherlayer.cornerRadius = width/2;
anotherlayer.masksToBounds = YES;
anotherlayer.borderColor = [UIColor grayColor].CGColor;
anotherlayer.borderWidth = 2.0;
UIImage </em>image=[UIImage imageNamed:@&ldquo;avatar.png&rdquo;];
[anotherlayer setContents:(id)image.CGImage];</p>

<p>[self.view.layer addSublayer:anotherlayer];
```</p>

<p>在动画开发中形变往往不是直接设置transform，而是通过keyPath进行设置。这种方法设置形变的本质和前面没有区别，只是利用了KVC可以动态修改其属性值而已，但是这种方式在动画中确实很常用的，因为它可以很方便的将几种形变组合到一起使用。key path的所有设置类型，见<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html#//apple_ref/doc/uid/TP40004514-CH12-SW1">Apple文档</a>，同样是解决动画旋转问题，只要将前面的旋转代码改为下面的代码即可：</p>

<p><code>objectivec
[layer setValue:@M_PI forKeyPath:@"transform.rotation.x"];
</code></p>

<h2>CoreAnimation相关</h2>

<p>在iOS中CoreAnimation分为几类：基础动画、关键帧动画、动画组、转场动画。各个类的关系大致如下：</p>

<p><img src="http://lucifer1988.github.io/images/CAAnimationTree.png"></p>

<ul>
<li>CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议。</li>
<li>CAPropertyAnimation：属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用。</li>
<li>CAAnimationGroup：动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行。</li>
<li>CATransition：转场动画，主要通过滤镜进行动画效果设置。</li>
<li>CABasicAnimation：基础动画，通过属性修改进行动画参数控制，只有初始状态和结束状态。</li>
<li>CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制。</li>
</ul>


<p>基础动画、关键帧动画都属于属性动画，就是通过修改属性值产生动画效果，开发人员只需要设置初始值和结束值，中间的过程动画（又叫“补间动画”）由系统自动计算产生。和基础动画不同的是关键帧动画可以设置多个属性值，每两个属性中间的补间动画由系统自动完成，因此从这个角度而言基础动画又可以看成是有两个关键帧的关键帧动画。</p>

<h3>基础动画</h3>

<p>在开发过程中很多情况下通过基础动画就可以满足开发需求，使用的UIView代码块制作的动画也是基础动画（在iOS7中UIView也对关键帧动画进行了封装），只是UIView装饰方法隐藏了更多的细节。如果不使用UIView封装的方法，动画创建一般分为以下几步：</p>

<ol>
<li><p>初始化动画并设置动画属性</p></li>
<li><p>设置动画属性初始值（可以省略）、结束值以及其他动画属性</p></li>
<li><p>给图层添加动画</p></li>
</ol>


<h4>移动动画</h4>

<p>下面以一个移动动画为例进行演示，在这个例子中点击屏幕哪个位置落花将飞向哪里：</p>

<p>```objectivec
@interface ACMoveAnimationViewController () {</p>

<pre><code>CALayer *petalLayer;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation ACMoveAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.
  UIImage *backgroundImage = [UIImage imageNamed:@&ldquo;background.jpg&rdquo;];
  self.view.layer.contents = (id)backgroundImage.CGImage;</p>

<p>  petalLayer = [[CALayer alloc] init];
  petalLayer.bounds = CGRectMake(0, 0, 10, 20);
  petalLayer.position = CGPointMake(50, 150);
  petalLayer.contents = (id)[UIImage imageNamed:@&ldquo;petal.png&rdquo;].CGImage;</p>

<p>  [self.view.layer addSublayer:petalLayer];
}</p></li>
<li><p>(void)touchesEnded:(NSSet<UITouch *> <em>)touches withEvent:(UIEvent </em>)event {
  UITouch *touch = touches.anyObject;
  [self animationMoveTo:[touch locationInView:self.view]];
}</p></li>
</ul>


<h1>pragma mark &ndash; Animation</h1>

<ul>
<li>(void)animationMoveTo:(CGPoint)location {
  CABasicAnimation *moveAnimation = [CABasicAnimation animationWithKeyPath:@&ldquo;position&rdquo;];
  moveAnimation.toValue = [NSValue valueWithCGPoint:location];
  moveAnimation.duration = 5.0;
  moveAnimation.repeatCount = 0;
  moveAnimation.removedOnCompletion = YES;
  [petalLayer addAnimation:moveAnimation forKey:@&ldquo;petalLayer_moveAnimation&rdquo;];
}</li>
</ul>


<p>@end
```</p>

<h4>完整移动动画</h4>

<p>上面实现了一个基本动画效果，但是这个动画存在一个问题：动画结束后动画图层回到了原来的位置。</p>

<p>图层动画的本质就是将图层内部的内容转化为位图经硬件操作形成一种动画效果，其实图层本身并没有任何的变化。上面的动画中图层并没有因为动画效果而改变它的位置（对于缩放动画其大小也是不会改变的），所以动画完成之后图层还是在原来的显示位置没有任何变化，如果这个图层在一个UIView中你会发现在UIView移动过程中你要触发UIView的点击事件也只能点击原来的位置（即使它已经运动到了别的位置），因为它的位置从来没有变过。</p>

<p>通过给动画设置一个代理去监听动画的开始和结束事件，在动画开始前给动画添加一个自定义属性“petalLayer_moveAnimation_destination”存储动画终点位置，然后在动画结束后设置动画的位置为终点位置。在<strong>&ndash; (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag</strong>中设置代码关闭了position的隐式动画，否则会导致两次移动，另外添加了使花瓣匀速移动的时间计算，和防止多次点击的flag控制。</p>

<p>```objectivec
@interface ACMoveAnimationFullEditionViewController () {</p>

<pre><code>CALayer *petalLayer;
BOOL isMoving;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation ACMoveAnimationFullEditionViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];</p>

<p>  isMoving = NO;
  UIImage *backgroundImage = [UIImage imageNamed:@&ldquo;background.jpg&rdquo;];
  self.view.layer.contents = (id)backgroundImage.CGImage;</p>

<p>  petalLayer = [[CALayer alloc] init];
  petalLayer.bounds = CGRectMake(0, 0, 10, 20);
  petalLayer.position = CGPointMake(50, 150);
  petalLayer.contents = (id)[UIImage imageNamed:@&ldquo;petal.png&rdquo;].CGImage;</p>

<p>  [self.view.layer addSublayer:petalLayer];
}</p></li>
<li><p>(void)didReceiveMemoryWarning {
  [super didReceiveMemoryWarning];
  // Dispose of any resources that can be recreated.
}</p></li>
<li><p>(void)touchesEnded:(NSSet<UITouch *> <em>)touches withEvent:(UIEvent </em>)event {
  if (isMoving) {
      return;
  }</p>

<p>  UITouch *touch = touches.anyObject;
  [self animationMoveTo:[touch locationInView:self.view]];
}</p></li>
</ul>


<h1>pragma mark &ndash; Animation</h1>

<ul>
<li><p>(void)animationMoveTo:(CGPoint)location {
  CABasicAnimation *moveAnimation = [CABasicAnimation animationWithKeyPath:@&ldquo;position&rdquo;];
  moveAnimation.toValue = [NSValue valueWithCGPoint:location];
  moveAnimation.duration = [self petalMoveDuring:location];
  moveAnimation.repeatCount = 0;
  moveAnimation.removedOnCompletion = YES;</p>

<p>  moveAnimation.delegate = self;
  [moveAnimation setValue:[NSValue valueWithCGPoint:location] forKey:@&ldquo;petalLayer_moveAnimation_destination&rdquo;];</p>

<p>  [petalLayer addAnimation:moveAnimation forKey:@&ldquo;petalLayer_moveAnimation&rdquo;];
}</p></li>
<li><p>(NSTimeInterval)petalMoveDuring:(CGPoint)destination {
  CGFloat deltaX = destination.x &ndash; petalLayer.position.x;
  CGFloat deltaY = destination.y &ndash; petalLayer.position.y;
  CGFloat distance = sqrt(deltaX<em>deltaX + deltaY</em>deltaY);
  return (NSTimeInterval)distance/50.0;
}</p></li>
</ul>


<h1>pragma mark &ndash; Animation Delegate</h1>

<ul>
<li><p>(void)animationDidStart:(CAAnimation *)anim {
  isMoving = YES;
}</p></li>
<li><p>(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag {
  [CATransaction begin];
  //禁用隐式动画
  [CATransaction setDisableActions:YES];
  petalLayer.position=[[anim valueForKey:@&ldquo;petalLayer_moveAnimation_destination&rdquo;] CGPointValue];
  [CATransaction commit];
  isMoving = NO;
}</p></li>
</ul>


<p>@end
```</p>

<h4>旋转动画</h4>

<p>图层的形变都是基于锚点进行的。例如旋转，旋转的中心点就是图层的锚点，这在最开始的锚点例子中也有介绍。</p>

<p>需要注意的是只给移动动画设置了代理，在旋转动画中并没有设置代理，否则代理方法会执行两遍。由于旋转动画会无限循环执行（上面设置了重复次数无穷大），并且两个动画的执行时间没有必然的关系，这样一来移动停止后可能还在旋转，为了让移动动画停止后旋转动画停止就需要使用到动画的暂停和恢复方法。</p>

<p>核心动画的运行有一个媒体时间的概念，假设将一个旋转动画设置旋转一周用时60秒的话，那么当动画旋转90度后媒体时间就是15秒。如果此时要将动画暂停只需要让媒体时间偏移量设置为15秒即可，并把动画运行速度设置为0使其停止运动。类似的，如果又过了60秒后需要恢复动画（此时媒体时间为75秒），这时只要将动画开始开始时间设置为当前媒体时间75秒减去暂停时的时间（也就是之前定格动画时的偏移量）15秒（开始时间=75-15=60秒），那么动画就会重新计算60秒后的状态再开始运行，与此同时将偏移量重新设置为0并且把运行速度设置1。这个过程中真正起到暂停动画和恢复动画的其实是动画速度的调整，媒体时间偏移量以及恢复时的开始时间设置主要为了让动画更加连贯。</p>

<p>```objectivec
&ndash; (void)animationRotate {</p>

<pre><code>CABasicAnimation *rotateAnimation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.z"];
rotateAnimation.duration = 6;
rotateAnimation.repeatCount = HUGE_VALF;
rotateAnimation.removedOnCompletion = NO;
rotateAnimation.autoreverses = YES;
rotateAnimation.toValue = [NSNumber numberWithFloat:M_PI_2*3];
[petalLayer addAnimation:rotateAnimation forKey:@"petalLayer_rotationAnimation"];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)animationPause {
  //取得指定图层动画的媒体时间，后面参数用于指定子图层，这里不需要
  CFTimeInterval interval = [petalLayer convertTime:CACurrentMediaTime() fromLayer:nil];
  //设置时间偏移量，保证暂停时停留在旋转的位置
  [petalLayer setTimeOffset:interval];
  //速度设置为0，暂停动画
  petalLayer.speed = 0;
}</p></li>
<li><p>(void)animationResume {
  //获得暂停的时间
  CFTimeInterval beginTime = CACurrentMediaTime() &ndash; petalLayer.timeOffset;
  //设置偏移量
  petalLayer.timeOffset = 0;
  //设置开始时间
  petalLayer.beginTime = beginTime;
  //设置动画速度，开始运动
  petalLayer.speed = 1.0;
}
```</p></li>
</ul>


<h3>关键帧动画</h3>

<p>熟悉flash开发的朋友对于关键帧动画应该不陌生，这种动画方式在flash开发中经常用到。关键帧动画就是在动画控制过程中开发者指定主要的动画状态，至于各个状态间动画如何进行则由系统自动运算补充（每两个关键帧之间系统形成的动画称为“补间动画”），这种动画的好处就是开发者不用逐个控制每个动画帧，而只要关心几个关键帧的状态即可。</p>

<p>关键帧动画开发分为两种形式：一种是通过设置不同的属性值进行关键帧控制，另一种是通过绘制路径进行关键帧控制。后者优先级高于前者，如果设置了路径则属性值就不再起作用。</p>

<h4>设置属性值的关键帧控制</h4>

<p>对于前面的落花动画效果而言其实落花的过程并不自然，很显然实际生活中它不可能沿着直线下落，这里我们不妨通过关键帧动画的values属性控制它在下落过程中的属性。</p>

<p>```objectivec
@interface ACKeyFrameAnimationViewController () {</p>

<pre><code>CALayer *petalLayer;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation ACKeyFrameAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.
  UIImage *backgroundImage = [UIImage imageNamed:@&ldquo;background.jpg&rdquo;];
  self.view.layer.contents = (id)backgroundImage.CGImage;</p>

<p>  petalLayer = [[CALayer alloc] init];
  petalLayer.bounds = CGRectMake(0, 0, 10, 20);
  petalLayer.position = CGPointMake(50, 150);
  petalLayer.contents = (id)[UIImage imageNamed:@&ldquo;petal.png&rdquo;].CGImage;</p>

<p>  [self.view.layer addSublayer:petalLayer];</p>

<p>  [self addKeyframeMoveAnimation];
}</p></li>
<li><p>(void)didReceiveMemoryWarning {
  [super didReceiveMemoryWarning];
  // Dispose of any resources that can be recreated.
}</p></li>
</ul>


<h1>pragma mark &ndash; animation</h1>

<ul>
<li><p>(void)addKeyframeMoveAnimation {
  CAKeyframeAnimation <em>keyframeAnimation = [CAKeyframeAnimation animationWithKeyPath:@&ldquo;position&rdquo;];
  //关键帧动画的初始值不能省略
  NSValue </em>key1 = [NSValue valueWithCGPoint:petalLayer.position];
  NSValue <em>key2 = [NSValue valueWithCGPoint:CGPointMake(80, 320)];
  NSValue </em>key3 = [NSValue valueWithCGPoint:CGPointMake(45, 400)];
  NSValue <em>key4 = [NSValue valueWithCGPoint:CGPointMake(55, 500)];
  NSArray </em>values = @[key1, key2, key3, key4];</p>

<p>  keyframeAnimation.values = values;
  keyframeAnimation.duration = 8.0;
  keyframeAnimation.beginTime = CACurrentMediaTime()+2;
  keyframeAnimation.delegate = self;
  [keyframeAnimation setValue:key4 forKey:@&ldquo;petalLayer_keyframeAnimation_destination&rdquo;];</p>

<p>  [petalLayer addAnimation:keyframeAnimation forKey:@&ldquo;petalLayer_keyframeAnimation_position&rdquo;];
}</p></li>
</ul>


<h1>pragma mark &ndash; animation delegate</h1>

<ul>
<li><p>(void)animationDidStart:(CAAnimation *)anim {
}</p></li>
<li><p>(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag {
  [CATransaction begin];
  [CATransaction setDisableActions:YES];
  petalLayer.position = [[anim valueForKey:@&ldquo;petalLayer_keyframeAnimation_destination&rdquo;] CGPointValue];
  [CATransaction commit];
}</p></li>
</ul>


<p>@end
```</p>

<h4>通过设置路径的关键帧控制</h4>

<p>上面的方式固然比前面使用基础动画效果要好一些，但其实还是存在问题，那就是落花飞落的路径是直线的，当然这个直线是根据程序中设置的四个关键帧自动形成的，那么如何让它沿着曲线飘落呢？这就是第二种类型的关键帧动画，通过描绘路径进行关键帧动画控制。假设让落花沿着一条贝塞尔曲线飘落：</p>

<p>```objectivec
&ndash; (void)addKeyframeMoveAnimation {</p>

<pre><code>CAKeyframeAnimation *keyframeAnimation = [CAKeyframeAnimation animationWithKeyPath:@"position"];

CGMutablePathRef path = CGPathCreateMutable();
CGPathMoveToPoint(path, NULL, petalLayer.position.x, petalLayer.position.y);
CGPathAddCurveToPoint(path, NULL, 300, 250, -100, 450, 100, 550);

keyframeAnimation.path = path;
CGPathRelease(path);
keyframeAnimation.duration = 8.0;
keyframeAnimation.beginTime = CACurrentMediaTime()+2;
keyframeAnimation.delegate = self;
[keyframeAnimation setValue:[NSValue valueWithCGPoint:CGPointMake(100, 550)] forKey:@"petalLayer_keyframeAnimation_destination"];

[petalLayer addAnimation:keyframeAnimation forKey:@"petalLayer_keyframeAnimation_position"];
</code></pre>

<p>}
```</p>

<h4>关键帧动画的其他重要属性</h4>

<ul>
<li>keyTimes：各个关键帧的时间控制。前面使用values设置了四个关键帧，默认情况下每两帧之间的间隔为:8/(4-1)秒。如果想要控制动画从第一帧到第二针占用时间4秒，从第二帧到第三帧时间为2秒，而从第三帧到第四帧时间2秒的话，就可以通过keyTimes进行设置。keyTimes中存储的是时间占用比例点，此时可以设置keyTimes的值为0.0，0.5，0.75，1.0（当然必须转换为NSNumber），也就是说1到2帧运行到总时间的50%，2到3帧运行到总时间的75%，3到4帧运行到8秒结束。</li>
<li>caculationMode：动画计算模式。还拿上面keyValues动画举例，之所以1到2帧能形成连贯性动画而不是直接从第1帧经过8/3秒到第2帧是因为动画模式是连续的（值为kCAAnimationLinear，这是计算模式的默认值）；而如果指定了动画模式为kCAAnimationDiscrete离散的那么你会看到动画从第1帧经过8/3秒直接到第2帧，中间没有任何过渡。其他动画模式还有：kCAAnimationPaced（均匀执行，会忽略keyTimes）、kCAAnimationCubic（平滑执行，对于位置变动关键帧动画运行轨迹更平滑）、kCAAnimationCubicPaced（平滑均匀执行）。</li>
</ul>


<p><img src="http://lucifer1988.github.io/images/caculationMode.png"></p>

<h3>组合动画</h3>

<p>实际开发中一个物体的运动往往是复合运动，单一属性的运动情况比较少，但恰恰属性动画每次进行动画设置时一次只能设置一个属性进行动画控制(不管是基础动画还是关键帧动画都是如此)，这样一来要做一个复合运动的动画就必须创建多个属性动画进行组合。对于一两种动画的组合或许处理起来还比较容易，但是对于更多动画的组合控制往往会变得很麻烦，动画组的产生就是基于这样一种情况而产生的。动画组是一系列动画的组合，凡是添加到动画组中的动画都受控于动画组，这样一来各类动画公共的行为就可以统一进行控制而不必单独设置，而且放到动画组中的各个动画可以并发执行，共同构建出复杂的动画效果。</p>

<p>动画组使用起来并不复杂，首先单独创建单个动画（可以是基础动画也可以是关键帧动画），然后将基础动画添加到动画组，最后将动画组添加到图层即可。</p>

<p>前面关键帧动画部分，路径动画看起来效果虽然很流畅，但是落花本身的旋转运动没有了，这里不妨将基础动画部分的旋转动画和路径关键帧动画进行组合使得整个动画看起来更加的和谐、顺畅。</p>

<p>```objectivec
@interface ACGroupAnimationViewController () {</p>

<pre><code>CALayer *petalLayer;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation ACGroupAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  UIImage *backgroundImage = [UIImage imageNamed:@&ldquo;background.jpg&rdquo;];
  self.view.layer.contents = (id)backgroundImage.CGImage;</p>

<p>  petalLayer = [[CALayer alloc] init];
  petalLayer.bounds = CGRectMake(0, 0, 10, 20);
  petalLayer.position = CGPointMake(100, 150);
  petalLayer.contents = (id)[UIImage imageNamed:@&ldquo;petal.png&rdquo;].CGImage;</p>

<p>  [self.view.layer addSublayer:petalLayer];</p>

<p>  [self addAnimationGroup];
}</p></li>
<li><p>(void)addAnimationGroup {
  CAAnimationGroup *animationGroup = [CAAnimationGroup animation];</p>

<p>  CABasicAnimation <em>rotateAnimation = [self rotateAnimation];
  CAKeyframeAnimation </em>keyframeMoveAnimation = [self keyframeMoveAnimation];
  animationGroup.animations = @[rotateAnimation, keyframeMoveAnimation];</p>

<p>  animationGroup.delegate = self;
  animationGroup.duration = 8.0;
  animationGroup.beginTime = CACurrentMediaTime()+2;</p>

<p>  [petalLayer addAnimation:animationGroup forKey:nil];
}</p></li>
<li><p>(CAKeyframeAnimation <em>)keyframeMoveAnimation {
  CAKeyframeAnimation </em>keyframeAnimation = [CAKeyframeAnimation animationWithKeyPath:@&ldquo;position&rdquo;];</p>

<p>  CGMutablePathRef path = CGPathCreateMutable();
  CGPathMoveToPoint(path, NULL, petalLayer.position.x, petalLayer.position.y);
  CGPathAddCurveToPoint(path, NULL, 300, 250, -100, 450, 100, 550);</p>

<p>  keyframeAnimation.path = path;
  CGPathRelease(path);
  [keyframeAnimation setValue:[NSValue valueWithCGPoint:CGPointMake(100, 550)] forKey:@&ldquo;petalLayer_keyframeAnimation_destination&rdquo;];
  return keyframeAnimation;
}</p></li>
<li><p>(CABasicAnimation <em>)rotateAnimation {
  CABasicAnimation </em>rotateAnimation = [CABasicAnimation animationWithKeyPath:@&ldquo;transform.rotation.z&rdquo;];
  rotateAnimation.repeatCount = HUGE_VALF;
  rotateAnimation.removedOnCompletion = NO;
  rotateAnimation.autoreverses = YES;
  rotateAnimation.toValue = [NSNumber numberWithFloat:M_PI_2<em>3];
  [rotateAnimation setValue:[NSNumber numberWithFloat:M_PI_2</em>3] forKey:@&ldquo;rotateAnimation_toValue&rdquo;];</p>

<p>  return rotateAnimation;
}</p></li>
</ul>


<h1>pragma mark &ndash; animation delegate</h1>

<ul>
<li><p>(void)animationDidStop:(CAAnimation <em>)anim finished:(BOOL)flag {
  CAAnimationGroup </em>animationGroup = (CAAnimationGroup <em>)anim;
  CABasicAnimation </em>rotateAnimation = (CABasicAnimation <em>)animationGroup.animations[0];
  CAKeyframeAnimation </em>keyframeMoveAnimation = (CAKeyframeAnimation *)animationGroup.animations[1];
  CGFloat toValue = [[rotateAnimation valueForKey:@&ldquo;rotateAnimation_toValue&rdquo;] floatValue];
  CGPoint toPoint = [[keyframeMoveAnimation valueForKey:@&ldquo;petalLayer_keyframeAnimation_destination&rdquo;] CGPointValue];</p>

<p>  [CATransaction begin];
  [CATransaction setDisableActions:YES];
  petalLayer.position = toPoint;
  petalLayer.transform = CATransform3DMakeRotation(toValue, 0, 0, 1);
  [CATransaction commit];
}</p></li>
</ul>


<p>@end
```</p>

<h3>转场动画</h3>

<p>转场动画就是从一个场景以动画的形式过渡到另一个场景。转场动画的使用一般分为以下几个步骤：</p>

<ol>
<li>创建转场动画</li>
<li>设置转场类型、子类型（可选）及其他属性</li>
<li>设置转场后的新视图并添加动画到图层</li>
</ol>


<p>Apple公开的只有四个转场动画类型：</p>

<ol>
<li>fade(kCATransitionFade，支持方向)</li>
<li>moveIn(kCATransitionMoveIn，支持方向)</li>
<li>push(kCATransitionPush，支持方向)</li>
<li>reveal(kCATransitionReveal，支持方向)</li>
</ol>


<p>另外还有一些私有API可以使用，但是只能用字符串来设置：</p>

<ol>
<li>cube(支持方向)</li>
<li>oglFlip(支持方向)</li>
<li>suckEffect(不支持方向)</li>
<li>rippleEffect(不支持方向)</li>
<li>pageCurl(支持方向)</li>
<li>pageUnCurl(支持方向)</li>
<li>cameraIrisHollowOpen(不支持方向)</li>
<li>cameraIrisHollowClose(不支持方向)</li>
</ol>


<p>支持方向的类型还可以选择四个subtype：</p>

<ol>
<li>kCATransitionFromRight</li>
<li>kCATransitionFromLeft</li>
<li>kCATransitionFromTop</li>
<li>kCATransitionFromBottom</li>
</ol>


<p>下面代码展示了全部效果：</p>

<p>```objectivec
@interface ACTransitionAnimationViewController () {</p>

<pre><code>UIImageView *imageView;
NSArray *transitionTypes;
</code></pre>

<p>}</p>

<p>@end</p>

<p>static int transitionTypeIndex;</p>

<p>@implementation ACTransitionAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.
  transitionTypes = @[@&ldquo;fade&rdquo;, @&ldquo;moveIn&rdquo;, @&ldquo;push&rdquo;, @&ldquo;reveal&rdquo;, @&ldquo;cube&rdquo;, @&ldquo;oglFlip&rdquo;, @&ldquo;suckEffect&rdquo;, @&ldquo;rippleEffect&rdquo;, @&ldquo;pageCurl&rdquo;, @&ldquo;pageUnCurl&rdquo;, @&ldquo;cameraIrisHollowOpen&rdquo;, @&ldquo;cameraIrisHollowClose&rdquo;];
  transitionTypeIndex = 0;</p>

<p>  imageView = [[UIImageView alloc] initWithFrame:[UIScreen mainScreen].bounds];
  [imageView setImage:[UIImage imageNamed:@&ldquo;background.jpg&rdquo;]];
  [self.view addSubview:imageView];</p>

<p>  UISwipeGestureRecognizer *swipeGesture = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipe:)];
  swipeGesture.direction = UISwipeGestureRecognizerDirectionLeft;
  [self.view addGestureRecognizer:swipeGesture];
}</p></li>
<li><p>(void)swipe:(UISwipeGestureRecognizer <em>)gestureRecognizer {
  if (transitionTypeIndex > 11) {
      transitionTypeIndex = 0;
  }
  CATransition </em>transition = [[CATransition alloc] init];
  transition.type = transitionTypes[transitionTypeIndex];
  transition.subtype = kCATransitionFromRight;
  transition.duration = 1.0;
  [imageView.layer addAnimation:transition forKey:@&ldquo;imageView_transition&rdquo;];</p>

<p>  transitionTypeIndex++;
}</p></li>
</ul>


<p>@end
```</p>

<h3>逐帧动画</h3>

<p>前面介绍了核心动画中大部分动画类型，但是做过动画处理的朋友都知道，在动画制作中还有一种动画类型“逐帧动画”。说到逐帧动画相信很多朋友第一个想到的就是UIImageView，通过设置UIImageView的animationImages属性，然后调用它的startAnimating方法去播放这组图片。当然这种方法在某些场景下是可以达到逐帧的动画效果，但是它也存在着很大的性能问题，并且这种方法一旦设置完图片中间的过程就无法控制了。</p>

<p>虽然在CoreAnimation中没有直接提供逐帧动画类型，但是却提供了用于完成逐帧动画的相关对象CADisplayLink。CADisplayLink是一个计时器，但是同NSTimer不同的是，CADisplayLink的刷新周期同屏幕完全一致。例如在iOS中屏幕刷新周期是60次/秒，CADisplayLink刷新周期同屏幕刷新一致也是60次/秒，这样一来使用它完成的逐帧动画（又称为“时钟动画”）完全感觉不到动画的停滞情况。</p>

<p>要将CADisplayLink加入到主线程的Runloop，它的时钟周期就和主运行循环保持一致，而主运行循环周期就是屏幕刷新周期。在CADisplayLink加入到主运行循环队列后就会循环调用目标方法，在这个方法中更新视图内容就可以完成逐帧动画。</p>

<p>当然这里不得不强调的是逐帧动画性能势必较低，但是对于一些事物的运动又不得不选择使用逐帧动画，例如人的运动，这是一个高度复杂的运动，基本动画、关键帧动画是不可能解决的。所大家一定要注意在循环方法中尽可能的降低算法复杂度，同时保证循环过程中内存峰值尽可能低。下面以一个鱼的运动为例为大家演示一下逐帧动画。</p>

<p>```objectivec
@interface ACFrameByFrameAnimationViewController () {</p>

<pre><code>UIImageView *imageView;
CALayer *layer;
NSMutableArray *imageArray;
</code></pre>

<p>}</p>

<p>@end</p>

<p>static int frameIndex = 0;</p>

<p>@implementation ACFrameByFrameAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  UIImage *backgroundImage = [UIImage imageNamed:@&ldquo;background1.png&rdquo;];
  self.view.layer.contents = (id)backgroundImage.CGImage;</p>

<p>  imageArray = [@[] mutableCopy];
  for (int i=0; i&lt;10; i++) {
      UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@&ldquo;fish%d.png&rdquo;, i]];
      [imageArray addObject:image];
  }</p>

<p>  //PlanA use UIImageView&rsquo;s AnimationImages
//    imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 87, 32)];
//    imageView.center = self.view.center;
//    imageView.animationDuration = imageArray.count/30;
//    [imageView setAnimationImages:imageArray];
//    [self.view addSubview:imageView];
//    [imageView startAnimating];</p>

<p>  //PlanB use CADisplayLink
  layer = [[CALayer alloc] init];
  layer.bounds = CGRectMake(0, 0, 87, 32);
  layer.position = self.view.center;
  [self.view.layer addSublayer:layer];</p>

<p>  CADisplayLink *displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(nextFrame)];
  [displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];
}</p></li>
</ul>


<p>//60fps
&ndash; (void)nextFrame {</p>

<pre><code>static int i = 0;
//30fps
if (++i%2 == 0) {
    UIImage *image = imageArray[frameIndex];
    layer.contents = (id)image.CGImage;
    frameIndex = (frameIndex+1)%10;
}
</code></pre>

<p>}</p>

<p>@end
```</p>

<h2>UIView动画封装</h2>

<p>其实UIView本身对于基本动画和关键帧动画、转场动画都有相应的封装，在对动画细节没有特殊要求的情况下使用起来也要简单的多。可以说在日常开发中90%以上的情况使用UIView的动画封装方法都可以搞定，因此在熟悉了核心动画的原理之后还是有必要给大家简单介绍一下UIView中各类动画使用方法的。</p>

<h3>基本动画</h3>

<h4>移动动画</h4>

<p>下面是之前移动动画在UIView层的封装，使用了block封装，也可以选用之前的beginAnimations单独设置，效果是一样的。</p>

<p>```objectivec
@interface ACViewMoveAnimationViewController () {</p>

<pre><code>UIImageView *petalView;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation ACViewMoveAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.
  UIImage *backgroundImage = [UIImage imageNamed:@&ldquo;background.jpg&rdquo;];
  self.view.layer.contents = (id)backgroundImage.CGImage;</p>

<p>  petalView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&ldquo;petal.png&rdquo;]];
  petalView.center = CGPointMake(50, 150);
  [self.view addSubview:petalView];
}</p></li>
<li><p>(void)touchesEnded:(NSSet<UITouch *> <em>)touches withEvent:(UIEvent </em>)event {
  UITouch <em>touch = touches.anyObject;
  CGPoint location = [touch locationInView:self.view];
  //方法1：block方式
  /</em>开始动画，UIView的动画方法执行完后动画会停留在重点位置，而不需要进行任何特殊处理
   duration:执行时间
   delay:延迟时间
   options:动画设置，例如自动恢复、匀速运动等
   completion:动画完成回调方法
   <em>/
  [UIView animateWithDuration:[self petalMoveDuring:[touch locationInView:self.view]] delay:0.0 options:UIViewAnimationOptionCurveLinear animations:^{
      petalView.center = location;
  } completion:nil];
  //方法2：静态方法
  //开始动画
  //[UIView beginAnimations:@&ldquo;KCBasicAnimation&rdquo; context:nil];
  //[UIView setAnimationDuration:5.0];
  //[UIView setAnimationDelay:1.0];//设置延迟
  //[UIView setAnimationRepeatAutoreverses:NO];//是否回复
  //[UIView setAnimationRepeatCount:10];//重复次数
  //[UIView setAnimationStartDate:(NSDate </em>)];//设置动画开始运行的时间
  //[UIView setAnimationDelegate:self];//设置代理
  //[UIView setAnimationWillStartSelector:(SEL)];//设置动画开始运动的执行方法
  //[UIView setAnimationDidStopSelector:(SEL)];//设置动画运行结束后的执行方法
  //petalView.center = location;
  //开始动画
  //[UIView commitAnimations];
}</p></li>
<li><p>(NSTimeInterval)petalMoveDuring:(CGPoint)destination {
  CGFloat deltaX = destination.x &ndash; petalView.center.x;
  CGFloat deltaY = destination.y &ndash; petalView.center.y;
  CGFloat distance = sqrt(deltaX<em>deltaX + deltaY</em>deltaY);
  NSLog(@&ldquo;%f&rdquo;, distance);
  return (NSTimeInterval)distance/50.0;
}</p></li>
</ul>


<p>@end
```</p>

<h4>弹簧动画效果</h4>

<p>iOS7新加入了一个弹性动画的接口，具体实现见代码。</p>

<p>```objectivec
@interface ACViewSpringAnimationViewController () {</p>

<pre><code>UIImageView *ballView;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation ACViewSpringAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  ballView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&ldquo;ball&rdquo;]];
  ballView.center = self.view.center;
  [self.view addSubview:ballView];
}</p></li>
<li><p>(void)touchesEnded:(NSSet<UITouch *> <em>)touches withEvent:(UIEvent </em>)event {
  UITouch <em>touch = touches.anyObject;
  CGPoint location = [touch locationInView:self.view];
  /</em>创建弹性动画
   damping:阻尼，范围0-1，阻尼越接近于0，弹性效果越明显
   velocity:弹性复位的速度
   */
  [UIView animateWithDuration:[self petalMoveDuring:location] delay:0 usingSpringWithDamping:0.5 initialSpringVelocity:0 options:UIViewAnimationOptionCurveLinear animations:^{
      ballView.center = location;
  } completion:nil];
}</p></li>
<li><p>(NSTimeInterval)petalMoveDuring:(CGPoint)destination {
  CGFloat deltaX = destination.x &ndash; ballView.center.x;
  CGFloat deltaY = destination.y &ndash; ballView.center.y;
  CGFloat distance = sqrt(deltaX<em>deltaX + deltaY</em>deltaY);
  NSLog(@&ldquo;%f&rdquo;, distance);
  return (NSTimeInterval)distance/150.0;
}</p></li>
</ul>


<p>@end
```</p>

<h4>UIView动画设置参数</h4>

<p>在动画方法中有一个NS_OPTION参数，UIViewAnimationOptions类型，它是一个枚举类型，动画参数分为三类，对应CoreAnimation的各类设置，可以组合使用：</p>

<ol>
<li>常规动画属性设置（可以同时选择多个进行设置）

<ul>
<li>UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。</li>
<li>UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。</li>
<li>UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。</li>
<li>UIViewAnimationOptionRepeat：重复运行动画。</li>
<li>UIViewAnimationOptionAutoreverse ：动画运行到结束点后仍然以动画方式回到初始点。</li>
<li>UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。</li>
<li>UIViewAnimationOptionOverrideInheritedCurve：忽略嵌套动画速度设置。</li>
<li>UIViewAnimationOptionAllowAnimatedContent：动画过程中重绘视图（注意仅仅适用于转场动画）。</li>
<li>UIViewAnimationOptionShowHideTransitionViews：视图切换时直接隐藏旧视图、显示新视图，而不是将旧视图从父视图移除（仅仅适用于转场动画）</li>
<li>UIViewAnimationOptionOverrideInheritedOptions ：不继承父动画设置或动画类型。</li>
</ul>
</li>
<li>动画速度控制（可从其中选择一个设置）

<ul>
<li>UIViewAnimationOptionCurveEaseInOut：动画先缓慢，然后逐渐加速。</li>
<li>UIViewAnimationOptionCurveEaseIn ：动画逐渐变慢。</li>
<li>UIViewAnimationOptionCurveEaseOut：动画逐渐加速。</li>
<li>UIViewAnimationOptionCurveLinear ：动画匀速执行，默认值。</li>
</ul>
</li>
<li>转场类型（仅适用于转场动画设置，可以从中选择一个进行设置，基本动画、关键帧动画不需要设置）

<ul>
<li>UIViewAnimationOptionTransitionNone：没有转场动画效果。</li>
<li>UIViewAnimationOptionTransitionFlipFromLeft ：从左侧翻转效果。</li>
<li>UIViewAnimationOptionTransitionFlipFromRight：从右侧翻转效果。</li>
<li>UIViewAnimationOptionTransitionCurlUp：向后翻页的动画过渡效果。</li>
<li>UIViewAnimationOptionTransitionCurlDown ：向前翻页的动画过渡效果。</li>
<li>UIViewAnimationOptionTransitionCrossDissolve：旧视图溶解消失显示下一个新视图的效果。</li>
<li>UIViewAnimationOptionTransitionFlipFromTop ：从上方翻转效果。</li>
<li>UIViewAnimationOptionTransitionFlipFromBottom：从底部翻转效果。</li>
</ul>
</li>
</ol>


<h3>UIView关键帧动画</h3>

<p>从iOS7开始UIView动画中封装了关键帧动画，下面就来看一下如何使用UIView封装方法进行关键帧动画控制，这里实现前面关键帧动画部分对于落花的控制。</p>

<p>```objectivec
@interface ACViewKeyframeAnimationViewController () {</p>

<pre><code>UIImageView *petalView;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation ACViewKeyframeAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.</p>

<p>  self.view.layer.contents = (id)[UIImage imageNamed:@&ldquo;background.jpg&rdquo;].CGImage;</p>

<p>  petalView = [[UIImageView alloc] init];
  petalView.frame = CGRectMake(50, 150, 0, 0);
  petalView.image = [UIImage imageNamed:@&ldquo;petal&rdquo;];
  [petalView sizeToFit];
  [self.view addSubview:petalView];</p>

<p>  [self addKeyframeAnimation];
}</p></li>
<li><p>(void)addKeyframeAnimation {
  [UIView animateKeyframesWithDuration:5.0 delay:0.0 options:UIViewKeyframeAnimationOptionCalculationModeLinear animations:^{
      [UIView addKeyframeWithRelativeStartTime:0.0 relativeDuration:0.5 animations:^{
          petalView.center = CGPointMake(80.0, 220.0);
      }];
      [UIView addKeyframeWithRelativeStartTime:0.5 relativeDuration:0.25 animations:^{
          petalView.center = CGPointMake(45.0, 300.0);
      }];
      [UIView addKeyframeWithRelativeStartTime:0.75 relativeDuration:0.25 animations:^{
          petalView.center = CGPointMake(55.0, 400.0);
      }];
  } completion:nil];
}</p></li>
</ul>


<p>@end
```</p>

<h4>UIView关键帧动画设置参数</h4>

<p>对于关键帧动画也有一些动画参数设置options，UIViewKeyframeAnimationOptions类型，和上面基本动画参数设置有些差别，关键帧动画设置参数分为两类，可以组合使用：</p>

<ol>
<li><p>常规动画属性设置（可以同时选择多个进行设置）</p>

<ul>
<li>UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。</li>
<li>UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。</li>
<li>UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。</li>
<li>UIViewAnimationOptionRepeat：重复运行动画。</li>
<li>UIViewAnimationOptionAutoreverse：动画运行到结束点后仍然以动画方式回到初始点。</li>
<li>UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。</li>
<li>UIViewAnimationOptionOverrideInheritedOptions：不继承父动画设置或动画类型。</li>
</ul>
</li>
<li><p>动画模式设置（同前面关键帧动画动画模式一一对应，可以从其中选择一个进行设置）</p>

<ul>
<li>UIViewKeyframeAnimationOptionCalculationModeLinear：连续运算模式。</li>
<li>UIViewKeyframeAnimationOptionCalculationModeDiscrete：离散运算模式。</li>
<li>UIViewKeyframeAnimationOptionCalculationModePaced：均匀执行运算模式。</li>
<li>UIViewKeyframeAnimationOptionCalculationModeCubic：平滑运算模式。</li>
<li>UIViewKeyframeAnimationOptionCalculationModeCubicPaced：平滑均匀运算模式。</li>
</ul>
</li>
</ol>


<p>注意：前面说过关键帧动画有两种形式，上面演示的是属性值关键帧动画，路径关键帧动画目前UIView还不支持。</p>

<h3>UIView转场动画</h3>

<p>从iOS4.0开始，UIView直接封装了转场动画。</p>

<p>```objectivec
@interface ACViewTransitionAnimationViewController () {</p>

<pre><code>UIImageView *imageView;
NSArray *transitionTypes;
</code></pre>

<p>}</p>

<p>@end</p>

<p>static int transitionTypeIndex;</p>

<p>@implementation ACViewTransitionAnimationViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view.
  transitionTypes = @[[NSNumber numberWithUnsignedInteger:UIViewAnimationOptionTransitionFlipFromRight], [NSNumber numberWithUnsignedInteger:UIViewAnimationOptionTransitionCurlUp], [NSNumber numberWithUnsignedInteger:UIViewAnimationOptionTransitionCrossDissolve], [NSNumber numberWithUnsignedInteger:UIViewAnimationOptionTransitionFlipFromBottom]];
  transitionTypeIndex = 0;</p>

<p>  imageView = [[UIImageView alloc] initWithFrame:[UIScreen mainScreen].bounds];
  [imageView setImage:[UIImage imageNamed:@&ldquo;background.jpg&rdquo;]];
  [self.view addSubview:imageView];</p>

<p>  UISwipeGestureRecognizer *swipeGesture = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipe:)];
  swipeGesture.direction = UISwipeGestureRecognizerDirectionLeft;
  [self.view addGestureRecognizer:swipeGesture];
}</p></li>
<li><p>(void)swipe:(UISwipeGestureRecognizer *)gestureRecognizer {
  if (transitionTypeIndex > 3) {
      transitionTypeIndex = 0;
  }</p>

<p>  UIViewAnimationOptions option;
  option = [transitionTypes[transitionTypeIndex] unsignedIntegerValue];
  option = option|UIViewAnimationOptionCurveLinear;
  [UIView transitionWithView:imageView duration:1.0 options:option animations:^{
      [imageView setImage:[UIImage imageNamed:@&ldquo;background.jpg&rdquo;]];
  } completion:nil];</p>

<p>  transitionTypeIndex++;
}</p></li>
</ul>


<p>@end
```</p>

<p>如果有两个完全不同的视图，并且每个视图布局都很复杂，此时要在这两个视图之间进行转场可以使用以下方法进行两个视图间的转场，需要注意的是默认情况下转出的视图会从父视图移除，转入后重新添加，可以通过UIViewAnimationOptionShowHideTransitionViews参数设置，设置此参数后转出的视图会隐藏（不会移除）转入后再显示。</p>

<p><code>objectivec
+(void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion;
</code></p>

<p>注意：转场动画设置参数完全同基本动画参数设置；同直接使用转场动画不同的是使用UIView的装饰方法进行转场动画其动画效果较少，因为这里无法直接使用私有API。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发备忘录1]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/11/05/ioskai-fa-bei-wang-lu-1/"/>
    <updated>2015-11-05T13:41:03+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/11/05/ioskai-fa-bei-wang-lu-1</id>
    <content type="html"><![CDATA[<p>总结一些iOS开发必备的知识点，结构可能会比较杂，可以当做备忘录使用，不断更新中。</p>

<!--more-->


<h2>1.library和framework的比较</h2>

<p>library也就是我们常用的.a文件，而framework就是.framework文件，当然还有.dylib这样的文件。</p>

<h3>静态库和动态库的区别</h3>

<ul>
<li>静态库：链接时完整地拷贝至可执行文件夹中，被多次使用时会有多份冗余拷贝。</li>
<li>动态库：链接时不复制，程序运行是由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。</li>
</ul>


<h3>iOS库的形式</h3>

<ul>
<li>静态库：.a和.framework</li>
<li>动态库：.dylib和.framework</li>
<li>系统提供的.framework是动态的，而自己开发的.framework是静态的</li>
</ul>


<h3>.a和.framework区别</h3>

<ul>
<li>.a就是一个纯二进制的文件，而.framework还会包含头文件和资源文件</li>
<li>.a一般是要配合.h头文件使用的，.framework是可以直接使用的</li>
<li>实际上.framework = .a + .h + sourceFile</li>
</ul>


<h3>需要注意的问题</h3>

<ul>
<li>注意理解：无论是.a静态库还.framework静态库，我们需要的都是二进制文件+.h+其它资源文件的形式，不同的是，.a本身就是二进制文件，需要我们自己配上.h和其它文件才能使用，而.framework本身已经包含了.h和其它文件，可以直接使用。</li>
<li>图片资源的处理：两种静态库，一般都是把图片文件单独的放在一个.bundle文件中，一般.bundle的名字和.a或.framework的名字相同。.bundle文件很好弄，新建一个文件夹，把它改名为.bundle就可以了，右键，显示包内容可以向其中添加图片资源。</li>
<li>category是我们实际开发项目中经常用到的，把category打成静态库是没有问题的，但是在用这个静态库的工程中，调用category中的方法时会有找不到该方法的运行时错误（selector not recognized），解决办法是：在使用静态库的工程中配置other linker flags的值为-ObjC。</li>
<li>如果一个静态库很复杂，需要暴露的.h比较多的话，就可以在静态库的内部创建一个.h文件（一般这个.h文件的名字和静态库的名字相同），然后把所有需要暴露出来的.h文件都集中放在这个.h文件中，而那些原本需要暴露的.h都不需要再暴露了，只需要把.h暴露出来就可以了。</li>
<li>创建.a文件的一篇<a href="http://www.raywenderlich.com/41377/creating-a-static-library-in-ios-tutorial">博客</a>，创建.framework的一篇<a href="http://www.raywenderlich.com/65964/create-a-framework-for-ios">博客</a>。</li>
</ul>


<!--more-->


<h2>2.事件响应链The Responder Chain</h2>

<h3>事件的传递顺序</h3>

<p>当用户触发的一个事件发生，UIKit会创建一个包含要处理的事件信息的事件对象。然后她会将事件对象放入active app’s（应用程序对象，每个程序对应唯一一个）事件队列。对于触摸事件，事件对象就是UIEvent对象封装的一系列触摸集合。对于动作事件，这个事件对象依赖于使用的framework和你关心哪种动作事件。</p>

<h3>事件类型</h3>

<p>事件通过特殊的路径传递直到被传递到一个可以处理该事件的对象。首先，单例的UIApplication对象从顶层的队列中获取事件，然后分发。典型的，它将事件发送到App的key window对象，window则为了处理该事件而发送它到初始化对象（initial object），这个初始化对像依靠事件类型。</p>

<ul>
<li>触摸事件（Touch events）。对于触摸事件，window对象首先会尝试将事件传递给事件发生的view。这个view就是所谓的hit-test view。寻找hit-test view的方法叫hit-testing，具体描述见<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW4">Apple文档</a>。</li>
<li>动作事件和远程控制事件（Motion and remote control events）。在这些事件中，window对象发送事件到第一个响应器。第一个响应器的具体描述见<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW1">Apple文档</a>。</li>
</ul>


<p>事件传递路径的最终目的时找出能处理和响应该事件的对象。因此，UIKit给适合处理该事件的对象发送事件。对于触摸事件，这个对象就是hit-test view，对于其他事件，这个对象就是第一个响应器（first responder）。</p>

<h3>触摸事件的响应链</h3>

<p>iOS使用hit-testing寻找触摸的view。 Hit-Testing通过检查触摸点是否在关联的view边界内，如果在，则递归地（recursively）检查该view的所有子view。在层级上处于lowest（就是用户直接接触view）且边界范围包含触摸点的view成为hit-test view。确定hit-test view后，它传递触摸事件给该view。</p>

<p>举例说明，假设用户触摸了图中的view E。iOS通过如下顺序查找hit-test view。</p>

<p><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png" alt="image" /></p>

<ol>
<li>触摸点在view A中，所以要检查子view B和C。</li>
<li>触摸点不在view B中，但在C中，所以检查C的子view D和E。</li>
<li>触摸点不在D中，但在E中。</li>
</ol>


<p><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/hitTest:withEvent:">hitTest:withEvent:</a>方法通过传递进来CGPoint和UIEvent返回hit test view。该方法调用<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/pointInside:withEvent:">pointInside:withEvent:</a>方法，如果传入hitTest:withEvent:的point在view的边界范围内，则pointInside:withEvent:返回YES。然后，这个方法会在view的所有子view中递归的调用hitTest:withEvent:。</p>

<p>如果传入hitTest:withEvent:的point不在view的边界范围内，则pointInside:withEvent:返回NO。这个point会被忽略，hitTest:withEvent:返回nil。如果一个子view返回NO，则它所在的view的层级上的分支的子view都会被忽略。</p>

<p>Hit-test view是处理触摸事件的第一选择，如果hit-test view不能处理事件，该事件将从事件响应链中寻找响应器，直到系统找到一个处理事件的对象。</p>

<h3>响应器链</h3>

<p>一些类型的事件的传递依赖响应器链。响应器链（responder chain）是一系列相关的响应器对象。它开始于第一个响应器终止于应用对象（application object）。如果第一个responder不处理事件，则会根据responder chain将event传递给下一个responder。</p>

<p>Responder object，即可以响应和处理事件的对象。UIResponder类是所有responder对象的基类，它定义了动态的接口，不仅处理事件也包括处理响应行为。包括UIApplication，UIViewController，和UIView类都是responder，这意味着所有view和大部分关键的controller对象都是responder。但是Core Animation layers不是responders。</p>

<p>First responder被设计来第一个接收事件。典型的，first responder是一个view object。之所以成为第一个responder由于两个原因：</p>

<ol>
<li>覆盖canBecomeFirstResponder方法，返回YES。</li>
<li>接收becomeFirstResponder消息。如果必须，一个object能发送给自身这个消息。</li>
</ol>


<h3>响应器链的传输路径</h3>

<p>如果初始化对象（initial object）—— 即hit-test view或者first responder —— 不处理事件，UIKit会将事件传递给responder chain的下一个responder。每个responder决定它是传递事件还是通过nextResponder方法传递给它的下一个responder。这个操作继续直到一个responder处理event或者没有responder了。</p>

<p>Responder chain 序列在iOS确定一个事件并将它传递给initial object（通常是view）时开始。所以initial view有处理事件的第一个机会。下图描述了两个不同的事件传递路径（因为不同的app 设置）。一个App的事件传递路径由app特殊的构成决定，但事件传递路径会遵守相同的规则。</p>

<p><img src="http://lucifer1988.github.io/images/responser_chain.jpeg"></p>

<h3>手动指定当前view不响应事件</h3>

<p>```objectivec
&ndash;(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event {</p>

<pre><code>for (UIView *view in self.subviews) {
    if (!view.hidden &amp;&amp; view.userInteractionEnabled &amp;&amp; [view pointInside:[self convertPoint:point toView:view] withEvent:event])
        return YES;
}
return NO;
</code></pre>

<p>}
```</p>

<h3>总结</h3>

<p>事件的传递和响应分两个链：</p>

<ul>
<li>传递链：由系统向离用户最近的view传递。UIKit –> active app’s event queue –> window –> root view –>……–>lowest view</li>
<li>响应链：由离用户最近的view向系统传递。initial view –> super view –> …..–> view controller –> window –> Application</li>
</ul>

]]></content>
  </entry>
  
</feed>
