<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 刘毅的技术博客]]></title>
  <link href="http://lucifer1988.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://lucifer1988.github.io/"/>
  <updated>2014-03-04T13:24:53+08:00</updated>
  <id>http://lucifer1988.github.io/</id>
  <author>
    <name><![CDATA[刘毅]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[调试利器-PonyDebugger]]></title>
    <link href="http://lucifer1988.github.io/blog/2014/03/03/diao-shi-li-qi-ponydebugger/"/>
    <updated>2014-03-03T15:12:01+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2014/03/03/diao-shi-li-qi-ponydebugger</id>
    <content type="html"><![CDATA[<p><img src="http://lucifer1988.github.io/images/ponyDebugger_icon.png"></p>

<p>PonyDebugger是git上一个利用Chrome开发者工具来进行iOS客户端远程调试的工具包，与其他远类型程调试工具相比，它有着非常IMBA且又非常实用的功能：网络活动监控、查看CoreData对象、视图层级查看等，下面让我们看看如何驾驭这只神奇的小马驹吧！</p>

<!--more-->


<h2>功能</h2>

<p>PonyDebugger提供了四个特色的功能，包括：监控网络、CoreData对象查看、视图分层查看和远程日志打印。</p>

<h3>监控网络</h3>

<p>所有通过NSURLConnection进行的网络访问，都会被监测到，也就是说那些基于NSURLConnection的第三方网络组件，如AFNetworking，都可以被监测到，而且看以方便的查看到：访问类型、接口名、错误类型，返回类型、网络延时等信息，非常强大！</p>

<p><img src="http://lucifer1988.github.io/images/ponyDebugger_Network.png"></p>

<h3>CoreData对象查看</h3>

<p>这个功能就不必多说了，你可能见过很多方便的sqlite工具，比如FireFox的SQLite Manager插件，但是这样直接查看CoreData对象的不多见吧？</p>

<p><img src="http://lucifer1988.github.io/images/ponyDebugger_CoreData.png"></p>

<h3>视图分层查看</h3>

<p>这个功能对于前端开发者来说是最重要不过了，PonyDebugger将你应用的视图关系以xml的形式分层展示出来，选择相应xml，会在客户端进行对应视图的高亮响应，xml的属性信息可以在客户端进行配置，而且竟然支持直接修改xml属性值，而客户端UI会实时做出改变！</p>

<p><img src="http://lucifer1988.github.io/images/ponyDebugger_ViewHierarchy.png"></p>

<h3>远程日志打印</h3>

<p>这个可能你觉得没什么亮点，上次介绍的NSLogger可是专门做这件事的，不过PonyDebugger的这一功能也不会让你失望，它的语句类型不多，主要分为<code>PDLog()</code>和<code>PDLogObjects()</code>，<code>PDLog()</code>负责打印字符串信息，<code>PDLogObjects()</code>负责打印对象和数组。不过正如下图所示，<code>PDLogObjects()</code>打印出的对象也是分层展示的，比如查看一个数组中自定义modal对象的一个属性的值这样的事情就非常轻松，而且不用你再回Xcode中加断点，这是不很爽啊！</p>

<p><img src="http://lucifer1988.github.io/images/ponyDebugger_Console.png"></p>

<h2>配置</h2>

<p>配置工作包括配置服务器端和客户端。</p>

<h3>配置服务器端</h3>

<ul>
<li>安装Xcode&rsquo;s Command Line Tools，在之前的版本中可直接在Xcode中安装，如果你的环境更新到10.9和Xcode5之后，不妨参考<a href="http://ourcoders.com/thread/show/1208/">这里</a>进行安装，这是之前10.9更新CocoaPods时发现的一个问题。</li>
<li>在终端执行以下命令，进行安装</li>
</ul>


<p><code>
curl -sk https://cloud.github.com/downloads/square/PonyDebugger/bootstrap-ponyd.py | \
  python - --ponyd-symlink=/usr/local/bin/ponyd ~/Library/PonyDebugger
</code>
注：如果在安装过程中报出如下错误：</p>

<p>```
···
  Running setup.py (path:/Users/user/Library/PonyDebugger/build/tornado/setup.py) egg_info for package tornado</p>

<pre><code>warning: no previously-included files matching '_auto2to3*' found anywhere in distribution
</code></pre>

<p>Downloading/unpacking pybonjour (from ponydebugger)
  Could not find any downloads that satisfy the requirement pybonjour (from ponydebugger)
  Some externally hosted files were ignored (use &mdash;allow-external pybonjour to allow).
Cleaning up&hellip;
<code>
可以参考[这里](https://github.com/square/PonyDebugger/issues/100)的解决方法，在我安装的过程中也遇到了这个问题，按照提示是</code>pip<code>安装时没有配置</code>&mdash;allow-external pybonjour &mdash;allow-unverified pybonjour```。</p>

<ul>
<li>成功安装后，在终端输入<code>ponyd serve --listen-interface=127.0.0.1</code>，打开监听。</li>
<li>最后打开浏览器，输入地址<code>http://localhost:9000</code>，如果访问到如下结果，说明安装成功。</li>
</ul>


<p><img src="http://lucifer1988.github.io/images/ponyDebugger_install.png"></p>

<h3>配置客户端</h3>

<p>由于现在PonyDebugger支持CocoaPods安装了，可以直接在你的podfile中加入：</p>

<p><code>
pod 'PonyDebugger'
</code>
然后，安装一下就可以了。</p>

<p><code>
pod install
</code>
不了解CocoaPods的童鞋可以参考下唐巧大哥的<a href="http://blog.devtang.com/blog/2012/12/02/use-cocoapod-to-manage-ios-lib-dependency/">这篇介绍</a>，希望手动加入PonyDebugger的童鞋可以参考<a href="https://github.com/square/PonyDebugger">官方文档</a>中Manual Installation一项。</p>

<h2>使用</h2>

<p>相比起搭建环境，PonyDebugger的使用非常简单。你需要在你应用的<code>AppDelegate.m</code>的<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {}</code>方法中加入以下代码：</p>

<p>```</p>

<pre><code>PDDebugger *debugger = [PDDebugger defaultInstance];
//设置网络监控
[debugger enableNetworkTrafficDebugging];
[debugger forwardAllNetworkTraffic];
//通过TCP连接至服务端
[debugger connectToURL:[NSURL URLWithString:@"ws://localhost:9000/device"]];
// 也可通过bonjour自动连接
//[debugger autoConnect];
// 或连接至指定bonjour服务
//[debugger autoConnectToBonjourServiceNamed:@"MY PONY"];
//设置CoreData监控
[debugger enableCoreDataDebugging];
[debugger addManagedObjectContext:self.managedObjectContext withName:@"TIME Test MOC"];
//设置视图分层监控
[debugger enableViewHierarchyDebugging];
[debugger setDisplayedViewAttributeKeyPaths:@[@"frame", @"hidden", @"alpha", @"opaque", @"accessibilityLabel", @"text"]];
//设置远程日志打印
[debugger enableRemoteLogging];
</code></pre>

<p>```</p>

<h2>小结</h2>

<p>本文可以作为<code>PonyDebugger</code>一个入门级的文档。相比上一次介绍的<code>NSLogger</code>来说，<code>PonyDebugger</code>的展示方式和查看方式更加直观和方便，作为通用的调试工具非常不错，而<code>NSLogger</code>拥有强大的日志记录功能，但想要发挥<code>NSLogger</code>的作用，对程序员的经验和能力就有了一定的要求，所以两种工具各有千秋，大家各取所需就好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[强力的日志分析工具-NSLogger]]></title>
    <link href="http://lucifer1988.github.io/blog/2014/02/25/qiang-li-de-ri-zhi-fen-xi-gong-ju-nslogger/"/>
    <updated>2014-02-25T17:00:29+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2014/02/25/qiang-li-de-ri-zhi-fen-xi-gong-ju-nslogger</id>
    <content type="html"><![CDATA[<blockquote><p>NSLogger出现了，在Florent Pillet的打造下，一个开源强力的输出工具给了log这一古老的工作崭新的生命。标签输出，优先级查找，直接输出图像，多线程标记，时序控制，甚至是通过网络log到别人的终端或者是从别人的终端程序中记录log。在这里，只有想不到没有做不到，堪称是史上最为强大的logger。<br/>
<p align="right">&mdash;OneV&rsquo;s Den</p></p></blockquote>

<p>NSLogger是一款强力的日志记录和分析工具，其强大的功能，可以完全替代Xcode自带的Debugger，本文将介绍一些其主要特点和用法。git地址：<a href="https://github.com/fpillet/NSLogger">https://github.com/fpillet/NSLogger</a></p>

<!--more-->


<h2>安装</h2>

<p>NSLogger由两部分组成，一是需要加入工程中的组件代码，二是查看和管理日志的Mac客户端。组件代码可通过CocoaPods安装，也可通过手动添加（手动添加需要引入CFNetwok.framework和SystemConfiguration.framework）。Mac客户端NSLoggerViewer的源码包含在了组件当中，可以自己生成，也可以<a href="http://doruby.com/assets/NSLoggerViewer.zip">点击这里</a>下载生成好的客户端，NSLoggerViewer实际运行图：</p>

<p><img src="http://lucifer1988.github.io/images/NSLoggerViewer.png"></p>

<!--more-->


<h2>特点</h2>

<ul>
<li>标签输出</li>
<li>自定义优先级</li>
<li>直接输出图片</li>
<li>多线程标记</li>
<li>时序控制</li>
<li>远程记录</li>
</ul>


<!--more-->


<h2>配置</h2>

<p>首先要将LoggerClient.h头文件import进来，通过LoggerSetOptions()配置Logger的一些属性：</p>

<p>```
enum {
  kLoggerOption_LogToConsole               = 0x01,
  kLoggerOption_BufferLogsUntilConnection  = 0x02,
  kLoggerOption_BrowseBonjour              = 0x04,
  kLoggerOption_BrowseOnlyLocalDomain      = 0x08,
  kLoggerOption_UseSSL                     = 0x10,
  kLoggerOption_CaptureSystemConsole       = 0x20
};</p>

<p>void LoggerSetOptions(Logger *logger, uint32_t flags);
```
一般使用默认Logger，第一个参数传入NULL就行，至于第二个参数主要是一些功能开关选项，将需要开启的功能相或后作为第二个参数即可，详细参数说明<a href="https://github.com/fpillet/NSLogger/wiki/NSLogger-API">点击</a>，实例：</p>

<p>```</p>

<pre><code>    LoggerSetOptions(NULL,                  
                     kLoggerOption_BufferLogsUntilConnection |
                     kLoggerOption_UseSSL |
                     kLoggerOption_CaptureSystemConsole|
                     kLoggerOption_BrowseBonjour|
                     kLoggerOption_BrowseOnlyLocalDomain : 0));
</code></pre>

<p>```
NSLogger支持TCP和Bonjour两种方式连接终端设备，Bonjour连接一般不需要配置，如果要是使用TCP连接，要通过LoggerSetViewerHost()配置IP地址和端口（同时需配置NSLoggerViewer，在Preferences的Network中，勾选 “Listen for loggers on TCP port”打开监听）：</p>

<p><code>
void LoggerSetViewerHost(Logger *aLogger, CFStringRef host, UInt32 port);
</code>
同样，使用默认Logger，第一参数传NULL，实例：</p>

<p><code>
LoggerSetViewerHost(NULL, (__bridge CFStringRef)@"192.168.11.38", (UInt32)50000);
</code>
以上代码放到<code>- (void)applicationDidFinishLaunching:(UIApplication *)application</code>统一配置。</p>

<!--more-->


<h2>使用</h2>

<p>使用NSLogger基本方法和NSLog并无本质差别，只是开发者可以添加一些标签和级别参数，以供NSLoggerViewer端的日志过滤。</p>

<p><code>
void LogMessage(NSString *tag, int level, NSString *format, ...);
</code>
同时也支持添加文件名、方法名、行号、变量名等参数：</p>

<p><code>
void LogMessageF(const char *file, int line, const char *function, NSString *tag, int level, NSString *format, ...);
void LogMessage_va(NSString *tag, int level, NSString *format, va_list args);
</code>
NSLogger支持直接打印二进制数据：</p>

<p><code>
void LogData(NSString *tag, int level, NSData *data);
void LogDataF(const char *file, int line, const char *function, NSString *tag, int level, NSData *data);
</code>
NSLogger最大的优点，支持直接打印图片，而且可以指定打印图片的大小：</p>

<p><code>
void LogImageData(NSString *tag, int level, int width, int height, NSData *data);
void LogImageDataF(const char *file, int line, const char *function, NSString *tag, int level, int width, int height, NSData *data);
</code></p>

<!--more-->


<h2>Tips</h2>

<ul>
<li>直接使用默认打印函数过于繁琐，可结合需求自己定义宏来定义打印方法：</li>
</ul>


<p>```</p>

<h1>ifdef DEBUG</h1>

<h1>define LOG_NETWORK(level, &hellip;) LogMessageF(FILE,LINE,FUNCTION,&ldquo;network&rdquo;,level,<strong>VA_ARGS</strong>)</h1>

<h1>define LOG_GENERAL(level, &hellip;) LogMessageF(<strong>FILE</strong>,<strong>LINE</strong>,<strong>FUNCTION</strong>,“general”,level,VA_ARGS)</h1>

<h1>define LOG_GRAPHICS(level, &hellip;) LogMessageF(FILE,LINE,FUNCTION,@&ldquo;graphics&rdquo;,level,VA_ARGS)</h1>

<h1>define LOG_TRACE(&hellip;) LogMessageF( <strong>FILE</strong>,<strong>LINE</strong>,<strong>FUNCTION</strong>, NULL, 0, <strong>VA_ARGS</strong>)</h1>

<h1>else</h1>

<h1>define LOG_NETWORK(&hellip;) do{}while(0)</h1>

<h1>define LOG_GENERAL(&hellip;) do{}while(0)</h1>

<h1>define LOG_GRAPHICS(&hellip;) do{}while(0)</h1>

<h1>define LOG_TRACE(&hellip;) do{}while(0)</h1>

<p><code>
* 如果程序启动后，没有数据发送到NSLoggerViewer，可以先clean一下。
* 通过NSLoggerViewer当中Tools功能下</code>Add Mark<code>(**Cmd-M**)可以在日志列表底部快速添加一个时间戳标记，而使用</code>Add Mark With Title```(<strong>shift-Cmd-M</strong>)可以添加自定义标题的标记，通过这些标记将日志按照需要进行分块。<br/>
<img src="http://lucifer1988.github.io/images/NSLoggerViewer_Marker.png"></p>

<h2>总结</h2>

<p>本文介绍了NSLogger的一些基本用法和技巧，以后还会介绍一些其他的调试工具，不过个人感觉工具再好，不能真正结合自己的项目用起来，也没有太大意义，所以还是在平时能多去试试这些工具，这样才能利用到它们为我们真正做一些事情。</p>
]]></content>
  </entry>
  
</feed>
