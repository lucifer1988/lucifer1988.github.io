<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 刘毅的技术博客]]></title>
  <link href="http://lucifer1988.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://lucifer1988.github.io/"/>
  <updated>2015-10-20T17:21:53+08:00</updated>
  <id>http://lucifer1988.github.io/</id>
  <author>
    <name><![CDATA[刘毅]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Generics]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/15/swift-by-tutorials-generics/"/>
    <updated>2015-10-15T11:05:56+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/15/swift-by-tutorials-generics</id>
    <content type="html"><![CDATA[<p>经过前三章，基本对Swift的基本语法有了较全面的介绍，接下来会分别就Swift比较重要的几个技术要点介绍，这一节将讨论一个比较流行的语言特性，generics，即泛型。对于类型安全的编程语言，希望代码可以在一个场景下运行，但又想要在其他场景中也可以是合法的，比如对于一个加法函数，Int和Float类型的函数形式是一样的，只是变量类型不同，在强调类型的语言中，你必须分开定义这两个方法。很多语言为这一问题提供了解决方案，C++是使用了模板，而Swift、Java、C#是使用了泛型，也就是这一章的主角，配合主题这一章将创建一个Flickr照片搜素App来实践这一技术。</p>

<!--more-->


<h2>Introducing generics</h2>

<p>1.泛型是什么？举例来说Array和Dictionary就是类型安全的泛型应用实例。在OC中Array和Dictionary是可以存放不同类型的对象的，当然这有时是提供了很多方便，但当你去使用一个Array或Dictionary时，你如何知道其中的类型？只能通过文档或其他代码，而且没有任何办法去控制在runtime中出现数据异常。<br/>
2.而Swift中对Array和Dictionary中类型是固定的，编译器会完成类型检查，而你的代码本身也对自己做了注释，比较下处理点击的方法在OC和Swift中的区别，在OC中调用这一方法，你一般是需要将set中的对象转化为UITouch类型，而Swift不仅省去你这一操作，代码可读性也更优。</p>

<p><code>objectivec
//in OC
-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;
//in Swift
func touchesBegan(touches: [UITouch]!, withEvent event: UIEvent!)
</code></p>

<p>2.所以说泛型就是类似Array这样，所有的Array运作方式都是一致的，都是将数据存在一张有序的表中，但泛型的Array将值的类型作为了参数，也就是不论Array中类型如何，都可以执行Array的方法。</p>

<!--more-->


<h2>Generics in action</h2>

<p>1.本章的实例项目是要从Flickr的搜索接口获取对应图片，并进行展示的一个App，其中网络访问部分大神已经写好了。</p>

<!--more-->


<h2>Ordered dictionaries</h2>

<p>1.第一个需求就是希望将用户最近搜索的图片放在前面，那么如果正常来讲，我们要用Array来存数据源，而不是Dictionary或Set，因为后两者是无序的，而这里为了应用泛型，打算自己创建一个有序的Dictionary，实际上就是想把key作为顺序。</p>

<h3>The initial data structure</h3>

<p>1.首先声明有序字典为Struct类型，并声明它的泛型类型参数，KeyType和ValueType并不是真实的类型，只是两个你用来替代类型的参数，一般用T来表示，如果单词表示的话用驼峰式大写首字母来表示。</p>

<p><code>objectivec
struct OrderedDictionary&lt;KeyType, ValueType&gt; {
}
</code></p>

<p>2.创建一个有序字典最简单的方法是，在内部同时维护一个Dictionary和Array，这里使用了typealias分别给[KeyType]和[KeyType: ValueType]做了类型名替代，这样下面声明Array和Dictionary就可以直接用替代类型名来定义，同理这个也可以用在替换函数类型和闭包等比较长的类型的替换。</p>

<p>```objectivec
typealias ArrayType = [KeyType]
typealias DictionaryType = [KeyType: ValueType]</p>

<p>var array = ArrayType()
var dictionary = DictionaryType()
```</p>

<p>3.对比Dictionary的定义，KeyType需要遵循Hashable协议，因为Dictionary需要对key做hash，所以在定义泛型那儿要加上遵循该协议。</p>

<p><code>objectivec
struct OrderedDictionary&lt;KeyType: Hashable, ValueType&gt;
</code></p>

<h3>Keys, values and all that jazz</h3>

<p>1.第一个要加入的方法是insert方法，因为是有序字典，所以有所不同。</p>

<p>```objectivec
mutating func insert(value: ValueType, forKey key: KeyType, atIndex index: Int) &ndash;> ValueType? {
  var adjustedIndex = index</p>

<p>  let existingValue = self.dictionary[key]
  if existingValue != nil {</p>

<pre><code>let existingIndex = self.array.indexOf(key)!
if existingIndex &lt; index {
  adjustedIndex--
}
self.array.removeAtIndex(existingIndex)
</code></pre>

<p>  }</p>

<p>  self.array.insert(key, atIndex:adjustedIndex)
  self.dictionary[key] = value</p>

<p>  return existingValue
}
```</p>

<p>2.有几点需要说明，首先，该方法前的mutating关键字，因为Struct默认是不可变的，也就是是说你不能在实例方法中修改struct的成员变量，加上mutating是为了告诉编译器该方法可以修改struct成员变量，使编译器在适当的时候对struct做copy操作(前面说过，实际上是copy-on-write)，同时也增加了可读性。<br/>
3.然后是remove方法，这里先对index是否越界做了判断，可以像OC中使用Assertions断言，也可以如下使用precondition，如果失败，会退出App。</p>

<p><code>objectivec
mutating func removeAtIndex(index: Int) -&gt; (KeyType, ValueType) {
  precondition(index &lt; self.array.count, "Index out-of-bounds")
  let key = self.array.removeAtIndex(index)
  let value = self.dictionary.removeValueForKey(key)!
  return (key, value)
}
</code></p>

<p>4.这里在结束后会返回一个元组类型的删除值，使之与Swift的Array和Dictionary的remove方法保持一致。</p>

<h3>Accessing values</h3>

<p>1.上一节为有序字典添加了写入的方法，接下来添加一些读取的方法，首先是获取count的方法，如下，使用了前面提到的computed property技术。</p>

<p><code>objectivec
var count: Int {
  return self.array.count
}
</code></p>

<p>2.在Swift中我们一般使用subscript来访问变量，类似dictionary[1]，一般是见于Array和Dictionary，不过我们计划在我们的有序字典也加入这一特性。</p>

<p>```objectivec
subscript(key: KeyType) &ndash;> ValueType? {
  get {</p>

<pre><code>return self.dictionary[key]
</code></pre>

<p>  }
  set {</p>

<pre><code>if let index = self.array.indexOf(key) {
} else {
  self.array.append(key)
}
self.dictionary[key] = newValue
</code></pre>

<p>  }
}
```</p>

<p>3.上述代码就是如何在自己的Struct中加入subscript行为，类似computed property，subscript有两个闭包，分别是getter和setter。<br/>
4.因为这是一个有序数组，我们打算让他支持通过index来访问，需要注意的是：一，无论setter，getter都需要判断index是否越界；二，setter中输入的值newValue是一个元组类型，所以需要用let (key, value) = newValue将键值取出来。</p>

<p>```objectivec
subscript(index: Int) &ndash;> (KeyType, ValueType) {
  get {</p>

<pre><code>precondition(index &lt; self.array.count, "Index out-of-bounds")
let key = self.array[index]
let value = self.dictionary[key]!
return (key, value)
</code></pre>

<p>  }
  set {</p>

<pre><code>precondition(index &lt; self.array.count, "Index out-of-bounds")
let (key, value) = newValue
let originalKey = self.array[index]
self.dictionary[originalKey] = nil
self.array[index] = key
self.dictionary[key] = value
</code></pre>

<p>  }
}
```</p>

<p>5.这里可能有个疑问，就是如果使用者使用Int作为KeyType呢？因为Int也遵循hashable，完全可以作为key，那么编译器如何判断该用哪组方法呢？遇到这种情况，setter方法当然没问题，因为赋值也不同，那么getter方法只能在取值时就声明返回值的类型，这样编译器会通过这个类型选择使用哪个方法。</p>

<p><code>objectivec
var dict = OrderedDictionary&lt;Int, String&gt;()
dict.insert("dog", forKey: 1, atIndex: 0)
dict.insert("cat", forKey: 2, atIndex: 1)
print(dict.array.description + " : " + dict.dictionary.description)
//"[1, 2] : [2: "cat", 1: "dog"]"
var byIndex: (Int, String) = dict[0]
print(byIndex)
//"(1, "dog")"
var byKey: String? = dict[2]
print(byKey)
//"Optional("cat")"
</code></p>

<p>6.在使用type interface时，编译器需要明确知道返回值的类型，如果出现上述相同方法，返回值类型不同的情况，必须caller指明类型，否则编译器是不会知道该返回那个值的。</p>

<!--more-->


<h2>Aside: Assertions &amp; preconditions</h2>

<p>1.assertions和precondition都是判断程序是否能继续执行时的判断条件，不同的是，assertion是不会在release build时编译的，而precondition可以；assertion是被用于在开发时获取bug，而precondition是用于当一个条件不满足时，抛出严重异常的。<br/>
2.assertion的一个使用场景是有多个创建view的方法共同来构建页面，但其中一些依赖于另一些完成，这时要使用assertion。</p>

<p>```objectivec
private func configureTableView() {</p>

<pre><code>self.tableView = UITableView(frame: CGRectZero) 
self.tableView.delegate = self 
self.tableView.dataSource = self 
self.view.addSubview(self.tableView)}private func configureHeader() {   assert(self.tableView != nil)   let headerView = UIView(frame: CGRectMake(0, 0, 320, 50))   headerView.backgroundColor = UIColor.clearColor()   let label = UILabel(frame: CGRectZero)  label.text = "My Table"     label.sizeToFit()   label.frame = CGRectMake(0, 0, label.bounds.size.width, label.bounds.size.height) headerView.addSubview(label)  self.tableView.tableHeaderView = headerView }
</code></pre>

<p>```</p>

<p>3.关于assertion一个有趣的现象是编译器允许在release build时假设assertion是true，有时也会导致一些bug，如下，输入0时，在debug下没问题，会触发断言；而在release中，编译器自动认为assertion是true，然后optimizer就会跳过if，直接进入>0的分支。</p>

<p>```objectivec
func foo(value: Int) {</p>

<pre><code>assert(value &gt; 0)   if value &gt; 0 {      print("Yes, it's greater than zero")    } else { 
    print("Nope")   } }
</code></pre>

<p>```</p>

<p>4.再来看下precondition，它和assertion做的是一样的工作，但是可以在release下运行，使用它是为了确保一些必要的条件，如下例，数组越界即使不加precondition，也会crash，但是通过precondition，可以获取到自定义的log信息，方便调试。</p>

<p>```objectivec
func fetchPeopleBetweenIndexes(start: Int, end: Int) &ndash;> [Person] {</p>

<pre><code>precondition(start &lt; end)   precondition(start &gt;= 0)    precondition(end &lt;= self.people.count)  return Array(self.people[start..&lt;end]) 
</code></pre>

<p>}
```</p>

<p>5.一般的经验是，在你release时可以跳过，但是希望在debug阶段获取失败信息时使用assertion；而在将会导致数据损坏或者其他严重问题前，使用precondition。同时在你开发一些第三方库时，在容易出现数据输入错误这些位置可以使用precondition来提示开发者。</p>

<!--more-->


<h2>Adding image search</h2>

<p>1.创建App的数据源，使用的就是之前自定义的有序字典，你可能注意到使用了Flickr.photo，Photo是一个定义在Flickr中的类，这样的机制非常有用，在保持类名尽量短的基础上实现了命名空间，在Flickr类中，可以单独使用Photo类。</p>

<p><code>objectivec
var searches = OrderedDictionary&lt;String, [Flickr.Photo]&gt;()
</code></p>

<p>2.然后实现tableView的委托和数据源协议。</p>

<p>```objectivec
func tableView(tableView: UITableView, numberOfRowsInSection section: Int) &ndash;> Int {
  return self.searches.count
}</p>

<p>func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) &ndash;> UITableViewCell {
  let cell = tableView.dequeueReusableCellWithIdentifier(&ldquo;Cell&rdquo;, forIndexPath: indexPath) as UITableViewCell
  let (term, photos) = self.searches[indexPath.row]
  cell.textLabel!.text = &ldquo;(term) ((photos.count))&rdquo;
  return cell
}
```</p>

<p>3.然后是UISearchBarDelegate，这里调用Flickr的search方法是使用了Trailing Closures技术，即如果closure作为一个方法最后一个变量，那么可以写到所调用方法的外面（后面），如下：</p>

<p>```objectivec
func searchBarSearchButtonClicked(searchBar: UISearchBar!) {
  searchBar.resignFirstResponder()
  let searchTerm = searchBar.text
  Flickr.search(searchTerm!) {</p>

<pre><code>switch ($0) {
case .Error:
  break
case .Results(let results):
  self.searches.insert(results, forKey: searchTerm!, atIndex: 0)
  self.tableView.reloadData()
}
</code></pre>

<p>  }
}
```</p>

<p>```objectivec
func someFunctionThatTakesAClosure(closure: () &ndash;> Void) {</p>

<pre><code>// function body goes here
</code></pre>

<p>}
// here&rsquo;s how you call this function without using a trailing closure:
someFunctionThatTakesAClosure({</p>

<pre><code>// closure's body goes here
</code></pre>

<p>})
// here&rsquo;s how you call this function with a trailing closure instead:
someFunctionThatTakesAClosure() {</p>

<pre><code>// trailing closure's body goes here
</code></pre>

<p>}
```</p>

<h3>Show me the photos!</h3>

<p>1.这一节来完成详情页，先是在prepareForSegue方法中设置DetailViewController。</p>

<p>```objectivec
override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
  if segue.identifier == &ldquo;showDetail&rdquo; {</p>

<pre><code>if let indexPath = self.tableView.indexPathForSelectedRow {
  let (_, photos) = self.searches[indexPath.row]
  (segue.destinationViewController as! DetailViewController).photos = photos
}
</code></pre>

<p>  }
}
```</p>

<h3>Deleting searches</h3>

<p>1.为搜索页添加滑动删除功能。</p>

<p><code>objectivec
self.navigationItem.leftBarButtonItem = self.editButtonItem()
</code></p>

<p><code>objectivec
override func setEditing(editing: Bool, animated: Bool)  {
  super.setEditing(editing, animated: animated)
  self.tableView.setEditing(editing, animated: animated)
}
</code></p>

<p><code>objectivec
func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -&gt; Bool {
  return true
}
</code></p>

<p>```objectivec
func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {
  if editingStyle == .Delete {</p>

<pre><code>self.searches.removeAtIndex(indexPath.row)
tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Fade)
</code></pre>

<p>  }
}
```</p>

<!--more-->


<h2>Generic functions and protocols</h2>

<p>1.这一节介绍泛型的函数和协议，之前一直使用的find方法就是一个泛型方法，这是一个全局方法，泛型参数C定义了domain参数，也间接定义了value参数的类型，且返回值也和C有关：</p>

<p><code>objectivec
func find&lt;C: Collection where C.GeneratorType.Element: Equatable&gt; (domain: C, value: C.GeneratorType.Element) -&gt; C.IndexType?
</code></p>

<p>2.我们之前定义的有序字典的insert方法中这么使用了find()，没有指出C，其实这又是type interface的体现，通过第一个参数推断出了C的类型。</p>

<p><code>objectivec
let existingIndex = find(self.array, key)!
</code></p>

<p>3.那么GeneratorType是什么？上述的Collection协议，同时也遵从于SequenceType协议，如下，要实现该协议，必须有个typealias名为Generator，且遵从于GeneratorType协议，同时实现generate()方法返回Generator类型。</p>

<p>```objectivec
protocol SequenceType { typealias Generator : GeneratorType</p>

<pre><code>public func generate() -&gt; Self.Generator}
</code></pre>

<p>```</p>

<p>4.那么在自定义的有序数组上实验下SeqenceType，首先定义typealias名为Generator，使用AnyGenerator这个泛型类。</p>

<p>```objectivec
extension OrderedDictionary: SequenceType {
  typealias Generator = AnyGenerator&lt;(KeyType, ValueType)>
  func generate() &ndash;> AnyGenerator&lt;(KeyType, ValueType)> {</p>

<pre><code>var index = 0
return anyGenerator {
  if index &lt; self.array.count {
    let key = self.array[index++]
    return (key, self.dictionary[key]!)
  } else {
    return nil
  }
}
</code></pre>

<p>  }
}
```</p>

<p>5.而在实现generate()方法中，通过调用了anyGenerator方法，该方法只有一个closure参数，所以使用了Trailing Closures技术，这个closure会在每次调用next()时调用，在closure中，你完成自己的遍历方法。</p>

<p><code>objectivec
public func anyGenerator&lt;Element&gt;(body: () -&gt; Element?) -&gt; AnyGenerator&lt;Element&gt;
</code></p>

<p>6.实现了SequenceType Protocol，你可以使用for-in来遍历字典，其实typealias Generator = AnyGenerator&lt;(KeyType, ValueType)>这句可以删除，因为Swift从func generate() &ndash;> AnyGenerator&lt;(KeyType, ValueType)>()返回值推断出了该类型。<br/>
7.实际上SequenceType Protocol就是一个泛型协议，只不过因为protocol不能使用&lt;>关键字，而像Java和C#是可以的，原因也很简单，Protocols本身就是定义给class或struct实现的，这本身就是带有泛型的性质，Swift的思想就是protocol定义接口，而class和struct定义类型、泛型或其他。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Classes and Structs]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/12/swift-by-tutorials-classes-and-structs/"/>
    <updated>2015-10-12T15:26:48+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/12/swift-by-tutorials-classes-and-structs</id>
    <content type="html"><![CDATA[<p>继上两章对Swift的基本类型的学习，这一章开始介绍Swift中的Class和Struct，Class对所有面向对象的语言都不陌生，而Struct可能用的比较少，因为大部分用于C中，但Swift中的Struct与C还有很多不同，这章会一一介绍，而且同时会讲到Class与Struct之间的不同与使用场景，以及它们的扩展，也是这一章的重点。</p>

<!--more-->


<h2>Getting started</h2>

<h3>The class concept</h3>

<p>1.类是通过总结一些对象的共同特点，定义基本类型，通过继承来创建具体使用的子类型，它拥有自己的数据和方法，可以视为数据的容器。</p>

<h2>My first class</h2>

<p>1.介绍示例项目的Class设计。</p>

<h3>Creating the class</h3>

<p>1.import语句用于导入Swift的库文件，记性好的话，之前Apple在OC中加入了@import来替代#import（如：@import Foundation;替代#import &lt;Foundation/Foundation.h>），其实Swift中的import是和这个一致的。<br/>
2.定义一个类如下即可，但是如果如下，有未初始化赋值的非optional变量，那么会提示你增加初始化方法。</p>

<p>```objectivec
class Treasure {</p>

<pre><code>let what: String
let latitude: Double
let longitude:Double
</code></pre>

<p>}
init(what: String, latitude: Double, longitude: Double) {</p>

<pre><code>self.what = waht
self.latitude = latitude
self.longitude = longitude
</code></pre>

<p>}
```</p>

<h3>A struct-ural improvement</h3>

<p>1.下一步的优化是把经纬度信息做成一个结构体，那么就涉及到了Swift中的Struct，Swift中Struct和Class一样，都可以存储数据和拥有自己的方法，但要记住Struct始终是一个数值型的容器，它的用途只是持有数据，不要让它承担更多的功能。</p>

<p>```objectivec
struct GeoLocation {</p>

<pre><code>var latitude: Double
var longitude: Double
</code></pre>

<p>}
```</p>

<p>2.在Swift中，在工程中的文件是相互自动import的，所以你不用再去手动导入，这一点在你开发library和framework也是一样的。</p>

<h3>Reference types vs. value types</h3>

<p>1.Swift中，Struct与Class的最大区别是，Class在本质上是指针引用类型，而Struct是值类型，在赋值过程中，Class传递的是指针，而Struct则会copy一份新值，从如下的例子即可看出。</p>

<p>```objectivec
struct MyStruct {</p>

<pre><code>var foo: Double = 0.0
</code></pre>

<p>}
class MyClass {</p>

<pre><code>var foo: Double = 0.0
</code></pre>

<p>}
var structA = MyStruct()
var structB = structA
structB.foo = 1.0
print(structA.foo)
//0.0
print(structB.foo)
//1.0
var classA = MyClass()
var classB = classA
classB.foo = 1.0
print(classA.foo)
//1.0
print(classB.foo)
//0.0
```</p>

<p>2.需要说明的一点，Swift在copy一个Struct时是很智能的，只会在确定必要的时候copy，也就是说structB = structA并不会创建出拷贝，只有你开始改变其中一个值时，runtime会开始执行copy。<br/>
3.另外关于let类型的Struct和Class还有一些细微的区别，对于二者的var实例，是没有区别的，都可以改变各自的属性或将自身赋值给其他实例，但对于let实例，Class依然可以修改自己的属性变量，但是不能将自己赋值给其他实例，而Struct既不能改变自己的属性变量，也不能将自己赋值给其他实例，这也是为什么Array和Dictionary是Struct而不是Class。</p>

<p>```objectivec
struct MyStruct {</p>

<pre><code>var foo: Double = 0.0
</code></pre>

<p>}
class MyClass {</p>

<pre><code>var foo: Double = 0.0
</code></pre>

<p>}
var classA = MyClass()
let classB = MyClass()
classA.foo = 1.0
classB.foo = 1.0
classB = classA
//error
var structA = MyStruct()
let structB = MyStruct()
structA.foo = 1.0
structB.foo = 1.0
//error
structB = structA
//error
```</p>

<h3>Convenience initializers</h3>

<p>1.在实例中其实还是不必要将GeoLocation暴露给使用者，可以直接给出更方便的初始化方法，这就用到了convenience initializer，在该初始化方法中跳转到了原初始化方法中，也称为designated initializer。</p>

<p>```objectivec
convenience init(what: String, latitude: Double, longitude: Double) {</p>

<pre><code>let location = GeoLocation(latitude: latitude, longitude: longitude)
self.init(what: what, location: location)
</code></pre>

<p>}
```</p>

<p>2.Struct不需要显式的初始化方法，Swift为你自动添加了，你只需要按Struct的属性顺序一一初始化就行了，这也是为什么上述方法中可以自动初始化GeoLocation。</p>

<h3>Class inheritance</h3>

<p>1.Swift中的继承是怎样的？如下例：</p>

<p>```objectivec
class HistoryTreasure: Treasure {</p>

<pre><code>let yaer: Int
init(what: String, year: Int, latitude: Double, longitude: Double) {
    self.year = year
    let location = GeoLocation(latitude: latitude, longitude: longitude)
    super.init(what: what, location: location)
}
</code></pre>

<p>}
```</p>

<p>2.子类如果有自己新的属性时，需要自己的designated initializer，而子类的designated initializer必须引用父类的一个designated initializer（注意不可以是convenience initializer），所以和上一节比较相当于做了重复工作。<br/>
3.这里有与OC不同的一点，在OC中子类的init()方法中，是先调用父类的init()，再进行子类属性的赋值，而在Swift中是最后调用父类的init()，因为在Swift中是initializer来初始化所有属性，最后交给父类来处理，父类的init()要放在最后，是因为它不知道子类中声明的新属性，必须在它之前把这些新属性初始化。</p>

<!--more-->


<h2>Swift and MapKit</h2>

<p>1.重写父类方法，Swift中需要在方法前加上override关键字，增加了可读性，同时如果你写的方法不存在于父类，那么编译器会报error通知你。</p>

<p>```objectivec
override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()
</code></pre>

<p>}
```</p>

<h3>Class extensions and computed properties</h3>

<p>1.示例中需要将Treasure类型的变量显示在MKMapView上，那么就要使Treasure遵循MKAnnotation协议，我们使用了extension来实现：</p>

<p>```objectivec
import MapKit
extension Treasure: MKAnnotation {</p>

<pre><code>var coordinate: CLLocationCoordinate2D {
    return self.location.coordinate
}
var title: String {
    return self.what
}
</code></pre>

<p>}
```</p>

<p>2.extension类似OC的category，都是扩展类的技术，但是优于category，因为extension不但可以添加方法，还可以添加新属性。<br/>
3.这里添加的两个property有些特别，它们是Swift中的computed properties，每次访问它们都会执行后面的方法，用法与普通的properties是一致的。</p>

<h3>Your first struct extension</h3>

<p>1.Struct也可以添加extension，下例中的extension起到了分割代码，增加可读性的作用，这是extension的习惯用法。</p>

<p>```objectivec
import MapKit
extension GeoLocation {</p>

<pre><code>var coordinate: CLLocationCoordinate2D {
    return CLLocationCoordinate2DMake(self.latitude, self.longitude)
}
var mapPoint: MKMapPoint {
    return MKMapPointForCoordinate(self.coordinate)
}
</code></pre>

<p>}
```</p>

<h3>Inheriting from NSObject</h3>

<p>1.类遵循MKAnnotation同时，也应该遵循NSObject协议，因为MKAnnotation继承自NSObject协议。</p>

<h3>Pinning the map</h3>

<p>1.在viewDidLoad()中添加以下代码，完成mapView上打点的工作。</p>

<p><code>objectivec
self.mapView.delegate = self
self.mapView.addAnnotations(self.treasures)
</code></p>

<p>2.然后添加viewController的extension，并实现MKMapViewDelegate的方法：</p>

<p>```objectivec
extension ViewController: MKMapViewDelegate {</p>

<pre><code>func mapView(mapView: MKMapView, viewForAnnotation annotation: MKAnnotation) -&gt; MKAnnotationView
{
    if let treasure = annotation as? Treasure {
        var view = mapView.dequeueReusableAnnotationViewWithIdentifier("pin") as! MKPinAnnotationView!
        if view = nil {
            view = MKPinAnnotationView(annotation: annotation, reuseIdentifier: "pin")
            view.canShowCallout = true
            view.animatesDrop = false
            view.calloutOffset = CGPoint(x: -5, y: 5)
            view.rightCalloutAccessoryView = UIButton(type: .DetailDisclosure) as UIView
        } else {
            view.annotation = annotation
        }
        return view
    }
    return nil
}
</code></pre>

<p>}
```</p>

<p>3.在实现的mapView:viewForAnnotation方法中，annotation参数类型为MKAnnotation!，是一个隐式拆解的optional类型，但是我们还是进行了if/let的检查，因为这个方法是OC的API，是没有optional的，所以为了兼容Swift只能声明为这个类型，所以还需要显式拆解。<br/>
4.同时除了检查是否为nil，我们还要注意传入的类型是否为Treasure类型，这儿用到了inline downcasting技术，也是Swift的一种简写语法，if let treasure = annotation as？ Treasure{}，如果annotation不是Treasure类型，那么也不会进入if，这是Swift中确保类型正确的一种技术。<br/>
5.获取MKPinAnnotationView利用了一贯的复用技术，另外此处又一次用到了downcast技术，只不过因为返回的类型肯定可以确定都是MKPinAnnotationView，所以用了非optional版本。</p>

<h3>The reduce algorithm</h3>

<p>1.这一节是为了解决app载入后不能直接定位到目标位置，而要先定位自己的位置这个bug。</p>

<p><code>objectivec
let rectToDisplay = self.treasures.reduce(MKMapRectNull) {
  (mapRect: MKMapRect, treasure: Treasure) -&gt; MKMapRect in
  let treasurePointRect = MKMapRect(origin: treasure.location.mapPoint, size: MKMapSize(width: 0, height: 0))
  return MKMapRectUnion(mapRect, treasurePointRect)
}
self.mapView.setVisibleMapRect(rectToDisplay, edgePadding: UIEdgeInsetsMake(74, 10, 10, 10), animated: false)
</code></p>

<p>2.为了达到这一优化，实际就是要获取可以展示全部treasures的最小地图范围，然后在地图绘制这一区域。而输入是一个数组，需要一个它们逐个计算的结果，这里使用了函数式编程中的Reduce函数，这是处理这一问题的最佳方案，下面是Swift中reduce的原型，需要一个初始值initial，这里对应的是MKMapRectNull，是一个空区域，然后combine的方法是(mapRect: MKMapRect, treasure: Treasure) &ndash;> MKMapRect类型的方法，mapRect是每次执行后的返回值，初始值就是initial，而treasure是array每个元素的遍历，最后可以得到一个MKMapRect类型的区域，包含了所有元素的最小区域，然后setVisibleMapRect()，并加了边距来适应其他页面元素，最终达到了目的，Swift中的函数式编程还会在第七章继续讲解。</p>

<p><code>objectivec
reduce(initial: U, combine: (U, T) -&gt; U) -&gt; U
</code></p>

<!--more-->


<h2>Polymorphism</h2>

<p>1.现在又有新需求了，需要不同类型的Treasure在地图上显示Annotation颜色不同，这可以通过多态来实现，首先在父类中添加方法，再在子类中重写该方法：</p>

<p><code>objectivec
//in parent class
func pinColor() -&gt; MKPinAnnotationColor  {
  return MKPinAnnotationColor.Red
}
//in subclass
override func pinColor() -&gt; MKPinAnnotationColor  {
  return MKPinAnnotationColor.Purple
}
</code></p>

<p>2.然后在绘制MKPinAnnotationView那儿调用该方法：</p>

<p><code>objectivec
view.pinColor = treasure.pinColor()
</code></p>

<h3>Dynamic dispatch and final classes</h3>

<p>1.对于上面的Treasure多态，runtime是怎么执行的呢？是靠dynamic dispatch实现的，这一技术其实在OC里用的很普遍，OC作为动态语言，可以在runtime修改所传递的消息，甚至消息的接收者，都是靠动态分发(详细过程可参照前一部的Effective Objective-C2.0的笔记)。<br/>
2.Dynamic dispatch在Swift中依然存在，就是为了实现多态这类特性，不同于OC的消息分发机制，Swift的分发更像C++，它通过virtual tables(简称vtables)来实现。<br/>
3.如上例，当编译器遇到pinColor()调用，因为Treasure有很多子类，它便会去使用vtable去查找，而如果是Treasure的子类调用pinColor()，编译器依然会去先去查找vtable，而不是直接去调用pinColor()方法，因为它并不知道有没有类继续在继承，虽然开发者知道它是没有子类的。<br/>
4.所以通过告知编译器某些类没有子类，会提高app的效率，缩短运行时间，我们可以通过在类型前加final关键字来告知编译器这一信息。</p>

<p><code>objectivec
final class HistoryTreasure: Treasure
</code></p>

<!--more-->


<h2>Adding annotations</h2>

<p>1.继续，新的需求是用户点击每个annotation时弹出一个alertView来告知用户一些信息。因为每个alert提示的信息不同，所以打算将生成alert的任务交给treasure，然后viewController负责显示，采用的是利用protocol技术。<br/>
2.首先在Treasure.swift文件中声明Alertable协议，然后Treasure的子类分别遵循并实现其中的方法。</p>

<p>```objectivec
@objc protocol Alertable {</p>

<pre><code>fun alert() -&gt; UIAlertController
</code></pre>

<p>}
```</p>

<p>```objectivec
extension HistoryTreasure: Alertable {<br/>
  func alert() &ndash;> UIAlertController {</p>

<pre><code>let alert = UIAlertController(title: "History", message: "From \(self.year):\n\(self.what)", preferredStyle: UIAlertControllerStyle.Alert)
return alert
</code></pre>

<p>  }
}
```</p>

<p>3.然后在viewController中实现MapView点击Annotation的委托方法。</p>

<p>```objectivec
func mapView(mapView: MKMapView, annotationView view: MKAnnotationView, calloutAccessoryControlTapped control: UIControl) {
  if let treasure = view.annotation as? Treasure {</p>

<pre><code>if let alertable = treasure as? Alertable {
  let alert = alertable.alert()
  alert.addAction(UIAlertAction(title: "OK", style: UIAlertActionStyle.Default, handler: nil))
  self.presentViewController(alert, animated: true, completion: nil)
}
</code></pre>

<p>  }
}
```</p>

<!--more-->


<h2>Sorting an array</h2>

<p>1.新需求，用户可以在找到第一个treasure后能有选项可以使其找到下一个最近的treasure。首先我们给GeoLocation添加一个计算点之间的方法。</p>

<p><code>objectivec
func distanceBetween(other: GeoLocation) -&gt; Double {
  let locationA = CLLocation(latitude: self.latitude, longitude: self.longitude)
  let locationB = CLLocation(latitude: other.latitude, longitude: other.longitude)
  return locationA.distanceFromLocation(locationB)
}
</code></p>

<p>2.该方法是直接定义在struct的定义中的，Swift中的Struct可以定义方法，这也是它与C的Struct的最大区别，C中的Struct只能定义变量，导致与之相关的方法只能定义为全局方法，而如何按照类型归纳这些方法就需要开发者手工将其写到一个头文件中，这显然费时也不合理，而Swift真正实现了Struct中可以真正拥有自己的方法。<br/>
3.像用户点击Annotation后弹出的alert再添加一个Find Nearest的选项，并实现找到离该点最近的Treasure。</p>

<p>```objectivec
alert.addAction(UIAlertAction(title: &ldquo;Find Nearest&rdquo;, style: UIAlertActionStyle.Default) { action in
  var sortedTreasures = self.treasures
  sortedTreasures.sortInPlace {</p>

<pre><code>let distanceA = treasure.location.distanceBetween($0.location)
let distanceB = treasure.location.distanceBetween($1.location)
return distanceA &lt; distanceB
</code></pre>

<p>  }
  mapView.deselectAnnotation(treasure, animated: true)
  mapView.selectAnnotation(sortedTreasures[1], animated: true)
  })
```</p>

<p>4.上述代码的核心是sortedTreasures的排序，利用了sort()方法(Swift中改为sortInPlace())，$1和$2分别代表了传入方法的第一和第二参数，是简写形式，分别计算出两点距离当前treasure的距离，然后返回Bool告知是否已按照小大顺序排好，最后数组排序后，展示第二个元素，来展示最近的treasure。</p>

<p><code>objectivec
public mutating func sortInPlace(@noescape isOrderedBefore: (Self.Generator.Element, Self.Generator.Element) -&gt; Bool)
</code></p>

<!--more-->


<h2>Equality and operator overload</h2>

<p>1.照例，新需求，需要标记用户发现treasure的路径并在用户在已发现的treasure上操作时提示用户。<br/>
2.创建已找到Treasure的数组和要绘制的地图线，并实现MKMapViewDelegate的一个方法。</p>

<p><code>objectivec
private var foundLocations: [GeoLocation] = []
private var polyline: MKPolyline!
</code></p>

<p>```objectivec
func mapView(mapView: MKMapView, rendererForOverlay overlay: MKOverlay) &ndash;> MKOverlayRenderer {
  if let polylineOverlay = overlay as? MKPolyline {</p>

<pre><code>let renderer = MKPolylineRenderer(polyline: polylineOverlay)
renderer.strokeColor = UIColor.blueColor()
return renderer
</code></pre>

<p>  }
  return nil
}
```</p>

<p>3.在上一节添加alert的位置再添加Found项，再创建markTreasureAsFound()方法来标记已找到的Treasure，并绘制新的MKPolyline。</p>

<p><code>objectivec
alert.addAction(UIAlertAction(title: "Found", style: UIAlertActionStyle.Default) { action in
  self.markTreasureAsFound(treasure)
  })
</code></p>

<p>```objectivec
private func markTreasureAsFound(treasure: Treasure) {
  if let index = self.foundLocations.indexOf(treasure.location) {</p>

<pre><code>let alert = UIAlertController(title: "Oops!", message: "You've already found this treasure (at step \(index + 1))! Try again!", preferredStyle: .Alert)
alert.addAction(UIAlertAction(title: "OK", style: .Default, handler: nil))
self.presentViewController(alert, animated: true, completion: nil)
</code></pre>

<p>  } else {</p>

<pre><code>self.foundLocations.append(treasure.location)
if self.polyline != nil {
  self.mapView.removeOverlay(self.polyline)
}
var coordinates = self.foundLocations.map { $0.coordinate }
self.polyline = MKPolyline(coordinates: &amp;coordinates, count: coordinates.count)
self.mapView.addOverlay(self.polyline)
</code></pre>

<p>  }
}
```</p>

<p>4.首先利用find()函数（Swift2.0已弃用，改为collection的indexOf()方法）来获取目前位置是否已在foundLocations中，返回值为optional类型，所以需要if/let判断，这里就体现了这一技术的便利。<br/>
5.在创建MKPolyline时，先对foundLocations使用了map方法，map如前面提到的reduce一样，也是函数式编程的一种，它的作用是从一个数组中获取另外一个数组，这里就是从foundLocations得到了由其中每一个location的coordinate组成的新数组，$0代表每一个location。<br/>
6.这里需要实现find()方法（实际在Swift2.0已弃用），需要在GeoLocation中遵循Equatable协议，，因为find()中比较每个元素是通过==来比较的（类似OC中的isEqual()），而Class和Struc默认是不能用==比较的。这里用到了Swift的又一新特性，operator overload，既可以直接重写==这样的操作符，但需要注意下面对==的重写，并没有包含在extension中，因为operation overload都必须在定义在全局中，因为它本身并不属于某个类，它只是与一个类有关，基于要比较的的两个参数是这个类的实例。</p>

<p><code>objectivec
protocol Equatable {    func ==(lhs: Self, rhs: Self) -&gt; Bool}
</code></p>

<p><code>objectivec
extension GeoLocation: Equatable {
}
func ==(lhs: GeoLocation, rhs: GeoLocation) -&gt; Bool {
  return lhs.latitude == rhs.latitude &amp;&amp; lhs.longitude == rhs.longitude
}
</code></p>

<!--more-->


<h2>Access Control</h2>

<p>1.目前为止所有变量和方法都是public的，但Swift提供了访问权限的关键字，包括：Public(所有代码均可访问)、Internal(只在该target(library或app)下的代码可以访问，是默认权限)、Private(只有该文件可以访问)。<br/>
2.例如有一些类中的帮助方法，你不希望暴露在外，因为他们可以改变着一些不该暴露的内部状态信息。<br/>
3.需要注意的是Unit test通常是另外一个Target，如果你的代码有部分需要单元测试，那么需要声明为public。<br/>
4.与OC相比，OC是没有绝对的私有方法的，因为即使没有暴露在在头文件中，也可以通过runtime注入来访问私有方法。</p>

<p><code>objectivec
private func markTreasureAsFound(treasure: Treasure)
</code></p>

<p><code>objectivec
private var treasures: [Treasure] = []private var foundLocations: [GeoLocation] = [] private var polyline: MKPolyline!
</code></p>

<p>5.internal一般是不会显式声明的，如果是一个library被多个app使用，你可能会将内部类声明为internal，这样就不会被其他app中的代码使用了。<br/>
6.访问控制标志是表达你代码意图的很好的方式，可以使代码更易维护，也会减少Bug，</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Language Basics II]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/10/swift-by-tutorials-language-basics-ii/"/>
    <updated>2015-10-10T14:41:12+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/10/swift-by-tutorials-language-basics-ii</id>
    <content type="html"><![CDATA[<p>继上一篇后，本章将继续介绍Swift的基础知识，但是相比第一章会有所提升，包括了Optional类型对象的用法、Swift中的Collection类型用法以及与OC的Collection的不同之处。</p>

<!--more-->


<h2>Optionals</h2>

<p>1.空指针是一个困扰着各类语言的常见问题，在Java中，调用了空指针会直接抛出异常，在OC中向nil指针发送消息会返回nil，也就是说空指针是安全的，但有很多时候你并不希望指针为空，一般会加判断对象是否为nil的断言判断，但在Swift中，针对这个问题，有了新的解决方案。<br/>
2.Swift在对没有初始化赋值的变量使用时，会直接报错，而且像String类型也不能初始化直接赋nil值，这也保证了空指针不会出现。但是如果我们真的需要一个空值的变量怎么办呢？可以使用optional机制，它是用来指明一个变量是可能有值的，相当于给变量一个nil的默认值，这也是空指针的问题所在，它是一个合法的指针，但没有指向一个合法的对象。</p>

<h3>Declaring optionals</h3>

<p>1.使用optional很简单，如下，不赋值的话str默认为nil，在这里你可以把String?理解为一个不同于String的类型，所以能给String?直接赋值String类型实际上是Swift在内部进行了封装，Swift将String的值封装到了一个String?类型的实例中，然后再赋值给了str。</p>

<p><code>objectivec
//no assignment
var str: String?
//an assignment
var str: String? = "Swift by Tutorials!"
</code></p>

<p>2.如果你现在对str使用uppercaseString方法，会报错，这也验证了上面所说String?已是另一个类型的说法，那么如何让str使用String的方法呢？如下即可，通过if语句对str进行解封，并将其赋值给一个let型的String，这就是optional和if在Swift中的经典配合，这么做的好处就是让开发者可以在必选确认指针不为空的时候强制去进行空指针的检查。</p>

<p>```objectivec
if let unwrappedStr = str {</p>

<pre><code>print("Unwrapped! \(unwrappedStr.uppercaseString)")
</code></pre>

<p>} else {</p>

<pre><code>print("Was nil")
</code></pre>

<p>}
```</p>

<h3>Forced unwrapping</h3>

<p>1.在你了解optional机制下，在一些optional中你确定有值的时候，你可以使用强制解封，如下：</p>

<p><code>objectivec
var str: String? = "Swift by Tutorials!"
print("Force unwrapped! \(str!.uppercaseString)")
</code></p>

<p>2.但是需要注意的是，如果optional类型中的是nil值，那么会出现runtime error，所以使用强制解封，<strong>一定要在你100%确定你的optional对象不是空值</strong>。</p>

<h3>Implicit unwrapping</h3>

<p>1.你也可以不用!或者let来进行optional解封，使用以下方法，可以直接对变量使用方法，这看起来和没使用optional差不多，但是它在实质上和上述两种解封方法是一致的，只是语法不通而已，如果不去初始化赋值，那么你会得到和强制解封一个nil的optional的值一样的error。</p>

<p><code>objectivec
var str: String! = "Swift by Tutorials!"
str = str.lowercaseString
print(str)
</code></p>

<p>2.你也可以通过if来检查隐式解封的optional值，但你会发现这和OC中的做法一样，只不过在OC中你拿nil作为一个false的判断条件，而在Swift中你将nil作为一个无值的状态来判断。</p>

<p>```objectivec
if str != nil {</p>

<pre><code>str = str.lowercaseString
print(str)
</code></pre>

<p>}
```</p>

<p>3.<strong>最后注意，你要将隐式解封和强制解封一样重视，因为除了声明的地方，它和普通变量是一样的，这很容易忽视。</strong></p>

<h3>Optional chaining</h3>

<p>1.最后要介绍的是Optional chaining，这是上述三个解封方式之外的另一种optional来执行方法的方式，它的设计参照了OC中常用的delegate模式，即在optional类型变量执行方法时会先判断它是否为nil，不是nil的话直接执行，而如果是nil的话，则直接返回nil，其实和OC中对nil发送消息的处理是一样的。</p>

<p><code>objectivec
var maybeString: String? = "Swift by Tutorials!"
let uppercase = maybeString?.uppercaseString
</code></p>

<p>2.由于在对象声明和方法执行时两次使用optional，所以形成了Optional chaining。</p>

<!--more-->


<h2>Collection</h2>

<p>1.任何语言都会有集合类型，OC中有NSArray、NSDictionary、NSSet，其中包含可变和不可变类型，而在Swift中只保留了Array和Dictionary两种类型。</p>

<h3>Arrays</h3>

<p>1.Swift的Array有着其他语言中共同的特性，如下：</p>

<p><code>objectivec
//initialize array
var array = [1, 2, 3, 4, 5]
print(array[2])
//add an element
array.append(6)
print(array)
</code></p>

<p>2.Swift中你可以通过添加一个序列来扩展一个Array，比如上一节提到的Range。</p>

<p><code>objectivec
//add 7,8,9,10
//Swift2.0中将extend()改为了appendContentsOf()
//array.extend(7...10)
array.appendContentsOf(7...10)
</code></p>

<p>3.在上述数组中试图添加一个String，会直接报错，这在OC中可能是很正常的需求，可以在一个数组中添加不同类型的对象，但在Swift中只能在一个数组中添加同一类型的对象，在上面的Array初始化中是使用了type interface，如果制定类型声明的话应该是<em>var array: Array<Int> = [1, 2, 3, 4, 5]</em>（会在第四章详细说明），不过更常见的写法是<em>var arrray: [Int] = [1, 2, 3, 4, 5]</em>，这是Apple的语法糖，用来简化语法。</p>

<p><code>objectivec
//Array Initializer
var array: Array&lt;Int&gt; = [1, 2, 3, 4, 5]
var arrray: [Int] = [1, 2, 3, 4, 5]
</code></p>

<p>4.当然也可以让Array像NSArray那样工作，可以将类型声明为Array<Any>，但是仍然不推荐这么做，因为这样Swift的很多Array方法会因为类型不一而不能使用，而且也会失去Swift的提供的安全性保护。</p>

<p><code>objectivec
//add multiple type instance
var array: Array&lt;Any&gt; = []
array.append(6)
array.append("Swift By Tutorials!")
</code></p>

<h3>Dictionaries</h3>

<p>1.Swift的Dictionary与OC的NSDicionary大致相同，只是语法上略有变化，但需要注意的是，Dictionary也存在只能添加固定类型的键值对的情况，与上述的Array相同。</p>

<p><code>objectivec
var dictionary = [1: "Dog", 2: "Cat"]
//Another Initializer
//var dictionary: Dictionary&lt;Int:String&gt; = [1: "Dog", 2: "Cat"]
//var dictionary: [Int:String] = [1: "Dog", 2: "Cat"]
print(dictionary[1])
dictionary[3] = "Mouse"
print(dictionary)
dictionary[3] = nil
print(dictionary)
</code></p>

<p>2.从Dictionary中通过key直接获取值时，该值是optional类型的，因为有可能是不存在该key对应的值的，所以推荐读取Dictionary时还是使用上一章中介绍的安全拆解的方法，这又是Swift强制开发者随时考虑安全问题的一个表现。</p>

<p>```objectivec
if let value = dictionary[1] {</p>

<pre><code>print("Value is \(value)")
</code></pre>

<p>}
```</p>

<h3>Reference and copies</h3>

<p>1.这一节讨论Dictionary和Array在Swift中与OC所不同的内存管理策略，如下，从结果发现，Swift中将一个Dictionary直接赋值给另外的变量或常量，都是执行copy操作的，即改变新变量，并不会影响原来的Dictionary。</p>

<p><code>objectivec
var dictionaryA = [1: 1, 2: 4, 3: 9, 4: 16]
var dictionaryB = dictionaryA
print(dictionaryA)
print(dictionaryB)
dictionaryB[4] = nil
print(dictionaryA)
print(dictionaryB)
</code></p>

<p>2.那么关于Array呢？答案是一样的，Array也是会执行copy操作，这与OC中的NSDictionary和NSArray的指针赋值是完全不同的，所以单独强调一下。</p>

<p><code>objectivec
var arrayA = [1, 2, 3, 4, 5]
var arrayB = arrayA
print(arrayA)
print(arrayB)
arrayB.removeAtIndex(0)
print(arrayA)
print(arrayB)
</code></p>

<h3>Constant collection</h3>

<p>1.上面都是定义的var类型的Dictionary和Array，那么如果定义为let的话，Dictionary和Array是不能进行任何修改操作的（其实就是OC中的不可变类型）。</p>

<p><code>objectivec
let constantArray = [1, 2, 3, 4, 5]
//error
constantArray.append(6)
constantArray.removeAtIndex(0)
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift by Tutorials--Language Basics I]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/10/08/swift-by-tutorials-language-basics-i/"/>
    <updated>2015-10-08T14:26:37+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/10/08/swift-by-tutorials-language-basics-i</id>
    <content type="html"><![CDATA[<p>Swift更新到2.0了，是时候来一波Swift的集中学习了，这次用的教材是raywenderlich出版的Swift by Tutorials，我手里的版本是2014年12月份的，可能有些在Swift2.0中发生了变化，我会尽量标注出来。开始第一章，介绍一些Swift的基本语法。</p>

<!--more-->


<h2>Variables,constants and strings</h2>

<p>1.Playground是Xcode新加入的一种文件，实际上就是一个可以自动编译的swift文件，可以用来测试一些简单的代码，也能显示一些资源文件，下面是申明一个string类型，可以直接在playground运行。</p>

<p><code>objectivec
var greeting: String = "Hello"
//也可以不指名类型
//var greeting = "Hello"
//如对greeting赋值int型，会报错
//greeting = 9
print(greeting)
</code></p>

<p>2.string可以不声明类型，即可运行，是源于Swift的type interface的特性，即通过赋值自动确定变量的类型，但是之后再对其赋值整形，则会报错。因为Swift是静态输入语言，编译期间会进行类型检查。<strong>type interface是推荐使用的，可以使代码简洁，增加可读性</strong>。<br/>
3.Swift的string类型是可变的，而且改变方式不像NSMutableString那么复杂，直接使用+=方式即可。</p>

<p><code>objectivec
var greeting = "Hello"
greeting += "World"
print(greeting)
</code></p>

<p>4.如果想声明不可变String，只需添加let关键字即可。在Swift中，控制内建类型的可变性是通过添加let或var关键字来实现的，这不同于OC，需要两种类型来实现。<strong>你应该尽量使用不可变类型，这不仅使你的程序更加健壮，也会使编译器做更多优化，实际上let使用的场景是远远多于var的</strong>。</p>

<p><code>objectivec
let greeting = "Hello"
</code></p>

<p>5.let关键字不仅限于Swift内建类型，自定义的结构体和类也可以使用，但有些细微不同，这将在第三章中详细讲到。<br/>
6.改变string也可以利用append()方法，这是Swift String自带的一些API，但是数量不多。幸运的是，Swift String与OC的NSString是可转换的，NSString的全部方法，String也可全部使用，但是还是推荐尽量使用String自带的API，比较简洁。</p>

<p>```objectivec
//Swift String API
greeting.append(Character(&ldquo;!&rdquo;))
//bridge to NSString
//logout Hello World
import Foundation</p>

<p>var greeting = &ldquo;hello world&rdquo;.capitalizedString
print(greeting)
//NSString style append
import Foundation</p>

<p>var greeting = &ldquo;hello&rdquo;.stringByAppendingString(&ldquo; world&rdquo;)
print(greeting)
```</p>

<p>7.Swift String是一个值类型，当它被赋值给变量、常量、或者作为参数传入方法时，它的值是被copy的，如下例，改变alternateGreeting不会影响greeting的值。</p>

<p><code>objectivec
var alternateGreeting = greeting
alternateGreeting += " and beyond!"
print(alternateGreeting)
print(greeting)
</code></p>

<!--more-->


<h2>Semicolons(分号)</h2>

<ol>
<li>Swift中分号只有在同一行中添加多条代码时才强制使用，其他情况可以省略不写，<strong>这又是Swift代码简洁的一大表现</strong>。</li>
</ol>


<!--more-->


<h2>Numeric types and conversion</h2>

<p>1.这一节主要讲Swift的数值类型，下面创建了两个变量，Int类型的radius和Double类型的pi，Swift还有很多其他类型，如Int8、UInt16、Float等。除非你有特殊需求，那么Int和Double类型是你的首选，这两个类型有广泛的使用，而且编译器会自动选择Int的最佳长度，32或64，基于机器的字长，来生成最高效的代码。</p>

<p><code>objectivec
var radius = 4
let pi = 3.14159
</code></p>

<p>2.在Swift中，你可以使用<strong>_</strong>来作为千分号，如下。</p>

<p><code>objectivec
let milion = 1_000_000
</code></p>

<p>3.以下代码会报错，是因为*无法直接将Int和Double相乘，而Swift中也不会隐式转化，需要开发者显式转化，需要注意这里并不是类型转化，而是新生成了一个Double类型，在第三章中会详细讲解初始化方法。</p>

<p><code>objectivec
//error
var area = radius * radius * pi
//soluation
var area = Double(radius) * Double(radius) * pi
</code></p>

<p>4.显式转化变量是Swift的安全策略之一，另外一个是越界检查，下列代码在其他语言中可能会生成一个负数，而在Swift中会直接将其视为一个runtime error。同时，为了避免integer的越界计算error，Apple提供了&amp;+、&amp;-、&amp;*、&amp;/、&amp;%这些越界运算符，使用后会像常规计算一样，生成负数。</p>

<p><code>objectivec
var overflow = Int.max + 1
//overflow operators
var overflow = Int.max &amp;+ 1
</code></p>

<!--more-->


<h2>Booleans</h2>

<p>1.Swift的布尔类型为Bool，值为true或false，需要说明的一点是，作为Swift的安全特性之一，控制流中需要进行布尔判断的只能使用Bool类型，而不同于在OC中，可以将任意非零值作为判断条件，例如你不能在Swift中使用一个整数当做判断条件。</p>

<p><code>objectivec
let alwaysTrue = true
</code></p>

<!--more-->


<h2>Tuples(元组)</h2>

<p>1.元组用来将多个值组成一个类型，但是不像类和结构体，你不需要显式的定义这个类型，如下，你可以通过索引来访问每个值，也可以通过索引来改变每个值（前提是你得元组的是可变的），而越界访问，编译器会报error。</p>

<p><code>objectivec
var address = (742, "Evergreen Terrace")
print(address.0)
print(address.1)
address.0 = 744
</code></p>

<p>2.你也可以声明元组的类型，如下。如果想将元组的Int值类型改为Double有三种方式，同如下：</p>

<p><code>objectivec
var address: (Int, String) = (742, "Evergreen Terrace")
//change Int to Double
//1)using a type annotation
var address1: (Double, String) = (742, "Evergreen Terrace")
//2)by explicit creation of a Double
var address2 = (Double(742), "Evergreen Terrace")
//3)by using a double literal value
var address3 = (742.0, "Evergreen Terrace")
</code></p>

<p>3.你也可以把元组解析成单个元素，而这也是一个copy操作，改变新值不会影响原始的元组值，如下：</p>

<p><code>objectivec
var address = (742, "Evergreen Terrace")
let (house, street) = address
print(house)
print(street)
</code></p>

<p>4.此外，你可以为元组的每个值加一个key，提高可读性，同时上述的访问方法依然有效。</p>

<p><code>objectivec
var address = (number: 742, street: "Evergreen Terrace")
print(address.number)
print(address.street)
</code></p>

<p>5.元组只是一个类型，也可以进行嵌套，元组作为其他元组的一个元素，类和结构体虽然包含了元组的所有功能，但是在一些轻量的场景下，元组可以更加快速简单地去构建一个复合类型。</p>

<!--more-->


<h2>String interpolation</h2>

<p>1.打印出一个类的信息，是常见的需求，例如OC中NSObject的description方法，如果我们想打印出上一节中元组的信息，我们可能这么做：</p>

<p><code>objectivec
var address = (742, "Evergreen Terrace")
let (house, street) = address
print("I live at " + String(house) + ", " + street)
</code></p>

<p>2.这利用了Swift的+拼接字符串的技术，不过在Swift中有更加方便的字符串拼接技术来处理这一场景，string interpolation，如下：</p>

<p><code>objectivec
var address = (742, "Evergreen Terrace")
let (house, street) = address
print("I live at \(house), \(street)")
</code></p>

<p>3.当然这不是打印日志专用的，在你需要从一系列变量中构建String时，都可使用。</p>

<p>```objectivec
import Foundation</p>

<p>var address = (742, &ldquo;Evergreen Terrace&rdquo;)
let (house, street) = address
let str = &ldquo;I live at (house+10), (street.uppercaseString)&rdquo;
```</p>

<p>4.最后，如果想只打印出\时，请用\\转义。</p>

<!--more-->


<h2>Control flow</h2>

<h3>For loops</h3>

<p>1.首先要介绍的Swift中的for循环的新特性是closed range operator，即闭区间运算符，例子如下：</p>

<p>```objectivec
let greeting = &ldquo;Swift by Tutorials!&rdquo;
for i in 1&hellip;5 {</p>

<pre><code>print("\(i) - \(greeting)")
</code></pre>

<p>}
```</p>

<p>2.注意，其中的i并不是一个var类型的变量，而是每次循环创建一个let的常量，是不可被赋值的。<br/>
3.1&hellip;5是一个Range类型，与for循环并无关系，下例说明了这一问题：</p>

<p>```objectivec
var range = 1&hellip;5
for i in range {</p>

<pre><code>print("\(i) - \(greeting)")
</code></pre>

<p>}
//what&rsquo;s 1..5?
var range = Range(start: 1, end: 6)
```</p>

<p>4.x&hellip;y只是Range类型的一个简化的语法糖，你可以用x..&lt;y来创建半开半闭的区间，最后一个值为y-1。</p>

<p><code>objectivec
//means 1,2,3,4,5
var range1 = 1...5
//means 1,2,3,4
var range2 = 1..&lt;5
</code></p>

<p>5.那么还有个问题，for循环是怎么处理这个Range的？从而实现循环？其实是这样的，for循环可以处理很多可遍历的Swift类型，例如array、dictionary，还比如string也可以，所以range只是这些可遍历类型的其中之一而已。</p>

<p>```objectivec
for i in &ldquo;Swift&rdquo; {</p>

<pre><code>print(i)
</code></pre>

<p>}
```</p>

<p>6.<strong>再挖的深一点，为什么String和Range一样可以被遍历？去看一下它们的定义就可以得知，它们都遵循了Sequence protocol，通过实现协议中的方法，就可以得到generator，继而循环请求其中的值，在第四章我们将自己创建类型来实现这一协议和利用generator。</strong></p>

<h3>While loops</h3>

<p>1.Swift同时支持while循环和do-while循环(<strong>Swift2.0将do-while改为了repeat-while</strong>)。</p>

<p>```objectivec
//while loop
let greeting = &ldquo;Swift by Tutorials!&rdquo;
var i = 0
while i &lt; 5 {</p>

<pre><code>print("\(i) - \(greeting)")
i++
</code></pre>

<p>}
//repeat-while loop
let greeting = &ldquo;Swift by Tutorials!&rdquo;
var i = 0
repeat {</p>

<pre><code>print("\(i) - \(greeting)")
i++
</code></pre>

<p>} while i &lt; 5
```</p>

<h3>If statements</h3>

<p>1.Swift支持常规的if-else用法，需要注意的就是前面提到过的，if的条件必须是Bool类型，而且<strong>还有一点就是即使只有一条执行的语句，也要用{}，这是Swift和其他语言if的一个区别，不然会报错，这也是为了避免{}误用或少写导致的bug</strong>，此外，还有一个和if有关的关于optional value的技巧会在下一章讲到。</p>

<p>```objectivec
import Foundation</p>

<p>let greeting = &ldquo;Swift by Tutorials!&rdquo;</p>

<p>for i in 1&hellip;5 {</p>

<pre><code>if i == 5 {
    print(greeting.uppercaseString)
} else {
    print(greeting)
}
</code></pre>

<p>}
```</p>

<h3>Switch statements</h3>

<p>1.Swift支持常规的switch语句，与OC不同的是，Swift的switch条件可以使任意类型，而OC只是原始类型，编译器来确保每个case的条件与switch条件类型一致。<br/>
2.第二点，Swift中的switch不需要在每个case后添加break，这是因为在Swift中，每个case执行完后，会自动跳出switch，所以不需要手动添加break，同时这也是安全策略之一。</p>

<p>```objectivec
var direction = &ldquo;up"switch direction {</p>

<pre><code>case "down":        println("Going Down!")  case "up":      println("Going Up!")    default:        println("Going Nowhere") }
</code></pre>

<p>```
3.第三，Swift的switch相当智能，如果你提供的switch条件的可能值没有在case中被全部覆盖，会提示你添加default，如上例的String类型，不然会报error；而如果你的case覆盖了switch条件的所有值，如enum类型，那么不添加default也不会报错。<br/>
4.如何在switch在一个case中匹配多个值，参照下例：</p>

<p>```objectivec
var direction = &ldquo;up"switch direction {</p>

<pre><code>case "down", "up":      println("Going Somewhere!")     default:        println("Going Nowhere") }
</code></pre>

<p>```</p>

<p>5.可以利用上一节介绍的Range来实现case的区间匹配：</p>

<p>```objectivec
var score = 570</p>

<p>switch score {</p>

<pre><code>case 1..&lt;10:
    print("novice")
case 10..&lt;100:
    print("proficient")
case 100..&lt;1000:
    print("rock-star")
default:
    print("awesome")
</code></pre>

<p>}
```</p>

<p>6.另外switch与元组的结合，可以创造出更加复杂的场景处理：</p>

<p>```objectivec
let somePoint = (1, 1)
switch somePoint {</p>

<pre><code>case (0, 0):
    print("(0, 0) is at the origin")
case (_, 0):
    print("(\(somePoint.0), 0) is on the x-axis")
case (0, _):
    print("(0,\(somePoint.1)) is on the y-axis")
case (-2...2, -2...2):
    print("(\(somePoint.0), \(somePoint.1)) is inside the box")
default:
    print("(\(somePoint.0), \(somePoint.1)) is outside the box")
</code></pre>

<p>}
```</p>

<p>7.利用value binding技术，可以在判断期间将tuple的元素赋值给let变量（当然也可以声明为var类型，且它的作用范围只存在该case中）：</p>

<p>```objectivec
let anotherPoint = (2, 0)
switch anotherPoint {</p>

<pre><code>case (let x, 0):
    print("on the x-axis with an x value of \(x)")
case (0, let y):
    print("on the y-axis with an y value of \(y)")
case let (x, y):
    print("somewhere else at (\(x), \(y))")
</code></pre>

<p>}
```</p>

<p>8.switch可以添加where语句，为每个case添加额外的判断条件：</p>

<p>```objectivec
let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {</p>

<pre><code>case let (x, y) where x == y:
    print("(\(x), \(y)) is on the line x == y")
case let (x, y) where x == -y:
    print("(\(x), \(y)) is on the line x == -y")
case let(x, y):
    print("(\(x), \(y)) is just some arbitrary point")
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C读书笔记7]]></title>
    <link href="http://lucifer1988.github.io/blog/2015/09/16/effective-objective-cdu-shu-bi-ji-7/"/>
    <updated>2015-09-16T15:42:34+08:00</updated>
    <id>http://lucifer1988.github.io/blog/2015/09/16/effective-objective-cdu-shu-bi-ji-7</id>
    <content type="html"><![CDATA[<p>这是本书的最后一章了，集中讲解了有关Cocoa自带的system framework，这是开发中必须要使用的基本库，没有这些封装，很多基本的功能都无法实现，没有集合，也没有基类NSObject，可谓寸步难行，一些新的Api有时会节省我们很多工作量，同时这些库中的很多设计也是我们自己的代码需要学习的。</p>

<!--more-->


<h2>Item47 Familiarize Yourself with the System Frameworks</h2>

<ol>
<li>一个framework是将代码打包成一个动态库，会有头文件来描述接口，有时候也会有一些第三方的静态库（即.a文件），这些不能作为真正意义上的框架，但是被常常当做框架来用，所有的系统框架都使用了动态库。</li>
<li>Cocoa或Cocoa Touch是框架集，其中的基本框架就是Foundation框架，Foundation Framework不但提供了基本类型和基本集合，而且还有很多复杂功能，比如字符串处理。</li>
<li>除了另一个基础库是CoreFoundation，几乎就是Foundation的镜像库，只不过内部都是C接口和结构体，OC提供了一个名为toll-free bridging的转换特性，可以使OC对象和CF对象自由转化，toll-free bridging自身比较复杂，所以不建议自己去实现这一转化功能。除了上述两个基础框架，还有以下一些常用框架：</li>
<li>CFNetwork：基于C的网络请求基本框架，基于BSD socket提供了很多易用的请求工具，Foundation通过对它的部分封装，提供了OC类型的网络接口。</li>
<li>CoreAudio：提供了基于C的音频设备访问接口，本身是很复杂的，但OC的抽象将其变得易用不少。</li>
<li>AVFoundation：提供了用于播放和录制音视频的OC对象，例如播放视频的UI类。</li>
<li>CoreData：提供了用于数据持久化的OC对象，CoreData处理数据的存取，并能在Mac OS X与iOS之间通用。</li>
<li>CoreText：提供了基于C的文字高效的类型设置和渲染的接口。</li>
<li>使用一些C类型的框架，有时是必要的，因为通过绕过runtime，速度会更快，但是需要更加关注内存管理。</li>
<li>AppKit和UIKit分别是Mac OS X 和iOS的UI框架，提供了基于Foundation和CoreFoundation的OC类型，在它的下面是CoreAnimation和CoreGraphics在支持。</li>
<li>CoreAnimation基于OC类型，提供了渲染图像和展示动画的工具，它不是一个独立的框架，还是QuartzCore框架的一部分，但是很多情况CoreAnimation还是被优先使用。</li>
<li>CoreGraphics是基于C类型的，提供了用于2D渲染的必不可少的结构体和函数，CGPoint，CGSize，CGRect都是在这儿定义的。</li>
<li>UIKit的上层还有很多更高级的框架，例如：MapKit，Social framework。</li>
</ol>


<!--more-->


<h2>Item48 Prefer Block Enumeration to for Loops</h2>

<p>1.遍历一个集合类型是常见需求，，而OC也有很多方式，从标准的C的for循环，到OC 1.0的NSEnumerator，到OC 2.0的快速遍历，block加入OC后，又出现了遍历直接传入block进行对象处理的新方法。<br/>
2.For Loops：沿用最原始的C语言的循环，定义一个int型index，然后按照index去遍历每个对象，对于NSArray来说影响还不大，但是对于NSDictionary，NSSet来说，因为都是无序的，所以必须额外生成中间数组，这是额外的内存消耗，但倒序遍历只需要改变index为递减即可，还算方便。<br/>
3.OC 1.0 NSEnumerator：NSEnumerator是一个基类，需要重写-(NSArray*)allObjects,&ndash;(id)nextObject两个方法，而Foundation框架的集合类型都支持了NSEnumerator，可以通过不断执行nextObject()来完成遍历，它的优势是所有的集合类型的遍历方式都是类似的，而且也支持不同的enumerator来实现不同顺序来遍历，缺点是还是需要额外的enumerator，而且不能得知当前的index。</p>

<p>```objectivec
//NSArray enumerator
NSArray <em>anArray = /</em>&hellip;<em>/;
NSEnumerator </em>enumerator = [anArray objectEnumerator];
id object;
while((object = [enumerator nextObject])!=nil){</p>

<pre><code>//Do something with 'object'
</code></pre>

<p>}
//NSDictionary enumerator
NSDictionary <em>aDictionary = /</em>&hellip;*/;
id key;
while((key = [enumerator nextObject])!=nil){</p>

<pre><code>id value = aDictionary[key];
//Do something with 'key' and 'value'
</code></pre>

<p>}
//NSArray reverse enumerator
NSArray <em>anArray = /</em>&hellip;<em>/;
NSEnumerator </em>enumerator = [anArray reverseObjectEnumerator];
id object;
while((object = [enumerator nextObject])!=nil){</p>

<pre><code>//Do something with 'object'
</code></pre>

<p>}
```</p>

<p>4.Fast Enumeration：OC2.0引入了快速遍历，快速遍历详单与结合了for-loop和enumerator的双重特点，同时极大的简化了语法。实现这一技术是采用了NSFastEnumeration这一协议（只有一个方法），集合类型通过遵循这一协议，从而支持了快速遍历，实现协议中的方法使得类可以同时返回多个对象：</p>

<p><code>objectivec
//NSFastEnumeration
-(NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState*)state objects:(id*)stackbuffer count:(NSUInteger)length;
</code></p>

<p>```objectivec
//NSArray
NSArray <em>anArray = /</em>&hellip;*/;
for(id object in anArray){</p>

<pre><code>//Do something with 'object'
</code></pre>

<p>}
//NSDictionary
NSDictionary <em>aDictionary = /</em>&hellip;*/;
for(id key in aDictionary){</p>

<pre><code>id value = aDictionary[key];
//Do something with 'key' and value
</code></pre>

<p>}
```</p>

<p>如果需要反向遍历，可以通过下列方法，因为NSEnumerator也实现了NSFastEnumeration：</p>

<p>```objectivec
NSArray <em>anArray = /</em>&hellip;*/;
for(id object in [anArray reverseObjectEnumerator]){</p>

<pre><code>//Do something with 'object'
</code></pre>

<p>}
```</p>

<p>快速遍历的优点是效率很高，而且代码简洁，但是依然有两个缺陷，NSDictionary如果同时需要key和value的话，还是需要两步；同时index也是无法直接获取。</p>

<p>5.Block-Based Enumeration：是在OC引入block后的遍历集合的最新方法，下面是NSArray的基本block遍历方法，前两个参数很明显，第三个参数是用来停止遍历的：</p>

<p>```objectivec
//NSArray
&ndash;(void)enumerateObjectsUsingBlock:(void(^)(id object,NSUInteger idx,BOOL <em>stop))block;
//NSDictionary
&ndash;(void)enumerateLeysAndObjectsUsingBlock:(void(^)(id key,id object,BOOL </em>stop))block;
//example
NSArray <em>aArray = /</em>&hellip;<em>/;
[aArray enumerateObjectsUsingBlock:^(id object,NSUInteger idx,BOOL </em>stop){</p>

<pre><code>//Do something with 'object'
if(shouldStop){
    *stop = YES;
}
</code></pre>

<p>}];
```</p>

<p>block遍历虽然看起来语法比快速遍历更复杂了，但是代码还是很整洁的，而且提供了方便的停止遍历的方法，而在其他方式中需要自己添加break，另外你可以现在一次性获得所有的信息，包括：NSArray的index，NSDictionary的key和value。</p>

<p>如果NSDictionary的键值类型是确定的，那么你可以重写block中的id类型，也可以在类型出现异常时抛出警告，所以如果类型确定，还是推荐这么写的。</p>

<p>```objectivec
NSDictionary <em>aDictionary = /</em>&hellip;<em>/;
[aDictionary enumerateKeysAndObjectsUsingBlock:^(NSString </em>key,NSString <em>obj,BOOL </em>stop){</p>

<pre><code>//Do Something with 'key' and 'obj'
</code></pre>

<p>}];
```</p>

<p>除了这些，还有个最大的特点是，block遍历可以通过设置option（枚举类型）来实现各种各样的遍历方式，例如通过NSEnumerationConcurrent实现对集合中的对象并发执行方法（内部应该是利用了GCD的dispatch group），通过NSEnumerationReverse实现集合的逆向遍历，而且也可以通过位与操作，同时实现这两个option。</p>

<p><code>objectivec
//NSArray
-(void)enumerateObjectsWithOptions:(NSEnumerationOptions)options usingBlock:(void(^)(id object,NSUInteger idx,BOOL *stop))block;
//NSDictionary
-(void)enumerateLeysAndObjectsWithOptions:(NSEnumerationOptions)options usingBlock:(void(^)(id key,id object,BOOL *stop))block;
</code></p>

<p>综上，block遍历虽然语法不及快速遍历简洁，但是对于NSArray获得index，对于NSDictionary获得key和value这些信息，通过option获得并发执行遍历，都是优于其他遍历方法的。</p>

<!--more-->


<h2>Item49 Using Toll-Free Bridging for Collections with Custom Memory-Management Semantics</h2>

<p>1.Toll-Free Bridging是OC用来在Foundation定义的OC对象和CoreFoundation定义的对应的C结构体之间相互转化，使用了<strong>bridge关键字，相当于ARC依然持有OC对象，如果使用了</strong>bridge_retained，那么ARC就要交出持有权，那么在我们使用完CF指针后要执行CFRelease(aCFArray)来释放内存，反之你需要将CF指针转化为OC对象，并需要转移持有权时，要加上__bridge_transfer关键字，这三个关键字非常重要。</p>

<p><code>objectivec
NSArray *anNSArray = @[@1,@2,@3,@4,@5];
CFArrayRef aCFArray = (__bridge CFArrayRef)anNSArray;
NSLog(@"Size of array = %li", CFArrayGetCount(aCFArray));
</code></p>

<p>2.为什么要去使用CF结构体指针？当然绝大部分情况我们是不会刻意去使用的，作者列举了一个特殊的场景：NSDictionary的key是copy类型，而value是retain类型，也就意味着，不支持copy协议的类是不能作为NSDictionary的key的，如果我们需要一个value和key都是retain类型的dictionary，那要怎么办呢？<br/>
3.作者列举了一种思路，重新构建一个CF的字典类型，因为在这一级，我们可以控制key和value的回调类型，然后再通过Toll-Free Bridging来转化为需要的NSMutableDictionary，从而达到目的。</p>

<!--more-->


<h2>Item50 Use NSCache Instead of NSDictionary for Caches</h2>

<p>1.在网络请求中做缓存是常见的需求，因为一般会将data和url或者request对象做成键值对存储，所以一些年轻的程序员就会考虑用NSDictionary来做缓存，但是作者建议用NSCache来做这类缓存。<br/>
2.NSCache的优势之一是，当系统资源吃紧时，cache会被自动释放，且会优先释放最近未被使用的缓存，如果NSDictionary想实现这一点，是需要做很多额外工作的。<br/>
3.NSCache的优势之二是，NSDictionary的key是copy类型，而value是retain类型，而NSCache的key和value都是retain类型，这就意味着，NSCache可以将不实现copy协议的对象作为key，虽然根据Item49的做法，也可以把NSDictionary做成这种类型，但是实现起来很复杂。另外，NSCache是线程安全的，你可以在多个线程同时插值，在做缓存时，在主线程读取缓存，然后缓存不存在，在后台线程下载并赋值是常见的场景。<br/>
4.你可以手动控制缓存的容量，通过设置缓存数量和大小来控制，如果缓存数量或大小超过限制，也会开始自动释放，但释放的顺序是不可控的，所以想通过改变最大容量来让缓存按照顺序释放是不现实的。<br/>
5.需要注意的是，设置缓存大小容量，是基于加入缓存的对象的大小易于计算，如果计算对象大小成本过高的话，这就会影响效率，因为每次加入都会进行计算。例如去硬盘计算文件大小或去数据库查找大小就是耗时的操作，但如果是NSData作为缓存对象，那么获取它的大小代价就很小，只是读取一个property而已。<br/>
6.下面是一个使用NSCache的实例：</p>

<p>```objectivec
@implementation EOCClass{</p>

<pre><code>NSCache *_cache;
</code></pre>

<p>}
&ndash;(id)init{</p>

<pre><code>if((self = [super init])){
    _cache = [NSCache new];
    _cache.countLimit = 100;
    _cache.totalCostLimit = 5*1024*1024;
}
return self;
</code></pre>

<p>}
&ndash;(void)downloadDataForURL:(NSURL*)url{</p>

<pre><code>NSData *cachedData = [_cache objectForKey:url];
if(cacheData){
    //Cache hit
    [self useData:cachedData];
} else {
    //Cache miss
    EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];
    [fetcher startWithCompletionHandler:^(NSData *data){
        [_cache setObject:data forKey:url cost:data.length];
        [self useData:data];
    }];
}
</code></pre>

<p>}
@end
```</p>

<p>7.除了NSData，另一种可以和NSCache搭配的是NSPurgeableData，它是NSMutableData的子类，实现了NSDiscardableContent协议，NSPurgeableData的内存会在系统资源紧张时自动释放，<em>isContentDiscard</em>是协议中的一个方法，返回内存是否已释放。<br/>
8.NSPurgeableData在使用之前要用<em>beginContentAccess</em>确保目前内存不被释放，然后使用完后调用<em>endContentAccess</em>告知系统可以被释放，这一对操作可以嵌套，类似retain/release。<br/>
9.如果NSPurgeableData添加到NSCache，释放的对象会自动移出cache，这可以被<em>evictsObjectsWithDiscardedContent</em>这一property关闭或开启。<br/>
10.下面是一个NSPurgeableData的实例，注意NSPurgeableData被创建时就相当于+1purge reference count与alloc类似，所以不必再加<em>beginContentAccess</em>，但用完要加<em>endContentAccess</em>。</p>

<p>```objectivec
&ndash;(void)downloadDataForURL:(NSURL*)url{</p>

<pre><code>NSPurgeableData *cacheData = [_cache objectForKey:url];
if(cachedData){
    //Stop the data being purged
    [cacheData beginContentAccess];
    //Use the cached data
    [self useData:cachedData];
    //Mark that the data may be purged again
    [cacheData endContentAccess];
} else {
    //Cache miss
    EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];
    [fetcher startWithCompletionHandler:^(NSData *data){
        NSPurgeableData *purgeableData = [NSPurgeableData dataWithData:data];
        [_cache setObject:purgeableData forKey:url cost:purgeableData.length];
        //Don't need to beginContentAccess as it begins with access already marked
        [self useData:data];
        //Mark that the data may be purged now
        [purgeable endContentAccess];
    }];
}
</code></pre>

<p>}
```</p>

<!--more-->


<h2>Item51 Keep initialize and load Implementations Lean</h2>

<ol>
<li>一个类总会有有自己的初始化方法，由于OC中类型大部分继承于NSObject，所有有很多继承于NSObject的初始化方法，第一个就是<em>*(void)load</em>方法。</li>
<li><em>load</em>方法在每个class和category中会且只会被调用一次，这个方法发生在包含该类的library在加载后，一般是应用加载中，而且只是iOS代码的独有的，Mac OS X有更灵活的dynamic loading，可以使library在应用加载后加载，而category的load在其原class加载后加载。</li>
<li>想重写<em>load</em>方法的问题是，它运行时runtime处于不稳定的状态，所有父类的<em>load</em>方法是先于其他类的<em>load</em>调用的，所依赖库中的所有<em>load</em>方法会先调用。但在一个库中，这些类的<em>load</em>方法的调用顺序就是不可控的了。</li>
<li>作者举例：EOCClassB中实现了<em>load</em>方法，它导入了Foundation.h和EOCClassA.h头文件，而EOCClassA和它同属一个库，EOCClassB在其<em>load</em>方法中使用了NSLog输出NSString，也实例化了EOCClassA并进行了操作。那么NSLog和NSString的使用是没问题的，因为Foundation.h中的class肯定先于EOCClassB的<em>load</em>方法，但使用EOCClassA就有问题了，你不能保证EOCClassA的<em>load</em>是否已经在EOCClassB的<em>load</em>方法之前调用了，因为有可能EOCClassA在<em>load</em>之前是不可用的。</li>
<li><em>load</em>方法并不遵循于一般的继承规则，一个类没有实现<em>load</em>的话，是不会调用该方法的，即使它的父类实现了；<em>load</em>方法可同时存在于类和它的category中，且category的<em>load</em>会在本类的<em>load</em>之后调用。</li>
<li>所以综上，<em>load</em>方法并不适合我们自己做初始化工作，因为我们不能确保所有的类型都已经加载，所以实际上它的用途最好仅停留在测试层面，因为如果在<em>load</em>中加载过多任务，也会影响应用的加载时间，是很影响用户体验的。</li>
<li>第二个初始化方法是<em>+(void)initialize</em>方法，它也是会且只会被调用一次，它是被runtime调用的，而不能被直接调用，它与<em>load</em>有相似的地方，也有很多不同，概括有三点。</li>
<li>区别一是<em>initialize</em>是懒加载，只有一个类被第一次用到之前才会调用，因此会出现一个类的<em>initialize</em>永远没被调用过的情况，这也意味着不像<em>load</em>会出现所有的<em>load</em>方法在同一时间加载，而且会阻塞应用加载。</li>
<li>区别二是<em>initialize</em>在执行时，runtime是稳定状态，调用其他类的方法是安全的，而且runtime保证了<em>initialize</em>的线程安全，意味着只有执行<em>initialize</em>的线程可以和class和其实例交互，其他线程将会被阻塞，知道<em>initialize</em>完成。</li>
<li>区别三是<em>initialize</em>与其他消息一样，如果类的<em>initialize</em>没实现，但是父类实现了，那么父类的<em>initialize</em>会被调用。</li>
<li>作者举例父类实现了<em>initialize</em>，但是子类没有实现，但在log中会看到该方法被调用了两次，原因是使用一个类时，其父类的<em>initialize</em>会先调用，然后到子类时，由于没有实现该方法，所以继续沿响应链得知父类实现了该方法，所以又执行一次，为了避免这一问题，在<em>initialize</em>中加上<em>if(self == [EOCBaseClass class])</em>的判断就好了。</li>
<li>虽然<em>initialize</em>比<em>load</em>灵活一些了，但是作者依然不推荐在<em>initialize</em>中做很复杂的初始化工作，原因也有三。</li>
<li>原因一，一个类的<em>initialize</em>可能在任意线程，如果它发生在UI线程，而且<em>initialize</em>做了很多工作的话，可能导致主线程阻塞。预测哪个线程会先使用一个类是不可靠的，所以强制一个固定线程去触发类的<em>initialize</em>方法是不现实的。</li>
<li>原因二，你不能控制一个类什么时候<em>initialize</em>，它是确定会在一个类被第一次使用之前调用，但是假设它会在某个固定时间执行是不可靠的，runtime可能会有所更新，导致细微改变类的初始化方式，那么你对类已经初始化完毕的设想可能是错误的。</li>
<li>原因三，比较特殊，就是两个或多个类之间的初始化方法中出现了内部数据的相互调用，可能会出现，一个类需要另一个类初始化完毕，但是第二个类还依赖于第一个类的初始化完毕，造成了两个类之间的相互等待，和循环引用有一定程度的类似。</li>
<li>综上，<em>initialize</em>中并不适合做大量的工作，尤其是调用其他类或自己的方法，如果自己的方法必须依赖自己已经初始化完毕，那么也会出现上述问题，所以<em>initialize</em>的正确用法是去初始化那些，无法在编译期间赋值的全局静态变量和全局变量，比如static NSMutableArray *kSomeObjects，因为这些OC对象必须等到runtime激活后才能使用。</li>
<li>所以始终保持<em>initialize</em>和<em>load</em>方法简洁是一个好习惯，能避免大量的奇葩问题。</li>
</ol>


<!--more-->


<h2>Item52 Remember that NSTimer Retains Its Target</h2>

<p>1.NSTimer是一个常用的类，用来定时执行一些方法，或循环执行一些方法，它是需要和一个run loop关联的，你既可以在当前run loop预设置，也可以自己创建NSTimer对象自行设置。<br/>
2.NSTimer预设置的方法需要传入target和selector，timer会retain target，而会在timer失效时release它，一个timer可以通过直接调用invalidate（一般是循环的）或者启动后（一般是一次性的）就会失效。<br/>
3.因为timer会retain target，所以在循环执行时特别容易出现循环引用，如下，startPolling后，便会出现EOCClass和timer相互引用的结果，目前想解决这一问题，只能通过要求调用方自行调用stopPolling，但如果这时一个对外使用的类的话，这是不可控的；而寄希望于dealloc去解开这一循环，是不现实的，因为对于循环引用的两个对象，是不会出现一方先释放的。而且如果这一引用存在，会一直循环去执行这个任务，带来的问题不光是内存泄露。</p>

<p>```objectivec
 #import &lt;Foundation/Foundation.h>
@interface EOCClass:NSObject
&ndash;(void)startPolling;
&ndash;(void)stopPolling;
@end
@implementation EOCClass{</p>

<pre><code>NSTimer *_pollTimer;
</code></pre>

<p>}
&ndash;(id)init{</p>

<pre><code>return [super init];
</code></pre>

<p>}
&ndash;(void)dealloc{</p>

<pre><code>[_pollTimer invalidate];
</code></pre>

<p>}
&ndash;(void)stopPolling{</p>

<pre><code>[_pollTimer invalidate];
_pollTimer = nil;
</code></pre>

<p>}
&ndash;(void)startPolling{</p>

<pre><code>_pollTimer = [NSTimer scheduledTimerWithTimeInterval:5.0 target:self selector:@selector(p_doPoll) userInfo:nil repeats:YES];
</code></pre>

<p>}
&ndash;(void)p_doPoll{</p>

<pre><code>//Poll the resource
</code></pre>

<p>}
```</p>

<p>4.那么要想解决这个问题，又不依赖外部，一个方案是做一个NSTimer的block分类，如下，block被设置为userInfo参数，timer也会对它retain，block要进行一次copy，从stack移到heap上，这在Item37说过，现在的target变成了NSTimer这个类本身，因为NSTimer作为一个类对象，是一个单例，所以不用担心释放问题，虽然也存在循环引用，但是没关系。</p>

<p>```objectivec
 #import &lt;Foundation/Foundation.h>
@interface NSTimer(EOCBlockSupport)
+(NSTimer<em>)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats;
@end
@implementation NSTimer(EOCBlockSupport)
+(NSTimer</em>)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats{</p>

<pre><code>return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(eoc_blockInvoke:) userInfo:[block copy] repeats:repeats];
</code></pre>

<p>}
+(void)eoc_blockInvoke:(NSTimer*)timer{</p>

<pre><code>void(^block)()=timer.userInfo;
if(block){
    block();
} 
</code></pre>

<p>}
```</p>

<p>5.回到新方法的使用，像下面这样直接调用的话，还是会导致循环引用，因为block会retain self，而timer会在userInfo处retain block，而timer本身被self引用，所以正确的做法是做一个self的weak变量，在block中再声明一个strong的临时变量，确保block retain一个weak对象，而在block内部又不会提前释放掉，这也是解决block retain cycle的常见策略。</p>

<p>```objectivec
//wrong
&ndash;(void)startPolling{</p>

<pre><code>_polTimer = [NSTimer eoc_scheduledTimerWithTimeInterval:5.0 block:^{
    [self p_doPoll];
}
repeats:YES
];
</code></pre>

<p>}
//right
&ndash;(void)startPolling{</p>

<pre><code>__weak __typeof(self)weakSelf = self;
_polTimer = [NSTimer eoc_scheduledTimerWithTimeInterval:5.0 block:^{
    __strong __typeof(weakSelf)strongSelf = weakSelf; 
    [strongSelf p_doPoll];
}
repeats:YES
];
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
